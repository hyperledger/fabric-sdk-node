/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.Timestamp = (function() {
    
                /**
                 * Properties of a Timestamp.
                 * @memberof google.protobuf
                 * @interface ITimestamp
                 * @property {number|Long|null} [seconds] Timestamp seconds
                 * @property {number|null} [nanos] Timestamp nanos
                 */
    
                /**
                 * Constructs a new Timestamp.
                 * @memberof google.protobuf
                 * @classdesc Represents a Timestamp.
                 * @implements ITimestamp
                 * @constructor
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Timestamp seconds.
                 * @member {number|Long} seconds
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Timestamp nanos.
                 * @member {number} nanos
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.nanos = 0;
    
                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 * @returns {google.protobuf.Timestamp} Timestamp instance
                 */
                Timestamp.create = function create(properties) {
                    return new Timestamp(properties);
                };
    
                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };
    
                /**
                 * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Timestamp message.
                 * @function verify
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };
    
                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Timestamp} Timestamp
                 */
                Timestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Timestamp)
                        return object;
                    var message = new $root.google.protobuf.Timestamp();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.Timestamp} message Timestamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };
    
                /**
                 * Converts this Timestamp to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Timestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Timestamp;
            })();
    
            protobuf.Empty = (function() {
    
                /**
                 * Properties of an Empty.
                 * @memberof google.protobuf
                 * @interface IEmpty
                 */
    
                /**
                 * Constructs a new Empty.
                 * @memberof google.protobuf
                 * @classdesc Represents an Empty.
                 * @implements IEmpty
                 * @constructor
                 * @param {google.protobuf.IEmpty=} [properties] Properties to set
                 */
                function Empty(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new Empty instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty=} [properties] Properties to set
                 * @returns {google.protobuf.Empty} Empty instance
                 */
                Empty.create = function create(properties) {
                    return new Empty(properties);
                };
    
                /**
                 * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Empty.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Empty.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Empty message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Empty} Empty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Empty.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Empty message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Empty} Empty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Empty.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Empty message.
                 * @function verify
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Empty.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an Empty message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Empty} Empty
                 */
                Empty.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Empty)
                        return object;
                    return new $root.google.protobuf.Empty();
                };
    
                /**
                 * Creates a plain object from an Empty message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.Empty} message Empty
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Empty.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this Empty to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Empty
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Empty.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Empty;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();
    
    $root.kvrwset = (function() {
    
        /**
         * Namespace kvrwset.
         * @exports kvrwset
         * @namespace
         */
        var kvrwset = {};
    
        kvrwset.KVRWSet = (function() {
    
            /**
             * Properties of a KVRWSet.
             * @memberof kvrwset
             * @interface IKVRWSet
             * @property {Array.<kvrwset.IKVRead>|null} [reads] KVRWSet reads
             * @property {Array.<kvrwset.IRangeQueryInfo>|null} [range_queries_info] KVRWSet range_queries_info
             * @property {Array.<kvrwset.IKVWrite>|null} [writes] KVRWSet writes
             * @property {Array.<kvrwset.IKVMetadataWrite>|null} [metadata_writes] KVRWSet metadata_writes
             */
    
            /**
             * Constructs a new KVRWSet.
             * @memberof kvrwset
             * @classdesc Represents a KVRWSet.
             * @implements IKVRWSet
             * @constructor
             * @param {kvrwset.IKVRWSet=} [properties] Properties to set
             */
            function KVRWSet(properties) {
                this.reads = [];
                this.range_queries_info = [];
                this.writes = [];
                this.metadata_writes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVRWSet reads.
             * @member {Array.<kvrwset.IKVRead>} reads
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.reads = $util.emptyArray;
    
            /**
             * KVRWSet range_queries_info.
             * @member {Array.<kvrwset.IRangeQueryInfo>} range_queries_info
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.range_queries_info = $util.emptyArray;
    
            /**
             * KVRWSet writes.
             * @member {Array.<kvrwset.IKVWrite>} writes
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.writes = $util.emptyArray;
    
            /**
             * KVRWSet metadata_writes.
             * @member {Array.<kvrwset.IKVMetadataWrite>} metadata_writes
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.metadata_writes = $util.emptyArray;
    
            /**
             * Creates a new KVRWSet instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet=} [properties] Properties to set
             * @returns {kvrwset.KVRWSet} KVRWSet instance
             */
            KVRWSet.create = function create(properties) {
                return new KVRWSet(properties);
            };
    
            /**
             * Encodes the specified KVRWSet message. Does not implicitly {@link kvrwset.KVRWSet.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet} message KVRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRWSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.reads != null && message.reads.length)
                    for (var i = 0; i < message.reads.length; ++i)
                        $root.kvrwset.KVRead.encode(message.reads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.range_queries_info != null && message.range_queries_info.length)
                    for (var i = 0; i < message.range_queries_info.length; ++i)
                        $root.kvrwset.RangeQueryInfo.encode(message.range_queries_info[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.writes != null && message.writes.length)
                    for (var i = 0; i < message.writes.length; ++i)
                        $root.kvrwset.KVWrite.encode(message.writes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.metadata_writes != null && message.metadata_writes.length)
                    for (var i = 0; i < message.metadata_writes.length; ++i)
                        $root.kvrwset.KVMetadataWrite.encode(message.metadata_writes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVRWSet message, length delimited. Does not implicitly {@link kvrwset.KVRWSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet} message KVRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRWSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVRWSet message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVRWSet} KVRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRWSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVRWSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.reads && message.reads.length))
                            message.reads = [];
                        message.reads.push($root.kvrwset.KVRead.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.range_queries_info && message.range_queries_info.length))
                            message.range_queries_info = [];
                        message.range_queries_info.push($root.kvrwset.RangeQueryInfo.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.writes && message.writes.length))
                            message.writes = [];
                        message.writes.push($root.kvrwset.KVWrite.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.metadata_writes && message.metadata_writes.length))
                            message.metadata_writes = [];
                        message.metadata_writes.push($root.kvrwset.KVMetadataWrite.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVRWSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVRWSet} KVRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRWSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVRWSet message.
             * @function verify
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVRWSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.reads != null && message.hasOwnProperty("reads")) {
                    if (!Array.isArray(message.reads))
                        return "reads: array expected";
                    for (var i = 0; i < message.reads.length; ++i) {
                        var error = $root.kvrwset.KVRead.verify(message.reads[i]);
                        if (error)
                            return "reads." + error;
                    }
                }
                if (message.range_queries_info != null && message.hasOwnProperty("range_queries_info")) {
                    if (!Array.isArray(message.range_queries_info))
                        return "range_queries_info: array expected";
                    for (var i = 0; i < message.range_queries_info.length; ++i) {
                        var error = $root.kvrwset.RangeQueryInfo.verify(message.range_queries_info[i]);
                        if (error)
                            return "range_queries_info." + error;
                    }
                }
                if (message.writes != null && message.hasOwnProperty("writes")) {
                    if (!Array.isArray(message.writes))
                        return "writes: array expected";
                    for (var i = 0; i < message.writes.length; ++i) {
                        var error = $root.kvrwset.KVWrite.verify(message.writes[i]);
                        if (error)
                            return "writes." + error;
                    }
                }
                if (message.metadata_writes != null && message.hasOwnProperty("metadata_writes")) {
                    if (!Array.isArray(message.metadata_writes))
                        return "metadata_writes: array expected";
                    for (var i = 0; i < message.metadata_writes.length; ++i) {
                        var error = $root.kvrwset.KVMetadataWrite.verify(message.metadata_writes[i]);
                        if (error)
                            return "metadata_writes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVRWSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVRWSet} KVRWSet
             */
            KVRWSet.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVRWSet)
                    return object;
                var message = new $root.kvrwset.KVRWSet();
                if (object.reads) {
                    if (!Array.isArray(object.reads))
                        throw TypeError(".kvrwset.KVRWSet.reads: array expected");
                    message.reads = [];
                    for (var i = 0; i < object.reads.length; ++i) {
                        if (typeof object.reads[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.reads: object expected");
                        message.reads[i] = $root.kvrwset.KVRead.fromObject(object.reads[i]);
                    }
                }
                if (object.range_queries_info) {
                    if (!Array.isArray(object.range_queries_info))
                        throw TypeError(".kvrwset.KVRWSet.range_queries_info: array expected");
                    message.range_queries_info = [];
                    for (var i = 0; i < object.range_queries_info.length; ++i) {
                        if (typeof object.range_queries_info[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.range_queries_info: object expected");
                        message.range_queries_info[i] = $root.kvrwset.RangeQueryInfo.fromObject(object.range_queries_info[i]);
                    }
                }
                if (object.writes) {
                    if (!Array.isArray(object.writes))
                        throw TypeError(".kvrwset.KVRWSet.writes: array expected");
                    message.writes = [];
                    for (var i = 0; i < object.writes.length; ++i) {
                        if (typeof object.writes[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.writes: object expected");
                        message.writes[i] = $root.kvrwset.KVWrite.fromObject(object.writes[i]);
                    }
                }
                if (object.metadata_writes) {
                    if (!Array.isArray(object.metadata_writes))
                        throw TypeError(".kvrwset.KVRWSet.metadata_writes: array expected");
                    message.metadata_writes = [];
                    for (var i = 0; i < object.metadata_writes.length; ++i) {
                        if (typeof object.metadata_writes[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.metadata_writes: object expected");
                        message.metadata_writes[i] = $root.kvrwset.KVMetadataWrite.fromObject(object.metadata_writes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVRWSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.KVRWSet} message KVRWSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVRWSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.reads = [];
                    object.range_queries_info = [];
                    object.writes = [];
                    object.metadata_writes = [];
                }
                if (message.reads && message.reads.length) {
                    object.reads = [];
                    for (var j = 0; j < message.reads.length; ++j)
                        object.reads[j] = $root.kvrwset.KVRead.toObject(message.reads[j], options);
                }
                if (message.range_queries_info && message.range_queries_info.length) {
                    object.range_queries_info = [];
                    for (var j = 0; j < message.range_queries_info.length; ++j)
                        object.range_queries_info[j] = $root.kvrwset.RangeQueryInfo.toObject(message.range_queries_info[j], options);
                }
                if (message.writes && message.writes.length) {
                    object.writes = [];
                    for (var j = 0; j < message.writes.length; ++j)
                        object.writes[j] = $root.kvrwset.KVWrite.toObject(message.writes[j], options);
                }
                if (message.metadata_writes && message.metadata_writes.length) {
                    object.metadata_writes = [];
                    for (var j = 0; j < message.metadata_writes.length; ++j)
                        object.metadata_writes[j] = $root.kvrwset.KVMetadataWrite.toObject(message.metadata_writes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVRWSet to JSON.
             * @function toJSON
             * @memberof kvrwset.KVRWSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVRWSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVRWSet;
        })();
    
        kvrwset.HashedRWSet = (function() {
    
            /**
             * Properties of a HashedRWSet.
             * @memberof kvrwset
             * @interface IHashedRWSet
             * @property {Array.<kvrwset.IKVReadHash>|null} [hashed_reads] HashedRWSet hashed_reads
             * @property {Array.<kvrwset.IKVWriteHash>|null} [hashed_writes] HashedRWSet hashed_writes
             * @property {Array.<kvrwset.IKVMetadataWriteHash>|null} [metadata_writes] HashedRWSet metadata_writes
             */
    
            /**
             * Constructs a new HashedRWSet.
             * @memberof kvrwset
             * @classdesc Represents a HashedRWSet.
             * @implements IHashedRWSet
             * @constructor
             * @param {kvrwset.IHashedRWSet=} [properties] Properties to set
             */
            function HashedRWSet(properties) {
                this.hashed_reads = [];
                this.hashed_writes = [];
                this.metadata_writes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * HashedRWSet hashed_reads.
             * @member {Array.<kvrwset.IKVReadHash>} hashed_reads
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.hashed_reads = $util.emptyArray;
    
            /**
             * HashedRWSet hashed_writes.
             * @member {Array.<kvrwset.IKVWriteHash>} hashed_writes
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.hashed_writes = $util.emptyArray;
    
            /**
             * HashedRWSet metadata_writes.
             * @member {Array.<kvrwset.IKVMetadataWriteHash>} metadata_writes
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.metadata_writes = $util.emptyArray;
    
            /**
             * Creates a new HashedRWSet instance using the specified properties.
             * @function create
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet=} [properties] Properties to set
             * @returns {kvrwset.HashedRWSet} HashedRWSet instance
             */
            HashedRWSet.create = function create(properties) {
                return new HashedRWSet(properties);
            };
    
            /**
             * Encodes the specified HashedRWSet message. Does not implicitly {@link kvrwset.HashedRWSet.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet} message HashedRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashedRWSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hashed_reads != null && message.hashed_reads.length)
                    for (var i = 0; i < message.hashed_reads.length; ++i)
                        $root.kvrwset.KVReadHash.encode(message.hashed_reads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.hashed_writes != null && message.hashed_writes.length)
                    for (var i = 0; i < message.hashed_writes.length; ++i)
                        $root.kvrwset.KVWriteHash.encode(message.hashed_writes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata_writes != null && message.metadata_writes.length)
                    for (var i = 0; i < message.metadata_writes.length; ++i)
                        $root.kvrwset.KVMetadataWriteHash.encode(message.metadata_writes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified HashedRWSet message, length delimited. Does not implicitly {@link kvrwset.HashedRWSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet} message HashedRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashedRWSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a HashedRWSet message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashedRWSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.HashedRWSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.hashed_reads && message.hashed_reads.length))
                            message.hashed_reads = [];
                        message.hashed_reads.push($root.kvrwset.KVReadHash.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.hashed_writes && message.hashed_writes.length))
                            message.hashed_writes = [];
                        message.hashed_writes.push($root.kvrwset.KVWriteHash.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.metadata_writes && message.metadata_writes.length))
                            message.metadata_writes = [];
                        message.metadata_writes.push($root.kvrwset.KVMetadataWriteHash.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a HashedRWSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashedRWSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a HashedRWSet message.
             * @function verify
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HashedRWSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hashed_reads != null && message.hasOwnProperty("hashed_reads")) {
                    if (!Array.isArray(message.hashed_reads))
                        return "hashed_reads: array expected";
                    for (var i = 0; i < message.hashed_reads.length; ++i) {
                        var error = $root.kvrwset.KVReadHash.verify(message.hashed_reads[i]);
                        if (error)
                            return "hashed_reads." + error;
                    }
                }
                if (message.hashed_writes != null && message.hasOwnProperty("hashed_writes")) {
                    if (!Array.isArray(message.hashed_writes))
                        return "hashed_writes: array expected";
                    for (var i = 0; i < message.hashed_writes.length; ++i) {
                        var error = $root.kvrwset.KVWriteHash.verify(message.hashed_writes[i]);
                        if (error)
                            return "hashed_writes." + error;
                    }
                }
                if (message.metadata_writes != null && message.hasOwnProperty("metadata_writes")) {
                    if (!Array.isArray(message.metadata_writes))
                        return "metadata_writes: array expected";
                    for (var i = 0; i < message.metadata_writes.length; ++i) {
                        var error = $root.kvrwset.KVMetadataWriteHash.verify(message.metadata_writes[i]);
                        if (error)
                            return "metadata_writes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a HashedRWSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             */
            HashedRWSet.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.HashedRWSet)
                    return object;
                var message = new $root.kvrwset.HashedRWSet();
                if (object.hashed_reads) {
                    if (!Array.isArray(object.hashed_reads))
                        throw TypeError(".kvrwset.HashedRWSet.hashed_reads: array expected");
                    message.hashed_reads = [];
                    for (var i = 0; i < object.hashed_reads.length; ++i) {
                        if (typeof object.hashed_reads[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.hashed_reads: object expected");
                        message.hashed_reads[i] = $root.kvrwset.KVReadHash.fromObject(object.hashed_reads[i]);
                    }
                }
                if (object.hashed_writes) {
                    if (!Array.isArray(object.hashed_writes))
                        throw TypeError(".kvrwset.HashedRWSet.hashed_writes: array expected");
                    message.hashed_writes = [];
                    for (var i = 0; i < object.hashed_writes.length; ++i) {
                        if (typeof object.hashed_writes[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.hashed_writes: object expected");
                        message.hashed_writes[i] = $root.kvrwset.KVWriteHash.fromObject(object.hashed_writes[i]);
                    }
                }
                if (object.metadata_writes) {
                    if (!Array.isArray(object.metadata_writes))
                        throw TypeError(".kvrwset.HashedRWSet.metadata_writes: array expected");
                    message.metadata_writes = [];
                    for (var i = 0; i < object.metadata_writes.length; ++i) {
                        if (typeof object.metadata_writes[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.metadata_writes: object expected");
                        message.metadata_writes[i] = $root.kvrwset.KVMetadataWriteHash.fromObject(object.metadata_writes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a HashedRWSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.HashedRWSet} message HashedRWSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HashedRWSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.hashed_reads = [];
                    object.hashed_writes = [];
                    object.metadata_writes = [];
                }
                if (message.hashed_reads && message.hashed_reads.length) {
                    object.hashed_reads = [];
                    for (var j = 0; j < message.hashed_reads.length; ++j)
                        object.hashed_reads[j] = $root.kvrwset.KVReadHash.toObject(message.hashed_reads[j], options);
                }
                if (message.hashed_writes && message.hashed_writes.length) {
                    object.hashed_writes = [];
                    for (var j = 0; j < message.hashed_writes.length; ++j)
                        object.hashed_writes[j] = $root.kvrwset.KVWriteHash.toObject(message.hashed_writes[j], options);
                }
                if (message.metadata_writes && message.metadata_writes.length) {
                    object.metadata_writes = [];
                    for (var j = 0; j < message.metadata_writes.length; ++j)
                        object.metadata_writes[j] = $root.kvrwset.KVMetadataWriteHash.toObject(message.metadata_writes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this HashedRWSet to JSON.
             * @function toJSON
             * @memberof kvrwset.HashedRWSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HashedRWSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return HashedRWSet;
        })();
    
        kvrwset.KVRead = (function() {
    
            /**
             * Properties of a KVRead.
             * @memberof kvrwset
             * @interface IKVRead
             * @property {string|null} [key] KVRead key
             * @property {kvrwset.IVersion|null} [version] KVRead version
             */
    
            /**
             * Constructs a new KVRead.
             * @memberof kvrwset
             * @classdesc Represents a KVRead.
             * @implements IKVRead
             * @constructor
             * @param {kvrwset.IKVRead=} [properties] Properties to set
             */
            function KVRead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVRead key.
             * @member {string} key
             * @memberof kvrwset.KVRead
             * @instance
             */
            KVRead.prototype.key = "";
    
            /**
             * KVRead version.
             * @member {kvrwset.IVersion|null|undefined} version
             * @memberof kvrwset.KVRead
             * @instance
             */
            KVRead.prototype.version = null;
    
            /**
             * Creates a new KVRead instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead=} [properties] Properties to set
             * @returns {kvrwset.KVRead} KVRead instance
             */
            KVRead.create = function create(properties) {
                return new KVRead(properties);
            };
    
            /**
             * Encodes the specified KVRead message. Does not implicitly {@link kvrwset.KVRead.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead} message KVRead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    $root.kvrwset.Version.encode(message.version, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVRead message, length delimited. Does not implicitly {@link kvrwset.KVRead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead} message KVRead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVRead message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVRead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVRead} KVRead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVRead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.version = $root.kvrwset.Version.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVRead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVRead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVRead} KVRead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVRead message.
             * @function verify
             * @memberof kvrwset.KVRead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVRead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.kvrwset.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                return null;
            };
    
            /**
             * Creates a KVRead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVRead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVRead} KVRead
             */
            KVRead.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVRead)
                    return object;
                var message = new $root.kvrwset.KVRead();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".kvrwset.KVRead.version: object expected");
                    message.version = $root.kvrwset.Version.fromObject(object.version);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVRead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.KVRead} message KVRead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVRead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.version = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.kvrwset.Version.toObject(message.version, options);
                return object;
            };
    
            /**
             * Converts this KVRead to JSON.
             * @function toJSON
             * @memberof kvrwset.KVRead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVRead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVRead;
        })();
    
        kvrwset.KVWrite = (function() {
    
            /**
             * Properties of a KVWrite.
             * @memberof kvrwset
             * @interface IKVWrite
             * @property {string|null} [key] KVWrite key
             * @property {boolean|null} [is_delete] KVWrite is_delete
             * @property {Uint8Array|null} [value] KVWrite value
             */
    
            /**
             * Constructs a new KVWrite.
             * @memberof kvrwset
             * @classdesc Represents a KVWrite.
             * @implements IKVWrite
             * @constructor
             * @param {kvrwset.IKVWrite=} [properties] Properties to set
             */
            function KVWrite(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVWrite key.
             * @member {string} key
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.key = "";
    
            /**
             * KVWrite is_delete.
             * @member {boolean} is_delete
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.is_delete = false;
    
            /**
             * KVWrite value.
             * @member {Uint8Array} value
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KVWrite instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite=} [properties] Properties to set
             * @returns {kvrwset.KVWrite} KVWrite instance
             */
            KVWrite.create = function create(properties) {
                return new KVWrite(properties);
            };
    
            /**
             * Encodes the specified KVWrite message. Does not implicitly {@link kvrwset.KVWrite.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite} message KVWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWrite.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.is_delete != null && Object.hasOwnProperty.call(message, "is_delete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_delete);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KVWrite message, length delimited. Does not implicitly {@link kvrwset.KVWrite.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite} message KVWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWrite.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVWrite message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVWrite} KVWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWrite.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVWrite();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.is_delete = reader.bool();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVWrite message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVWrite} KVWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWrite.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVWrite message.
             * @function verify
             * @memberof kvrwset.KVWrite
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVWrite.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    if (typeof message.is_delete !== "boolean")
                        return "is_delete: boolean expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVWrite message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVWrite
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVWrite} KVWrite
             */
            KVWrite.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVWrite)
                    return object;
                var message = new $root.kvrwset.KVWrite();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.is_delete != null)
                    message.is_delete = Boolean(object.is_delete);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KVWrite message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.KVWrite} message KVWrite
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVWrite.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.is_delete = false;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    object.is_delete = message.is_delete;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KVWrite to JSON.
             * @function toJSON
             * @memberof kvrwset.KVWrite
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVWrite.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVWrite;
        })();
    
        kvrwset.KVMetadataWrite = (function() {
    
            /**
             * Properties of a KVMetadataWrite.
             * @memberof kvrwset
             * @interface IKVMetadataWrite
             * @property {string|null} [key] KVMetadataWrite key
             * @property {Array.<kvrwset.IKVMetadataEntry>|null} [entries] KVMetadataWrite entries
             */
    
            /**
             * Constructs a new KVMetadataWrite.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataWrite.
             * @implements IKVMetadataWrite
             * @constructor
             * @param {kvrwset.IKVMetadataWrite=} [properties] Properties to set
             */
            function KVMetadataWrite(properties) {
                this.entries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataWrite key.
             * @member {string} key
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             */
            KVMetadataWrite.prototype.key = "";
    
            /**
             * KVMetadataWrite entries.
             * @member {Array.<kvrwset.IKVMetadataEntry>} entries
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             */
            KVMetadataWrite.prototype.entries = $util.emptyArray;
    
            /**
             * Creates a new KVMetadataWrite instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite instance
             */
            KVMetadataWrite.create = function create(properties) {
                return new KVMetadataWrite(properties);
            };
    
            /**
             * Encodes the specified KVMetadataWrite message. Does not implicitly {@link kvrwset.KVMetadataWrite.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite} message KVMetadataWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWrite.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.entries != null && message.entries.length)
                    for (var i = 0; i < message.entries.length; ++i)
                        $root.kvrwset.KVMetadataEntry.encode(message.entries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataWrite message, length delimited. Does not implicitly {@link kvrwset.KVMetadataWrite.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite} message KVMetadataWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWrite.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataWrite message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWrite.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataWrite();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.kvrwset.KVMetadataEntry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataWrite message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWrite.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataWrite message.
             * @function verify
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataWrite.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (var i = 0; i < message.entries.length; ++i) {
                        var error = $root.kvrwset.KVMetadataEntry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVMetadataWrite message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             */
            KVMetadataWrite.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataWrite)
                    return object;
                var message = new $root.kvrwset.KVMetadataWrite();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".kvrwset.KVMetadataWrite.entries: array expected");
                    message.entries = [];
                    for (var i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".kvrwset.KVMetadataWrite.entries: object expected");
                        message.entries[i] = $root.kvrwset.KVMetadataEntry.fromObject(object.entries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataWrite message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.KVMetadataWrite} message KVMetadataWrite
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataWrite.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (var j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.kvrwset.KVMetadataEntry.toObject(message.entries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVMetadataWrite to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataWrite.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataWrite;
        })();
    
        kvrwset.KVReadHash = (function() {
    
            /**
             * Properties of a KVReadHash.
             * @memberof kvrwset
             * @interface IKVReadHash
             * @property {Uint8Array|null} [key_hash] KVReadHash key_hash
             * @property {kvrwset.IVersion|null} [version] KVReadHash version
             */
    
            /**
             * Constructs a new KVReadHash.
             * @memberof kvrwset
             * @classdesc Represents a KVReadHash.
             * @implements IKVReadHash
             * @constructor
             * @param {kvrwset.IKVReadHash=} [properties] Properties to set
             */
            function KVReadHash(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVReadHash key_hash.
             * @member {Uint8Array} key_hash
             * @memberof kvrwset.KVReadHash
             * @instance
             */
            KVReadHash.prototype.key_hash = $util.newBuffer([]);
    
            /**
             * KVReadHash version.
             * @member {kvrwset.IVersion|null|undefined} version
             * @memberof kvrwset.KVReadHash
             * @instance
             */
            KVReadHash.prototype.version = null;
    
            /**
             * Creates a new KVReadHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash=} [properties] Properties to set
             * @returns {kvrwset.KVReadHash} KVReadHash instance
             */
            KVReadHash.create = function create(properties) {
                return new KVReadHash(properties);
            };
    
            /**
             * Encodes the specified KVReadHash message. Does not implicitly {@link kvrwset.KVReadHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash} message KVReadHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVReadHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key_hash != null && Object.hasOwnProperty.call(message, "key_hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key_hash);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    $root.kvrwset.Version.encode(message.version, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVReadHash message, length delimited. Does not implicitly {@link kvrwset.KVReadHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash} message KVReadHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVReadHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVReadHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVReadHash} KVReadHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVReadHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVReadHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key_hash = reader.bytes();
                        break;
                    case 2:
                        message.version = $root.kvrwset.Version.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVReadHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVReadHash} KVReadHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVReadHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVReadHash message.
             * @function verify
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVReadHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    if (!(message.key_hash && typeof message.key_hash.length === "number" || $util.isString(message.key_hash)))
                        return "key_hash: buffer expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.kvrwset.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                return null;
            };
    
            /**
             * Creates a KVReadHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVReadHash} KVReadHash
             */
            KVReadHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVReadHash)
                    return object;
                var message = new $root.kvrwset.KVReadHash();
                if (object.key_hash != null)
                    if (typeof object.key_hash === "string")
                        $util.base64.decode(object.key_hash, message.key_hash = $util.newBuffer($util.base64.length(object.key_hash)), 0);
                    else if (object.key_hash.length)
                        message.key_hash = object.key_hash;
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".kvrwset.KVReadHash.version: object expected");
                    message.version = $root.kvrwset.Version.fromObject(object.version);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVReadHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.KVReadHash} message KVReadHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVReadHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key_hash = "";
                    else {
                        object.key_hash = [];
                        if (options.bytes !== Array)
                            object.key_hash = $util.newBuffer(object.key_hash);
                    }
                    object.version = null;
                }
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    object.key_hash = options.bytes === String ? $util.base64.encode(message.key_hash, 0, message.key_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.key_hash) : message.key_hash;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.kvrwset.Version.toObject(message.version, options);
                return object;
            };
    
            /**
             * Converts this KVReadHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVReadHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVReadHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVReadHash;
        })();
    
        kvrwset.KVWriteHash = (function() {
    
            /**
             * Properties of a KVWriteHash.
             * @memberof kvrwset
             * @interface IKVWriteHash
             * @property {Uint8Array|null} [key_hash] KVWriteHash key_hash
             * @property {boolean|null} [is_delete] KVWriteHash is_delete
             * @property {Uint8Array|null} [value_hash] KVWriteHash value_hash
             */
    
            /**
             * Constructs a new KVWriteHash.
             * @memberof kvrwset
             * @classdesc Represents a KVWriteHash.
             * @implements IKVWriteHash
             * @constructor
             * @param {kvrwset.IKVWriteHash=} [properties] Properties to set
             */
            function KVWriteHash(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVWriteHash key_hash.
             * @member {Uint8Array} key_hash
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.key_hash = $util.newBuffer([]);
    
            /**
             * KVWriteHash is_delete.
             * @member {boolean} is_delete
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.is_delete = false;
    
            /**
             * KVWriteHash value_hash.
             * @member {Uint8Array} value_hash
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.value_hash = $util.newBuffer([]);
    
            /**
             * Creates a new KVWriteHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash=} [properties] Properties to set
             * @returns {kvrwset.KVWriteHash} KVWriteHash instance
             */
            KVWriteHash.create = function create(properties) {
                return new KVWriteHash(properties);
            };
    
            /**
             * Encodes the specified KVWriteHash message. Does not implicitly {@link kvrwset.KVWriteHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash} message KVWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWriteHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key_hash != null && Object.hasOwnProperty.call(message, "key_hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key_hash);
                if (message.is_delete != null && Object.hasOwnProperty.call(message, "is_delete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_delete);
                if (message.value_hash != null && Object.hasOwnProperty.call(message, "value_hash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value_hash);
                return writer;
            };
    
            /**
             * Encodes the specified KVWriteHash message, length delimited. Does not implicitly {@link kvrwset.KVWriteHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash} message KVWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWriteHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVWriteHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWriteHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVWriteHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key_hash = reader.bytes();
                        break;
                    case 2:
                        message.is_delete = reader.bool();
                        break;
                    case 3:
                        message.value_hash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVWriteHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWriteHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVWriteHash message.
             * @function verify
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVWriteHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    if (!(message.key_hash && typeof message.key_hash.length === "number" || $util.isString(message.key_hash)))
                        return "key_hash: buffer expected";
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    if (typeof message.is_delete !== "boolean")
                        return "is_delete: boolean expected";
                if (message.value_hash != null && message.hasOwnProperty("value_hash"))
                    if (!(message.value_hash && typeof message.value_hash.length === "number" || $util.isString(message.value_hash)))
                        return "value_hash: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVWriteHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             */
            KVWriteHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVWriteHash)
                    return object;
                var message = new $root.kvrwset.KVWriteHash();
                if (object.key_hash != null)
                    if (typeof object.key_hash === "string")
                        $util.base64.decode(object.key_hash, message.key_hash = $util.newBuffer($util.base64.length(object.key_hash)), 0);
                    else if (object.key_hash.length)
                        message.key_hash = object.key_hash;
                if (object.is_delete != null)
                    message.is_delete = Boolean(object.is_delete);
                if (object.value_hash != null)
                    if (typeof object.value_hash === "string")
                        $util.base64.decode(object.value_hash, message.value_hash = $util.newBuffer($util.base64.length(object.value_hash)), 0);
                    else if (object.value_hash.length)
                        message.value_hash = object.value_hash;
                return message;
            };
    
            /**
             * Creates a plain object from a KVWriteHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.KVWriteHash} message KVWriteHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVWriteHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key_hash = "";
                    else {
                        object.key_hash = [];
                        if (options.bytes !== Array)
                            object.key_hash = $util.newBuffer(object.key_hash);
                    }
                    object.is_delete = false;
                    if (options.bytes === String)
                        object.value_hash = "";
                    else {
                        object.value_hash = [];
                        if (options.bytes !== Array)
                            object.value_hash = $util.newBuffer(object.value_hash);
                    }
                }
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    object.key_hash = options.bytes === String ? $util.base64.encode(message.key_hash, 0, message.key_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.key_hash) : message.key_hash;
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    object.is_delete = message.is_delete;
                if (message.value_hash != null && message.hasOwnProperty("value_hash"))
                    object.value_hash = options.bytes === String ? $util.base64.encode(message.value_hash, 0, message.value_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.value_hash) : message.value_hash;
                return object;
            };
    
            /**
             * Converts this KVWriteHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVWriteHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVWriteHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVWriteHash;
        })();
    
        kvrwset.KVMetadataWriteHash = (function() {
    
            /**
             * Properties of a KVMetadataWriteHash.
             * @memberof kvrwset
             * @interface IKVMetadataWriteHash
             * @property {Uint8Array|null} [key_hash] KVMetadataWriteHash key_hash
             * @property {Array.<kvrwset.IKVMetadataEntry>|null} [entries] KVMetadataWriteHash entries
             */
    
            /**
             * Constructs a new KVMetadataWriteHash.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataWriteHash.
             * @implements IKVMetadataWriteHash
             * @constructor
             * @param {kvrwset.IKVMetadataWriteHash=} [properties] Properties to set
             */
            function KVMetadataWriteHash(properties) {
                this.entries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataWriteHash key_hash.
             * @member {Uint8Array} key_hash
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             */
            KVMetadataWriteHash.prototype.key_hash = $util.newBuffer([]);
    
            /**
             * KVMetadataWriteHash entries.
             * @member {Array.<kvrwset.IKVMetadataEntry>} entries
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             */
            KVMetadataWriteHash.prototype.entries = $util.emptyArray;
    
            /**
             * Creates a new KVMetadataWriteHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash instance
             */
            KVMetadataWriteHash.create = function create(properties) {
                return new KVMetadataWriteHash(properties);
            };
    
            /**
             * Encodes the specified KVMetadataWriteHash message. Does not implicitly {@link kvrwset.KVMetadataWriteHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash} message KVMetadataWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWriteHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key_hash != null && Object.hasOwnProperty.call(message, "key_hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key_hash);
                if (message.entries != null && message.entries.length)
                    for (var i = 0; i < message.entries.length; ++i)
                        $root.kvrwset.KVMetadataEntry.encode(message.entries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataWriteHash message, length delimited. Does not implicitly {@link kvrwset.KVMetadataWriteHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash} message KVMetadataWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWriteHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataWriteHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWriteHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataWriteHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key_hash = reader.bytes();
                        break;
                    case 2:
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.kvrwset.KVMetadataEntry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataWriteHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWriteHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataWriteHash message.
             * @function verify
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataWriteHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    if (!(message.key_hash && typeof message.key_hash.length === "number" || $util.isString(message.key_hash)))
                        return "key_hash: buffer expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (var i = 0; i < message.entries.length; ++i) {
                        var error = $root.kvrwset.KVMetadataEntry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVMetadataWriteHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             */
            KVMetadataWriteHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataWriteHash)
                    return object;
                var message = new $root.kvrwset.KVMetadataWriteHash();
                if (object.key_hash != null)
                    if (typeof object.key_hash === "string")
                        $util.base64.decode(object.key_hash, message.key_hash = $util.newBuffer($util.base64.length(object.key_hash)), 0);
                    else if (object.key_hash.length)
                        message.key_hash = object.key_hash;
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".kvrwset.KVMetadataWriteHash.entries: array expected");
                    message.entries = [];
                    for (var i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".kvrwset.KVMetadataWriteHash.entries: object expected");
                        message.entries[i] = $root.kvrwset.KVMetadataEntry.fromObject(object.entries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataWriteHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.KVMetadataWriteHash} message KVMetadataWriteHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataWriteHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.key_hash = "";
                    else {
                        object.key_hash = [];
                        if (options.bytes !== Array)
                            object.key_hash = $util.newBuffer(object.key_hash);
                    }
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    object.key_hash = options.bytes === String ? $util.base64.encode(message.key_hash, 0, message.key_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.key_hash) : message.key_hash;
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (var j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.kvrwset.KVMetadataEntry.toObject(message.entries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVMetadataWriteHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataWriteHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataWriteHash;
        })();
    
        kvrwset.KVMetadataEntry = (function() {
    
            /**
             * Properties of a KVMetadataEntry.
             * @memberof kvrwset
             * @interface IKVMetadataEntry
             * @property {string|null} [name] KVMetadataEntry name
             * @property {Uint8Array|null} [value] KVMetadataEntry value
             */
    
            /**
             * Constructs a new KVMetadataEntry.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataEntry.
             * @implements IKVMetadataEntry
             * @constructor
             * @param {kvrwset.IKVMetadataEntry=} [properties] Properties to set
             */
            function KVMetadataEntry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataEntry name.
             * @member {string} name
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             */
            KVMetadataEntry.prototype.name = "";
    
            /**
             * KVMetadataEntry value.
             * @member {Uint8Array} value
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             */
            KVMetadataEntry.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KVMetadataEntry instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry instance
             */
            KVMetadataEntry.create = function create(properties) {
                return new KVMetadataEntry(properties);
            };
    
            /**
             * Encodes the specified KVMetadataEntry message. Does not implicitly {@link kvrwset.KVMetadataEntry.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry} message KVMetadataEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataEntry message, length delimited. Does not implicitly {@link kvrwset.KVMetadataEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry} message KVMetadataEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataEntry message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataEntry message.
             * @function verify
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVMetadataEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             */
            KVMetadataEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataEntry)
                    return object;
                var message = new $root.kvrwset.KVMetadataEntry();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.KVMetadataEntry} message KVMetadataEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KVMetadataEntry to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataEntry;
        })();
    
        kvrwset.Version = (function() {
    
            /**
             * Properties of a Version.
             * @memberof kvrwset
             * @interface IVersion
             * @property {number|Long|null} [block_num] Version block_num
             * @property {number|Long|null} [tx_num] Version tx_num
             */
    
            /**
             * Constructs a new Version.
             * @memberof kvrwset
             * @classdesc Represents a Version.
             * @implements IVersion
             * @constructor
             * @param {kvrwset.IVersion=} [properties] Properties to set
             */
            function Version(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Version block_num.
             * @member {number|Long} block_num
             * @memberof kvrwset.Version
             * @instance
             */
            Version.prototype.block_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Version tx_num.
             * @member {number|Long} tx_num
             * @memberof kvrwset.Version
             * @instance
             */
            Version.prototype.tx_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new Version instance using the specified properties.
             * @function create
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion=} [properties] Properties to set
             * @returns {kvrwset.Version} Version instance
             */
            Version.create = function create(properties) {
                return new Version(properties);
            };
    
            /**
             * Encodes the specified Version message. Does not implicitly {@link kvrwset.Version.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.block_num != null && Object.hasOwnProperty.call(message, "block_num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.block_num);
                if (message.tx_num != null && Object.hasOwnProperty.call(message, "tx_num"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.tx_num);
                return writer;
            };
    
            /**
             * Encodes the specified Version message, length delimited. Does not implicitly {@link kvrwset.Version.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Version message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.Version();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.block_num = reader.uint64();
                        break;
                    case 2:
                        message.tx_num = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Version message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Version message.
             * @function verify
             * @memberof kvrwset.Version
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Version.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.block_num != null && message.hasOwnProperty("block_num"))
                    if (!$util.isInteger(message.block_num) && !(message.block_num && $util.isInteger(message.block_num.low) && $util.isInteger(message.block_num.high)))
                        return "block_num: integer|Long expected";
                if (message.tx_num != null && message.hasOwnProperty("tx_num"))
                    if (!$util.isInteger(message.tx_num) && !(message.tx_num && $util.isInteger(message.tx_num.low) && $util.isInteger(message.tx_num.high)))
                        return "tx_num: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a Version message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.Version
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.Version} Version
             */
            Version.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.Version)
                    return object;
                var message = new $root.kvrwset.Version();
                if (object.block_num != null)
                    if ($util.Long)
                        (message.block_num = $util.Long.fromValue(object.block_num)).unsigned = true;
                    else if (typeof object.block_num === "string")
                        message.block_num = parseInt(object.block_num, 10);
                    else if (typeof object.block_num === "number")
                        message.block_num = object.block_num;
                    else if (typeof object.block_num === "object")
                        message.block_num = new $util.LongBits(object.block_num.low >>> 0, object.block_num.high >>> 0).toNumber(true);
                if (object.tx_num != null)
                    if ($util.Long)
                        (message.tx_num = $util.Long.fromValue(object.tx_num)).unsigned = true;
                    else if (typeof object.tx_num === "string")
                        message.tx_num = parseInt(object.tx_num, 10);
                    else if (typeof object.tx_num === "number")
                        message.tx_num = object.tx_num;
                    else if (typeof object.tx_num === "object")
                        message.tx_num = new $util.LongBits(object.tx_num.low >>> 0, object.tx_num.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a Version message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.Version} message Version
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Version.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.block_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.tx_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx_num = options.longs === String ? "0" : 0;
                }
                if (message.block_num != null && message.hasOwnProperty("block_num"))
                    if (typeof message.block_num === "number")
                        object.block_num = options.longs === String ? String(message.block_num) : message.block_num;
                    else
                        object.block_num = options.longs === String ? $util.Long.prototype.toString.call(message.block_num) : options.longs === Number ? new $util.LongBits(message.block_num.low >>> 0, message.block_num.high >>> 0).toNumber(true) : message.block_num;
                if (message.tx_num != null && message.hasOwnProperty("tx_num"))
                    if (typeof message.tx_num === "number")
                        object.tx_num = options.longs === String ? String(message.tx_num) : message.tx_num;
                    else
                        object.tx_num = options.longs === String ? $util.Long.prototype.toString.call(message.tx_num) : options.longs === Number ? new $util.LongBits(message.tx_num.low >>> 0, message.tx_num.high >>> 0).toNumber(true) : message.tx_num;
                return object;
            };
    
            /**
             * Converts this Version to JSON.
             * @function toJSON
             * @memberof kvrwset.Version
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Version.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Version;
        })();
    
        kvrwset.RangeQueryInfo = (function() {
    
            /**
             * Properties of a RangeQueryInfo.
             * @memberof kvrwset
             * @interface IRangeQueryInfo
             * @property {string|null} [start_key] RangeQueryInfo start_key
             * @property {string|null} [end_key] RangeQueryInfo end_key
             * @property {boolean|null} [itr_exhausted] RangeQueryInfo itr_exhausted
             * @property {kvrwset.IQueryReads|null} [raw_reads] RangeQueryInfo raw_reads
             * @property {kvrwset.IQueryReadsMerkleSummary|null} [reads_merkle_hashes] RangeQueryInfo reads_merkle_hashes
             */
    
            /**
             * Constructs a new RangeQueryInfo.
             * @memberof kvrwset
             * @classdesc Represents a RangeQueryInfo.
             * @implements IRangeQueryInfo
             * @constructor
             * @param {kvrwset.IRangeQueryInfo=} [properties] Properties to set
             */
            function RangeQueryInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RangeQueryInfo start_key.
             * @member {string} start_key
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.start_key = "";
    
            /**
             * RangeQueryInfo end_key.
             * @member {string} end_key
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.end_key = "";
    
            /**
             * RangeQueryInfo itr_exhausted.
             * @member {boolean} itr_exhausted
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.itr_exhausted = false;
    
            /**
             * RangeQueryInfo raw_reads.
             * @member {kvrwset.IQueryReads|null|undefined} raw_reads
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.raw_reads = null;
    
            /**
             * RangeQueryInfo reads_merkle_hashes.
             * @member {kvrwset.IQueryReadsMerkleSummary|null|undefined} reads_merkle_hashes
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.reads_merkle_hashes = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * RangeQueryInfo reads_info.
             * @member {"raw_reads"|"reads_merkle_hashes"|undefined} reads_info
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            Object.defineProperty(RangeQueryInfo.prototype, "reads_info", {
                get: $util.oneOfGetter($oneOfFields = ["raw_reads", "reads_merkle_hashes"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new RangeQueryInfo instance using the specified properties.
             * @function create
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo=} [properties] Properties to set
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo instance
             */
            RangeQueryInfo.create = function create(properties) {
                return new RangeQueryInfo(properties);
            };
    
            /**
             * Encodes the specified RangeQueryInfo message. Does not implicitly {@link kvrwset.RangeQueryInfo.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo} message RangeQueryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeQueryInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start_key != null && Object.hasOwnProperty.call(message, "start_key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.start_key);
                if (message.end_key != null && Object.hasOwnProperty.call(message, "end_key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.end_key);
                if (message.itr_exhausted != null && Object.hasOwnProperty.call(message, "itr_exhausted"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.itr_exhausted);
                if (message.raw_reads != null && Object.hasOwnProperty.call(message, "raw_reads"))
                    $root.kvrwset.QueryReads.encode(message.raw_reads, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.reads_merkle_hashes != null && Object.hasOwnProperty.call(message, "reads_merkle_hashes"))
                    $root.kvrwset.QueryReadsMerkleSummary.encode(message.reads_merkle_hashes, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RangeQueryInfo message, length delimited. Does not implicitly {@link kvrwset.RangeQueryInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo} message RangeQueryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeQueryInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RangeQueryInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeQueryInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.RangeQueryInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start_key = reader.string();
                        break;
                    case 2:
                        message.end_key = reader.string();
                        break;
                    case 3:
                        message.itr_exhausted = reader.bool();
                        break;
                    case 4:
                        message.raw_reads = $root.kvrwset.QueryReads.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.reads_merkle_hashes = $root.kvrwset.QueryReadsMerkleSummary.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RangeQueryInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeQueryInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RangeQueryInfo message.
             * @function verify
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RangeQueryInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.start_key != null && message.hasOwnProperty("start_key"))
                    if (!$util.isString(message.start_key))
                        return "start_key: string expected";
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    if (!$util.isString(message.end_key))
                        return "end_key: string expected";
                if (message.itr_exhausted != null && message.hasOwnProperty("itr_exhausted"))
                    if (typeof message.itr_exhausted !== "boolean")
                        return "itr_exhausted: boolean expected";
                if (message.raw_reads != null && message.hasOwnProperty("raw_reads")) {
                    properties.reads_info = 1;
                    {
                        var error = $root.kvrwset.QueryReads.verify(message.raw_reads);
                        if (error)
                            return "raw_reads." + error;
                    }
                }
                if (message.reads_merkle_hashes != null && message.hasOwnProperty("reads_merkle_hashes")) {
                    if (properties.reads_info === 1)
                        return "reads_info: multiple values";
                    properties.reads_info = 1;
                    {
                        var error = $root.kvrwset.QueryReadsMerkleSummary.verify(message.reads_merkle_hashes);
                        if (error)
                            return "reads_merkle_hashes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RangeQueryInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             */
            RangeQueryInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.RangeQueryInfo)
                    return object;
                var message = new $root.kvrwset.RangeQueryInfo();
                if (object.start_key != null)
                    message.start_key = String(object.start_key);
                if (object.end_key != null)
                    message.end_key = String(object.end_key);
                if (object.itr_exhausted != null)
                    message.itr_exhausted = Boolean(object.itr_exhausted);
                if (object.raw_reads != null) {
                    if (typeof object.raw_reads !== "object")
                        throw TypeError(".kvrwset.RangeQueryInfo.raw_reads: object expected");
                    message.raw_reads = $root.kvrwset.QueryReads.fromObject(object.raw_reads);
                }
                if (object.reads_merkle_hashes != null) {
                    if (typeof object.reads_merkle_hashes !== "object")
                        throw TypeError(".kvrwset.RangeQueryInfo.reads_merkle_hashes: object expected");
                    message.reads_merkle_hashes = $root.kvrwset.QueryReadsMerkleSummary.fromObject(object.reads_merkle_hashes);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RangeQueryInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.RangeQueryInfo} message RangeQueryInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RangeQueryInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.start_key = "";
                    object.end_key = "";
                    object.itr_exhausted = false;
                }
                if (message.start_key != null && message.hasOwnProperty("start_key"))
                    object.start_key = message.start_key;
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    object.end_key = message.end_key;
                if (message.itr_exhausted != null && message.hasOwnProperty("itr_exhausted"))
                    object.itr_exhausted = message.itr_exhausted;
                if (message.raw_reads != null && message.hasOwnProperty("raw_reads")) {
                    object.raw_reads = $root.kvrwset.QueryReads.toObject(message.raw_reads, options);
                    if (options.oneofs)
                        object.reads_info = "raw_reads";
                }
                if (message.reads_merkle_hashes != null && message.hasOwnProperty("reads_merkle_hashes")) {
                    object.reads_merkle_hashes = $root.kvrwset.QueryReadsMerkleSummary.toObject(message.reads_merkle_hashes, options);
                    if (options.oneofs)
                        object.reads_info = "reads_merkle_hashes";
                }
                return object;
            };
    
            /**
             * Converts this RangeQueryInfo to JSON.
             * @function toJSON
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RangeQueryInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RangeQueryInfo;
        })();
    
        kvrwset.QueryReads = (function() {
    
            /**
             * Properties of a QueryReads.
             * @memberof kvrwset
             * @interface IQueryReads
             * @property {Array.<kvrwset.IKVRead>|null} [kv_reads] QueryReads kv_reads
             */
    
            /**
             * Constructs a new QueryReads.
             * @memberof kvrwset
             * @classdesc Represents a QueryReads.
             * @implements IQueryReads
             * @constructor
             * @param {kvrwset.IQueryReads=} [properties] Properties to set
             */
            function QueryReads(properties) {
                this.kv_reads = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryReads kv_reads.
             * @member {Array.<kvrwset.IKVRead>} kv_reads
             * @memberof kvrwset.QueryReads
             * @instance
             */
            QueryReads.prototype.kv_reads = $util.emptyArray;
    
            /**
             * Creates a new QueryReads instance using the specified properties.
             * @function create
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads=} [properties] Properties to set
             * @returns {kvrwset.QueryReads} QueryReads instance
             */
            QueryReads.create = function create(properties) {
                return new QueryReads(properties);
            };
    
            /**
             * Encodes the specified QueryReads message. Does not implicitly {@link kvrwset.QueryReads.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads} message QueryReads message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReads.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kv_reads != null && message.kv_reads.length)
                    for (var i = 0; i < message.kv_reads.length; ++i)
                        $root.kvrwset.KVRead.encode(message.kv_reads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryReads message, length delimited. Does not implicitly {@link kvrwset.QueryReads.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads} message QueryReads message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReads.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryReads message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.QueryReads
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.QueryReads} QueryReads
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReads.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.QueryReads();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.kv_reads && message.kv_reads.length))
                            message.kv_reads = [];
                        message.kv_reads.push($root.kvrwset.KVRead.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryReads message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.QueryReads
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.QueryReads} QueryReads
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReads.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryReads message.
             * @function verify
             * @memberof kvrwset.QueryReads
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryReads.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kv_reads != null && message.hasOwnProperty("kv_reads")) {
                    if (!Array.isArray(message.kv_reads))
                        return "kv_reads: array expected";
                    for (var i = 0; i < message.kv_reads.length; ++i) {
                        var error = $root.kvrwset.KVRead.verify(message.kv_reads[i]);
                        if (error)
                            return "kv_reads." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryReads message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.QueryReads
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.QueryReads} QueryReads
             */
            QueryReads.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.QueryReads)
                    return object;
                var message = new $root.kvrwset.QueryReads();
                if (object.kv_reads) {
                    if (!Array.isArray(object.kv_reads))
                        throw TypeError(".kvrwset.QueryReads.kv_reads: array expected");
                    message.kv_reads = [];
                    for (var i = 0; i < object.kv_reads.length; ++i) {
                        if (typeof object.kv_reads[i] !== "object")
                            throw TypeError(".kvrwset.QueryReads.kv_reads: object expected");
                        message.kv_reads[i] = $root.kvrwset.KVRead.fromObject(object.kv_reads[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryReads message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.QueryReads} message QueryReads
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryReads.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.kv_reads = [];
                if (message.kv_reads && message.kv_reads.length) {
                    object.kv_reads = [];
                    for (var j = 0; j < message.kv_reads.length; ++j)
                        object.kv_reads[j] = $root.kvrwset.KVRead.toObject(message.kv_reads[j], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryReads to JSON.
             * @function toJSON
             * @memberof kvrwset.QueryReads
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryReads.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryReads;
        })();
    
        kvrwset.QueryReadsMerkleSummary = (function() {
    
            /**
             * Properties of a QueryReadsMerkleSummary.
             * @memberof kvrwset
             * @interface IQueryReadsMerkleSummary
             * @property {number|null} [max_degree] QueryReadsMerkleSummary max_degree
             * @property {number|null} [max_level] QueryReadsMerkleSummary max_level
             * @property {Array.<Uint8Array>|null} [max_level_hashes] QueryReadsMerkleSummary max_level_hashes
             */
    
            /**
             * Constructs a new QueryReadsMerkleSummary.
             * @memberof kvrwset
             * @classdesc Represents a QueryReadsMerkleSummary.
             * @implements IQueryReadsMerkleSummary
             * @constructor
             * @param {kvrwset.IQueryReadsMerkleSummary=} [properties] Properties to set
             */
            function QueryReadsMerkleSummary(properties) {
                this.max_level_hashes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryReadsMerkleSummary max_degree.
             * @member {number} max_degree
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.max_degree = 0;
    
            /**
             * QueryReadsMerkleSummary max_level.
             * @member {number} max_level
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.max_level = 0;
    
            /**
             * QueryReadsMerkleSummary max_level_hashes.
             * @member {Array.<Uint8Array>} max_level_hashes
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.max_level_hashes = $util.emptyArray;
    
            /**
             * Creates a new QueryReadsMerkleSummary instance using the specified properties.
             * @function create
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary=} [properties] Properties to set
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary instance
             */
            QueryReadsMerkleSummary.create = function create(properties) {
                return new QueryReadsMerkleSummary(properties);
            };
    
            /**
             * Encodes the specified QueryReadsMerkleSummary message. Does not implicitly {@link kvrwset.QueryReadsMerkleSummary.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary} message QueryReadsMerkleSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReadsMerkleSummary.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.max_degree != null && Object.hasOwnProperty.call(message, "max_degree"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.max_degree);
                if (message.max_level != null && Object.hasOwnProperty.call(message, "max_level"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.max_level);
                if (message.max_level_hashes != null && message.max_level_hashes.length)
                    for (var i = 0; i < message.max_level_hashes.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.max_level_hashes[i]);
                return writer;
            };
    
            /**
             * Encodes the specified QueryReadsMerkleSummary message, length delimited. Does not implicitly {@link kvrwset.QueryReadsMerkleSummary.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary} message QueryReadsMerkleSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReadsMerkleSummary.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryReadsMerkleSummary message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReadsMerkleSummary.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.QueryReadsMerkleSummary();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.max_degree = reader.uint32();
                        break;
                    case 2:
                        message.max_level = reader.uint32();
                        break;
                    case 3:
                        if (!(message.max_level_hashes && message.max_level_hashes.length))
                            message.max_level_hashes = [];
                        message.max_level_hashes.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryReadsMerkleSummary message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReadsMerkleSummary.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryReadsMerkleSummary message.
             * @function verify
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryReadsMerkleSummary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.max_degree != null && message.hasOwnProperty("max_degree"))
                    if (!$util.isInteger(message.max_degree))
                        return "max_degree: integer expected";
                if (message.max_level != null && message.hasOwnProperty("max_level"))
                    if (!$util.isInteger(message.max_level))
                        return "max_level: integer expected";
                if (message.max_level_hashes != null && message.hasOwnProperty("max_level_hashes")) {
                    if (!Array.isArray(message.max_level_hashes))
                        return "max_level_hashes: array expected";
                    for (var i = 0; i < message.max_level_hashes.length; ++i)
                        if (!(message.max_level_hashes[i] && typeof message.max_level_hashes[i].length === "number" || $util.isString(message.max_level_hashes[i])))
                            return "max_level_hashes: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a QueryReadsMerkleSummary message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             */
            QueryReadsMerkleSummary.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.QueryReadsMerkleSummary)
                    return object;
                var message = new $root.kvrwset.QueryReadsMerkleSummary();
                if (object.max_degree != null)
                    message.max_degree = object.max_degree >>> 0;
                if (object.max_level != null)
                    message.max_level = object.max_level >>> 0;
                if (object.max_level_hashes) {
                    if (!Array.isArray(object.max_level_hashes))
                        throw TypeError(".kvrwset.QueryReadsMerkleSummary.max_level_hashes: array expected");
                    message.max_level_hashes = [];
                    for (var i = 0; i < object.max_level_hashes.length; ++i)
                        if (typeof object.max_level_hashes[i] === "string")
                            $util.base64.decode(object.max_level_hashes[i], message.max_level_hashes[i] = $util.newBuffer($util.base64.length(object.max_level_hashes[i])), 0);
                        else if (object.max_level_hashes[i].length)
                            message.max_level_hashes[i] = object.max_level_hashes[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryReadsMerkleSummary message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.QueryReadsMerkleSummary} message QueryReadsMerkleSummary
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryReadsMerkleSummary.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.max_level_hashes = [];
                if (options.defaults) {
                    object.max_degree = 0;
                    object.max_level = 0;
                }
                if (message.max_degree != null && message.hasOwnProperty("max_degree"))
                    object.max_degree = message.max_degree;
                if (message.max_level != null && message.hasOwnProperty("max_level"))
                    object.max_level = message.max_level;
                if (message.max_level_hashes && message.max_level_hashes.length) {
                    object.max_level_hashes = [];
                    for (var j = 0; j < message.max_level_hashes.length; ++j)
                        object.max_level_hashes[j] = options.bytes === String ? $util.base64.encode(message.max_level_hashes[j], 0, message.max_level_hashes[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.max_level_hashes[j]) : message.max_level_hashes[j];
                }
                return object;
            };
    
            /**
             * Converts this QueryReadsMerkleSummary to JSON.
             * @function toJSON
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryReadsMerkleSummary.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryReadsMerkleSummary;
        })();
    
        return kvrwset;
    })();
    
    $root.rwset = (function() {
    
        /**
         * Namespace rwset.
         * @exports rwset
         * @namespace
         */
        var rwset = {};
    
        rwset.TxReadWriteSet = (function() {
    
            /**
             * Properties of a TxReadWriteSet.
             * @memberof rwset
             * @interface ITxReadWriteSet
             * @property {rwset.TxReadWriteSet.DataModel|null} [data_model] TxReadWriteSet data_model
             * @property {Array.<rwset.INsReadWriteSet>|null} [ns_rwset] TxReadWriteSet ns_rwset
             */
    
            /**
             * Constructs a new TxReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a TxReadWriteSet.
             * @implements ITxReadWriteSet
             * @constructor
             * @param {rwset.ITxReadWriteSet=} [properties] Properties to set
             */
            function TxReadWriteSet(properties) {
                this.ns_rwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TxReadWriteSet data_model.
             * @member {rwset.TxReadWriteSet.DataModel} data_model
             * @memberof rwset.TxReadWriteSet
             * @instance
             */
            TxReadWriteSet.prototype.data_model = 0;
    
            /**
             * TxReadWriteSet ns_rwset.
             * @member {Array.<rwset.INsReadWriteSet>} ns_rwset
             * @memberof rwset.TxReadWriteSet
             * @instance
             */
            TxReadWriteSet.prototype.ns_rwset = $util.emptyArray;
    
            /**
             * Creates a new TxReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet=} [properties] Properties to set
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet instance
             */
            TxReadWriteSet.create = function create(properties) {
                return new TxReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified TxReadWriteSet message. Does not implicitly {@link rwset.TxReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet} message TxReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data_model != null && Object.hasOwnProperty.call(message, "data_model"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.data_model);
                if (message.ns_rwset != null && message.ns_rwset.length)
                    for (var i = 0; i < message.ns_rwset.length; ++i)
                        $root.rwset.NsReadWriteSet.encode(message.ns_rwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified TxReadWriteSet message, length delimited. Does not implicitly {@link rwset.TxReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet} message TxReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TxReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.TxReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data_model = reader.int32();
                        break;
                    case 2:
                        if (!(message.ns_rwset && message.ns_rwset.length))
                            message.ns_rwset = [];
                        message.ns_rwset.push($root.rwset.NsReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TxReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TxReadWriteSet message.
             * @function verify
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data_model != null && message.hasOwnProperty("data_model"))
                    switch (message.data_model) {
                    default:
                        return "data_model: enum value expected";
                    case 0:
                        break;
                    }
                if (message.ns_rwset != null && message.hasOwnProperty("ns_rwset")) {
                    if (!Array.isArray(message.ns_rwset))
                        return "ns_rwset: array expected";
                    for (var i = 0; i < message.ns_rwset.length; ++i) {
                        var error = $root.rwset.NsReadWriteSet.verify(message.ns_rwset[i]);
                        if (error)
                            return "ns_rwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TxReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             */
            TxReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.TxReadWriteSet)
                    return object;
                var message = new $root.rwset.TxReadWriteSet();
                switch (object.data_model) {
                case "KV":
                case 0:
                    message.data_model = 0;
                    break;
                }
                if (object.ns_rwset) {
                    if (!Array.isArray(object.ns_rwset))
                        throw TypeError(".rwset.TxReadWriteSet.ns_rwset: array expected");
                    message.ns_rwset = [];
                    for (var i = 0; i < object.ns_rwset.length; ++i) {
                        if (typeof object.ns_rwset[i] !== "object")
                            throw TypeError(".rwset.TxReadWriteSet.ns_rwset: object expected");
                        message.ns_rwset[i] = $root.rwset.NsReadWriteSet.fromObject(object.ns_rwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TxReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.TxReadWriteSet} message TxReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ns_rwset = [];
                if (options.defaults)
                    object.data_model = options.enums === String ? "KV" : 0;
                if (message.data_model != null && message.hasOwnProperty("data_model"))
                    object.data_model = options.enums === String ? $root.rwset.TxReadWriteSet.DataModel[message.data_model] : message.data_model;
                if (message.ns_rwset && message.ns_rwset.length) {
                    object.ns_rwset = [];
                    for (var j = 0; j < message.ns_rwset.length; ++j)
                        object.ns_rwset[j] = $root.rwset.NsReadWriteSet.toObject(message.ns_rwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this TxReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.TxReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * DataModel enum.
             * @name rwset.TxReadWriteSet.DataModel
             * @enum {number}
             * @property {number} KV=0 KV value
             */
            TxReadWriteSet.DataModel = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "KV"] = 0;
                return values;
            })();
    
            return TxReadWriteSet;
        })();
    
        rwset.NsReadWriteSet = (function() {
    
            /**
             * Properties of a NsReadWriteSet.
             * @memberof rwset
             * @interface INsReadWriteSet
             * @property {string|null} [namespace] NsReadWriteSet namespace
             * @property {Uint8Array|null} [rwset] NsReadWriteSet rwset
             * @property {Array.<rwset.ICollectionHashedReadWriteSet>|null} [collection_hashed_rwset] NsReadWriteSet collection_hashed_rwset
             */
    
            /**
             * Constructs a new NsReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a NsReadWriteSet.
             * @implements INsReadWriteSet
             * @constructor
             * @param {rwset.INsReadWriteSet=} [properties] Properties to set
             */
            function NsReadWriteSet(properties) {
                this.collection_hashed_rwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NsReadWriteSet namespace.
             * @member {string} namespace
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.namespace = "";
    
            /**
             * NsReadWriteSet rwset.
             * @member {Uint8Array} rwset
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.rwset = $util.newBuffer([]);
    
            /**
             * NsReadWriteSet collection_hashed_rwset.
             * @member {Array.<rwset.ICollectionHashedReadWriteSet>} collection_hashed_rwset
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.collection_hashed_rwset = $util.emptyArray;
    
            /**
             * Creates a new NsReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet=} [properties] Properties to set
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet instance
             */
            NsReadWriteSet.create = function create(properties) {
                return new NsReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified NsReadWriteSet message. Does not implicitly {@link rwset.NsReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet} message NsReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.rwset != null && Object.hasOwnProperty.call(message, "rwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rwset);
                if (message.collection_hashed_rwset != null && message.collection_hashed_rwset.length)
                    for (var i = 0; i < message.collection_hashed_rwset.length; ++i)
                        $root.rwset.CollectionHashedReadWriteSet.encode(message.collection_hashed_rwset[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified NsReadWriteSet message, length delimited. Does not implicitly {@link rwset.NsReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet} message NsReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NsReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.NsReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        message.rwset = reader.bytes();
                        break;
                    case 3:
                        if (!(message.collection_hashed_rwset && message.collection_hashed_rwset.length))
                            message.collection_hashed_rwset = [];
                        message.collection_hashed_rwset.push($root.rwset.CollectionHashedReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NsReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NsReadWriteSet message.
             * @function verify
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NsReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    if (!(message.rwset && typeof message.rwset.length === "number" || $util.isString(message.rwset)))
                        return "rwset: buffer expected";
                if (message.collection_hashed_rwset != null && message.hasOwnProperty("collection_hashed_rwset")) {
                    if (!Array.isArray(message.collection_hashed_rwset))
                        return "collection_hashed_rwset: array expected";
                    for (var i = 0; i < message.collection_hashed_rwset.length; ++i) {
                        var error = $root.rwset.CollectionHashedReadWriteSet.verify(message.collection_hashed_rwset[i]);
                        if (error)
                            return "collection_hashed_rwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a NsReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             */
            NsReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.NsReadWriteSet)
                    return object;
                var message = new $root.rwset.NsReadWriteSet();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.rwset != null)
                    if (typeof object.rwset === "string")
                        $util.base64.decode(object.rwset, message.rwset = $util.newBuffer($util.base64.length(object.rwset)), 0);
                    else if (object.rwset.length)
                        message.rwset = object.rwset;
                if (object.collection_hashed_rwset) {
                    if (!Array.isArray(object.collection_hashed_rwset))
                        throw TypeError(".rwset.NsReadWriteSet.collection_hashed_rwset: array expected");
                    message.collection_hashed_rwset = [];
                    for (var i = 0; i < object.collection_hashed_rwset.length; ++i) {
                        if (typeof object.collection_hashed_rwset[i] !== "object")
                            throw TypeError(".rwset.NsReadWriteSet.collection_hashed_rwset: object expected");
                        message.collection_hashed_rwset[i] = $root.rwset.CollectionHashedReadWriteSet.fromObject(object.collection_hashed_rwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a NsReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.NsReadWriteSet} message NsReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NsReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collection_hashed_rwset = [];
                if (options.defaults) {
                    object.namespace = "";
                    if (options.bytes === String)
                        object.rwset = "";
                    else {
                        object.rwset = [];
                        if (options.bytes !== Array)
                            object.rwset = $util.newBuffer(object.rwset);
                    }
                }
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    object.rwset = options.bytes === String ? $util.base64.encode(message.rwset, 0, message.rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.rwset) : message.rwset;
                if (message.collection_hashed_rwset && message.collection_hashed_rwset.length) {
                    object.collection_hashed_rwset = [];
                    for (var j = 0; j < message.collection_hashed_rwset.length; ++j)
                        object.collection_hashed_rwset[j] = $root.rwset.CollectionHashedReadWriteSet.toObject(message.collection_hashed_rwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this NsReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.NsReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NsReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NsReadWriteSet;
        })();
    
        rwset.CollectionHashedReadWriteSet = (function() {
    
            /**
             * Properties of a CollectionHashedReadWriteSet.
             * @memberof rwset
             * @interface ICollectionHashedReadWriteSet
             * @property {string|null} [collection_name] CollectionHashedReadWriteSet collection_name
             * @property {Uint8Array|null} [hashed_rwset] CollectionHashedReadWriteSet hashed_rwset
             * @property {Uint8Array|null} [pvt_rwset_hash] CollectionHashedReadWriteSet pvt_rwset_hash
             */
    
            /**
             * Constructs a new CollectionHashedReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a CollectionHashedReadWriteSet.
             * @implements ICollectionHashedReadWriteSet
             * @constructor
             * @param {rwset.ICollectionHashedReadWriteSet=} [properties] Properties to set
             */
            function CollectionHashedReadWriteSet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionHashedReadWriteSet collection_name.
             * @member {string} collection_name
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.collection_name = "";
    
            /**
             * CollectionHashedReadWriteSet hashed_rwset.
             * @member {Uint8Array} hashed_rwset
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.hashed_rwset = $util.newBuffer([]);
    
            /**
             * CollectionHashedReadWriteSet pvt_rwset_hash.
             * @member {Uint8Array} pvt_rwset_hash
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.pvt_rwset_hash = $util.newBuffer([]);
    
            /**
             * Creates a new CollectionHashedReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet=} [properties] Properties to set
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet instance
             */
            CollectionHashedReadWriteSet.create = function create(properties) {
                return new CollectionHashedReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified CollectionHashedReadWriteSet message. Does not implicitly {@link rwset.CollectionHashedReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet} message CollectionHashedReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionHashedReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection_name != null && Object.hasOwnProperty.call(message, "collection_name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection_name);
                if (message.hashed_rwset != null && Object.hasOwnProperty.call(message, "hashed_rwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hashed_rwset);
                if (message.pvt_rwset_hash != null && Object.hasOwnProperty.call(message, "pvt_rwset_hash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pvt_rwset_hash);
                return writer;
            };
    
            /**
             * Encodes the specified CollectionHashedReadWriteSet message, length delimited. Does not implicitly {@link rwset.CollectionHashedReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet} message CollectionHashedReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionHashedReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionHashedReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionHashedReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.CollectionHashedReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection_name = reader.string();
                        break;
                    case 2:
                        message.hashed_rwset = reader.bytes();
                        break;
                    case 3:
                        message.pvt_rwset_hash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionHashedReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionHashedReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionHashedReadWriteSet message.
             * @function verify
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionHashedReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    if (!$util.isString(message.collection_name))
                        return "collection_name: string expected";
                if (message.hashed_rwset != null && message.hasOwnProperty("hashed_rwset"))
                    if (!(message.hashed_rwset && typeof message.hashed_rwset.length === "number" || $util.isString(message.hashed_rwset)))
                        return "hashed_rwset: buffer expected";
                if (message.pvt_rwset_hash != null && message.hasOwnProperty("pvt_rwset_hash"))
                    if (!(message.pvt_rwset_hash && typeof message.pvt_rwset_hash.length === "number" || $util.isString(message.pvt_rwset_hash)))
                        return "pvt_rwset_hash: buffer expected";
                return null;
            };
    
            /**
             * Creates a CollectionHashedReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             */
            CollectionHashedReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.CollectionHashedReadWriteSet)
                    return object;
                var message = new $root.rwset.CollectionHashedReadWriteSet();
                if (object.collection_name != null)
                    message.collection_name = String(object.collection_name);
                if (object.hashed_rwset != null)
                    if (typeof object.hashed_rwset === "string")
                        $util.base64.decode(object.hashed_rwset, message.hashed_rwset = $util.newBuffer($util.base64.length(object.hashed_rwset)), 0);
                    else if (object.hashed_rwset.length)
                        message.hashed_rwset = object.hashed_rwset;
                if (object.pvt_rwset_hash != null)
                    if (typeof object.pvt_rwset_hash === "string")
                        $util.base64.decode(object.pvt_rwset_hash, message.pvt_rwset_hash = $util.newBuffer($util.base64.length(object.pvt_rwset_hash)), 0);
                    else if (object.pvt_rwset_hash.length)
                        message.pvt_rwset_hash = object.pvt_rwset_hash;
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionHashedReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.CollectionHashedReadWriteSet} message CollectionHashedReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionHashedReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection_name = "";
                    if (options.bytes === String)
                        object.hashed_rwset = "";
                    else {
                        object.hashed_rwset = [];
                        if (options.bytes !== Array)
                            object.hashed_rwset = $util.newBuffer(object.hashed_rwset);
                    }
                    if (options.bytes === String)
                        object.pvt_rwset_hash = "";
                    else {
                        object.pvt_rwset_hash = [];
                        if (options.bytes !== Array)
                            object.pvt_rwset_hash = $util.newBuffer(object.pvt_rwset_hash);
                    }
                }
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    object.collection_name = message.collection_name;
                if (message.hashed_rwset != null && message.hasOwnProperty("hashed_rwset"))
                    object.hashed_rwset = options.bytes === String ? $util.base64.encode(message.hashed_rwset, 0, message.hashed_rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashed_rwset) : message.hashed_rwset;
                if (message.pvt_rwset_hash != null && message.hasOwnProperty("pvt_rwset_hash"))
                    object.pvt_rwset_hash = options.bytes === String ? $util.base64.encode(message.pvt_rwset_hash, 0, message.pvt_rwset_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.pvt_rwset_hash) : message.pvt_rwset_hash;
                return object;
            };
    
            /**
             * Converts this CollectionHashedReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionHashedReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionHashedReadWriteSet;
        })();
    
        rwset.TxPvtReadWriteSet = (function() {
    
            /**
             * Properties of a TxPvtReadWriteSet.
             * @memberof rwset
             * @interface ITxPvtReadWriteSet
             * @property {rwset.TxReadWriteSet.DataModel|null} [data_model] TxPvtReadWriteSet data_model
             * @property {Array.<rwset.INsPvtReadWriteSet>|null} [ns_pvt_rwset] TxPvtReadWriteSet ns_pvt_rwset
             */
    
            /**
             * Constructs a new TxPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a TxPvtReadWriteSet.
             * @implements ITxPvtReadWriteSet
             * @constructor
             * @param {rwset.ITxPvtReadWriteSet=} [properties] Properties to set
             */
            function TxPvtReadWriteSet(properties) {
                this.ns_pvt_rwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TxPvtReadWriteSet data_model.
             * @member {rwset.TxReadWriteSet.DataModel} data_model
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             */
            TxPvtReadWriteSet.prototype.data_model = 0;
    
            /**
             * TxPvtReadWriteSet ns_pvt_rwset.
             * @member {Array.<rwset.INsPvtReadWriteSet>} ns_pvt_rwset
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             */
            TxPvtReadWriteSet.prototype.ns_pvt_rwset = $util.emptyArray;
    
            /**
             * Creates a new TxPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet instance
             */
            TxPvtReadWriteSet.create = function create(properties) {
                return new TxPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSet message. Does not implicitly {@link rwset.TxPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet} message TxPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data_model != null && Object.hasOwnProperty.call(message, "data_model"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.data_model);
                if (message.ns_pvt_rwset != null && message.ns_pvt_rwset.length)
                    for (var i = 0; i < message.ns_pvt_rwset.length; ++i)
                        $root.rwset.NsPvtReadWriteSet.encode(message.ns_pvt_rwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.TxPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet} message TxPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TxPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.TxPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data_model = reader.int32();
                        break;
                    case 2:
                        if (!(message.ns_pvt_rwset && message.ns_pvt_rwset.length))
                            message.ns_pvt_rwset = [];
                        message.ns_pvt_rwset.push($root.rwset.NsPvtReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TxPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TxPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data_model != null && message.hasOwnProperty("data_model"))
                    switch (message.data_model) {
                    default:
                        return "data_model: enum value expected";
                    case 0:
                        break;
                    }
                if (message.ns_pvt_rwset != null && message.hasOwnProperty("ns_pvt_rwset")) {
                    if (!Array.isArray(message.ns_pvt_rwset))
                        return "ns_pvt_rwset: array expected";
                    for (var i = 0; i < message.ns_pvt_rwset.length; ++i) {
                        var error = $root.rwset.NsPvtReadWriteSet.verify(message.ns_pvt_rwset[i]);
                        if (error)
                            return "ns_pvt_rwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TxPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             */
            TxPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.TxPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.TxPvtReadWriteSet();
                switch (object.data_model) {
                case "KV":
                case 0:
                    message.data_model = 0;
                    break;
                }
                if (object.ns_pvt_rwset) {
                    if (!Array.isArray(object.ns_pvt_rwset))
                        throw TypeError(".rwset.TxPvtReadWriteSet.ns_pvt_rwset: array expected");
                    message.ns_pvt_rwset = [];
                    for (var i = 0; i < object.ns_pvt_rwset.length; ++i) {
                        if (typeof object.ns_pvt_rwset[i] !== "object")
                            throw TypeError(".rwset.TxPvtReadWriteSet.ns_pvt_rwset: object expected");
                        message.ns_pvt_rwset[i] = $root.rwset.NsPvtReadWriteSet.fromObject(object.ns_pvt_rwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TxPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.TxPvtReadWriteSet} message TxPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ns_pvt_rwset = [];
                if (options.defaults)
                    object.data_model = options.enums === String ? "KV" : 0;
                if (message.data_model != null && message.hasOwnProperty("data_model"))
                    object.data_model = options.enums === String ? $root.rwset.TxReadWriteSet.DataModel[message.data_model] : message.data_model;
                if (message.ns_pvt_rwset && message.ns_pvt_rwset.length) {
                    object.ns_pvt_rwset = [];
                    for (var j = 0; j < message.ns_pvt_rwset.length; ++j)
                        object.ns_pvt_rwset[j] = $root.rwset.NsPvtReadWriteSet.toObject(message.ns_pvt_rwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this TxPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TxPvtReadWriteSet;
        })();
    
        rwset.NsPvtReadWriteSet = (function() {
    
            /**
             * Properties of a NsPvtReadWriteSet.
             * @memberof rwset
             * @interface INsPvtReadWriteSet
             * @property {string|null} [namespace] NsPvtReadWriteSet namespace
             * @property {Array.<rwset.ICollectionPvtReadWriteSet>|null} [collection_pvt_rwset] NsPvtReadWriteSet collection_pvt_rwset
             */
    
            /**
             * Constructs a new NsPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a NsPvtReadWriteSet.
             * @implements INsPvtReadWriteSet
             * @constructor
             * @param {rwset.INsPvtReadWriteSet=} [properties] Properties to set
             */
            function NsPvtReadWriteSet(properties) {
                this.collection_pvt_rwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NsPvtReadWriteSet namespace.
             * @member {string} namespace
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             */
            NsPvtReadWriteSet.prototype.namespace = "";
    
            /**
             * NsPvtReadWriteSet collection_pvt_rwset.
             * @member {Array.<rwset.ICollectionPvtReadWriteSet>} collection_pvt_rwset
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             */
            NsPvtReadWriteSet.prototype.collection_pvt_rwset = $util.emptyArray;
    
            /**
             * Creates a new NsPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet instance
             */
            NsPvtReadWriteSet.create = function create(properties) {
                return new NsPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified NsPvtReadWriteSet message. Does not implicitly {@link rwset.NsPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet} message NsPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.collection_pvt_rwset != null && message.collection_pvt_rwset.length)
                    for (var i = 0; i < message.collection_pvt_rwset.length; ++i)
                        $root.rwset.CollectionPvtReadWriteSet.encode(message.collection_pvt_rwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified NsPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.NsPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet} message NsPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NsPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.NsPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        if (!(message.collection_pvt_rwset && message.collection_pvt_rwset.length))
                            message.collection_pvt_rwset = [];
                        message.collection_pvt_rwset.push($root.rwset.CollectionPvtReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NsPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NsPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NsPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.collection_pvt_rwset != null && message.hasOwnProperty("collection_pvt_rwset")) {
                    if (!Array.isArray(message.collection_pvt_rwset))
                        return "collection_pvt_rwset: array expected";
                    for (var i = 0; i < message.collection_pvt_rwset.length; ++i) {
                        var error = $root.rwset.CollectionPvtReadWriteSet.verify(message.collection_pvt_rwset[i]);
                        if (error)
                            return "collection_pvt_rwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a NsPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             */
            NsPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.NsPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.NsPvtReadWriteSet();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.collection_pvt_rwset) {
                    if (!Array.isArray(object.collection_pvt_rwset))
                        throw TypeError(".rwset.NsPvtReadWriteSet.collection_pvt_rwset: array expected");
                    message.collection_pvt_rwset = [];
                    for (var i = 0; i < object.collection_pvt_rwset.length; ++i) {
                        if (typeof object.collection_pvt_rwset[i] !== "object")
                            throw TypeError(".rwset.NsPvtReadWriteSet.collection_pvt_rwset: object expected");
                        message.collection_pvt_rwset[i] = $root.rwset.CollectionPvtReadWriteSet.fromObject(object.collection_pvt_rwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a NsPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.NsPvtReadWriteSet} message NsPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NsPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collection_pvt_rwset = [];
                if (options.defaults)
                    object.namespace = "";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.collection_pvt_rwset && message.collection_pvt_rwset.length) {
                    object.collection_pvt_rwset = [];
                    for (var j = 0; j < message.collection_pvt_rwset.length; ++j)
                        object.collection_pvt_rwset[j] = $root.rwset.CollectionPvtReadWriteSet.toObject(message.collection_pvt_rwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this NsPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NsPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NsPvtReadWriteSet;
        })();
    
        rwset.CollectionPvtReadWriteSet = (function() {
    
            /**
             * Properties of a CollectionPvtReadWriteSet.
             * @memberof rwset
             * @interface ICollectionPvtReadWriteSet
             * @property {string|null} [collection_name] CollectionPvtReadWriteSet collection_name
             * @property {Uint8Array|null} [rwset] CollectionPvtReadWriteSet rwset
             */
    
            /**
             * Constructs a new CollectionPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a CollectionPvtReadWriteSet.
             * @implements ICollectionPvtReadWriteSet
             * @constructor
             * @param {rwset.ICollectionPvtReadWriteSet=} [properties] Properties to set
             */
            function CollectionPvtReadWriteSet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionPvtReadWriteSet collection_name.
             * @member {string} collection_name
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             */
            CollectionPvtReadWriteSet.prototype.collection_name = "";
    
            /**
             * CollectionPvtReadWriteSet rwset.
             * @member {Uint8Array} rwset
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             */
            CollectionPvtReadWriteSet.prototype.rwset = $util.newBuffer([]);
    
            /**
             * Creates a new CollectionPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet instance
             */
            CollectionPvtReadWriteSet.create = function create(properties) {
                return new CollectionPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified CollectionPvtReadWriteSet message. Does not implicitly {@link rwset.CollectionPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet} message CollectionPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection_name != null && Object.hasOwnProperty.call(message, "collection_name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection_name);
                if (message.rwset != null && Object.hasOwnProperty.call(message, "rwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rwset);
                return writer;
            };
    
            /**
             * Encodes the specified CollectionPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.CollectionPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet} message CollectionPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.CollectionPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection_name = reader.string();
                        break;
                    case 2:
                        message.rwset = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    if (!$util.isString(message.collection_name))
                        return "collection_name: string expected";
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    if (!(message.rwset && typeof message.rwset.length === "number" || $util.isString(message.rwset)))
                        return "rwset: buffer expected";
                return null;
            };
    
            /**
             * Creates a CollectionPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             */
            CollectionPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.CollectionPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.CollectionPvtReadWriteSet();
                if (object.collection_name != null)
                    message.collection_name = String(object.collection_name);
                if (object.rwset != null)
                    if (typeof object.rwset === "string")
                        $util.base64.decode(object.rwset, message.rwset = $util.newBuffer($util.base64.length(object.rwset)), 0);
                    else if (object.rwset.length)
                        message.rwset = object.rwset;
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.CollectionPvtReadWriteSet} message CollectionPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection_name = "";
                    if (options.bytes === String)
                        object.rwset = "";
                    else {
                        object.rwset = [];
                        if (options.bytes !== Array)
                            object.rwset = $util.newBuffer(object.rwset);
                    }
                }
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    object.collection_name = message.collection_name;
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    object.rwset = options.bytes === String ? $util.base64.encode(message.rwset, 0, message.rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.rwset) : message.rwset;
                return object;
            };
    
            /**
             * Converts this CollectionPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionPvtReadWriteSet;
        })();
    
        return rwset;
    })();
    
    $root.queryresult = (function() {
    
        /**
         * Namespace queryresult.
         * @exports queryresult
         * @namespace
         */
        var queryresult = {};
    
        queryresult.KV = (function() {
    
            /**
             * Properties of a KV.
             * @memberof queryresult
             * @interface IKV
             * @property {string|null} [namespace] KV namespace
             * @property {string|null} [key] KV key
             * @property {Uint8Array|null} [value] KV value
             */
    
            /**
             * Constructs a new KV.
             * @memberof queryresult
             * @classdesc Represents a KV.
             * @implements IKV
             * @constructor
             * @param {queryresult.IKV=} [properties] Properties to set
             */
            function KV(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KV namespace.
             * @member {string} namespace
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.namespace = "";
    
            /**
             * KV key.
             * @member {string} key
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.key = "";
    
            /**
             * KV value.
             * @member {Uint8Array} value
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KV instance using the specified properties.
             * @function create
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV=} [properties] Properties to set
             * @returns {queryresult.KV} KV instance
             */
            KV.create = function create(properties) {
                return new KV(properties);
            };
    
            /**
             * Encodes the specified KV message. Does not implicitly {@link queryresult.KV.verify|verify} messages.
             * @function encode
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV} message KV message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KV.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KV message, length delimited. Does not implicitly {@link queryresult.KV.verify|verify} messages.
             * @function encodeDelimited
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV} message KV message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KV.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KV message from the specified reader or buffer.
             * @function decode
             * @memberof queryresult.KV
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {queryresult.KV} KV
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KV.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.queryresult.KV();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KV message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof queryresult.KV
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {queryresult.KV} KV
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KV.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KV message.
             * @function verify
             * @memberof queryresult.KV
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KV.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KV message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof queryresult.KV
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {queryresult.KV} KV
             */
            KV.fromObject = function fromObject(object) {
                if (object instanceof $root.queryresult.KV)
                    return object;
                var message = new $root.queryresult.KV();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KV message. Also converts values to other types if specified.
             * @function toObject
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.KV} message KV
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KV.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.namespace = "";
                    object.key = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KV to JSON.
             * @function toJSON
             * @memberof queryresult.KV
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KV.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KV;
        })();
    
        queryresult.KeyModification = (function() {
    
            /**
             * Properties of a KeyModification.
             * @memberof queryresult
             * @interface IKeyModification
             * @property {string|null} [tx_id] KeyModification tx_id
             * @property {Uint8Array|null} [value] KeyModification value
             * @property {google.protobuf.ITimestamp|null} [timestamp] KeyModification timestamp
             * @property {boolean|null} [is_delete] KeyModification is_delete
             */
    
            /**
             * Constructs a new KeyModification.
             * @memberof queryresult
             * @classdesc Represents a KeyModification.
             * @implements IKeyModification
             * @constructor
             * @param {queryresult.IKeyModification=} [properties] Properties to set
             */
            function KeyModification(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KeyModification tx_id.
             * @member {string} tx_id
             * @memberof queryresult.KeyModification
             * @instance
             */
            KeyModification.prototype.tx_id = "";
    
            /**
             * KeyModification value.
             * @member {Uint8Array} value
             * @memberof queryresult.KeyModification
             * @instance
             */
            KeyModification.prototype.value = $util.newBuffer([]);
    
            /**
             * KeyModification timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof queryresult.KeyModification
             * @instance
             */
            KeyModification.prototype.timestamp = null;
    
            /**
             * KeyModification is_delete.
             * @member {boolean} is_delete
             * @memberof queryresult.KeyModification
             * @instance
             */
            KeyModification.prototype.is_delete = false;
    
            /**
             * Creates a new KeyModification instance using the specified properties.
             * @function create
             * @memberof queryresult.KeyModification
             * @static
             * @param {queryresult.IKeyModification=} [properties] Properties to set
             * @returns {queryresult.KeyModification} KeyModification instance
             */
            KeyModification.create = function create(properties) {
                return new KeyModification(properties);
            };
    
            /**
             * Encodes the specified KeyModification message. Does not implicitly {@link queryresult.KeyModification.verify|verify} messages.
             * @function encode
             * @memberof queryresult.KeyModification
             * @static
             * @param {queryresult.IKeyModification} message KeyModification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyModification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx_id != null && Object.hasOwnProperty.call(message, "tx_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tx_id);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.is_delete != null && Object.hasOwnProperty.call(message, "is_delete"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_delete);
                return writer;
            };
    
            /**
             * Encodes the specified KeyModification message, length delimited. Does not implicitly {@link queryresult.KeyModification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof queryresult.KeyModification
             * @static
             * @param {queryresult.IKeyModification} message KeyModification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyModification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KeyModification message from the specified reader or buffer.
             * @function decode
             * @memberof queryresult.KeyModification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {queryresult.KeyModification} KeyModification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyModification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.queryresult.KeyModification();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tx_id = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.is_delete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KeyModification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof queryresult.KeyModification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {queryresult.KeyModification} KeyModification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyModification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KeyModification message.
             * @function verify
             * @memberof queryresult.KeyModification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyModification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    if (!$util.isString(message.tx_id))
                        return "tx_id: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    if (typeof message.is_delete !== "boolean")
                        return "is_delete: boolean expected";
                return null;
            };
    
            /**
             * Creates a KeyModification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof queryresult.KeyModification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {queryresult.KeyModification} KeyModification
             */
            KeyModification.fromObject = function fromObject(object) {
                if (object instanceof $root.queryresult.KeyModification)
                    return object;
                var message = new $root.queryresult.KeyModification();
                if (object.tx_id != null)
                    message.tx_id = String(object.tx_id);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".queryresult.KeyModification.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.is_delete != null)
                    message.is_delete = Boolean(object.is_delete);
                return message;
            };
    
            /**
             * Creates a plain object from a KeyModification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof queryresult.KeyModification
             * @static
             * @param {queryresult.KeyModification} message KeyModification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyModification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tx_id = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.timestamp = null;
                    object.is_delete = false;
                }
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    object.tx_id = message.tx_id;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    object.is_delete = message.is_delete;
                return object;
            };
    
            /**
             * Converts this KeyModification to JSON.
             * @function toJSON
             * @memberof queryresult.KeyModification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyModification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KeyModification;
        })();
    
        return queryresult;
    })();
    
    $root.transientstore = (function() {
    
        /**
         * Namespace transientstore.
         * @exports transientstore
         * @namespace
         */
        var transientstore = {};
    
        transientstore.TxPvtReadWriteSetWithConfigInfo = (function() {
    
            /**
             * Properties of a TxPvtReadWriteSetWithConfigInfo.
             * @memberof transientstore
             * @interface ITxPvtReadWriteSetWithConfigInfo
             * @property {number|Long|null} [endorsed_at] TxPvtReadWriteSetWithConfigInfo endorsed_at
             * @property {rwset.ITxPvtReadWriteSet|null} [pvt_rwset] TxPvtReadWriteSetWithConfigInfo pvt_rwset
             * @property {Object.<string,protos.ICollectionConfigPackage>|null} [collection_configs] TxPvtReadWriteSetWithConfigInfo collection_configs
             */
    
            /**
             * Constructs a new TxPvtReadWriteSetWithConfigInfo.
             * @memberof transientstore
             * @classdesc Represents a TxPvtReadWriteSetWithConfigInfo.
             * @implements ITxPvtReadWriteSetWithConfigInfo
             * @constructor
             * @param {transientstore.ITxPvtReadWriteSetWithConfigInfo=} [properties] Properties to set
             */
            function TxPvtReadWriteSetWithConfigInfo(properties) {
                this.collection_configs = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TxPvtReadWriteSetWithConfigInfo endorsed_at.
             * @member {number|Long} endorsed_at
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @instance
             */
            TxPvtReadWriteSetWithConfigInfo.prototype.endorsed_at = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * TxPvtReadWriteSetWithConfigInfo pvt_rwset.
             * @member {rwset.ITxPvtReadWriteSet|null|undefined} pvt_rwset
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @instance
             */
            TxPvtReadWriteSetWithConfigInfo.prototype.pvt_rwset = null;
    
            /**
             * TxPvtReadWriteSetWithConfigInfo collection_configs.
             * @member {Object.<string,protos.ICollectionConfigPackage>} collection_configs
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @instance
             */
            TxPvtReadWriteSetWithConfigInfo.prototype.collection_configs = $util.emptyObject;
    
            /**
             * Creates a new TxPvtReadWriteSetWithConfigInfo instance using the specified properties.
             * @function create
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {transientstore.ITxPvtReadWriteSetWithConfigInfo=} [properties] Properties to set
             * @returns {transientstore.TxPvtReadWriteSetWithConfigInfo} TxPvtReadWriteSetWithConfigInfo instance
             */
            TxPvtReadWriteSetWithConfigInfo.create = function create(properties) {
                return new TxPvtReadWriteSetWithConfigInfo(properties);
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSetWithConfigInfo message. Does not implicitly {@link transientstore.TxPvtReadWriteSetWithConfigInfo.verify|verify} messages.
             * @function encode
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {transientstore.ITxPvtReadWriteSetWithConfigInfo} message TxPvtReadWriteSetWithConfigInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSetWithConfigInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endorsed_at != null && Object.hasOwnProperty.call(message, "endorsed_at"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.endorsed_at);
                if (message.pvt_rwset != null && Object.hasOwnProperty.call(message, "pvt_rwset"))
                    $root.rwset.TxPvtReadWriteSet.encode(message.pvt_rwset, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.collection_configs != null && Object.hasOwnProperty.call(message, "collection_configs"))
                    for (var keys = Object.keys(message.collection_configs), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.protos.CollectionConfigPackage.encode(message.collection_configs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSetWithConfigInfo message, length delimited. Does not implicitly {@link transientstore.TxPvtReadWriteSetWithConfigInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {transientstore.ITxPvtReadWriteSetWithConfigInfo} message TxPvtReadWriteSetWithConfigInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSetWithConfigInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TxPvtReadWriteSetWithConfigInfo message from the specified reader or buffer.
             * @function decode
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {transientstore.TxPvtReadWriteSetWithConfigInfo} TxPvtReadWriteSetWithConfigInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSetWithConfigInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.transientstore.TxPvtReadWriteSetWithConfigInfo(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endorsed_at = reader.uint64();
                        break;
                    case 2:
                        message.pvt_rwset = $root.rwset.TxPvtReadWriteSet.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (message.collection_configs === $util.emptyObject)
                            message.collection_configs = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.protos.CollectionConfigPackage.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.collection_configs[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TxPvtReadWriteSetWithConfigInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {transientstore.TxPvtReadWriteSetWithConfigInfo} TxPvtReadWriteSetWithConfigInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSetWithConfigInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TxPvtReadWriteSetWithConfigInfo message.
             * @function verify
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxPvtReadWriteSetWithConfigInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endorsed_at != null && message.hasOwnProperty("endorsed_at"))
                    if (!$util.isInteger(message.endorsed_at) && !(message.endorsed_at && $util.isInteger(message.endorsed_at.low) && $util.isInteger(message.endorsed_at.high)))
                        return "endorsed_at: integer|Long expected";
                if (message.pvt_rwset != null && message.hasOwnProperty("pvt_rwset")) {
                    var error = $root.rwset.TxPvtReadWriteSet.verify(message.pvt_rwset);
                    if (error)
                        return "pvt_rwset." + error;
                }
                if (message.collection_configs != null && message.hasOwnProperty("collection_configs")) {
                    if (!$util.isObject(message.collection_configs))
                        return "collection_configs: object expected";
                    var key = Object.keys(message.collection_configs);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.protos.CollectionConfigPackage.verify(message.collection_configs[key[i]]);
                        if (error)
                            return "collection_configs." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TxPvtReadWriteSetWithConfigInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {transientstore.TxPvtReadWriteSetWithConfigInfo} TxPvtReadWriteSetWithConfigInfo
             */
            TxPvtReadWriteSetWithConfigInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.transientstore.TxPvtReadWriteSetWithConfigInfo)
                    return object;
                var message = new $root.transientstore.TxPvtReadWriteSetWithConfigInfo();
                if (object.endorsed_at != null)
                    if ($util.Long)
                        (message.endorsed_at = $util.Long.fromValue(object.endorsed_at)).unsigned = true;
                    else if (typeof object.endorsed_at === "string")
                        message.endorsed_at = parseInt(object.endorsed_at, 10);
                    else if (typeof object.endorsed_at === "number")
                        message.endorsed_at = object.endorsed_at;
                    else if (typeof object.endorsed_at === "object")
                        message.endorsed_at = new $util.LongBits(object.endorsed_at.low >>> 0, object.endorsed_at.high >>> 0).toNumber(true);
                if (object.pvt_rwset != null) {
                    if (typeof object.pvt_rwset !== "object")
                        throw TypeError(".transientstore.TxPvtReadWriteSetWithConfigInfo.pvt_rwset: object expected");
                    message.pvt_rwset = $root.rwset.TxPvtReadWriteSet.fromObject(object.pvt_rwset);
                }
                if (object.collection_configs) {
                    if (typeof object.collection_configs !== "object")
                        throw TypeError(".transientstore.TxPvtReadWriteSetWithConfigInfo.collection_configs: object expected");
                    message.collection_configs = {};
                    for (var keys = Object.keys(object.collection_configs), i = 0; i < keys.length; ++i) {
                        if (typeof object.collection_configs[keys[i]] !== "object")
                            throw TypeError(".transientstore.TxPvtReadWriteSetWithConfigInfo.collection_configs: object expected");
                        message.collection_configs[keys[i]] = $root.protos.CollectionConfigPackage.fromObject(object.collection_configs[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TxPvtReadWriteSetWithConfigInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {transientstore.TxPvtReadWriteSetWithConfigInfo} message TxPvtReadWriteSetWithConfigInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxPvtReadWriteSetWithConfigInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.collection_configs = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.endorsed_at = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.endorsed_at = options.longs === String ? "0" : 0;
                    object.pvt_rwset = null;
                }
                if (message.endorsed_at != null && message.hasOwnProperty("endorsed_at"))
                    if (typeof message.endorsed_at === "number")
                        object.endorsed_at = options.longs === String ? String(message.endorsed_at) : message.endorsed_at;
                    else
                        object.endorsed_at = options.longs === String ? $util.Long.prototype.toString.call(message.endorsed_at) : options.longs === Number ? new $util.LongBits(message.endorsed_at.low >>> 0, message.endorsed_at.high >>> 0).toNumber(true) : message.endorsed_at;
                if (message.pvt_rwset != null && message.hasOwnProperty("pvt_rwset"))
                    object.pvt_rwset = $root.rwset.TxPvtReadWriteSet.toObject(message.pvt_rwset, options);
                var keys2;
                if (message.collection_configs && (keys2 = Object.keys(message.collection_configs)).length) {
                    object.collection_configs = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.collection_configs[keys2[j]] = $root.protos.CollectionConfigPackage.toObject(message.collection_configs[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this TxPvtReadWriteSetWithConfigInfo to JSON.
             * @function toJSON
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxPvtReadWriteSetWithConfigInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TxPvtReadWriteSetWithConfigInfo;
        })();
    
        return transientstore;
    })();
    
    $root.protos = (function() {
    
        /**
         * Namespace protos.
         * @exports protos
         * @namespace
         */
        var protos = {};
    
        protos.CollectionConfigPackage = (function() {
    
            /**
             * Properties of a CollectionConfigPackage.
             * @memberof protos
             * @interface ICollectionConfigPackage
             * @property {Array.<protos.ICollectionConfig>|null} [config] CollectionConfigPackage config
             */
    
            /**
             * Constructs a new CollectionConfigPackage.
             * @memberof protos
             * @classdesc Represents a CollectionConfigPackage.
             * @implements ICollectionConfigPackage
             * @constructor
             * @param {protos.ICollectionConfigPackage=} [properties] Properties to set
             */
            function CollectionConfigPackage(properties) {
                this.config = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionConfigPackage config.
             * @member {Array.<protos.ICollectionConfig>} config
             * @memberof protos.CollectionConfigPackage
             * @instance
             */
            CollectionConfigPackage.prototype.config = $util.emptyArray;
    
            /**
             * Creates a new CollectionConfigPackage instance using the specified properties.
             * @function create
             * @memberof protos.CollectionConfigPackage
             * @static
             * @param {protos.ICollectionConfigPackage=} [properties] Properties to set
             * @returns {protos.CollectionConfigPackage} CollectionConfigPackage instance
             */
            CollectionConfigPackage.create = function create(properties) {
                return new CollectionConfigPackage(properties);
            };
    
            /**
             * Encodes the specified CollectionConfigPackage message. Does not implicitly {@link protos.CollectionConfigPackage.verify|verify} messages.
             * @function encode
             * @memberof protos.CollectionConfigPackage
             * @static
             * @param {protos.ICollectionConfigPackage} message CollectionConfigPackage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfigPackage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.config != null && message.config.length)
                    for (var i = 0; i < message.config.length; ++i)
                        $root.protos.CollectionConfig.encode(message.config[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionConfigPackage message, length delimited. Does not implicitly {@link protos.CollectionConfigPackage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.CollectionConfigPackage
             * @static
             * @param {protos.ICollectionConfigPackage} message CollectionConfigPackage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfigPackage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionConfigPackage message from the specified reader or buffer.
             * @function decode
             * @memberof protos.CollectionConfigPackage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.CollectionConfigPackage} CollectionConfigPackage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfigPackage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CollectionConfigPackage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.config && message.config.length))
                            message.config = [];
                        message.config.push($root.protos.CollectionConfig.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionConfigPackage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.CollectionConfigPackage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.CollectionConfigPackage} CollectionConfigPackage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfigPackage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionConfigPackage message.
             * @function verify
             * @memberof protos.CollectionConfigPackage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionConfigPackage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.config != null && message.hasOwnProperty("config")) {
                    if (!Array.isArray(message.config))
                        return "config: array expected";
                    for (var i = 0; i < message.config.length; ++i) {
                        var error = $root.protos.CollectionConfig.verify(message.config[i]);
                        if (error)
                            return "config." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionConfigPackage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.CollectionConfigPackage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.CollectionConfigPackage} CollectionConfigPackage
             */
            CollectionConfigPackage.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.CollectionConfigPackage)
                    return object;
                var message = new $root.protos.CollectionConfigPackage();
                if (object.config) {
                    if (!Array.isArray(object.config))
                        throw TypeError(".protos.CollectionConfigPackage.config: array expected");
                    message.config = [];
                    for (var i = 0; i < object.config.length; ++i) {
                        if (typeof object.config[i] !== "object")
                            throw TypeError(".protos.CollectionConfigPackage.config: object expected");
                        message.config[i] = $root.protos.CollectionConfig.fromObject(object.config[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionConfigPackage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.CollectionConfigPackage
             * @static
             * @param {protos.CollectionConfigPackage} message CollectionConfigPackage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionConfigPackage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.config = [];
                if (message.config && message.config.length) {
                    object.config = [];
                    for (var j = 0; j < message.config.length; ++j)
                        object.config[j] = $root.protos.CollectionConfig.toObject(message.config[j], options);
                }
                return object;
            };
    
            /**
             * Converts this CollectionConfigPackage to JSON.
             * @function toJSON
             * @memberof protos.CollectionConfigPackage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionConfigPackage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionConfigPackage;
        })();
    
        protos.CollectionConfig = (function() {
    
            /**
             * Properties of a CollectionConfig.
             * @memberof protos
             * @interface ICollectionConfig
             * @property {protos.IStaticCollectionConfig|null} [static_collection_config] CollectionConfig static_collection_config
             */
    
            /**
             * Constructs a new CollectionConfig.
             * @memberof protos
             * @classdesc Represents a CollectionConfig.
             * @implements ICollectionConfig
             * @constructor
             * @param {protos.ICollectionConfig=} [properties] Properties to set
             */
            function CollectionConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionConfig static_collection_config.
             * @member {protos.IStaticCollectionConfig|null|undefined} static_collection_config
             * @memberof protos.CollectionConfig
             * @instance
             */
            CollectionConfig.prototype.static_collection_config = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * CollectionConfig payload.
             * @member {"static_collection_config"|undefined} payload
             * @memberof protos.CollectionConfig
             * @instance
             */
            Object.defineProperty(CollectionConfig.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["static_collection_config"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new CollectionConfig instance using the specified properties.
             * @function create
             * @memberof protos.CollectionConfig
             * @static
             * @param {protos.ICollectionConfig=} [properties] Properties to set
             * @returns {protos.CollectionConfig} CollectionConfig instance
             */
            CollectionConfig.create = function create(properties) {
                return new CollectionConfig(properties);
            };
    
            /**
             * Encodes the specified CollectionConfig message. Does not implicitly {@link protos.CollectionConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.CollectionConfig
             * @static
             * @param {protos.ICollectionConfig} message CollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.static_collection_config != null && Object.hasOwnProperty.call(message, "static_collection_config"))
                    $root.protos.StaticCollectionConfig.encode(message.static_collection_config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionConfig message, length delimited. Does not implicitly {@link protos.CollectionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.CollectionConfig
             * @static
             * @param {protos.ICollectionConfig} message CollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.CollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.CollectionConfig} CollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CollectionConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.static_collection_config = $root.protos.StaticCollectionConfig.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.CollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.CollectionConfig} CollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionConfig message.
             * @function verify
             * @memberof protos.CollectionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.static_collection_config != null && message.hasOwnProperty("static_collection_config")) {
                    properties.payload = 1;
                    {
                        var error = $root.protos.StaticCollectionConfig.verify(message.static_collection_config);
                        if (error)
                            return "static_collection_config." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.CollectionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.CollectionConfig} CollectionConfig
             */
            CollectionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.CollectionConfig)
                    return object;
                var message = new $root.protos.CollectionConfig();
                if (object.static_collection_config != null) {
                    if (typeof object.static_collection_config !== "object")
                        throw TypeError(".protos.CollectionConfig.static_collection_config: object expected");
                    message.static_collection_config = $root.protos.StaticCollectionConfig.fromObject(object.static_collection_config);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.CollectionConfig
             * @static
             * @param {protos.CollectionConfig} message CollectionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.static_collection_config != null && message.hasOwnProperty("static_collection_config")) {
                    object.static_collection_config = $root.protos.StaticCollectionConfig.toObject(message.static_collection_config, options);
                    if (options.oneofs)
                        object.payload = "static_collection_config";
                }
                return object;
            };
    
            /**
             * Converts this CollectionConfig to JSON.
             * @function toJSON
             * @memberof protos.CollectionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionConfig;
        })();
    
        protos.StaticCollectionConfig = (function() {
    
            /**
             * Properties of a StaticCollectionConfig.
             * @memberof protos
             * @interface IStaticCollectionConfig
             * @property {string|null} [name] StaticCollectionConfig name
             * @property {protos.ICollectionPolicyConfig|null} [member_orgs_policy] StaticCollectionConfig member_orgs_policy
             * @property {number|null} [required_peer_count] StaticCollectionConfig required_peer_count
             * @property {number|null} [maximum_peer_count] StaticCollectionConfig maximum_peer_count
             * @property {number|Long|null} [block_to_live] StaticCollectionConfig block_to_live
             * @property {boolean|null} [member_only_read] StaticCollectionConfig member_only_read
             * @property {boolean|null} [member_only_write] StaticCollectionConfig member_only_write
             * @property {protos.IApplicationPolicy|null} [endorsement_policy] StaticCollectionConfig endorsement_policy
             */
    
            /**
             * Constructs a new StaticCollectionConfig.
             * @memberof protos
             * @classdesc Represents a StaticCollectionConfig.
             * @implements IStaticCollectionConfig
             * @constructor
             * @param {protos.IStaticCollectionConfig=} [properties] Properties to set
             */
            function StaticCollectionConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StaticCollectionConfig name.
             * @member {string} name
             * @memberof protos.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.name = "";
    
            /**
             * StaticCollectionConfig member_orgs_policy.
             * @member {protos.ICollectionPolicyConfig|null|undefined} member_orgs_policy
             * @memberof protos.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.member_orgs_policy = null;
    
            /**
             * StaticCollectionConfig required_peer_count.
             * @member {number} required_peer_count
             * @memberof protos.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.required_peer_count = 0;
    
            /**
             * StaticCollectionConfig maximum_peer_count.
             * @member {number} maximum_peer_count
             * @memberof protos.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.maximum_peer_count = 0;
    
            /**
             * StaticCollectionConfig block_to_live.
             * @member {number|Long} block_to_live
             * @memberof protos.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.block_to_live = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * StaticCollectionConfig member_only_read.
             * @member {boolean} member_only_read
             * @memberof protos.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.member_only_read = false;
    
            /**
             * StaticCollectionConfig member_only_write.
             * @member {boolean} member_only_write
             * @memberof protos.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.member_only_write = false;
    
            /**
             * StaticCollectionConfig endorsement_policy.
             * @member {protos.IApplicationPolicy|null|undefined} endorsement_policy
             * @memberof protos.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.endorsement_policy = null;
    
            /**
             * Creates a new StaticCollectionConfig instance using the specified properties.
             * @function create
             * @memberof protos.StaticCollectionConfig
             * @static
             * @param {protos.IStaticCollectionConfig=} [properties] Properties to set
             * @returns {protos.StaticCollectionConfig} StaticCollectionConfig instance
             */
            StaticCollectionConfig.create = function create(properties) {
                return new StaticCollectionConfig(properties);
            };
    
            /**
             * Encodes the specified StaticCollectionConfig message. Does not implicitly {@link protos.StaticCollectionConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.StaticCollectionConfig
             * @static
             * @param {protos.IStaticCollectionConfig} message StaticCollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaticCollectionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.member_orgs_policy != null && Object.hasOwnProperty.call(message, "member_orgs_policy"))
                    $root.protos.CollectionPolicyConfig.encode(message.member_orgs_policy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.required_peer_count != null && Object.hasOwnProperty.call(message, "required_peer_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.required_peer_count);
                if (message.maximum_peer_count != null && Object.hasOwnProperty.call(message, "maximum_peer_count"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maximum_peer_count);
                if (message.block_to_live != null && Object.hasOwnProperty.call(message, "block_to_live"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.block_to_live);
                if (message.member_only_read != null && Object.hasOwnProperty.call(message, "member_only_read"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.member_only_read);
                if (message.member_only_write != null && Object.hasOwnProperty.call(message, "member_only_write"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.member_only_write);
                if (message.endorsement_policy != null && Object.hasOwnProperty.call(message, "endorsement_policy"))
                    $root.protos.ApplicationPolicy.encode(message.endorsement_policy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StaticCollectionConfig message, length delimited. Does not implicitly {@link protos.StaticCollectionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.StaticCollectionConfig
             * @static
             * @param {protos.IStaticCollectionConfig} message StaticCollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaticCollectionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StaticCollectionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.StaticCollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.StaticCollectionConfig} StaticCollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaticCollectionConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StaticCollectionConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.member_orgs_policy = $root.protos.CollectionPolicyConfig.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.required_peer_count = reader.int32();
                        break;
                    case 4:
                        message.maximum_peer_count = reader.int32();
                        break;
                    case 5:
                        message.block_to_live = reader.uint64();
                        break;
                    case 6:
                        message.member_only_read = reader.bool();
                        break;
                    case 7:
                        message.member_only_write = reader.bool();
                        break;
                    case 8:
                        message.endorsement_policy = $root.protos.ApplicationPolicy.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StaticCollectionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.StaticCollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.StaticCollectionConfig} StaticCollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaticCollectionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StaticCollectionConfig message.
             * @function verify
             * @memberof protos.StaticCollectionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StaticCollectionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.member_orgs_policy != null && message.hasOwnProperty("member_orgs_policy")) {
                    var error = $root.protos.CollectionPolicyConfig.verify(message.member_orgs_policy);
                    if (error)
                        return "member_orgs_policy." + error;
                }
                if (message.required_peer_count != null && message.hasOwnProperty("required_peer_count"))
                    if (!$util.isInteger(message.required_peer_count))
                        return "required_peer_count: integer expected";
                if (message.maximum_peer_count != null && message.hasOwnProperty("maximum_peer_count"))
                    if (!$util.isInteger(message.maximum_peer_count))
                        return "maximum_peer_count: integer expected";
                if (message.block_to_live != null && message.hasOwnProperty("block_to_live"))
                    if (!$util.isInteger(message.block_to_live) && !(message.block_to_live && $util.isInteger(message.block_to_live.low) && $util.isInteger(message.block_to_live.high)))
                        return "block_to_live: integer|Long expected";
                if (message.member_only_read != null && message.hasOwnProperty("member_only_read"))
                    if (typeof message.member_only_read !== "boolean")
                        return "member_only_read: boolean expected";
                if (message.member_only_write != null && message.hasOwnProperty("member_only_write"))
                    if (typeof message.member_only_write !== "boolean")
                        return "member_only_write: boolean expected";
                if (message.endorsement_policy != null && message.hasOwnProperty("endorsement_policy")) {
                    var error = $root.protos.ApplicationPolicy.verify(message.endorsement_policy);
                    if (error)
                        return "endorsement_policy." + error;
                }
                return null;
            };
    
            /**
             * Creates a StaticCollectionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.StaticCollectionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.StaticCollectionConfig} StaticCollectionConfig
             */
            StaticCollectionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.StaticCollectionConfig)
                    return object;
                var message = new $root.protos.StaticCollectionConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.member_orgs_policy != null) {
                    if (typeof object.member_orgs_policy !== "object")
                        throw TypeError(".protos.StaticCollectionConfig.member_orgs_policy: object expected");
                    message.member_orgs_policy = $root.protos.CollectionPolicyConfig.fromObject(object.member_orgs_policy);
                }
                if (object.required_peer_count != null)
                    message.required_peer_count = object.required_peer_count | 0;
                if (object.maximum_peer_count != null)
                    message.maximum_peer_count = object.maximum_peer_count | 0;
                if (object.block_to_live != null)
                    if ($util.Long)
                        (message.block_to_live = $util.Long.fromValue(object.block_to_live)).unsigned = true;
                    else if (typeof object.block_to_live === "string")
                        message.block_to_live = parseInt(object.block_to_live, 10);
                    else if (typeof object.block_to_live === "number")
                        message.block_to_live = object.block_to_live;
                    else if (typeof object.block_to_live === "object")
                        message.block_to_live = new $util.LongBits(object.block_to_live.low >>> 0, object.block_to_live.high >>> 0).toNumber(true);
                if (object.member_only_read != null)
                    message.member_only_read = Boolean(object.member_only_read);
                if (object.member_only_write != null)
                    message.member_only_write = Boolean(object.member_only_write);
                if (object.endorsement_policy != null) {
                    if (typeof object.endorsement_policy !== "object")
                        throw TypeError(".protos.StaticCollectionConfig.endorsement_policy: object expected");
                    message.endorsement_policy = $root.protos.ApplicationPolicy.fromObject(object.endorsement_policy);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StaticCollectionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.StaticCollectionConfig
             * @static
             * @param {protos.StaticCollectionConfig} message StaticCollectionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StaticCollectionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.member_orgs_policy = null;
                    object.required_peer_count = 0;
                    object.maximum_peer_count = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.block_to_live = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_to_live = options.longs === String ? "0" : 0;
                    object.member_only_read = false;
                    object.member_only_write = false;
                    object.endorsement_policy = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.member_orgs_policy != null && message.hasOwnProperty("member_orgs_policy"))
                    object.member_orgs_policy = $root.protos.CollectionPolicyConfig.toObject(message.member_orgs_policy, options);
                if (message.required_peer_count != null && message.hasOwnProperty("required_peer_count"))
                    object.required_peer_count = message.required_peer_count;
                if (message.maximum_peer_count != null && message.hasOwnProperty("maximum_peer_count"))
                    object.maximum_peer_count = message.maximum_peer_count;
                if (message.block_to_live != null && message.hasOwnProperty("block_to_live"))
                    if (typeof message.block_to_live === "number")
                        object.block_to_live = options.longs === String ? String(message.block_to_live) : message.block_to_live;
                    else
                        object.block_to_live = options.longs === String ? $util.Long.prototype.toString.call(message.block_to_live) : options.longs === Number ? new $util.LongBits(message.block_to_live.low >>> 0, message.block_to_live.high >>> 0).toNumber(true) : message.block_to_live;
                if (message.member_only_read != null && message.hasOwnProperty("member_only_read"))
                    object.member_only_read = message.member_only_read;
                if (message.member_only_write != null && message.hasOwnProperty("member_only_write"))
                    object.member_only_write = message.member_only_write;
                if (message.endorsement_policy != null && message.hasOwnProperty("endorsement_policy"))
                    object.endorsement_policy = $root.protos.ApplicationPolicy.toObject(message.endorsement_policy, options);
                return object;
            };
    
            /**
             * Converts this StaticCollectionConfig to JSON.
             * @function toJSON
             * @memberof protos.StaticCollectionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StaticCollectionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StaticCollectionConfig;
        })();
    
        protos.CollectionPolicyConfig = (function() {
    
            /**
             * Properties of a CollectionPolicyConfig.
             * @memberof protos
             * @interface ICollectionPolicyConfig
             * @property {common.ISignaturePolicyEnvelope|null} [signature_policy] CollectionPolicyConfig signature_policy
             */
    
            /**
             * Constructs a new CollectionPolicyConfig.
             * @memberof protos
             * @classdesc Represents a CollectionPolicyConfig.
             * @implements ICollectionPolicyConfig
             * @constructor
             * @param {protos.ICollectionPolicyConfig=} [properties] Properties to set
             */
            function CollectionPolicyConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionPolicyConfig signature_policy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} signature_policy
             * @memberof protos.CollectionPolicyConfig
             * @instance
             */
            CollectionPolicyConfig.prototype.signature_policy = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * CollectionPolicyConfig payload.
             * @member {"signature_policy"|undefined} payload
             * @memberof protos.CollectionPolicyConfig
             * @instance
             */
            Object.defineProperty(CollectionPolicyConfig.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["signature_policy"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new CollectionPolicyConfig instance using the specified properties.
             * @function create
             * @memberof protos.CollectionPolicyConfig
             * @static
             * @param {protos.ICollectionPolicyConfig=} [properties] Properties to set
             * @returns {protos.CollectionPolicyConfig} CollectionPolicyConfig instance
             */
            CollectionPolicyConfig.create = function create(properties) {
                return new CollectionPolicyConfig(properties);
            };
    
            /**
             * Encodes the specified CollectionPolicyConfig message. Does not implicitly {@link protos.CollectionPolicyConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.CollectionPolicyConfig
             * @static
             * @param {protos.ICollectionPolicyConfig} message CollectionPolicyConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPolicyConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signature_policy != null && Object.hasOwnProperty.call(message, "signature_policy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.signature_policy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionPolicyConfig message, length delimited. Does not implicitly {@link protos.CollectionPolicyConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.CollectionPolicyConfig
             * @static
             * @param {protos.ICollectionPolicyConfig} message CollectionPolicyConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPolicyConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionPolicyConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.CollectionPolicyConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.CollectionPolicyConfig} CollectionPolicyConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPolicyConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CollectionPolicyConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signature_policy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionPolicyConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.CollectionPolicyConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.CollectionPolicyConfig} CollectionPolicyConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPolicyConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionPolicyConfig message.
             * @function verify
             * @memberof protos.CollectionPolicyConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionPolicyConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.signature_policy != null && message.hasOwnProperty("signature_policy")) {
                    properties.payload = 1;
                    {
                        var error = $root.common.SignaturePolicyEnvelope.verify(message.signature_policy);
                        if (error)
                            return "signature_policy." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionPolicyConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.CollectionPolicyConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.CollectionPolicyConfig} CollectionPolicyConfig
             */
            CollectionPolicyConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.CollectionPolicyConfig)
                    return object;
                var message = new $root.protos.CollectionPolicyConfig();
                if (object.signature_policy != null) {
                    if (typeof object.signature_policy !== "object")
                        throw TypeError(".protos.CollectionPolicyConfig.signature_policy: object expected");
                    message.signature_policy = $root.common.SignaturePolicyEnvelope.fromObject(object.signature_policy);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionPolicyConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.CollectionPolicyConfig
             * @static
             * @param {protos.CollectionPolicyConfig} message CollectionPolicyConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionPolicyConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.signature_policy != null && message.hasOwnProperty("signature_policy")) {
                    object.signature_policy = $root.common.SignaturePolicyEnvelope.toObject(message.signature_policy, options);
                    if (options.oneofs)
                        object.payload = "signature_policy";
                }
                return object;
            };
    
            /**
             * Converts this CollectionPolicyConfig to JSON.
             * @function toJSON
             * @memberof protos.CollectionPolicyConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionPolicyConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionPolicyConfig;
        })();
    
        protos.ApplicationPolicy = (function() {
    
            /**
             * Properties of an ApplicationPolicy.
             * @memberof protos
             * @interface IApplicationPolicy
             * @property {common.ISignaturePolicyEnvelope|null} [signature_policy] ApplicationPolicy signature_policy
             * @property {string|null} [channel_config_policy_reference] ApplicationPolicy channel_config_policy_reference
             */
    
            /**
             * Constructs a new ApplicationPolicy.
             * @memberof protos
             * @classdesc Represents an ApplicationPolicy.
             * @implements IApplicationPolicy
             * @constructor
             * @param {protos.IApplicationPolicy=} [properties] Properties to set
             */
            function ApplicationPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ApplicationPolicy signature_policy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} signature_policy
             * @memberof protos.ApplicationPolicy
             * @instance
             */
            ApplicationPolicy.prototype.signature_policy = null;
    
            /**
             * ApplicationPolicy channel_config_policy_reference.
             * @member {string|null|undefined} channel_config_policy_reference
             * @memberof protos.ApplicationPolicy
             * @instance
             */
            ApplicationPolicy.prototype.channel_config_policy_reference = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * ApplicationPolicy Type.
             * @member {"signature_policy"|"channel_config_policy_reference"|undefined} Type
             * @memberof protos.ApplicationPolicy
             * @instance
             */
            Object.defineProperty(ApplicationPolicy.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["signature_policy", "channel_config_policy_reference"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new ApplicationPolicy instance using the specified properties.
             * @function create
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {protos.IApplicationPolicy=} [properties] Properties to set
             * @returns {protos.ApplicationPolicy} ApplicationPolicy instance
             */
            ApplicationPolicy.create = function create(properties) {
                return new ApplicationPolicy(properties);
            };
    
            /**
             * Encodes the specified ApplicationPolicy message. Does not implicitly {@link protos.ApplicationPolicy.verify|verify} messages.
             * @function encode
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {protos.IApplicationPolicy} message ApplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplicationPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signature_policy != null && Object.hasOwnProperty.call(message, "signature_policy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.signature_policy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.channel_config_policy_reference != null && Object.hasOwnProperty.call(message, "channel_config_policy_reference"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel_config_policy_reference);
                return writer;
            };
    
            /**
             * Encodes the specified ApplicationPolicy message, length delimited. Does not implicitly {@link protos.ApplicationPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {protos.IApplicationPolicy} message ApplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplicationPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ApplicationPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ApplicationPolicy} ApplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplicationPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ApplicationPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signature_policy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.channel_config_policy_reference = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ApplicationPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ApplicationPolicy} ApplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplicationPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ApplicationPolicy message.
             * @function verify
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApplicationPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.signature_policy != null && message.hasOwnProperty("signature_policy")) {
                    properties.Type = 1;
                    {
                        var error = $root.common.SignaturePolicyEnvelope.verify(message.signature_policy);
                        if (error)
                            return "signature_policy." + error;
                    }
                }
                if (message.channel_config_policy_reference != null && message.hasOwnProperty("channel_config_policy_reference")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    if (!$util.isString(message.channel_config_policy_reference))
                        return "channel_config_policy_reference: string expected";
                }
                return null;
            };
    
            /**
             * Creates an ApplicationPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ApplicationPolicy} ApplicationPolicy
             */
            ApplicationPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ApplicationPolicy)
                    return object;
                var message = new $root.protos.ApplicationPolicy();
                if (object.signature_policy != null) {
                    if (typeof object.signature_policy !== "object")
                        throw TypeError(".protos.ApplicationPolicy.signature_policy: object expected");
                    message.signature_policy = $root.common.SignaturePolicyEnvelope.fromObject(object.signature_policy);
                }
                if (object.channel_config_policy_reference != null)
                    message.channel_config_policy_reference = String(object.channel_config_policy_reference);
                return message;
            };
    
            /**
             * Creates a plain object from an ApplicationPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {protos.ApplicationPolicy} message ApplicationPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ApplicationPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.signature_policy != null && message.hasOwnProperty("signature_policy")) {
                    object.signature_policy = $root.common.SignaturePolicyEnvelope.toObject(message.signature_policy, options);
                    if (options.oneofs)
                        object.Type = "signature_policy";
                }
                if (message.channel_config_policy_reference != null && message.hasOwnProperty("channel_config_policy_reference")) {
                    object.channel_config_policy_reference = message.channel_config_policy_reference;
                    if (options.oneofs)
                        object.Type = "channel_config_policy_reference";
                }
                return object;
            };
    
            /**
             * Converts this ApplicationPolicy to JSON.
             * @function toJSON
             * @memberof protos.ApplicationPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ApplicationPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ApplicationPolicy;
        })();
    
        protos.FilteredBlock = (function() {
    
            /**
             * Properties of a FilteredBlock.
             * @memberof protos
             * @interface IFilteredBlock
             * @property {string|null} [channel_id] FilteredBlock channel_id
             * @property {number|Long|null} [number] FilteredBlock number
             * @property {Array.<protos.IFilteredTransaction>|null} [filtered_transactions] FilteredBlock filtered_transactions
             */
    
            /**
             * Constructs a new FilteredBlock.
             * @memberof protos
             * @classdesc Represents a FilteredBlock.
             * @implements IFilteredBlock
             * @constructor
             * @param {protos.IFilteredBlock=} [properties] Properties to set
             */
            function FilteredBlock(properties) {
                this.filtered_transactions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FilteredBlock channel_id.
             * @member {string} channel_id
             * @memberof protos.FilteredBlock
             * @instance
             */
            FilteredBlock.prototype.channel_id = "";
    
            /**
             * FilteredBlock number.
             * @member {number|Long} number
             * @memberof protos.FilteredBlock
             * @instance
             */
            FilteredBlock.prototype.number = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * FilteredBlock filtered_transactions.
             * @member {Array.<protos.IFilteredTransaction>} filtered_transactions
             * @memberof protos.FilteredBlock
             * @instance
             */
            FilteredBlock.prototype.filtered_transactions = $util.emptyArray;
    
            /**
             * Creates a new FilteredBlock instance using the specified properties.
             * @function create
             * @memberof protos.FilteredBlock
             * @static
             * @param {protos.IFilteredBlock=} [properties] Properties to set
             * @returns {protos.FilteredBlock} FilteredBlock instance
             */
            FilteredBlock.create = function create(properties) {
                return new FilteredBlock(properties);
            };
    
            /**
             * Encodes the specified FilteredBlock message. Does not implicitly {@link protos.FilteredBlock.verify|verify} messages.
             * @function encode
             * @memberof protos.FilteredBlock
             * @static
             * @param {protos.IFilteredBlock} message FilteredBlock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredBlock.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel_id != null && Object.hasOwnProperty.call(message, "channel_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel_id);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.number);
                if (message.filtered_transactions != null && message.filtered_transactions.length)
                    for (var i = 0; i < message.filtered_transactions.length; ++i)
                        $root.protos.FilteredTransaction.encode(message.filtered_transactions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FilteredBlock message, length delimited. Does not implicitly {@link protos.FilteredBlock.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.FilteredBlock
             * @static
             * @param {protos.IFilteredBlock} message FilteredBlock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredBlock.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FilteredBlock message from the specified reader or buffer.
             * @function decode
             * @memberof protos.FilteredBlock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.FilteredBlock} FilteredBlock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredBlock.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.FilteredBlock();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel_id = reader.string();
                        break;
                    case 2:
                        message.number = reader.uint64();
                        break;
                    case 4:
                        if (!(message.filtered_transactions && message.filtered_transactions.length))
                            message.filtered_transactions = [];
                        message.filtered_transactions.push($root.protos.FilteredTransaction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FilteredBlock message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.FilteredBlock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.FilteredBlock} FilteredBlock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredBlock.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FilteredBlock message.
             * @function verify
             * @memberof protos.FilteredBlock
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilteredBlock.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (!$util.isString(message.channel_id))
                        return "channel_id: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                if (message.filtered_transactions != null && message.hasOwnProperty("filtered_transactions")) {
                    if (!Array.isArray(message.filtered_transactions))
                        return "filtered_transactions: array expected";
                    for (var i = 0; i < message.filtered_transactions.length; ++i) {
                        var error = $root.protos.FilteredTransaction.verify(message.filtered_transactions[i]);
                        if (error)
                            return "filtered_transactions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a FilteredBlock message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.FilteredBlock
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.FilteredBlock} FilteredBlock
             */
            FilteredBlock.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.FilteredBlock)
                    return object;
                var message = new $root.protos.FilteredBlock();
                if (object.channel_id != null)
                    message.channel_id = String(object.channel_id);
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = true;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber(true);
                if (object.filtered_transactions) {
                    if (!Array.isArray(object.filtered_transactions))
                        throw TypeError(".protos.FilteredBlock.filtered_transactions: array expected");
                    message.filtered_transactions = [];
                    for (var i = 0; i < object.filtered_transactions.length; ++i) {
                        if (typeof object.filtered_transactions[i] !== "object")
                            throw TypeError(".protos.FilteredBlock.filtered_transactions: object expected");
                        message.filtered_transactions[i] = $root.protos.FilteredTransaction.fromObject(object.filtered_transactions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FilteredBlock message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.FilteredBlock
             * @static
             * @param {protos.FilteredBlock} message FilteredBlock
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilteredBlock.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.filtered_transactions = [];
                if (options.defaults) {
                    object.channel_id = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    object.channel_id = message.channel_id;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber(true) : message.number;
                if (message.filtered_transactions && message.filtered_transactions.length) {
                    object.filtered_transactions = [];
                    for (var j = 0; j < message.filtered_transactions.length; ++j)
                        object.filtered_transactions[j] = $root.protos.FilteredTransaction.toObject(message.filtered_transactions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this FilteredBlock to JSON.
             * @function toJSON
             * @memberof protos.FilteredBlock
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilteredBlock.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FilteredBlock;
        })();
    
        protos.FilteredTransaction = (function() {
    
            /**
             * Properties of a FilteredTransaction.
             * @memberof protos
             * @interface IFilteredTransaction
             * @property {string|null} [txid] FilteredTransaction txid
             * @property {common.HeaderType|null} [type] FilteredTransaction type
             * @property {protos.TxValidationCode|null} [tx_validation_code] FilteredTransaction tx_validation_code
             * @property {protos.IFilteredTransactionActions|null} [transaction_actions] FilteredTransaction transaction_actions
             */
    
            /**
             * Constructs a new FilteredTransaction.
             * @memberof protos
             * @classdesc Represents a FilteredTransaction.
             * @implements IFilteredTransaction
             * @constructor
             * @param {protos.IFilteredTransaction=} [properties] Properties to set
             */
            function FilteredTransaction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FilteredTransaction txid.
             * @member {string} txid
             * @memberof protos.FilteredTransaction
             * @instance
             */
            FilteredTransaction.prototype.txid = "";
    
            /**
             * FilteredTransaction type.
             * @member {common.HeaderType} type
             * @memberof protos.FilteredTransaction
             * @instance
             */
            FilteredTransaction.prototype.type = 0;
    
            /**
             * FilteredTransaction tx_validation_code.
             * @member {protos.TxValidationCode} tx_validation_code
             * @memberof protos.FilteredTransaction
             * @instance
             */
            FilteredTransaction.prototype.tx_validation_code = 0;
    
            /**
             * FilteredTransaction transaction_actions.
             * @member {protos.IFilteredTransactionActions|null|undefined} transaction_actions
             * @memberof protos.FilteredTransaction
             * @instance
             */
            FilteredTransaction.prototype.transaction_actions = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * FilteredTransaction Data.
             * @member {"transaction_actions"|undefined} Data
             * @memberof protos.FilteredTransaction
             * @instance
             */
            Object.defineProperty(FilteredTransaction.prototype, "Data", {
                get: $util.oneOfGetter($oneOfFields = ["transaction_actions"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new FilteredTransaction instance using the specified properties.
             * @function create
             * @memberof protos.FilteredTransaction
             * @static
             * @param {protos.IFilteredTransaction=} [properties] Properties to set
             * @returns {protos.FilteredTransaction} FilteredTransaction instance
             */
            FilteredTransaction.create = function create(properties) {
                return new FilteredTransaction(properties);
            };
    
            /**
             * Encodes the specified FilteredTransaction message. Does not implicitly {@link protos.FilteredTransaction.verify|verify} messages.
             * @function encode
             * @memberof protos.FilteredTransaction
             * @static
             * @param {protos.IFilteredTransaction} message FilteredTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredTransaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.tx_validation_code != null && Object.hasOwnProperty.call(message, "tx_validation_code"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tx_validation_code);
                if (message.transaction_actions != null && Object.hasOwnProperty.call(message, "transaction_actions"))
                    $root.protos.FilteredTransactionActions.encode(message.transaction_actions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FilteredTransaction message, length delimited. Does not implicitly {@link protos.FilteredTransaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.FilteredTransaction
             * @static
             * @param {protos.IFilteredTransaction} message FilteredTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FilteredTransaction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.FilteredTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.FilteredTransaction} FilteredTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredTransaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.FilteredTransaction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txid = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.tx_validation_code = reader.int32();
                        break;
                    case 4:
                        message.transaction_actions = $root.protos.FilteredTransactionActions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FilteredTransaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.FilteredTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.FilteredTransaction} FilteredTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredTransaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FilteredTransaction message.
             * @function verify
             * @memberof protos.FilteredTransaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilteredTransaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.txid != null && message.hasOwnProperty("txid"))
                    if (!$util.isString(message.txid))
                        return "txid: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 8:
                        break;
                    }
                if (message.tx_validation_code != null && message.hasOwnProperty("tx_validation_code"))
                    switch (message.tx_validation_code) {
                    default:
                        return "tx_validation_code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 254:
                    case 255:
                        break;
                    }
                if (message.transaction_actions != null && message.hasOwnProperty("transaction_actions")) {
                    properties.Data = 1;
                    {
                        var error = $root.protos.FilteredTransactionActions.verify(message.transaction_actions);
                        if (error)
                            return "transaction_actions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a FilteredTransaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.FilteredTransaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.FilteredTransaction} FilteredTransaction
             */
            FilteredTransaction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.FilteredTransaction)
                    return object;
                var message = new $root.protos.FilteredTransaction();
                if (object.txid != null)
                    message.txid = String(object.txid);
                switch (object.type) {
                case "MESSAGE":
                case 0:
                    message.type = 0;
                    break;
                case "CONFIG":
                case 1:
                    message.type = 1;
                    break;
                case "CONFIG_UPDATE":
                case 2:
                    message.type = 2;
                    break;
                case "ENDORSER_TRANSACTION":
                case 3:
                    message.type = 3;
                    break;
                case "ORDERER_TRANSACTION":
                case 4:
                    message.type = 4;
                    break;
                case "DELIVER_SEEK_INFO":
                case 5:
                    message.type = 5;
                    break;
                case "CHAINCODE_PACKAGE":
                case 6:
                    message.type = 6;
                    break;
                case "PEER_ADMIN_OPERATION":
                case 8:
                    message.type = 8;
                    break;
                }
                switch (object.tx_validation_code) {
                case "VALID":
                case 0:
                    message.tx_validation_code = 0;
                    break;
                case "NIL_ENVELOPE":
                case 1:
                    message.tx_validation_code = 1;
                    break;
                case "BAD_PAYLOAD":
                case 2:
                    message.tx_validation_code = 2;
                    break;
                case "BAD_COMMON_HEADER":
                case 3:
                    message.tx_validation_code = 3;
                    break;
                case "BAD_CREATOR_SIGNATURE":
                case 4:
                    message.tx_validation_code = 4;
                    break;
                case "INVALID_ENDORSER_TRANSACTION":
                case 5:
                    message.tx_validation_code = 5;
                    break;
                case "INVALID_CONFIG_TRANSACTION":
                case 6:
                    message.tx_validation_code = 6;
                    break;
                case "UNSUPPORTED_TX_PAYLOAD":
                case 7:
                    message.tx_validation_code = 7;
                    break;
                case "BAD_PROPOSAL_TXID":
                case 8:
                    message.tx_validation_code = 8;
                    break;
                case "DUPLICATE_TXID":
                case 9:
                    message.tx_validation_code = 9;
                    break;
                case "ENDORSEMENT_POLICY_FAILURE":
                case 10:
                    message.tx_validation_code = 10;
                    break;
                case "MVCC_READ_CONFLICT":
                case 11:
                    message.tx_validation_code = 11;
                    break;
                case "PHANTOM_READ_CONFLICT":
                case 12:
                    message.tx_validation_code = 12;
                    break;
                case "UNKNOWN_TX_TYPE":
                case 13:
                    message.tx_validation_code = 13;
                    break;
                case "TARGET_CHAIN_NOT_FOUND":
                case 14:
                    message.tx_validation_code = 14;
                    break;
                case "MARSHAL_TX_ERROR":
                case 15:
                    message.tx_validation_code = 15;
                    break;
                case "NIL_TXACTION":
                case 16:
                    message.tx_validation_code = 16;
                    break;
                case "EXPIRED_CHAINCODE":
                case 17:
                    message.tx_validation_code = 17;
                    break;
                case "CHAINCODE_VERSION_CONFLICT":
                case 18:
                    message.tx_validation_code = 18;
                    break;
                case "BAD_HEADER_EXTENSION":
                case 19:
                    message.tx_validation_code = 19;
                    break;
                case "BAD_CHANNEL_HEADER":
                case 20:
                    message.tx_validation_code = 20;
                    break;
                case "BAD_RESPONSE_PAYLOAD":
                case 21:
                    message.tx_validation_code = 21;
                    break;
                case "BAD_RWSET":
                case 22:
                    message.tx_validation_code = 22;
                    break;
                case "ILLEGAL_WRITESET":
                case 23:
                    message.tx_validation_code = 23;
                    break;
                case "INVALID_WRITESET":
                case 24:
                    message.tx_validation_code = 24;
                    break;
                case "INVALID_CHAINCODE":
                case 25:
                    message.tx_validation_code = 25;
                    break;
                case "NOT_VALIDATED":
                case 254:
                    message.tx_validation_code = 254;
                    break;
                case "INVALID_OTHER_REASON":
                case 255:
                    message.tx_validation_code = 255;
                    break;
                }
                if (object.transaction_actions != null) {
                    if (typeof object.transaction_actions !== "object")
                        throw TypeError(".protos.FilteredTransaction.transaction_actions: object expected");
                    message.transaction_actions = $root.protos.FilteredTransactionActions.fromObject(object.transaction_actions);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FilteredTransaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.FilteredTransaction
             * @static
             * @param {protos.FilteredTransaction} message FilteredTransaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilteredTransaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.txid = "";
                    object.type = options.enums === String ? "MESSAGE" : 0;
                    object.tx_validation_code = options.enums === String ? "VALID" : 0;
                }
                if (message.txid != null && message.hasOwnProperty("txid"))
                    object.txid = message.txid;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.common.HeaderType[message.type] : message.type;
                if (message.tx_validation_code != null && message.hasOwnProperty("tx_validation_code"))
                    object.tx_validation_code = options.enums === String ? $root.protos.TxValidationCode[message.tx_validation_code] : message.tx_validation_code;
                if (message.transaction_actions != null && message.hasOwnProperty("transaction_actions")) {
                    object.transaction_actions = $root.protos.FilteredTransactionActions.toObject(message.transaction_actions, options);
                    if (options.oneofs)
                        object.Data = "transaction_actions";
                }
                return object;
            };
    
            /**
             * Converts this FilteredTransaction to JSON.
             * @function toJSON
             * @memberof protos.FilteredTransaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilteredTransaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FilteredTransaction;
        })();
    
        protos.FilteredTransactionActions = (function() {
    
            /**
             * Properties of a FilteredTransactionActions.
             * @memberof protos
             * @interface IFilteredTransactionActions
             * @property {Array.<protos.IFilteredChaincodeAction>|null} [chaincode_actions] FilteredTransactionActions chaincode_actions
             */
    
            /**
             * Constructs a new FilteredTransactionActions.
             * @memberof protos
             * @classdesc Represents a FilteredTransactionActions.
             * @implements IFilteredTransactionActions
             * @constructor
             * @param {protos.IFilteredTransactionActions=} [properties] Properties to set
             */
            function FilteredTransactionActions(properties) {
                this.chaincode_actions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FilteredTransactionActions chaincode_actions.
             * @member {Array.<protos.IFilteredChaincodeAction>} chaincode_actions
             * @memberof protos.FilteredTransactionActions
             * @instance
             */
            FilteredTransactionActions.prototype.chaincode_actions = $util.emptyArray;
    
            /**
             * Creates a new FilteredTransactionActions instance using the specified properties.
             * @function create
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {protos.IFilteredTransactionActions=} [properties] Properties to set
             * @returns {protos.FilteredTransactionActions} FilteredTransactionActions instance
             */
            FilteredTransactionActions.create = function create(properties) {
                return new FilteredTransactionActions(properties);
            };
    
            /**
             * Encodes the specified FilteredTransactionActions message. Does not implicitly {@link protos.FilteredTransactionActions.verify|verify} messages.
             * @function encode
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {protos.IFilteredTransactionActions} message FilteredTransactionActions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredTransactionActions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_actions != null && message.chaincode_actions.length)
                    for (var i = 0; i < message.chaincode_actions.length; ++i)
                        $root.protos.FilteredChaincodeAction.encode(message.chaincode_actions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FilteredTransactionActions message, length delimited. Does not implicitly {@link protos.FilteredTransactionActions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {protos.IFilteredTransactionActions} message FilteredTransactionActions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredTransactionActions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FilteredTransactionActions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.FilteredTransactionActions} FilteredTransactionActions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredTransactionActions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.FilteredTransactionActions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.chaincode_actions && message.chaincode_actions.length))
                            message.chaincode_actions = [];
                        message.chaincode_actions.push($root.protos.FilteredChaincodeAction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FilteredTransactionActions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.FilteredTransactionActions} FilteredTransactionActions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredTransactionActions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FilteredTransactionActions message.
             * @function verify
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilteredTransactionActions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_actions != null && message.hasOwnProperty("chaincode_actions")) {
                    if (!Array.isArray(message.chaincode_actions))
                        return "chaincode_actions: array expected";
                    for (var i = 0; i < message.chaincode_actions.length; ++i) {
                        var error = $root.protos.FilteredChaincodeAction.verify(message.chaincode_actions[i]);
                        if (error)
                            return "chaincode_actions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a FilteredTransactionActions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.FilteredTransactionActions} FilteredTransactionActions
             */
            FilteredTransactionActions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.FilteredTransactionActions)
                    return object;
                var message = new $root.protos.FilteredTransactionActions();
                if (object.chaincode_actions) {
                    if (!Array.isArray(object.chaincode_actions))
                        throw TypeError(".protos.FilteredTransactionActions.chaincode_actions: array expected");
                    message.chaincode_actions = [];
                    for (var i = 0; i < object.chaincode_actions.length; ++i) {
                        if (typeof object.chaincode_actions[i] !== "object")
                            throw TypeError(".protos.FilteredTransactionActions.chaincode_actions: object expected");
                        message.chaincode_actions[i] = $root.protos.FilteredChaincodeAction.fromObject(object.chaincode_actions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FilteredTransactionActions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {protos.FilteredTransactionActions} message FilteredTransactionActions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilteredTransactionActions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincode_actions = [];
                if (message.chaincode_actions && message.chaincode_actions.length) {
                    object.chaincode_actions = [];
                    for (var j = 0; j < message.chaincode_actions.length; ++j)
                        object.chaincode_actions[j] = $root.protos.FilteredChaincodeAction.toObject(message.chaincode_actions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this FilteredTransactionActions to JSON.
             * @function toJSON
             * @memberof protos.FilteredTransactionActions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilteredTransactionActions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FilteredTransactionActions;
        })();
    
        protos.FilteredChaincodeAction = (function() {
    
            /**
             * Properties of a FilteredChaincodeAction.
             * @memberof protos
             * @interface IFilteredChaincodeAction
             * @property {protos.IChaincodeEvent|null} [chaincode_event] FilteredChaincodeAction chaincode_event
             */
    
            /**
             * Constructs a new FilteredChaincodeAction.
             * @memberof protos
             * @classdesc Represents a FilteredChaincodeAction.
             * @implements IFilteredChaincodeAction
             * @constructor
             * @param {protos.IFilteredChaincodeAction=} [properties] Properties to set
             */
            function FilteredChaincodeAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FilteredChaincodeAction chaincode_event.
             * @member {protos.IChaincodeEvent|null|undefined} chaincode_event
             * @memberof protos.FilteredChaincodeAction
             * @instance
             */
            FilteredChaincodeAction.prototype.chaincode_event = null;
    
            /**
             * Creates a new FilteredChaincodeAction instance using the specified properties.
             * @function create
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {protos.IFilteredChaincodeAction=} [properties] Properties to set
             * @returns {protos.FilteredChaincodeAction} FilteredChaincodeAction instance
             */
            FilteredChaincodeAction.create = function create(properties) {
                return new FilteredChaincodeAction(properties);
            };
    
            /**
             * Encodes the specified FilteredChaincodeAction message. Does not implicitly {@link protos.FilteredChaincodeAction.verify|verify} messages.
             * @function encode
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {protos.IFilteredChaincodeAction} message FilteredChaincodeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredChaincodeAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_event != null && Object.hasOwnProperty.call(message, "chaincode_event"))
                    $root.protos.ChaincodeEvent.encode(message.chaincode_event, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FilteredChaincodeAction message, length delimited. Does not implicitly {@link protos.FilteredChaincodeAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {protos.IFilteredChaincodeAction} message FilteredChaincodeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredChaincodeAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FilteredChaincodeAction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.FilteredChaincodeAction} FilteredChaincodeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredChaincodeAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.FilteredChaincodeAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_event = $root.protos.ChaincodeEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FilteredChaincodeAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.FilteredChaincodeAction} FilteredChaincodeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredChaincodeAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FilteredChaincodeAction message.
             * @function verify
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilteredChaincodeAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_event != null && message.hasOwnProperty("chaincode_event")) {
                    var error = $root.protos.ChaincodeEvent.verify(message.chaincode_event);
                    if (error)
                        return "chaincode_event." + error;
                }
                return null;
            };
    
            /**
             * Creates a FilteredChaincodeAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.FilteredChaincodeAction} FilteredChaincodeAction
             */
            FilteredChaincodeAction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.FilteredChaincodeAction)
                    return object;
                var message = new $root.protos.FilteredChaincodeAction();
                if (object.chaincode_event != null) {
                    if (typeof object.chaincode_event !== "object")
                        throw TypeError(".protos.FilteredChaincodeAction.chaincode_event: object expected");
                    message.chaincode_event = $root.protos.ChaincodeEvent.fromObject(object.chaincode_event);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FilteredChaincodeAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {protos.FilteredChaincodeAction} message FilteredChaincodeAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilteredChaincodeAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chaincode_event = null;
                if (message.chaincode_event != null && message.hasOwnProperty("chaincode_event"))
                    object.chaincode_event = $root.protos.ChaincodeEvent.toObject(message.chaincode_event, options);
                return object;
            };
    
            /**
             * Converts this FilteredChaincodeAction to JSON.
             * @function toJSON
             * @memberof protos.FilteredChaincodeAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilteredChaincodeAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FilteredChaincodeAction;
        })();
    
        protos.BlockAndPrivateData = (function() {
    
            /**
             * Properties of a BlockAndPrivateData.
             * @memberof protos
             * @interface IBlockAndPrivateData
             * @property {common.IBlock|null} [block] BlockAndPrivateData block
             * @property {Object.<string,rwset.ITxPvtReadWriteSet>|null} [private_data_map] BlockAndPrivateData private_data_map
             */
    
            /**
             * Constructs a new BlockAndPrivateData.
             * @memberof protos
             * @classdesc Represents a BlockAndPrivateData.
             * @implements IBlockAndPrivateData
             * @constructor
             * @param {protos.IBlockAndPrivateData=} [properties] Properties to set
             */
            function BlockAndPrivateData(properties) {
                this.private_data_map = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockAndPrivateData block.
             * @member {common.IBlock|null|undefined} block
             * @memberof protos.BlockAndPrivateData
             * @instance
             */
            BlockAndPrivateData.prototype.block = null;
    
            /**
             * BlockAndPrivateData private_data_map.
             * @member {Object.<string,rwset.ITxPvtReadWriteSet>} private_data_map
             * @memberof protos.BlockAndPrivateData
             * @instance
             */
            BlockAndPrivateData.prototype.private_data_map = $util.emptyObject;
    
            /**
             * Creates a new BlockAndPrivateData instance using the specified properties.
             * @function create
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {protos.IBlockAndPrivateData=} [properties] Properties to set
             * @returns {protos.BlockAndPrivateData} BlockAndPrivateData instance
             */
            BlockAndPrivateData.create = function create(properties) {
                return new BlockAndPrivateData(properties);
            };
    
            /**
             * Encodes the specified BlockAndPrivateData message. Does not implicitly {@link protos.BlockAndPrivateData.verify|verify} messages.
             * @function encode
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {protos.IBlockAndPrivateData} message BlockAndPrivateData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockAndPrivateData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                    $root.common.Block.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.private_data_map != null && Object.hasOwnProperty.call(message, "private_data_map"))
                    for (var keys = Object.keys(message.private_data_map), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]);
                        $root.rwset.TxPvtReadWriteSet.encode(message.private_data_map[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified BlockAndPrivateData message, length delimited. Does not implicitly {@link protos.BlockAndPrivateData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {protos.IBlockAndPrivateData} message BlockAndPrivateData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockAndPrivateData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockAndPrivateData message from the specified reader or buffer.
             * @function decode
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.BlockAndPrivateData} BlockAndPrivateData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockAndPrivateData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.BlockAndPrivateData(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.block = $root.common.Block.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (message.private_data_map === $util.emptyObject)
                            message.private_data_map = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint64();
                                break;
                            case 2:
                                value = $root.rwset.TxPvtReadWriteSet.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.private_data_map[typeof key === "object" ? $util.longToHash(key) : key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockAndPrivateData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.BlockAndPrivateData} BlockAndPrivateData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockAndPrivateData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockAndPrivateData message.
             * @function verify
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockAndPrivateData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.block != null && message.hasOwnProperty("block")) {
                    var error = $root.common.Block.verify(message.block);
                    if (error)
                        return "block." + error;
                }
                if (message.private_data_map != null && message.hasOwnProperty("private_data_map")) {
                    if (!$util.isObject(message.private_data_map))
                        return "private_data_map: object expected";
                    var key = Object.keys(message.private_data_map);
                    for (var i = 0; i < key.length; ++i) {
                        if (!$util.key64Re.test(key[i]))
                            return "private_data_map: integer|Long key{k:uint64} expected";
                        {
                            var error = $root.rwset.TxPvtReadWriteSet.verify(message.private_data_map[key[i]]);
                            if (error)
                                return "private_data_map." + error;
                        }
                    }
                }
                return null;
            };
    
            /**
             * Creates a BlockAndPrivateData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.BlockAndPrivateData} BlockAndPrivateData
             */
            BlockAndPrivateData.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.BlockAndPrivateData)
                    return object;
                var message = new $root.protos.BlockAndPrivateData();
                if (object.block != null) {
                    if (typeof object.block !== "object")
                        throw TypeError(".protos.BlockAndPrivateData.block: object expected");
                    message.block = $root.common.Block.fromObject(object.block);
                }
                if (object.private_data_map) {
                    if (typeof object.private_data_map !== "object")
                        throw TypeError(".protos.BlockAndPrivateData.private_data_map: object expected");
                    message.private_data_map = {};
                    for (var keys = Object.keys(object.private_data_map), i = 0; i < keys.length; ++i) {
                        if (typeof object.private_data_map[keys[i]] !== "object")
                            throw TypeError(".protos.BlockAndPrivateData.private_data_map: object expected");
                        message.private_data_map[keys[i]] = $root.rwset.TxPvtReadWriteSet.fromObject(object.private_data_map[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a BlockAndPrivateData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {protos.BlockAndPrivateData} message BlockAndPrivateData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockAndPrivateData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.private_data_map = {};
                if (options.defaults)
                    object.block = null;
                if (message.block != null && message.hasOwnProperty("block"))
                    object.block = $root.common.Block.toObject(message.block, options);
                var keys2;
                if (message.private_data_map && (keys2 = Object.keys(message.private_data_map)).length) {
                    object.private_data_map = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.private_data_map[keys2[j]] = $root.rwset.TxPvtReadWriteSet.toObject(message.private_data_map[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this BlockAndPrivateData to JSON.
             * @function toJSON
             * @memberof protos.BlockAndPrivateData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockAndPrivateData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockAndPrivateData;
        })();
    
        protos.DeliverResponse = (function() {
    
            /**
             * Properties of a DeliverResponse.
             * @memberof protos
             * @interface IDeliverResponse
             * @property {common.Status|null} [status] DeliverResponse status
             * @property {common.IBlock|null} [block] DeliverResponse block
             * @property {protos.IFilteredBlock|null} [filtered_block] DeliverResponse filtered_block
             * @property {protos.IBlockAndPrivateData|null} [block_and_private_data] DeliverResponse block_and_private_data
             */
    
            /**
             * Constructs a new DeliverResponse.
             * @memberof protos
             * @classdesc Represents a DeliverResponse.
             * @implements IDeliverResponse
             * @constructor
             * @param {protos.IDeliverResponse=} [properties] Properties to set
             */
            function DeliverResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DeliverResponse status.
             * @member {common.Status|null|undefined} status
             * @memberof protos.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.status = null;
    
            /**
             * DeliverResponse block.
             * @member {common.IBlock|null|undefined} block
             * @memberof protos.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.block = null;
    
            /**
             * DeliverResponse filtered_block.
             * @member {protos.IFilteredBlock|null|undefined} filtered_block
             * @memberof protos.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.filtered_block = null;
    
            /**
             * DeliverResponse block_and_private_data.
             * @member {protos.IBlockAndPrivateData|null|undefined} block_and_private_data
             * @memberof protos.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.block_and_private_data = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * DeliverResponse Type.
             * @member {"status"|"block"|"filtered_block"|"block_and_private_data"|undefined} Type
             * @memberof protos.DeliverResponse
             * @instance
             */
            Object.defineProperty(DeliverResponse.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["status", "block", "filtered_block", "block_and_private_data"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new DeliverResponse instance using the specified properties.
             * @function create
             * @memberof protos.DeliverResponse
             * @static
             * @param {protos.IDeliverResponse=} [properties] Properties to set
             * @returns {protos.DeliverResponse} DeliverResponse instance
             */
            DeliverResponse.create = function create(properties) {
                return new DeliverResponse(properties);
            };
    
            /**
             * Encodes the specified DeliverResponse message. Does not implicitly {@link protos.DeliverResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.DeliverResponse
             * @static
             * @param {protos.IDeliverResponse} message DeliverResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeliverResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                    $root.common.Block.encode(message.block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.filtered_block != null && Object.hasOwnProperty.call(message, "filtered_block"))
                    $root.protos.FilteredBlock.encode(message.filtered_block, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.block_and_private_data != null && Object.hasOwnProperty.call(message, "block_and_private_data"))
                    $root.protos.BlockAndPrivateData.encode(message.block_and_private_data, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DeliverResponse message, length delimited. Does not implicitly {@link protos.DeliverResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.DeliverResponse
             * @static
             * @param {protos.IDeliverResponse} message DeliverResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeliverResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DeliverResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.DeliverResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.DeliverResponse} DeliverResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeliverResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeliverResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.block = $root.common.Block.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.filtered_block = $root.protos.FilteredBlock.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.block_and_private_data = $root.protos.BlockAndPrivateData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DeliverResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.DeliverResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.DeliverResponse} DeliverResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeliverResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DeliverResponse message.
             * @function verify
             * @memberof protos.DeliverResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeliverResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.status != null && message.hasOwnProperty("status")) {
                    properties.Type = 1;
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 200:
                    case 400:
                    case 403:
                    case 404:
                    case 413:
                    case 500:
                    case 501:
                    case 503:
                        break;
                    }
                }
                if (message.block != null && message.hasOwnProperty("block")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.common.Block.verify(message.block);
                        if (error)
                            return "block." + error;
                    }
                }
                if (message.filtered_block != null && message.hasOwnProperty("filtered_block")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.protos.FilteredBlock.verify(message.filtered_block);
                        if (error)
                            return "filtered_block." + error;
                    }
                }
                if (message.block_and_private_data != null && message.hasOwnProperty("block_and_private_data")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.protos.BlockAndPrivateData.verify(message.block_and_private_data);
                        if (error)
                            return "block_and_private_data." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a DeliverResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.DeliverResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.DeliverResponse} DeliverResponse
             */
            DeliverResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.DeliverResponse)
                    return object;
                var message = new $root.protos.DeliverResponse();
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 200:
                    message.status = 200;
                    break;
                case "BAD_REQUEST":
                case 400:
                    message.status = 400;
                    break;
                case "FORBIDDEN":
                case 403:
                    message.status = 403;
                    break;
                case "NOT_FOUND":
                case 404:
                    message.status = 404;
                    break;
                case "REQUEST_ENTITY_TOO_LARGE":
                case 413:
                    message.status = 413;
                    break;
                case "INTERNAL_SERVER_ERROR":
                case 500:
                    message.status = 500;
                    break;
                case "NOT_IMPLEMENTED":
                case 501:
                    message.status = 501;
                    break;
                case "SERVICE_UNAVAILABLE":
                case 503:
                    message.status = 503;
                    break;
                }
                if (object.block != null) {
                    if (typeof object.block !== "object")
                        throw TypeError(".protos.DeliverResponse.block: object expected");
                    message.block = $root.common.Block.fromObject(object.block);
                }
                if (object.filtered_block != null) {
                    if (typeof object.filtered_block !== "object")
                        throw TypeError(".protos.DeliverResponse.filtered_block: object expected");
                    message.filtered_block = $root.protos.FilteredBlock.fromObject(object.filtered_block);
                }
                if (object.block_and_private_data != null) {
                    if (typeof object.block_and_private_data !== "object")
                        throw TypeError(".protos.DeliverResponse.block_and_private_data: object expected");
                    message.block_and_private_data = $root.protos.BlockAndPrivateData.fromObject(object.block_and_private_data);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DeliverResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.DeliverResponse
             * @static
             * @param {protos.DeliverResponse} message DeliverResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeliverResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.status != null && message.hasOwnProperty("status")) {
                    object.status = options.enums === String ? $root.common.Status[message.status] : message.status;
                    if (options.oneofs)
                        object.Type = "status";
                }
                if (message.block != null && message.hasOwnProperty("block")) {
                    object.block = $root.common.Block.toObject(message.block, options);
                    if (options.oneofs)
                        object.Type = "block";
                }
                if (message.filtered_block != null && message.hasOwnProperty("filtered_block")) {
                    object.filtered_block = $root.protos.FilteredBlock.toObject(message.filtered_block, options);
                    if (options.oneofs)
                        object.Type = "filtered_block";
                }
                if (message.block_and_private_data != null && message.hasOwnProperty("block_and_private_data")) {
                    object.block_and_private_data = $root.protos.BlockAndPrivateData.toObject(message.block_and_private_data, options);
                    if (options.oneofs)
                        object.Type = "block_and_private_data";
                }
                return object;
            };
    
            /**
             * Converts this DeliverResponse to JSON.
             * @function toJSON
             * @memberof protos.DeliverResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeliverResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DeliverResponse;
        })();
    
        protos.Deliver = (function() {
    
            /**
             * Constructs a new Deliver service.
             * @memberof protos
             * @classdesc Represents a Deliver
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Deliver(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Deliver.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Deliver;
    
            /**
             * Creates new Deliver service using the specified rpc implementation.
             * @function create
             * @memberof protos.Deliver
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Deliver} RPC service. Useful where requests and/or responses are streamed.
             */
            Deliver.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link protos.Deliver#deliver}.
             * @memberof protos.Deliver
             * @typedef DeliverCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.DeliverResponse} [response] DeliverResponse
             */
    
            /**
             * Calls Deliver.
             * @function deliver
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {protos.Deliver.DeliverCallback} callback Node-style callback called with the error, if any, and DeliverResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Deliver.prototype.deliver = function deliver(request, callback) {
                return this.rpcCall(deliver, $root.common.Envelope, $root.protos.DeliverResponse, request, callback);
            }, "name", { value: "Deliver" });
    
            /**
             * Calls Deliver.
             * @function deliver
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<protos.DeliverResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link protos.Deliver#deliverFiltered}.
             * @memberof protos.Deliver
             * @typedef DeliverFilteredCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.DeliverResponse} [response] DeliverResponse
             */
    
            /**
             * Calls DeliverFiltered.
             * @function deliverFiltered
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {protos.Deliver.DeliverFilteredCallback} callback Node-style callback called with the error, if any, and DeliverResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Deliver.prototype.deliverFiltered = function deliverFiltered(request, callback) {
                return this.rpcCall(deliverFiltered, $root.common.Envelope, $root.protos.DeliverResponse, request, callback);
            }, "name", { value: "DeliverFiltered" });
    
            /**
             * Calls DeliverFiltered.
             * @function deliverFiltered
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<protos.DeliverResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link protos.Deliver#deliverWithPrivateData}.
             * @memberof protos.Deliver
             * @typedef DeliverWithPrivateDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.DeliverResponse} [response] DeliverResponse
             */
    
            /**
             * Calls DeliverWithPrivateData.
             * @function deliverWithPrivateData
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {protos.Deliver.DeliverWithPrivateDataCallback} callback Node-style callback called with the error, if any, and DeliverResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Deliver.prototype.deliverWithPrivateData = function deliverWithPrivateData(request, callback) {
                return this.rpcCall(deliverWithPrivateData, $root.common.Envelope, $root.protos.DeliverResponse, request, callback);
            }, "name", { value: "DeliverWithPrivateData" });
    
            /**
             * Calls DeliverWithPrivateData.
             * @function deliverWithPrivateData
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<protos.DeliverResponse>} Promise
             * @variation 2
             */
    
            return Deliver;
        })();
    
        protos.ChaincodeEvent = (function() {
    
            /**
             * Properties of a ChaincodeEvent.
             * @memberof protos
             * @interface IChaincodeEvent
             * @property {string|null} [chaincode_id] ChaincodeEvent chaincode_id
             * @property {string|null} [tx_id] ChaincodeEvent tx_id
             * @property {string|null} [event_name] ChaincodeEvent event_name
             * @property {Uint8Array|null} [payload] ChaincodeEvent payload
             */
    
            /**
             * Constructs a new ChaincodeEvent.
             * @memberof protos
             * @classdesc Represents a ChaincodeEvent.
             * @implements IChaincodeEvent
             * @constructor
             * @param {protos.IChaincodeEvent=} [properties] Properties to set
             */
            function ChaincodeEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeEvent chaincode_id.
             * @member {string} chaincode_id
             * @memberof protos.ChaincodeEvent
             * @instance
             */
            ChaincodeEvent.prototype.chaincode_id = "";
    
            /**
             * ChaincodeEvent tx_id.
             * @member {string} tx_id
             * @memberof protos.ChaincodeEvent
             * @instance
             */
            ChaincodeEvent.prototype.tx_id = "";
    
            /**
             * ChaincodeEvent event_name.
             * @member {string} event_name
             * @memberof protos.ChaincodeEvent
             * @instance
             */
            ChaincodeEvent.prototype.event_name = "";
    
            /**
             * ChaincodeEvent payload.
             * @member {Uint8Array} payload
             * @memberof protos.ChaincodeEvent
             * @instance
             */
            ChaincodeEvent.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeEvent instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {protos.IChaincodeEvent=} [properties] Properties to set
             * @returns {protos.ChaincodeEvent} ChaincodeEvent instance
             */
            ChaincodeEvent.create = function create(properties) {
                return new ChaincodeEvent(properties);
            };
    
            /**
             * Encodes the specified ChaincodeEvent message. Does not implicitly {@link protos.ChaincodeEvent.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {protos.IChaincodeEvent} message ChaincodeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_id != null && Object.hasOwnProperty.call(message, "chaincode_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.chaincode_id);
                if (message.tx_id != null && Object.hasOwnProperty.call(message, "tx_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tx_id);
                if (message.event_name != null && Object.hasOwnProperty.call(message, "event_name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.event_name);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeEvent message, length delimited. Does not implicitly {@link protos.ChaincodeEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {protos.IChaincodeEvent} message ChaincodeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeEvent message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeEvent} ChaincodeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_id = reader.string();
                        break;
                    case 2:
                        message.tx_id = reader.string();
                        break;
                    case 3:
                        message.event_name = reader.string();
                        break;
                    case 4:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeEvent} ChaincodeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeEvent message.
             * @function verify
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_id != null && message.hasOwnProperty("chaincode_id"))
                    if (!$util.isString(message.chaincode_id))
                        return "chaincode_id: string expected";
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    if (!$util.isString(message.tx_id))
                        return "tx_id: string expected";
                if (message.event_name != null && message.hasOwnProperty("event_name"))
                    if (!$util.isString(message.event_name))
                        return "event_name: string expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeEvent} ChaincodeEvent
             */
            ChaincodeEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeEvent)
                    return object;
                var message = new $root.protos.ChaincodeEvent();
                if (object.chaincode_id != null)
                    message.chaincode_id = String(object.chaincode_id);
                if (object.tx_id != null)
                    message.tx_id = String(object.tx_id);
                if (object.event_name != null)
                    message.event_name = String(object.event_name);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {protos.ChaincodeEvent} message ChaincodeEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.chaincode_id = "";
                    object.tx_id = "";
                    object.event_name = "";
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.chaincode_id != null && message.hasOwnProperty("chaincode_id"))
                    object.chaincode_id = message.chaincode_id;
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    object.tx_id = message.tx_id;
                if (message.event_name != null && message.hasOwnProperty("event_name"))
                    object.event_name = message.event_name;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this ChaincodeEvent to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeEvent;
        })();
    
        protos.ProcessedTransaction = (function() {
    
            /**
             * Properties of a ProcessedTransaction.
             * @memberof protos
             * @interface IProcessedTransaction
             * @property {common.IEnvelope|null} [transactionEnvelope] ProcessedTransaction transactionEnvelope
             * @property {number|null} [validationCode] ProcessedTransaction validationCode
             */
    
            /**
             * Constructs a new ProcessedTransaction.
             * @memberof protos
             * @classdesc Represents a ProcessedTransaction.
             * @implements IProcessedTransaction
             * @constructor
             * @param {protos.IProcessedTransaction=} [properties] Properties to set
             */
            function ProcessedTransaction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ProcessedTransaction transactionEnvelope.
             * @member {common.IEnvelope|null|undefined} transactionEnvelope
             * @memberof protos.ProcessedTransaction
             * @instance
             */
            ProcessedTransaction.prototype.transactionEnvelope = null;
    
            /**
             * ProcessedTransaction validationCode.
             * @member {number} validationCode
             * @memberof protos.ProcessedTransaction
             * @instance
             */
            ProcessedTransaction.prototype.validationCode = 0;
    
            /**
             * Creates a new ProcessedTransaction instance using the specified properties.
             * @function create
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {protos.IProcessedTransaction=} [properties] Properties to set
             * @returns {protos.ProcessedTransaction} ProcessedTransaction instance
             */
            ProcessedTransaction.create = function create(properties) {
                return new ProcessedTransaction(properties);
            };
    
            /**
             * Encodes the specified ProcessedTransaction message. Does not implicitly {@link protos.ProcessedTransaction.verify|verify} messages.
             * @function encode
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {protos.IProcessedTransaction} message ProcessedTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProcessedTransaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.transactionEnvelope != null && Object.hasOwnProperty.call(message, "transactionEnvelope"))
                    $root.common.Envelope.encode(message.transactionEnvelope, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.validationCode != null && Object.hasOwnProperty.call(message, "validationCode"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.validationCode);
                return writer;
            };
    
            /**
             * Encodes the specified ProcessedTransaction message, length delimited. Does not implicitly {@link protos.ProcessedTransaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {protos.IProcessedTransaction} message ProcessedTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProcessedTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ProcessedTransaction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ProcessedTransaction} ProcessedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProcessedTransaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ProcessedTransaction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.transactionEnvelope = $root.common.Envelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.validationCode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ProcessedTransaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ProcessedTransaction} ProcessedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProcessedTransaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ProcessedTransaction message.
             * @function verify
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProcessedTransaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.transactionEnvelope != null && message.hasOwnProperty("transactionEnvelope")) {
                    var error = $root.common.Envelope.verify(message.transactionEnvelope);
                    if (error)
                        return "transactionEnvelope." + error;
                }
                if (message.validationCode != null && message.hasOwnProperty("validationCode"))
                    if (!$util.isInteger(message.validationCode))
                        return "validationCode: integer expected";
                return null;
            };
    
            /**
             * Creates a ProcessedTransaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ProcessedTransaction} ProcessedTransaction
             */
            ProcessedTransaction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ProcessedTransaction)
                    return object;
                var message = new $root.protos.ProcessedTransaction();
                if (object.transactionEnvelope != null) {
                    if (typeof object.transactionEnvelope !== "object")
                        throw TypeError(".protos.ProcessedTransaction.transactionEnvelope: object expected");
                    message.transactionEnvelope = $root.common.Envelope.fromObject(object.transactionEnvelope);
                }
                if (object.validationCode != null)
                    message.validationCode = object.validationCode | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a ProcessedTransaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {protos.ProcessedTransaction} message ProcessedTransaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProcessedTransaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.transactionEnvelope = null;
                    object.validationCode = 0;
                }
                if (message.transactionEnvelope != null && message.hasOwnProperty("transactionEnvelope"))
                    object.transactionEnvelope = $root.common.Envelope.toObject(message.transactionEnvelope, options);
                if (message.validationCode != null && message.hasOwnProperty("validationCode"))
                    object.validationCode = message.validationCode;
                return object;
            };
    
            /**
             * Converts this ProcessedTransaction to JSON.
             * @function toJSON
             * @memberof protos.ProcessedTransaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProcessedTransaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ProcessedTransaction;
        })();
    
        protos.Transaction = (function() {
    
            /**
             * Properties of a Transaction.
             * @memberof protos
             * @interface ITransaction
             * @property {Array.<protos.ITransactionAction>|null} [actions] Transaction actions
             */
    
            /**
             * Constructs a new Transaction.
             * @memberof protos
             * @classdesc Represents a Transaction.
             * @implements ITransaction
             * @constructor
             * @param {protos.ITransaction=} [properties] Properties to set
             */
            function Transaction(properties) {
                this.actions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Transaction actions.
             * @member {Array.<protos.ITransactionAction>} actions
             * @memberof protos.Transaction
             * @instance
             */
            Transaction.prototype.actions = $util.emptyArray;
    
            /**
             * Creates a new Transaction instance using the specified properties.
             * @function create
             * @memberof protos.Transaction
             * @static
             * @param {protos.ITransaction=} [properties] Properties to set
             * @returns {protos.Transaction} Transaction instance
             */
            Transaction.create = function create(properties) {
                return new Transaction(properties);
            };
    
            /**
             * Encodes the specified Transaction message. Does not implicitly {@link protos.Transaction.verify|verify} messages.
             * @function encode
             * @memberof protos.Transaction
             * @static
             * @param {protos.ITransaction} message Transaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actions != null && message.actions.length)
                    for (var i = 0; i < message.actions.length; ++i)
                        $root.protos.TransactionAction.encode(message.actions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Transaction message, length delimited. Does not implicitly {@link protos.Transaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.Transaction
             * @static
             * @param {protos.ITransaction} message Transaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Transaction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.Transaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.Transaction} Transaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Transaction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.protos.TransactionAction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Transaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.Transaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.Transaction} Transaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Transaction message.
             * @function verify
             * @memberof protos.Transaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Transaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actions != null && message.hasOwnProperty("actions")) {
                    if (!Array.isArray(message.actions))
                        return "actions: array expected";
                    for (var i = 0; i < message.actions.length; ++i) {
                        var error = $root.protos.TransactionAction.verify(message.actions[i]);
                        if (error)
                            return "actions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.Transaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.Transaction} Transaction
             */
            Transaction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.Transaction)
                    return object;
                var message = new $root.protos.Transaction();
                if (object.actions) {
                    if (!Array.isArray(object.actions))
                        throw TypeError(".protos.Transaction.actions: array expected");
                    message.actions = [];
                    for (var i = 0; i < object.actions.length; ++i) {
                        if (typeof object.actions[i] !== "object")
                            throw TypeError(".protos.Transaction.actions: object expected");
                        message.actions[i] = $root.protos.TransactionAction.fromObject(object.actions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Transaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.Transaction
             * @static
             * @param {protos.Transaction} message Transaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Transaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.actions = [];
                if (message.actions && message.actions.length) {
                    object.actions = [];
                    for (var j = 0; j < message.actions.length; ++j)
                        object.actions[j] = $root.protos.TransactionAction.toObject(message.actions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Transaction to JSON.
             * @function toJSON
             * @memberof protos.Transaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Transaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Transaction;
        })();
    
        protos.TransactionAction = (function() {
    
            /**
             * Properties of a TransactionAction.
             * @memberof protos
             * @interface ITransactionAction
             * @property {Uint8Array|null} [header] TransactionAction header
             * @property {Uint8Array|null} [payload] TransactionAction payload
             */
    
            /**
             * Constructs a new TransactionAction.
             * @memberof protos
             * @classdesc Represents a TransactionAction.
             * @implements ITransactionAction
             * @constructor
             * @param {protos.ITransactionAction=} [properties] Properties to set
             */
            function TransactionAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TransactionAction header.
             * @member {Uint8Array} header
             * @memberof protos.TransactionAction
             * @instance
             */
            TransactionAction.prototype.header = $util.newBuffer([]);
    
            /**
             * TransactionAction payload.
             * @member {Uint8Array} payload
             * @memberof protos.TransactionAction
             * @instance
             */
            TransactionAction.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new TransactionAction instance using the specified properties.
             * @function create
             * @memberof protos.TransactionAction
             * @static
             * @param {protos.ITransactionAction=} [properties] Properties to set
             * @returns {protos.TransactionAction} TransactionAction instance
             */
            TransactionAction.create = function create(properties) {
                return new TransactionAction(properties);
            };
    
            /**
             * Encodes the specified TransactionAction message. Does not implicitly {@link protos.TransactionAction.verify|verify} messages.
             * @function encode
             * @memberof protos.TransactionAction
             * @static
             * @param {protos.ITransactionAction} message TransactionAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.header);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified TransactionAction message, length delimited. Does not implicitly {@link protos.TransactionAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.TransactionAction
             * @static
             * @param {protos.ITransactionAction} message TransactionAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TransactionAction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.TransactionAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.TransactionAction} TransactionAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.TransactionAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = reader.bytes();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TransactionAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.TransactionAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.TransactionAction} TransactionAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TransactionAction message.
             * @function verify
             * @memberof protos.TransactionAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransactionAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header"))
                    if (!(message.header && typeof message.header.length === "number" || $util.isString(message.header)))
                        return "header: buffer expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a TransactionAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.TransactionAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.TransactionAction} TransactionAction
             */
            TransactionAction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.TransactionAction)
                    return object;
                var message = new $root.protos.TransactionAction();
                if (object.header != null)
                    if (typeof object.header === "string")
                        $util.base64.decode(object.header, message.header = $util.newBuffer($util.base64.length(object.header)), 0);
                    else if (object.header.length)
                        message.header = object.header;
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a TransactionAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.TransactionAction
             * @static
             * @param {protos.TransactionAction} message TransactionAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransactionAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.header = "";
                    else {
                        object.header = [];
                        if (options.bytes !== Array)
                            object.header = $util.newBuffer(object.header);
                    }
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = options.bytes === String ? $util.base64.encode(message.header, 0, message.header.length) : options.bytes === Array ? Array.prototype.slice.call(message.header) : message.header;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this TransactionAction to JSON.
             * @function toJSON
             * @memberof protos.TransactionAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransactionAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TransactionAction;
        })();
    
        protos.ChaincodeActionPayload = (function() {
    
            /**
             * Properties of a ChaincodeActionPayload.
             * @memberof protos
             * @interface IChaincodeActionPayload
             * @property {Uint8Array|null} [chaincode_proposal_payload] ChaincodeActionPayload chaincode_proposal_payload
             * @property {protos.IChaincodeEndorsedAction|null} [action] ChaincodeActionPayload action
             */
    
            /**
             * Constructs a new ChaincodeActionPayload.
             * @memberof protos
             * @classdesc Represents a ChaincodeActionPayload.
             * @implements IChaincodeActionPayload
             * @constructor
             * @param {protos.IChaincodeActionPayload=} [properties] Properties to set
             */
            function ChaincodeActionPayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeActionPayload chaincode_proposal_payload.
             * @member {Uint8Array} chaincode_proposal_payload
             * @memberof protos.ChaincodeActionPayload
             * @instance
             */
            ChaincodeActionPayload.prototype.chaincode_proposal_payload = $util.newBuffer([]);
    
            /**
             * ChaincodeActionPayload action.
             * @member {protos.IChaincodeEndorsedAction|null|undefined} action
             * @memberof protos.ChaincodeActionPayload
             * @instance
             */
            ChaincodeActionPayload.prototype.action = null;
    
            /**
             * Creates a new ChaincodeActionPayload instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {protos.IChaincodeActionPayload=} [properties] Properties to set
             * @returns {protos.ChaincodeActionPayload} ChaincodeActionPayload instance
             */
            ChaincodeActionPayload.create = function create(properties) {
                return new ChaincodeActionPayload(properties);
            };
    
            /**
             * Encodes the specified ChaincodeActionPayload message. Does not implicitly {@link protos.ChaincodeActionPayload.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {protos.IChaincodeActionPayload} message ChaincodeActionPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeActionPayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_proposal_payload != null && Object.hasOwnProperty.call(message, "chaincode_proposal_payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chaincode_proposal_payload);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    $root.protos.ChaincodeEndorsedAction.encode(message.action, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeActionPayload message, length delimited. Does not implicitly {@link protos.ChaincodeActionPayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {protos.IChaincodeActionPayload} message ChaincodeActionPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeActionPayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeActionPayload message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeActionPayload} ChaincodeActionPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeActionPayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeActionPayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_proposal_payload = reader.bytes();
                        break;
                    case 2:
                        message.action = $root.protos.ChaincodeEndorsedAction.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeActionPayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeActionPayload} ChaincodeActionPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeActionPayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeActionPayload message.
             * @function verify
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeActionPayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_proposal_payload != null && message.hasOwnProperty("chaincode_proposal_payload"))
                    if (!(message.chaincode_proposal_payload && typeof message.chaincode_proposal_payload.length === "number" || $util.isString(message.chaincode_proposal_payload)))
                        return "chaincode_proposal_payload: buffer expected";
                if (message.action != null && message.hasOwnProperty("action")) {
                    var error = $root.protos.ChaincodeEndorsedAction.verify(message.action);
                    if (error)
                        return "action." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeActionPayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeActionPayload} ChaincodeActionPayload
             */
            ChaincodeActionPayload.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeActionPayload)
                    return object;
                var message = new $root.protos.ChaincodeActionPayload();
                if (object.chaincode_proposal_payload != null)
                    if (typeof object.chaincode_proposal_payload === "string")
                        $util.base64.decode(object.chaincode_proposal_payload, message.chaincode_proposal_payload = $util.newBuffer($util.base64.length(object.chaincode_proposal_payload)), 0);
                    else if (object.chaincode_proposal_payload.length)
                        message.chaincode_proposal_payload = object.chaincode_proposal_payload;
                if (object.action != null) {
                    if (typeof object.action !== "object")
                        throw TypeError(".protos.ChaincodeActionPayload.action: object expected");
                    message.action = $root.protos.ChaincodeEndorsedAction.fromObject(object.action);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeActionPayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {protos.ChaincodeActionPayload} message ChaincodeActionPayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeActionPayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.chaincode_proposal_payload = "";
                    else {
                        object.chaincode_proposal_payload = [];
                        if (options.bytes !== Array)
                            object.chaincode_proposal_payload = $util.newBuffer(object.chaincode_proposal_payload);
                    }
                    object.action = null;
                }
                if (message.chaincode_proposal_payload != null && message.hasOwnProperty("chaincode_proposal_payload"))
                    object.chaincode_proposal_payload = options.bytes === String ? $util.base64.encode(message.chaincode_proposal_payload, 0, message.chaincode_proposal_payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.chaincode_proposal_payload) : message.chaincode_proposal_payload;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = $root.protos.ChaincodeEndorsedAction.toObject(message.action, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeActionPayload to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeActionPayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeActionPayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeActionPayload;
        })();
    
        protos.ChaincodeEndorsedAction = (function() {
    
            /**
             * Properties of a ChaincodeEndorsedAction.
             * @memberof protos
             * @interface IChaincodeEndorsedAction
             * @property {Uint8Array|null} [proposal_response_payload] ChaincodeEndorsedAction proposal_response_payload
             * @property {Array.<protos.IEndorsement>|null} [endorsements] ChaincodeEndorsedAction endorsements
             */
    
            /**
             * Constructs a new ChaincodeEndorsedAction.
             * @memberof protos
             * @classdesc Represents a ChaincodeEndorsedAction.
             * @implements IChaincodeEndorsedAction
             * @constructor
             * @param {protos.IChaincodeEndorsedAction=} [properties] Properties to set
             */
            function ChaincodeEndorsedAction(properties) {
                this.endorsements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeEndorsedAction proposal_response_payload.
             * @member {Uint8Array} proposal_response_payload
             * @memberof protos.ChaincodeEndorsedAction
             * @instance
             */
            ChaincodeEndorsedAction.prototype.proposal_response_payload = $util.newBuffer([]);
    
            /**
             * ChaincodeEndorsedAction endorsements.
             * @member {Array.<protos.IEndorsement>} endorsements
             * @memberof protos.ChaincodeEndorsedAction
             * @instance
             */
            ChaincodeEndorsedAction.prototype.endorsements = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeEndorsedAction instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {protos.IChaincodeEndorsedAction=} [properties] Properties to set
             * @returns {protos.ChaincodeEndorsedAction} ChaincodeEndorsedAction instance
             */
            ChaincodeEndorsedAction.create = function create(properties) {
                return new ChaincodeEndorsedAction(properties);
            };
    
            /**
             * Encodes the specified ChaincodeEndorsedAction message. Does not implicitly {@link protos.ChaincodeEndorsedAction.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {protos.IChaincodeEndorsedAction} message ChaincodeEndorsedAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsedAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.proposal_response_payload != null && Object.hasOwnProperty.call(message, "proposal_response_payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.proposal_response_payload);
                if (message.endorsements != null && message.endorsements.length)
                    for (var i = 0; i < message.endorsements.length; ++i)
                        $root.protos.Endorsement.encode(message.endorsements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeEndorsedAction message, length delimited. Does not implicitly {@link protos.ChaincodeEndorsedAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {protos.IChaincodeEndorsedAction} message ChaincodeEndorsedAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsedAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeEndorsedAction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeEndorsedAction} ChaincodeEndorsedAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsedAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeEndorsedAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.proposal_response_payload = reader.bytes();
                        break;
                    case 2:
                        if (!(message.endorsements && message.endorsements.length))
                            message.endorsements = [];
                        message.endorsements.push($root.protos.Endorsement.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeEndorsedAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeEndorsedAction} ChaincodeEndorsedAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsedAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeEndorsedAction message.
             * @function verify
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeEndorsedAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.proposal_response_payload != null && message.hasOwnProperty("proposal_response_payload"))
                    if (!(message.proposal_response_payload && typeof message.proposal_response_payload.length === "number" || $util.isString(message.proposal_response_payload)))
                        return "proposal_response_payload: buffer expected";
                if (message.endorsements != null && message.hasOwnProperty("endorsements")) {
                    if (!Array.isArray(message.endorsements))
                        return "endorsements: array expected";
                    for (var i = 0; i < message.endorsements.length; ++i) {
                        var error = $root.protos.Endorsement.verify(message.endorsements[i]);
                        if (error)
                            return "endorsements." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeEndorsedAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeEndorsedAction} ChaincodeEndorsedAction
             */
            ChaincodeEndorsedAction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeEndorsedAction)
                    return object;
                var message = new $root.protos.ChaincodeEndorsedAction();
                if (object.proposal_response_payload != null)
                    if (typeof object.proposal_response_payload === "string")
                        $util.base64.decode(object.proposal_response_payload, message.proposal_response_payload = $util.newBuffer($util.base64.length(object.proposal_response_payload)), 0);
                    else if (object.proposal_response_payload.length)
                        message.proposal_response_payload = object.proposal_response_payload;
                if (object.endorsements) {
                    if (!Array.isArray(object.endorsements))
                        throw TypeError(".protos.ChaincodeEndorsedAction.endorsements: array expected");
                    message.endorsements = [];
                    for (var i = 0; i < object.endorsements.length; ++i) {
                        if (typeof object.endorsements[i] !== "object")
                            throw TypeError(".protos.ChaincodeEndorsedAction.endorsements: object expected");
                        message.endorsements[i] = $root.protos.Endorsement.fromObject(object.endorsements[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeEndorsedAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {protos.ChaincodeEndorsedAction} message ChaincodeEndorsedAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeEndorsedAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.endorsements = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.proposal_response_payload = "";
                    else {
                        object.proposal_response_payload = [];
                        if (options.bytes !== Array)
                            object.proposal_response_payload = $util.newBuffer(object.proposal_response_payload);
                    }
                if (message.proposal_response_payload != null && message.hasOwnProperty("proposal_response_payload"))
                    object.proposal_response_payload = options.bytes === String ? $util.base64.encode(message.proposal_response_payload, 0, message.proposal_response_payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposal_response_payload) : message.proposal_response_payload;
                if (message.endorsements && message.endorsements.length) {
                    object.endorsements = [];
                    for (var j = 0; j < message.endorsements.length; ++j)
                        object.endorsements[j] = $root.protos.Endorsement.toObject(message.endorsements[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeEndorsedAction to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeEndorsedAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeEndorsedAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeEndorsedAction;
        })();
    
        /**
         * TxValidationCode enum.
         * @name protos.TxValidationCode
         * @enum {number}
         * @property {number} VALID=0 VALID value
         * @property {number} NIL_ENVELOPE=1 NIL_ENVELOPE value
         * @property {number} BAD_PAYLOAD=2 BAD_PAYLOAD value
         * @property {number} BAD_COMMON_HEADER=3 BAD_COMMON_HEADER value
         * @property {number} BAD_CREATOR_SIGNATURE=4 BAD_CREATOR_SIGNATURE value
         * @property {number} INVALID_ENDORSER_TRANSACTION=5 INVALID_ENDORSER_TRANSACTION value
         * @property {number} INVALID_CONFIG_TRANSACTION=6 INVALID_CONFIG_TRANSACTION value
         * @property {number} UNSUPPORTED_TX_PAYLOAD=7 UNSUPPORTED_TX_PAYLOAD value
         * @property {number} BAD_PROPOSAL_TXID=8 BAD_PROPOSAL_TXID value
         * @property {number} DUPLICATE_TXID=9 DUPLICATE_TXID value
         * @property {number} ENDORSEMENT_POLICY_FAILURE=10 ENDORSEMENT_POLICY_FAILURE value
         * @property {number} MVCC_READ_CONFLICT=11 MVCC_READ_CONFLICT value
         * @property {number} PHANTOM_READ_CONFLICT=12 PHANTOM_READ_CONFLICT value
         * @property {number} UNKNOWN_TX_TYPE=13 UNKNOWN_TX_TYPE value
         * @property {number} TARGET_CHAIN_NOT_FOUND=14 TARGET_CHAIN_NOT_FOUND value
         * @property {number} MARSHAL_TX_ERROR=15 MARSHAL_TX_ERROR value
         * @property {number} NIL_TXACTION=16 NIL_TXACTION value
         * @property {number} EXPIRED_CHAINCODE=17 EXPIRED_CHAINCODE value
         * @property {number} CHAINCODE_VERSION_CONFLICT=18 CHAINCODE_VERSION_CONFLICT value
         * @property {number} BAD_HEADER_EXTENSION=19 BAD_HEADER_EXTENSION value
         * @property {number} BAD_CHANNEL_HEADER=20 BAD_CHANNEL_HEADER value
         * @property {number} BAD_RESPONSE_PAYLOAD=21 BAD_RESPONSE_PAYLOAD value
         * @property {number} BAD_RWSET=22 BAD_RWSET value
         * @property {number} ILLEGAL_WRITESET=23 ILLEGAL_WRITESET value
         * @property {number} INVALID_WRITESET=24 INVALID_WRITESET value
         * @property {number} INVALID_CHAINCODE=25 INVALID_CHAINCODE value
         * @property {number} NOT_VALIDATED=254 NOT_VALIDATED value
         * @property {number} INVALID_OTHER_REASON=255 INVALID_OTHER_REASON value
         */
        protos.TxValidationCode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VALID"] = 0;
            values[valuesById[1] = "NIL_ENVELOPE"] = 1;
            values[valuesById[2] = "BAD_PAYLOAD"] = 2;
            values[valuesById[3] = "BAD_COMMON_HEADER"] = 3;
            values[valuesById[4] = "BAD_CREATOR_SIGNATURE"] = 4;
            values[valuesById[5] = "INVALID_ENDORSER_TRANSACTION"] = 5;
            values[valuesById[6] = "INVALID_CONFIG_TRANSACTION"] = 6;
            values[valuesById[7] = "UNSUPPORTED_TX_PAYLOAD"] = 7;
            values[valuesById[8] = "BAD_PROPOSAL_TXID"] = 8;
            values[valuesById[9] = "DUPLICATE_TXID"] = 9;
            values[valuesById[10] = "ENDORSEMENT_POLICY_FAILURE"] = 10;
            values[valuesById[11] = "MVCC_READ_CONFLICT"] = 11;
            values[valuesById[12] = "PHANTOM_READ_CONFLICT"] = 12;
            values[valuesById[13] = "UNKNOWN_TX_TYPE"] = 13;
            values[valuesById[14] = "TARGET_CHAIN_NOT_FOUND"] = 14;
            values[valuesById[15] = "MARSHAL_TX_ERROR"] = 15;
            values[valuesById[16] = "NIL_TXACTION"] = 16;
            values[valuesById[17] = "EXPIRED_CHAINCODE"] = 17;
            values[valuesById[18] = "CHAINCODE_VERSION_CONFLICT"] = 18;
            values[valuesById[19] = "BAD_HEADER_EXTENSION"] = 19;
            values[valuesById[20] = "BAD_CHANNEL_HEADER"] = 20;
            values[valuesById[21] = "BAD_RESPONSE_PAYLOAD"] = 21;
            values[valuesById[22] = "BAD_RWSET"] = 22;
            values[valuesById[23] = "ILLEGAL_WRITESET"] = 23;
            values[valuesById[24] = "INVALID_WRITESET"] = 24;
            values[valuesById[25] = "INVALID_CHAINCODE"] = 25;
            values[valuesById[254] = "NOT_VALIDATED"] = 254;
            values[valuesById[255] = "INVALID_OTHER_REASON"] = 255;
            return values;
        })();
    
        /**
         * MetaDataKeys enum.
         * @name protos.MetaDataKeys
         * @enum {number}
         * @property {number} VALIDATION_PARAMETER=0 VALIDATION_PARAMETER value
         * @property {number} VALIDATION_PARAMETER_V2=1 VALIDATION_PARAMETER_V2 value
         */
        protos.MetaDataKeys = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VALIDATION_PARAMETER"] = 0;
            values[valuesById[1] = "VALIDATION_PARAMETER_V2"] = 1;
            return values;
        })();
    
        protos.ProposalResponse = (function() {
    
            /**
             * Properties of a ProposalResponse.
             * @memberof protos
             * @interface IProposalResponse
             * @property {number|null} [version] ProposalResponse version
             * @property {google.protobuf.ITimestamp|null} [timestamp] ProposalResponse timestamp
             * @property {protos.IResponse|null} [response] ProposalResponse response
             * @property {Uint8Array|null} [payload] ProposalResponse payload
             * @property {protos.IEndorsement|null} [endorsement] ProposalResponse endorsement
             */
    
            /**
             * Constructs a new ProposalResponse.
             * @memberof protos
             * @classdesc Represents a ProposalResponse.
             * @implements IProposalResponse
             * @constructor
             * @param {protos.IProposalResponse=} [properties] Properties to set
             */
            function ProposalResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ProposalResponse version.
             * @member {number} version
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.version = 0;
    
            /**
             * ProposalResponse timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.timestamp = null;
    
            /**
             * ProposalResponse response.
             * @member {protos.IResponse|null|undefined} response
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.response = null;
    
            /**
             * ProposalResponse payload.
             * @member {Uint8Array} payload
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.payload = $util.newBuffer([]);
    
            /**
             * ProposalResponse endorsement.
             * @member {protos.IEndorsement|null|undefined} endorsement
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.endorsement = null;
    
            /**
             * Creates a new ProposalResponse instance using the specified properties.
             * @function create
             * @memberof protos.ProposalResponse
             * @static
             * @param {protos.IProposalResponse=} [properties] Properties to set
             * @returns {protos.ProposalResponse} ProposalResponse instance
             */
            ProposalResponse.create = function create(properties) {
                return new ProposalResponse(properties);
            };
    
            /**
             * Encodes the specified ProposalResponse message. Does not implicitly {@link protos.ProposalResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.ProposalResponse
             * @static
             * @param {protos.IProposalResponse} message ProposalResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposalResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                    $root.protos.Response.encode(message.response, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.payload);
                if (message.endorsement != null && Object.hasOwnProperty.call(message, "endorsement"))
                    $root.protos.Endorsement.encode(message.endorsement, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ProposalResponse message, length delimited. Does not implicitly {@link protos.ProposalResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ProposalResponse
             * @static
             * @param {protos.IProposalResponse} message ProposalResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposalResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ProposalResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ProposalResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ProposalResponse} ProposalResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposalResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ProposalResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.int32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.response = $root.protos.Response.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.payload = reader.bytes();
                        break;
                    case 6:
                        message.endorsement = $root.protos.Endorsement.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ProposalResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ProposalResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ProposalResponse} ProposalResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposalResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ProposalResponse message.
             * @function verify
             * @memberof protos.ProposalResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProposalResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.response != null && message.hasOwnProperty("response")) {
                    var error = $root.protos.Response.verify(message.response);
                    if (error)
                        return "response." + error;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.endorsement != null && message.hasOwnProperty("endorsement")) {
                    var error = $root.protos.Endorsement.verify(message.endorsement);
                    if (error)
                        return "endorsement." + error;
                }
                return null;
            };
    
            /**
             * Creates a ProposalResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ProposalResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ProposalResponse} ProposalResponse
             */
            ProposalResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ProposalResponse)
                    return object;
                var message = new $root.protos.ProposalResponse();
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".protos.ProposalResponse.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.response != null) {
                    if (typeof object.response !== "object")
                        throw TypeError(".protos.ProposalResponse.response: object expected");
                    message.response = $root.protos.Response.fromObject(object.response);
                }
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.endorsement != null) {
                    if (typeof object.endorsement !== "object")
                        throw TypeError(".protos.ProposalResponse.endorsement: object expected");
                    message.endorsement = $root.protos.Endorsement.fromObject(object.endorsement);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ProposalResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ProposalResponse
             * @static
             * @param {protos.ProposalResponse} message ProposalResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProposalResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.version = 0;
                    object.timestamp = null;
                    object.response = null;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    object.endorsement = null;
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.response != null && message.hasOwnProperty("response"))
                    object.response = $root.protos.Response.toObject(message.response, options);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.endorsement != null && message.hasOwnProperty("endorsement"))
                    object.endorsement = $root.protos.Endorsement.toObject(message.endorsement, options);
                return object;
            };
    
            /**
             * Converts this ProposalResponse to JSON.
             * @function toJSON
             * @memberof protos.ProposalResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProposalResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ProposalResponse;
        })();
    
        protos.Response = (function() {
    
            /**
             * Properties of a Response.
             * @memberof protos
             * @interface IResponse
             * @property {number|null} [status] Response status
             * @property {string|null} [message] Response message
             * @property {Uint8Array|null} [payload] Response payload
             */
    
            /**
             * Constructs a new Response.
             * @memberof protos
             * @classdesc Represents a Response.
             * @implements IResponse
             * @constructor
             * @param {protos.IResponse=} [properties] Properties to set
             */
            function Response(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Response status.
             * @member {number} status
             * @memberof protos.Response
             * @instance
             */
            Response.prototype.status = 0;
    
            /**
             * Response message.
             * @member {string} message
             * @memberof protos.Response
             * @instance
             */
            Response.prototype.message = "";
    
            /**
             * Response payload.
             * @member {Uint8Array} payload
             * @memberof protos.Response
             * @instance
             */
            Response.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new Response instance using the specified properties.
             * @function create
             * @memberof protos.Response
             * @static
             * @param {protos.IResponse=} [properties] Properties to set
             * @returns {protos.Response} Response instance
             */
            Response.create = function create(properties) {
                return new Response(properties);
            };
    
            /**
             * Encodes the specified Response message. Does not implicitly {@link protos.Response.verify|verify} messages.
             * @function encode
             * @memberof protos.Response
             * @static
             * @param {protos.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified Response message, length delimited. Does not implicitly {@link protos.Response.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.Response
             * @static
             * @param {protos.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Response message from the specified reader or buffer.
             * @function decode
             * @memberof protos.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Response();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Response message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Response message.
             * @function verify
             * @memberof protos.Response
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a Response message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.Response
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.Response} Response
             */
            Response.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.Response)
                    return object;
                var message = new $root.protos.Response();
                if (object.status != null)
                    message.status = object.status | 0;
                if (object.message != null)
                    message.message = String(object.message);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a Response message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.Response
             * @static
             * @param {protos.Response} message Response
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.status = 0;
                    object.message = "";
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this Response to JSON.
             * @function toJSON
             * @memberof protos.Response
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Response;
        })();
    
        protos.ProposalResponsePayload = (function() {
    
            /**
             * Properties of a ProposalResponsePayload.
             * @memberof protos
             * @interface IProposalResponsePayload
             * @property {Uint8Array|null} [proposal_hash] ProposalResponsePayload proposal_hash
             * @property {Uint8Array|null} [extension] ProposalResponsePayload extension
             */
    
            /**
             * Constructs a new ProposalResponsePayload.
             * @memberof protos
             * @classdesc Represents a ProposalResponsePayload.
             * @implements IProposalResponsePayload
             * @constructor
             * @param {protos.IProposalResponsePayload=} [properties] Properties to set
             */
            function ProposalResponsePayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ProposalResponsePayload proposal_hash.
             * @member {Uint8Array} proposal_hash
             * @memberof protos.ProposalResponsePayload
             * @instance
             */
            ProposalResponsePayload.prototype.proposal_hash = $util.newBuffer([]);
    
            /**
             * ProposalResponsePayload extension.
             * @member {Uint8Array} extension
             * @memberof protos.ProposalResponsePayload
             * @instance
             */
            ProposalResponsePayload.prototype.extension = $util.newBuffer([]);
    
            /**
             * Creates a new ProposalResponsePayload instance using the specified properties.
             * @function create
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {protos.IProposalResponsePayload=} [properties] Properties to set
             * @returns {protos.ProposalResponsePayload} ProposalResponsePayload instance
             */
            ProposalResponsePayload.create = function create(properties) {
                return new ProposalResponsePayload(properties);
            };
    
            /**
             * Encodes the specified ProposalResponsePayload message. Does not implicitly {@link protos.ProposalResponsePayload.verify|verify} messages.
             * @function encode
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {protos.IProposalResponsePayload} message ProposalResponsePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposalResponsePayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.proposal_hash != null && Object.hasOwnProperty.call(message, "proposal_hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.proposal_hash);
                if (message.extension != null && Object.hasOwnProperty.call(message, "extension"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.extension);
                return writer;
            };
    
            /**
             * Encodes the specified ProposalResponsePayload message, length delimited. Does not implicitly {@link protos.ProposalResponsePayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {protos.IProposalResponsePayload} message ProposalResponsePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposalResponsePayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ProposalResponsePayload message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ProposalResponsePayload} ProposalResponsePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposalResponsePayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ProposalResponsePayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.proposal_hash = reader.bytes();
                        break;
                    case 2:
                        message.extension = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ProposalResponsePayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ProposalResponsePayload} ProposalResponsePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposalResponsePayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ProposalResponsePayload message.
             * @function verify
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProposalResponsePayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.proposal_hash != null && message.hasOwnProperty("proposal_hash"))
                    if (!(message.proposal_hash && typeof message.proposal_hash.length === "number" || $util.isString(message.proposal_hash)))
                        return "proposal_hash: buffer expected";
                if (message.extension != null && message.hasOwnProperty("extension"))
                    if (!(message.extension && typeof message.extension.length === "number" || $util.isString(message.extension)))
                        return "extension: buffer expected";
                return null;
            };
    
            /**
             * Creates a ProposalResponsePayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ProposalResponsePayload} ProposalResponsePayload
             */
            ProposalResponsePayload.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ProposalResponsePayload)
                    return object;
                var message = new $root.protos.ProposalResponsePayload();
                if (object.proposal_hash != null)
                    if (typeof object.proposal_hash === "string")
                        $util.base64.decode(object.proposal_hash, message.proposal_hash = $util.newBuffer($util.base64.length(object.proposal_hash)), 0);
                    else if (object.proposal_hash.length)
                        message.proposal_hash = object.proposal_hash;
                if (object.extension != null)
                    if (typeof object.extension === "string")
                        $util.base64.decode(object.extension, message.extension = $util.newBuffer($util.base64.length(object.extension)), 0);
                    else if (object.extension.length)
                        message.extension = object.extension;
                return message;
            };
    
            /**
             * Creates a plain object from a ProposalResponsePayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {protos.ProposalResponsePayload} message ProposalResponsePayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProposalResponsePayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.proposal_hash = "";
                    else {
                        object.proposal_hash = [];
                        if (options.bytes !== Array)
                            object.proposal_hash = $util.newBuffer(object.proposal_hash);
                    }
                    if (options.bytes === String)
                        object.extension = "";
                    else {
                        object.extension = [];
                        if (options.bytes !== Array)
                            object.extension = $util.newBuffer(object.extension);
                    }
                }
                if (message.proposal_hash != null && message.hasOwnProperty("proposal_hash"))
                    object.proposal_hash = options.bytes === String ? $util.base64.encode(message.proposal_hash, 0, message.proposal_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposal_hash) : message.proposal_hash;
                if (message.extension != null && message.hasOwnProperty("extension"))
                    object.extension = options.bytes === String ? $util.base64.encode(message.extension, 0, message.extension.length) : options.bytes === Array ? Array.prototype.slice.call(message.extension) : message.extension;
                return object;
            };
    
            /**
             * Converts this ProposalResponsePayload to JSON.
             * @function toJSON
             * @memberof protos.ProposalResponsePayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProposalResponsePayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ProposalResponsePayload;
        })();
    
        protos.Endorsement = (function() {
    
            /**
             * Properties of an Endorsement.
             * @memberof protos
             * @interface IEndorsement
             * @property {Uint8Array|null} [endorser] Endorsement endorser
             * @property {Uint8Array|null} [signature] Endorsement signature
             */
    
            /**
             * Constructs a new Endorsement.
             * @memberof protos
             * @classdesc Represents an Endorsement.
             * @implements IEndorsement
             * @constructor
             * @param {protos.IEndorsement=} [properties] Properties to set
             */
            function Endorsement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Endorsement endorser.
             * @member {Uint8Array} endorser
             * @memberof protos.Endorsement
             * @instance
             */
            Endorsement.prototype.endorser = $util.newBuffer([]);
    
            /**
             * Endorsement signature.
             * @member {Uint8Array} signature
             * @memberof protos.Endorsement
             * @instance
             */
            Endorsement.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new Endorsement instance using the specified properties.
             * @function create
             * @memberof protos.Endorsement
             * @static
             * @param {protos.IEndorsement=} [properties] Properties to set
             * @returns {protos.Endorsement} Endorsement instance
             */
            Endorsement.create = function create(properties) {
                return new Endorsement(properties);
            };
    
            /**
             * Encodes the specified Endorsement message. Does not implicitly {@link protos.Endorsement.verify|verify} messages.
             * @function encode
             * @memberof protos.Endorsement
             * @static
             * @param {protos.IEndorsement} message Endorsement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endorsement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endorser != null && Object.hasOwnProperty.call(message, "endorser"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.endorser);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified Endorsement message, length delimited. Does not implicitly {@link protos.Endorsement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.Endorsement
             * @static
             * @param {protos.IEndorsement} message Endorsement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endorsement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Endorsement message from the specified reader or buffer.
             * @function decode
             * @memberof protos.Endorsement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.Endorsement} Endorsement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endorsement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Endorsement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endorser = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Endorsement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.Endorsement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.Endorsement} Endorsement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endorsement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Endorsement message.
             * @function verify
             * @memberof protos.Endorsement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Endorsement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endorser != null && message.hasOwnProperty("endorser"))
                    if (!(message.endorser && typeof message.endorser.length === "number" || $util.isString(message.endorser)))
                        return "endorser: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates an Endorsement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.Endorsement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.Endorsement} Endorsement
             */
            Endorsement.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.Endorsement)
                    return object;
                var message = new $root.protos.Endorsement();
                if (object.endorser != null)
                    if (typeof object.endorser === "string")
                        $util.base64.decode(object.endorser, message.endorser = $util.newBuffer($util.base64.length(object.endorser)), 0);
                    else if (object.endorser.length)
                        message.endorser = object.endorser;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from an Endorsement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.Endorsement
             * @static
             * @param {protos.Endorsement} message Endorsement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Endorsement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.endorser = "";
                    else {
                        object.endorser = [];
                        if (options.bytes !== Array)
                            object.endorser = $util.newBuffer(object.endorser);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.endorser != null && message.hasOwnProperty("endorser"))
                    object.endorser = options.bytes === String ? $util.base64.encode(message.endorser, 0, message.endorser.length) : options.bytes === Array ? Array.prototype.slice.call(message.endorser) : message.endorser;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this Endorsement to JSON.
             * @function toJSON
             * @memberof protos.Endorsement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Endorsement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Endorsement;
        })();
    
        protos.ChaincodeMessage = (function() {
    
            /**
             * Properties of a ChaincodeMessage.
             * @memberof protos
             * @interface IChaincodeMessage
             * @property {protos.ChaincodeMessage.Type|null} [type] ChaincodeMessage type
             * @property {google.protobuf.ITimestamp|null} [timestamp] ChaincodeMessage timestamp
             * @property {Uint8Array|null} [payload] ChaincodeMessage payload
             * @property {string|null} [txid] ChaincodeMessage txid
             * @property {protos.ISignedProposal|null} [proposal] ChaincodeMessage proposal
             * @property {protos.IChaincodeEvent|null} [chaincode_event] ChaincodeMessage chaincode_event
             * @property {string|null} [channel_id] ChaincodeMessage channel_id
             */
    
            /**
             * Constructs a new ChaincodeMessage.
             * @memberof protos
             * @classdesc Represents a ChaincodeMessage.
             * @implements IChaincodeMessage
             * @constructor
             * @param {protos.IChaincodeMessage=} [properties] Properties to set
             */
            function ChaincodeMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeMessage type.
             * @member {protos.ChaincodeMessage.Type} type
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.type = 0;
    
            /**
             * ChaincodeMessage timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.timestamp = null;
    
            /**
             * ChaincodeMessage payload.
             * @member {Uint8Array} payload
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.payload = $util.newBuffer([]);
    
            /**
             * ChaincodeMessage txid.
             * @member {string} txid
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.txid = "";
    
            /**
             * ChaincodeMessage proposal.
             * @member {protos.ISignedProposal|null|undefined} proposal
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.proposal = null;
    
            /**
             * ChaincodeMessage chaincode_event.
             * @member {protos.IChaincodeEvent|null|undefined} chaincode_event
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.chaincode_event = null;
    
            /**
             * ChaincodeMessage channel_id.
             * @member {string} channel_id
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.channel_id = "";
    
            /**
             * Creates a new ChaincodeMessage instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {protos.IChaincodeMessage=} [properties] Properties to set
             * @returns {protos.ChaincodeMessage} ChaincodeMessage instance
             */
            ChaincodeMessage.create = function create(properties) {
                return new ChaincodeMessage(properties);
            };
    
            /**
             * Encodes the specified ChaincodeMessage message. Does not implicitly {@link protos.ChaincodeMessage.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {protos.IChaincodeMessage} message ChaincodeMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.txid);
                if (message.proposal != null && Object.hasOwnProperty.call(message, "proposal"))
                    $root.protos.SignedProposal.encode(message.proposal, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.chaincode_event != null && Object.hasOwnProperty.call(message, "chaincode_event"))
                    $root.protos.ChaincodeEvent.encode(message.chaincode_event, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.channel_id != null && Object.hasOwnProperty.call(message, "channel_id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.channel_id);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeMessage message, length delimited. Does not implicitly {@link protos.ChaincodeMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {protos.IChaincodeMessage} message ChaincodeMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeMessage message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeMessage} ChaincodeMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.payload = reader.bytes();
                        break;
                    case 4:
                        message.txid = reader.string();
                        break;
                    case 5:
                        message.proposal = $root.protos.SignedProposal.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.chaincode_event = $root.protos.ChaincodeEvent.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.channel_id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeMessage} ChaincodeMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeMessage message.
             * @function verify
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                        break;
                    }
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.txid != null && message.hasOwnProperty("txid"))
                    if (!$util.isString(message.txid))
                        return "txid: string expected";
                if (message.proposal != null && message.hasOwnProperty("proposal")) {
                    var error = $root.protos.SignedProposal.verify(message.proposal);
                    if (error)
                        return "proposal." + error;
                }
                if (message.chaincode_event != null && message.hasOwnProperty("chaincode_event")) {
                    var error = $root.protos.ChaincodeEvent.verify(message.chaincode_event);
                    if (error)
                        return "chaincode_event." + error;
                }
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (!$util.isString(message.channel_id))
                        return "channel_id: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeMessage} ChaincodeMessage
             */
            ChaincodeMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeMessage)
                    return object;
                var message = new $root.protos.ChaincodeMessage();
                switch (object.type) {
                case "UNDEFINED":
                case 0:
                    message.type = 0;
                    break;
                case "REGISTER":
                case 1:
                    message.type = 1;
                    break;
                case "REGISTERED":
                case 2:
                    message.type = 2;
                    break;
                case "INIT":
                case 3:
                    message.type = 3;
                    break;
                case "READY":
                case 4:
                    message.type = 4;
                    break;
                case "TRANSACTION":
                case 5:
                    message.type = 5;
                    break;
                case "COMPLETED":
                case 6:
                    message.type = 6;
                    break;
                case "ERROR":
                case 7:
                    message.type = 7;
                    break;
                case "GET_STATE":
                case 8:
                    message.type = 8;
                    break;
                case "PUT_STATE":
                case 9:
                    message.type = 9;
                    break;
                case "DEL_STATE":
                case 10:
                    message.type = 10;
                    break;
                case "INVOKE_CHAINCODE":
                case 11:
                    message.type = 11;
                    break;
                case "RESPONSE":
                case 13:
                    message.type = 13;
                    break;
                case "GET_STATE_BY_RANGE":
                case 14:
                    message.type = 14;
                    break;
                case "GET_QUERY_RESULT":
                case 15:
                    message.type = 15;
                    break;
                case "QUERY_STATE_NEXT":
                case 16:
                    message.type = 16;
                    break;
                case "QUERY_STATE_CLOSE":
                case 17:
                    message.type = 17;
                    break;
                case "KEEPALIVE":
                case 18:
                    message.type = 18;
                    break;
                case "GET_HISTORY_FOR_KEY":
                case 19:
                    message.type = 19;
                    break;
                case "GET_STATE_METADATA":
                case 20:
                    message.type = 20;
                    break;
                case "PUT_STATE_METADATA":
                case 21:
                    message.type = 21;
                    break;
                case "GET_PRIVATE_DATA_HASH":
                case 22:
                    message.type = 22;
                    break;
                }
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".protos.ChaincodeMessage.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.txid != null)
                    message.txid = String(object.txid);
                if (object.proposal != null) {
                    if (typeof object.proposal !== "object")
                        throw TypeError(".protos.ChaincodeMessage.proposal: object expected");
                    message.proposal = $root.protos.SignedProposal.fromObject(object.proposal);
                }
                if (object.chaincode_event != null) {
                    if (typeof object.chaincode_event !== "object")
                        throw TypeError(".protos.ChaincodeMessage.chaincode_event: object expected");
                    message.chaincode_event = $root.protos.ChaincodeEvent.fromObject(object.chaincode_event);
                }
                if (object.channel_id != null)
                    message.channel_id = String(object.channel_id);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {protos.ChaincodeMessage} message ChaincodeMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNDEFINED" : 0;
                    object.timestamp = null;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    object.txid = "";
                    object.proposal = null;
                    object.chaincode_event = null;
                    object.channel_id = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.ChaincodeMessage.Type[message.type] : message.type;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.txid != null && message.hasOwnProperty("txid"))
                    object.txid = message.txid;
                if (message.proposal != null && message.hasOwnProperty("proposal"))
                    object.proposal = $root.protos.SignedProposal.toObject(message.proposal, options);
                if (message.chaincode_event != null && message.hasOwnProperty("chaincode_event"))
                    object.chaincode_event = $root.protos.ChaincodeEvent.toObject(message.chaincode_event, options);
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    object.channel_id = message.channel_id;
                return object;
            };
    
            /**
             * Converts this ChaincodeMessage to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Type enum.
             * @name protos.ChaincodeMessage.Type
             * @enum {number}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} REGISTER=1 REGISTER value
             * @property {number} REGISTERED=2 REGISTERED value
             * @property {number} INIT=3 INIT value
             * @property {number} READY=4 READY value
             * @property {number} TRANSACTION=5 TRANSACTION value
             * @property {number} COMPLETED=6 COMPLETED value
             * @property {number} ERROR=7 ERROR value
             * @property {number} GET_STATE=8 GET_STATE value
             * @property {number} PUT_STATE=9 PUT_STATE value
             * @property {number} DEL_STATE=10 DEL_STATE value
             * @property {number} INVOKE_CHAINCODE=11 INVOKE_CHAINCODE value
             * @property {number} RESPONSE=13 RESPONSE value
             * @property {number} GET_STATE_BY_RANGE=14 GET_STATE_BY_RANGE value
             * @property {number} GET_QUERY_RESULT=15 GET_QUERY_RESULT value
             * @property {number} QUERY_STATE_NEXT=16 QUERY_STATE_NEXT value
             * @property {number} QUERY_STATE_CLOSE=17 QUERY_STATE_CLOSE value
             * @property {number} KEEPALIVE=18 KEEPALIVE value
             * @property {number} GET_HISTORY_FOR_KEY=19 GET_HISTORY_FOR_KEY value
             * @property {number} GET_STATE_METADATA=20 GET_STATE_METADATA value
             * @property {number} PUT_STATE_METADATA=21 PUT_STATE_METADATA value
             * @property {number} GET_PRIVATE_DATA_HASH=22 GET_PRIVATE_DATA_HASH value
             */
            ChaincodeMessage.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "REGISTER"] = 1;
                values[valuesById[2] = "REGISTERED"] = 2;
                values[valuesById[3] = "INIT"] = 3;
                values[valuesById[4] = "READY"] = 4;
                values[valuesById[5] = "TRANSACTION"] = 5;
                values[valuesById[6] = "COMPLETED"] = 6;
                values[valuesById[7] = "ERROR"] = 7;
                values[valuesById[8] = "GET_STATE"] = 8;
                values[valuesById[9] = "PUT_STATE"] = 9;
                values[valuesById[10] = "DEL_STATE"] = 10;
                values[valuesById[11] = "INVOKE_CHAINCODE"] = 11;
                values[valuesById[13] = "RESPONSE"] = 13;
                values[valuesById[14] = "GET_STATE_BY_RANGE"] = 14;
                values[valuesById[15] = "GET_QUERY_RESULT"] = 15;
                values[valuesById[16] = "QUERY_STATE_NEXT"] = 16;
                values[valuesById[17] = "QUERY_STATE_CLOSE"] = 17;
                values[valuesById[18] = "KEEPALIVE"] = 18;
                values[valuesById[19] = "GET_HISTORY_FOR_KEY"] = 19;
                values[valuesById[20] = "GET_STATE_METADATA"] = 20;
                values[valuesById[21] = "PUT_STATE_METADATA"] = 21;
                values[valuesById[22] = "GET_PRIVATE_DATA_HASH"] = 22;
                return values;
            })();
    
            return ChaincodeMessage;
        })();
    
        protos.GetState = (function() {
    
            /**
             * Properties of a GetState.
             * @memberof protos
             * @interface IGetState
             * @property {string|null} [key] GetState key
             * @property {string|null} [collection] GetState collection
             */
    
            /**
             * Constructs a new GetState.
             * @memberof protos
             * @classdesc Represents a GetState.
             * @implements IGetState
             * @constructor
             * @param {protos.IGetState=} [properties] Properties to set
             */
            function GetState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetState key.
             * @member {string} key
             * @memberof protos.GetState
             * @instance
             */
            GetState.prototype.key = "";
    
            /**
             * GetState collection.
             * @member {string} collection
             * @memberof protos.GetState
             * @instance
             */
            GetState.prototype.collection = "";
    
            /**
             * Creates a new GetState instance using the specified properties.
             * @function create
             * @memberof protos.GetState
             * @static
             * @param {protos.IGetState=} [properties] Properties to set
             * @returns {protos.GetState} GetState instance
             */
            GetState.create = function create(properties) {
                return new GetState(properties);
            };
    
            /**
             * Encodes the specified GetState message. Does not implicitly {@link protos.GetState.verify|verify} messages.
             * @function encode
             * @memberof protos.GetState
             * @static
             * @param {protos.IGetState} message GetState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                return writer;
            };
    
            /**
             * Encodes the specified GetState message, length delimited. Does not implicitly {@link protos.GetState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetState
             * @static
             * @param {protos.IGetState} message GetState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetState message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetState} GetState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetState} GetState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetState message.
             * @function verify
             * @memberof protos.GetState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                return null;
            };
    
            /**
             * Creates a GetState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetState} GetState
             */
            GetState.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetState)
                    return object;
                var message = new $root.protos.GetState();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.collection != null)
                    message.collection = String(object.collection);
                return message;
            };
    
            /**
             * Creates a plain object from a GetState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetState
             * @static
             * @param {protos.GetState} message GetState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.collection = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                return object;
            };
    
            /**
             * Converts this GetState to JSON.
             * @function toJSON
             * @memberof protos.GetState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetState;
        })();
    
        protos.GetStateMetadata = (function() {
    
            /**
             * Properties of a GetStateMetadata.
             * @memberof protos
             * @interface IGetStateMetadata
             * @property {string|null} [key] GetStateMetadata key
             * @property {string|null} [collection] GetStateMetadata collection
             */
    
            /**
             * Constructs a new GetStateMetadata.
             * @memberof protos
             * @classdesc Represents a GetStateMetadata.
             * @implements IGetStateMetadata
             * @constructor
             * @param {protos.IGetStateMetadata=} [properties] Properties to set
             */
            function GetStateMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetStateMetadata key.
             * @member {string} key
             * @memberof protos.GetStateMetadata
             * @instance
             */
            GetStateMetadata.prototype.key = "";
    
            /**
             * GetStateMetadata collection.
             * @member {string} collection
             * @memberof protos.GetStateMetadata
             * @instance
             */
            GetStateMetadata.prototype.collection = "";
    
            /**
             * Creates a new GetStateMetadata instance using the specified properties.
             * @function create
             * @memberof protos.GetStateMetadata
             * @static
             * @param {protos.IGetStateMetadata=} [properties] Properties to set
             * @returns {protos.GetStateMetadata} GetStateMetadata instance
             */
            GetStateMetadata.create = function create(properties) {
                return new GetStateMetadata(properties);
            };
    
            /**
             * Encodes the specified GetStateMetadata message. Does not implicitly {@link protos.GetStateMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.GetStateMetadata
             * @static
             * @param {protos.IGetStateMetadata} message GetStateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStateMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                return writer;
            };
    
            /**
             * Encodes the specified GetStateMetadata message, length delimited. Does not implicitly {@link protos.GetStateMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetStateMetadata
             * @static
             * @param {protos.IGetStateMetadata} message GetStateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStateMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetStateMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetStateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetStateMetadata} GetStateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStateMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetStateMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetStateMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetStateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetStateMetadata} GetStateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStateMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetStateMetadata message.
             * @function verify
             * @memberof protos.GetStateMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStateMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                return null;
            };
    
            /**
             * Creates a GetStateMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetStateMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetStateMetadata} GetStateMetadata
             */
            GetStateMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetStateMetadata)
                    return object;
                var message = new $root.protos.GetStateMetadata();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.collection != null)
                    message.collection = String(object.collection);
                return message;
            };
    
            /**
             * Creates a plain object from a GetStateMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetStateMetadata
             * @static
             * @param {protos.GetStateMetadata} message GetStateMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStateMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.collection = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                return object;
            };
    
            /**
             * Converts this GetStateMetadata to JSON.
             * @function toJSON
             * @memberof protos.GetStateMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStateMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetStateMetadata;
        })();
    
        protos.PutState = (function() {
    
            /**
             * Properties of a PutState.
             * @memberof protos
             * @interface IPutState
             * @property {string|null} [key] PutState key
             * @property {Uint8Array|null} [value] PutState value
             * @property {string|null} [collection] PutState collection
             */
    
            /**
             * Constructs a new PutState.
             * @memberof protos
             * @classdesc Represents a PutState.
             * @implements IPutState
             * @constructor
             * @param {protos.IPutState=} [properties] Properties to set
             */
            function PutState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PutState key.
             * @member {string} key
             * @memberof protos.PutState
             * @instance
             */
            PutState.prototype.key = "";
    
            /**
             * PutState value.
             * @member {Uint8Array} value
             * @memberof protos.PutState
             * @instance
             */
            PutState.prototype.value = $util.newBuffer([]);
    
            /**
             * PutState collection.
             * @member {string} collection
             * @memberof protos.PutState
             * @instance
             */
            PutState.prototype.collection = "";
    
            /**
             * Creates a new PutState instance using the specified properties.
             * @function create
             * @memberof protos.PutState
             * @static
             * @param {protos.IPutState=} [properties] Properties to set
             * @returns {protos.PutState} PutState instance
             */
            PutState.create = function create(properties) {
                return new PutState(properties);
            };
    
            /**
             * Encodes the specified PutState message. Does not implicitly {@link protos.PutState.verify|verify} messages.
             * @function encode
             * @memberof protos.PutState
             * @static
             * @param {protos.IPutState} message PutState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                return writer;
            };
    
            /**
             * Encodes the specified PutState message, length delimited. Does not implicitly {@link protos.PutState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.PutState
             * @static
             * @param {protos.IPutState} message PutState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PutState message from the specified reader or buffer.
             * @function decode
             * @memberof protos.PutState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.PutState} PutState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.PutState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PutState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.PutState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.PutState} PutState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PutState message.
             * @function verify
             * @memberof protos.PutState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PutState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                return null;
            };
    
            /**
             * Creates a PutState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.PutState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.PutState} PutState
             */
            PutState.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.PutState)
                    return object;
                var message = new $root.protos.PutState();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.collection != null)
                    message.collection = String(object.collection);
                return message;
            };
    
            /**
             * Creates a plain object from a PutState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.PutState
             * @static
             * @param {protos.PutState} message PutState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PutState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.collection = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                return object;
            };
    
            /**
             * Converts this PutState to JSON.
             * @function toJSON
             * @memberof protos.PutState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PutState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PutState;
        })();
    
        protos.PutStateMetadata = (function() {
    
            /**
             * Properties of a PutStateMetadata.
             * @memberof protos
             * @interface IPutStateMetadata
             * @property {string|null} [key] PutStateMetadata key
             * @property {string|null} [collection] PutStateMetadata collection
             * @property {protos.IStateMetadata|null} [metadata] PutStateMetadata metadata
             */
    
            /**
             * Constructs a new PutStateMetadata.
             * @memberof protos
             * @classdesc Represents a PutStateMetadata.
             * @implements IPutStateMetadata
             * @constructor
             * @param {protos.IPutStateMetadata=} [properties] Properties to set
             */
            function PutStateMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PutStateMetadata key.
             * @member {string} key
             * @memberof protos.PutStateMetadata
             * @instance
             */
            PutStateMetadata.prototype.key = "";
    
            /**
             * PutStateMetadata collection.
             * @member {string} collection
             * @memberof protos.PutStateMetadata
             * @instance
             */
            PutStateMetadata.prototype.collection = "";
    
            /**
             * PutStateMetadata metadata.
             * @member {protos.IStateMetadata|null|undefined} metadata
             * @memberof protos.PutStateMetadata
             * @instance
             */
            PutStateMetadata.prototype.metadata = null;
    
            /**
             * Creates a new PutStateMetadata instance using the specified properties.
             * @function create
             * @memberof protos.PutStateMetadata
             * @static
             * @param {protos.IPutStateMetadata=} [properties] Properties to set
             * @returns {protos.PutStateMetadata} PutStateMetadata instance
             */
            PutStateMetadata.create = function create(properties) {
                return new PutStateMetadata(properties);
            };
    
            /**
             * Encodes the specified PutStateMetadata message. Does not implicitly {@link protos.PutStateMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.PutStateMetadata
             * @static
             * @param {protos.IPutStateMetadata} message PutStateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutStateMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.protos.StateMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PutStateMetadata message, length delimited. Does not implicitly {@link protos.PutStateMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.PutStateMetadata
             * @static
             * @param {protos.IPutStateMetadata} message PutStateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutStateMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PutStateMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.PutStateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.PutStateMetadata} PutStateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutStateMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.PutStateMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    case 4:
                        message.metadata = $root.protos.StateMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PutStateMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.PutStateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.PutStateMetadata} PutStateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutStateMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PutStateMetadata message.
             * @function verify
             * @memberof protos.PutStateMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PutStateMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    var error = $root.protos.StateMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };
    
            /**
             * Creates a PutStateMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.PutStateMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.PutStateMetadata} PutStateMetadata
             */
            PutStateMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.PutStateMetadata)
                    return object;
                var message = new $root.protos.PutStateMetadata();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.PutStateMetadata.metadata: object expected");
                    message.metadata = $root.protos.StateMetadata.fromObject(object.metadata);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PutStateMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.PutStateMetadata
             * @static
             * @param {protos.PutStateMetadata} message PutStateMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PutStateMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.collection = "";
                    object.metadata = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.protos.StateMetadata.toObject(message.metadata, options);
                return object;
            };
    
            /**
             * Converts this PutStateMetadata to JSON.
             * @function toJSON
             * @memberof protos.PutStateMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PutStateMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PutStateMetadata;
        })();
    
        protos.DelState = (function() {
    
            /**
             * Properties of a DelState.
             * @memberof protos
             * @interface IDelState
             * @property {string|null} [key] DelState key
             * @property {string|null} [collection] DelState collection
             */
    
            /**
             * Constructs a new DelState.
             * @memberof protos
             * @classdesc Represents a DelState.
             * @implements IDelState
             * @constructor
             * @param {protos.IDelState=} [properties] Properties to set
             */
            function DelState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DelState key.
             * @member {string} key
             * @memberof protos.DelState
             * @instance
             */
            DelState.prototype.key = "";
    
            /**
             * DelState collection.
             * @member {string} collection
             * @memberof protos.DelState
             * @instance
             */
            DelState.prototype.collection = "";
    
            /**
             * Creates a new DelState instance using the specified properties.
             * @function create
             * @memberof protos.DelState
             * @static
             * @param {protos.IDelState=} [properties] Properties to set
             * @returns {protos.DelState} DelState instance
             */
            DelState.create = function create(properties) {
                return new DelState(properties);
            };
    
            /**
             * Encodes the specified DelState message. Does not implicitly {@link protos.DelState.verify|verify} messages.
             * @function encode
             * @memberof protos.DelState
             * @static
             * @param {protos.IDelState} message DelState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                return writer;
            };
    
            /**
             * Encodes the specified DelState message, length delimited. Does not implicitly {@link protos.DelState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.DelState
             * @static
             * @param {protos.IDelState} message DelState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DelState message from the specified reader or buffer.
             * @function decode
             * @memberof protos.DelState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.DelState} DelState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DelState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DelState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.DelState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.DelState} DelState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DelState message.
             * @function verify
             * @memberof protos.DelState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DelState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                return null;
            };
    
            /**
             * Creates a DelState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.DelState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.DelState} DelState
             */
            DelState.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.DelState)
                    return object;
                var message = new $root.protos.DelState();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.collection != null)
                    message.collection = String(object.collection);
                return message;
            };
    
            /**
             * Creates a plain object from a DelState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.DelState
             * @static
             * @param {protos.DelState} message DelState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DelState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.collection = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                return object;
            };
    
            /**
             * Converts this DelState to JSON.
             * @function toJSON
             * @memberof protos.DelState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DelState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DelState;
        })();
    
        protos.GetStateByRange = (function() {
    
            /**
             * Properties of a GetStateByRange.
             * @memberof protos
             * @interface IGetStateByRange
             * @property {string|null} [startKey] GetStateByRange startKey
             * @property {string|null} [endKey] GetStateByRange endKey
             * @property {string|null} [collection] GetStateByRange collection
             * @property {Uint8Array|null} [metadata] GetStateByRange metadata
             */
    
            /**
             * Constructs a new GetStateByRange.
             * @memberof protos
             * @classdesc Represents a GetStateByRange.
             * @implements IGetStateByRange
             * @constructor
             * @param {protos.IGetStateByRange=} [properties] Properties to set
             */
            function GetStateByRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetStateByRange startKey.
             * @member {string} startKey
             * @memberof protos.GetStateByRange
             * @instance
             */
            GetStateByRange.prototype.startKey = "";
    
            /**
             * GetStateByRange endKey.
             * @member {string} endKey
             * @memberof protos.GetStateByRange
             * @instance
             */
            GetStateByRange.prototype.endKey = "";
    
            /**
             * GetStateByRange collection.
             * @member {string} collection
             * @memberof protos.GetStateByRange
             * @instance
             */
            GetStateByRange.prototype.collection = "";
    
            /**
             * GetStateByRange metadata.
             * @member {Uint8Array} metadata
             * @memberof protos.GetStateByRange
             * @instance
             */
            GetStateByRange.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new GetStateByRange instance using the specified properties.
             * @function create
             * @memberof protos.GetStateByRange
             * @static
             * @param {protos.IGetStateByRange=} [properties] Properties to set
             * @returns {protos.GetStateByRange} GetStateByRange instance
             */
            GetStateByRange.create = function create(properties) {
                return new GetStateByRange(properties);
            };
    
            /**
             * Encodes the specified GetStateByRange message. Does not implicitly {@link protos.GetStateByRange.verify|verify} messages.
             * @function encode
             * @memberof protos.GetStateByRange
             * @static
             * @param {protos.IGetStateByRange} message GetStateByRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStateByRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startKey != null && Object.hasOwnProperty.call(message, "startKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.startKey);
                if (message.endKey != null && Object.hasOwnProperty.call(message, "endKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.endKey);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified GetStateByRange message, length delimited. Does not implicitly {@link protos.GetStateByRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetStateByRange
             * @static
             * @param {protos.IGetStateByRange} message GetStateByRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStateByRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetStateByRange message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetStateByRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetStateByRange} GetStateByRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStateByRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetStateByRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startKey = reader.string();
                        break;
                    case 2:
                        message.endKey = reader.string();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    case 4:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetStateByRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetStateByRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetStateByRange} GetStateByRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStateByRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetStateByRange message.
             * @function verify
             * @memberof protos.GetStateByRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStateByRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startKey != null && message.hasOwnProperty("startKey"))
                    if (!$util.isString(message.startKey))
                        return "startKey: string expected";
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    if (!$util.isString(message.endKey))
                        return "endKey: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a GetStateByRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetStateByRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetStateByRange} GetStateByRange
             */
            GetStateByRange.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetStateByRange)
                    return object;
                var message = new $root.protos.GetStateByRange();
                if (object.startKey != null)
                    message.startKey = String(object.startKey);
                if (object.endKey != null)
                    message.endKey = String(object.endKey);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a GetStateByRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetStateByRange
             * @static
             * @param {protos.GetStateByRange} message GetStateByRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStateByRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.startKey = "";
                    object.endKey = "";
                    object.collection = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.startKey != null && message.hasOwnProperty("startKey"))
                    object.startKey = message.startKey;
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    object.endKey = message.endKey;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this GetStateByRange to JSON.
             * @function toJSON
             * @memberof protos.GetStateByRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStateByRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetStateByRange;
        })();
    
        protos.GetQueryResult = (function() {
    
            /**
             * Properties of a GetQueryResult.
             * @memberof protos
             * @interface IGetQueryResult
             * @property {string|null} [query] GetQueryResult query
             * @property {string|null} [collection] GetQueryResult collection
             * @property {Uint8Array|null} [metadata] GetQueryResult metadata
             */
    
            /**
             * Constructs a new GetQueryResult.
             * @memberof protos
             * @classdesc Represents a GetQueryResult.
             * @implements IGetQueryResult
             * @constructor
             * @param {protos.IGetQueryResult=} [properties] Properties to set
             */
            function GetQueryResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetQueryResult query.
             * @member {string} query
             * @memberof protos.GetQueryResult
             * @instance
             */
            GetQueryResult.prototype.query = "";
    
            /**
             * GetQueryResult collection.
             * @member {string} collection
             * @memberof protos.GetQueryResult
             * @instance
             */
            GetQueryResult.prototype.collection = "";
    
            /**
             * GetQueryResult metadata.
             * @member {Uint8Array} metadata
             * @memberof protos.GetQueryResult
             * @instance
             */
            GetQueryResult.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new GetQueryResult instance using the specified properties.
             * @function create
             * @memberof protos.GetQueryResult
             * @static
             * @param {protos.IGetQueryResult=} [properties] Properties to set
             * @returns {protos.GetQueryResult} GetQueryResult instance
             */
            GetQueryResult.create = function create(properties) {
                return new GetQueryResult(properties);
            };
    
            /**
             * Encodes the specified GetQueryResult message. Does not implicitly {@link protos.GetQueryResult.verify|verify} messages.
             * @function encode
             * @memberof protos.GetQueryResult
             * @static
             * @param {protos.IGetQueryResult} message GetQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified GetQueryResult message, length delimited. Does not implicitly {@link protos.GetQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetQueryResult
             * @static
             * @param {protos.IGetQueryResult} message GetQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetQueryResult} GetQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    case 3:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetQueryResult} GetQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetQueryResult message.
             * @function verify
             * @memberof protos.GetQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a GetQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetQueryResult} GetQueryResult
             */
            GetQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetQueryResult)
                    return object;
                var message = new $root.protos.GetQueryResult();
                if (object.query != null)
                    message.query = String(object.query);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a GetQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetQueryResult
             * @static
             * @param {protos.GetQueryResult} message GetQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.query = "";
                    object.collection = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this GetQueryResult to JSON.
             * @function toJSON
             * @memberof protos.GetQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetQueryResult;
        })();
    
        protos.QueryMetadata = (function() {
    
            /**
             * Properties of a QueryMetadata.
             * @memberof protos
             * @interface IQueryMetadata
             * @property {number|null} [pageSize] QueryMetadata pageSize
             * @property {string|null} [bookmark] QueryMetadata bookmark
             */
    
            /**
             * Constructs a new QueryMetadata.
             * @memberof protos
             * @classdesc Represents a QueryMetadata.
             * @implements IQueryMetadata
             * @constructor
             * @param {protos.IQueryMetadata=} [properties] Properties to set
             */
            function QueryMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryMetadata pageSize.
             * @member {number} pageSize
             * @memberof protos.QueryMetadata
             * @instance
             */
            QueryMetadata.prototype.pageSize = 0;
    
            /**
             * QueryMetadata bookmark.
             * @member {string} bookmark
             * @memberof protos.QueryMetadata
             * @instance
             */
            QueryMetadata.prototype.bookmark = "";
    
            /**
             * Creates a new QueryMetadata instance using the specified properties.
             * @function create
             * @memberof protos.QueryMetadata
             * @static
             * @param {protos.IQueryMetadata=} [properties] Properties to set
             * @returns {protos.QueryMetadata} QueryMetadata instance
             */
            QueryMetadata.create = function create(properties) {
                return new QueryMetadata(properties);
            };
    
            /**
             * Encodes the specified QueryMetadata message. Does not implicitly {@link protos.QueryMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryMetadata
             * @static
             * @param {protos.IQueryMetadata} message QueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pageSize != null && Object.hasOwnProperty.call(message, "pageSize"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pageSize);
                if (message.bookmark != null && Object.hasOwnProperty.call(message, "bookmark"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.bookmark);
                return writer;
            };
    
            /**
             * Encodes the specified QueryMetadata message, length delimited. Does not implicitly {@link protos.QueryMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryMetadata
             * @static
             * @param {protos.IQueryMetadata} message QueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryMetadata} QueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pageSize = reader.int32();
                        break;
                    case 2:
                        message.bookmark = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryMetadata} QueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryMetadata message.
             * @function verify
             * @memberof protos.QueryMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (!$util.isInteger(message.pageSize))
                        return "pageSize: integer expected";
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    if (!$util.isString(message.bookmark))
                        return "bookmark: string expected";
                return null;
            };
    
            /**
             * Creates a QueryMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryMetadata} QueryMetadata
             */
            QueryMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryMetadata)
                    return object;
                var message = new $root.protos.QueryMetadata();
                if (object.pageSize != null)
                    message.pageSize = object.pageSize | 0;
                if (object.bookmark != null)
                    message.bookmark = String(object.bookmark);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryMetadata
             * @static
             * @param {protos.QueryMetadata} message QueryMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.pageSize = 0;
                    object.bookmark = "";
                }
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    object.pageSize = message.pageSize;
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    object.bookmark = message.bookmark;
                return object;
            };
    
            /**
             * Converts this QueryMetadata to JSON.
             * @function toJSON
             * @memberof protos.QueryMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryMetadata;
        })();
    
        protos.GetHistoryForKey = (function() {
    
            /**
             * Properties of a GetHistoryForKey.
             * @memberof protos
             * @interface IGetHistoryForKey
             * @property {string|null} [key] GetHistoryForKey key
             */
    
            /**
             * Constructs a new GetHistoryForKey.
             * @memberof protos
             * @classdesc Represents a GetHistoryForKey.
             * @implements IGetHistoryForKey
             * @constructor
             * @param {protos.IGetHistoryForKey=} [properties] Properties to set
             */
            function GetHistoryForKey(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetHistoryForKey key.
             * @member {string} key
             * @memberof protos.GetHistoryForKey
             * @instance
             */
            GetHistoryForKey.prototype.key = "";
    
            /**
             * Creates a new GetHistoryForKey instance using the specified properties.
             * @function create
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {protos.IGetHistoryForKey=} [properties] Properties to set
             * @returns {protos.GetHistoryForKey} GetHistoryForKey instance
             */
            GetHistoryForKey.create = function create(properties) {
                return new GetHistoryForKey(properties);
            };
    
            /**
             * Encodes the specified GetHistoryForKey message. Does not implicitly {@link protos.GetHistoryForKey.verify|verify} messages.
             * @function encode
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {protos.IGetHistoryForKey} message GetHistoryForKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryForKey.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                return writer;
            };
    
            /**
             * Encodes the specified GetHistoryForKey message, length delimited. Does not implicitly {@link protos.GetHistoryForKey.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {protos.IGetHistoryForKey} message GetHistoryForKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryForKey.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetHistoryForKey message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetHistoryForKey} GetHistoryForKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryForKey.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetHistoryForKey();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetHistoryForKey message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetHistoryForKey} GetHistoryForKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryForKey.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetHistoryForKey message.
             * @function verify
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryForKey.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                return null;
            };
    
            /**
             * Creates a GetHistoryForKey message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetHistoryForKey} GetHistoryForKey
             */
            GetHistoryForKey.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetHistoryForKey)
                    return object;
                var message = new $root.protos.GetHistoryForKey();
                if (object.key != null)
                    message.key = String(object.key);
                return message;
            };
    
            /**
             * Creates a plain object from a GetHistoryForKey message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {protos.GetHistoryForKey} message GetHistoryForKey
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryForKey.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                return object;
            };
    
            /**
             * Converts this GetHistoryForKey to JSON.
             * @function toJSON
             * @memberof protos.GetHistoryForKey
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryForKey.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetHistoryForKey;
        })();
    
        protos.QueryStateNext = (function() {
    
            /**
             * Properties of a QueryStateNext.
             * @memberof protos
             * @interface IQueryStateNext
             * @property {string|null} [id] QueryStateNext id
             */
    
            /**
             * Constructs a new QueryStateNext.
             * @memberof protos
             * @classdesc Represents a QueryStateNext.
             * @implements IQueryStateNext
             * @constructor
             * @param {protos.IQueryStateNext=} [properties] Properties to set
             */
            function QueryStateNext(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryStateNext id.
             * @member {string} id
             * @memberof protos.QueryStateNext
             * @instance
             */
            QueryStateNext.prototype.id = "";
    
            /**
             * Creates a new QueryStateNext instance using the specified properties.
             * @function create
             * @memberof protos.QueryStateNext
             * @static
             * @param {protos.IQueryStateNext=} [properties] Properties to set
             * @returns {protos.QueryStateNext} QueryStateNext instance
             */
            QueryStateNext.create = function create(properties) {
                return new QueryStateNext(properties);
            };
    
            /**
             * Encodes the specified QueryStateNext message. Does not implicitly {@link protos.QueryStateNext.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryStateNext
             * @static
             * @param {protos.IQueryStateNext} message QueryStateNext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStateNext.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified QueryStateNext message, length delimited. Does not implicitly {@link protos.QueryStateNext.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryStateNext
             * @static
             * @param {protos.IQueryStateNext} message QueryStateNext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStateNext.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryStateNext message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryStateNext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryStateNext} QueryStateNext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStateNext.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryStateNext();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryStateNext message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryStateNext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryStateNext} QueryStateNext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStateNext.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryStateNext message.
             * @function verify
             * @memberof protos.QueryStateNext
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryStateNext.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };
    
            /**
             * Creates a QueryStateNext message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryStateNext
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryStateNext} QueryStateNext
             */
            QueryStateNext.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryStateNext)
                    return object;
                var message = new $root.protos.QueryStateNext();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryStateNext message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryStateNext
             * @static
             * @param {protos.QueryStateNext} message QueryStateNext
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryStateNext.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };
    
            /**
             * Converts this QueryStateNext to JSON.
             * @function toJSON
             * @memberof protos.QueryStateNext
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryStateNext.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryStateNext;
        })();
    
        protos.QueryStateClose = (function() {
    
            /**
             * Properties of a QueryStateClose.
             * @memberof protos
             * @interface IQueryStateClose
             * @property {string|null} [id] QueryStateClose id
             */
    
            /**
             * Constructs a new QueryStateClose.
             * @memberof protos
             * @classdesc Represents a QueryStateClose.
             * @implements IQueryStateClose
             * @constructor
             * @param {protos.IQueryStateClose=} [properties] Properties to set
             */
            function QueryStateClose(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryStateClose id.
             * @member {string} id
             * @memberof protos.QueryStateClose
             * @instance
             */
            QueryStateClose.prototype.id = "";
    
            /**
             * Creates a new QueryStateClose instance using the specified properties.
             * @function create
             * @memberof protos.QueryStateClose
             * @static
             * @param {protos.IQueryStateClose=} [properties] Properties to set
             * @returns {protos.QueryStateClose} QueryStateClose instance
             */
            QueryStateClose.create = function create(properties) {
                return new QueryStateClose(properties);
            };
    
            /**
             * Encodes the specified QueryStateClose message. Does not implicitly {@link protos.QueryStateClose.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryStateClose
             * @static
             * @param {protos.IQueryStateClose} message QueryStateClose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStateClose.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified QueryStateClose message, length delimited. Does not implicitly {@link protos.QueryStateClose.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryStateClose
             * @static
             * @param {protos.IQueryStateClose} message QueryStateClose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStateClose.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryStateClose message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryStateClose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryStateClose} QueryStateClose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStateClose.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryStateClose();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryStateClose message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryStateClose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryStateClose} QueryStateClose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStateClose.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryStateClose message.
             * @function verify
             * @memberof protos.QueryStateClose
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryStateClose.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };
    
            /**
             * Creates a QueryStateClose message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryStateClose
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryStateClose} QueryStateClose
             */
            QueryStateClose.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryStateClose)
                    return object;
                var message = new $root.protos.QueryStateClose();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryStateClose message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryStateClose
             * @static
             * @param {protos.QueryStateClose} message QueryStateClose
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryStateClose.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };
    
            /**
             * Converts this QueryStateClose to JSON.
             * @function toJSON
             * @memberof protos.QueryStateClose
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryStateClose.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryStateClose;
        })();
    
        protos.QueryResultBytes = (function() {
    
            /**
             * Properties of a QueryResultBytes.
             * @memberof protos
             * @interface IQueryResultBytes
             * @property {Uint8Array|null} [resultBytes] QueryResultBytes resultBytes
             */
    
            /**
             * Constructs a new QueryResultBytes.
             * @memberof protos
             * @classdesc Represents a QueryResultBytes.
             * @implements IQueryResultBytes
             * @constructor
             * @param {protos.IQueryResultBytes=} [properties] Properties to set
             */
            function QueryResultBytes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryResultBytes resultBytes.
             * @member {Uint8Array} resultBytes
             * @memberof protos.QueryResultBytes
             * @instance
             */
            QueryResultBytes.prototype.resultBytes = $util.newBuffer([]);
    
            /**
             * Creates a new QueryResultBytes instance using the specified properties.
             * @function create
             * @memberof protos.QueryResultBytes
             * @static
             * @param {protos.IQueryResultBytes=} [properties] Properties to set
             * @returns {protos.QueryResultBytes} QueryResultBytes instance
             */
            QueryResultBytes.create = function create(properties) {
                return new QueryResultBytes(properties);
            };
    
            /**
             * Encodes the specified QueryResultBytes message. Does not implicitly {@link protos.QueryResultBytes.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryResultBytes
             * @static
             * @param {protos.IQueryResultBytes} message QueryResultBytes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResultBytes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultBytes != null && Object.hasOwnProperty.call(message, "resultBytes"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.resultBytes);
                return writer;
            };
    
            /**
             * Encodes the specified QueryResultBytes message, length delimited. Does not implicitly {@link protos.QueryResultBytes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryResultBytes
             * @static
             * @param {protos.IQueryResultBytes} message QueryResultBytes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResultBytes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryResultBytes message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryResultBytes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryResultBytes} QueryResultBytes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResultBytes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryResultBytes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resultBytes = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryResultBytes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryResultBytes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryResultBytes} QueryResultBytes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResultBytes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryResultBytes message.
             * @function verify
             * @memberof protos.QueryResultBytes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResultBytes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultBytes != null && message.hasOwnProperty("resultBytes"))
                    if (!(message.resultBytes && typeof message.resultBytes.length === "number" || $util.isString(message.resultBytes)))
                        return "resultBytes: buffer expected";
                return null;
            };
    
            /**
             * Creates a QueryResultBytes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryResultBytes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryResultBytes} QueryResultBytes
             */
            QueryResultBytes.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryResultBytes)
                    return object;
                var message = new $root.protos.QueryResultBytes();
                if (object.resultBytes != null)
                    if (typeof object.resultBytes === "string")
                        $util.base64.decode(object.resultBytes, message.resultBytes = $util.newBuffer($util.base64.length(object.resultBytes)), 0);
                    else if (object.resultBytes.length)
                        message.resultBytes = object.resultBytes;
                return message;
            };
    
            /**
             * Creates a plain object from a QueryResultBytes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryResultBytes
             * @static
             * @param {protos.QueryResultBytes} message QueryResultBytes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResultBytes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.resultBytes = "";
                    else {
                        object.resultBytes = [];
                        if (options.bytes !== Array)
                            object.resultBytes = $util.newBuffer(object.resultBytes);
                    }
                if (message.resultBytes != null && message.hasOwnProperty("resultBytes"))
                    object.resultBytes = options.bytes === String ? $util.base64.encode(message.resultBytes, 0, message.resultBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.resultBytes) : message.resultBytes;
                return object;
            };
    
            /**
             * Converts this QueryResultBytes to JSON.
             * @function toJSON
             * @memberof protos.QueryResultBytes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResultBytes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryResultBytes;
        })();
    
        protos.QueryResponse = (function() {
    
            /**
             * Properties of a QueryResponse.
             * @memberof protos
             * @interface IQueryResponse
             * @property {Array.<protos.IQueryResultBytes>|null} [results] QueryResponse results
             * @property {boolean|null} [has_more] QueryResponse has_more
             * @property {string|null} [id] QueryResponse id
             * @property {Uint8Array|null} [metadata] QueryResponse metadata
             */
    
            /**
             * Constructs a new QueryResponse.
             * @memberof protos
             * @classdesc Represents a QueryResponse.
             * @implements IQueryResponse
             * @constructor
             * @param {protos.IQueryResponse=} [properties] Properties to set
             */
            function QueryResponse(properties) {
                this.results = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryResponse results.
             * @member {Array.<protos.IQueryResultBytes>} results
             * @memberof protos.QueryResponse
             * @instance
             */
            QueryResponse.prototype.results = $util.emptyArray;
    
            /**
             * QueryResponse has_more.
             * @member {boolean} has_more
             * @memberof protos.QueryResponse
             * @instance
             */
            QueryResponse.prototype.has_more = false;
    
            /**
             * QueryResponse id.
             * @member {string} id
             * @memberof protos.QueryResponse
             * @instance
             */
            QueryResponse.prototype.id = "";
    
            /**
             * QueryResponse metadata.
             * @member {Uint8Array} metadata
             * @memberof protos.QueryResponse
             * @instance
             */
            QueryResponse.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new QueryResponse instance using the specified properties.
             * @function create
             * @memberof protos.QueryResponse
             * @static
             * @param {protos.IQueryResponse=} [properties] Properties to set
             * @returns {protos.QueryResponse} QueryResponse instance
             */
            QueryResponse.create = function create(properties) {
                return new QueryResponse(properties);
            };
    
            /**
             * Encodes the specified QueryResponse message. Does not implicitly {@link protos.QueryResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryResponse
             * @static
             * @param {protos.IQueryResponse} message QueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.results != null && message.results.length)
                    for (var i = 0; i < message.results.length; ++i)
                        $root.protos.QueryResultBytes.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.has_more != null && Object.hasOwnProperty.call(message, "has_more"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.has_more);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified QueryResponse message, length delimited. Does not implicitly {@link protos.QueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryResponse
             * @static
             * @param {protos.IQueryResponse} message QueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryResponse} QueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.results && message.results.length))
                            message.results = [];
                        message.results.push($root.protos.QueryResultBytes.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.has_more = reader.bool();
                        break;
                    case 3:
                        message.id = reader.string();
                        break;
                    case 4:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryResponse} QueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryResponse message.
             * @function verify
             * @memberof protos.QueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.results != null && message.hasOwnProperty("results")) {
                    if (!Array.isArray(message.results))
                        return "results: array expected";
                    for (var i = 0; i < message.results.length; ++i) {
                        var error = $root.protos.QueryResultBytes.verify(message.results[i]);
                        if (error)
                            return "results." + error;
                    }
                }
                if (message.has_more != null && message.hasOwnProperty("has_more"))
                    if (typeof message.has_more !== "boolean")
                        return "has_more: boolean expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a QueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryResponse} QueryResponse
             */
            QueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryResponse)
                    return object;
                var message = new $root.protos.QueryResponse();
                if (object.results) {
                    if (!Array.isArray(object.results))
                        throw TypeError(".protos.QueryResponse.results: array expected");
                    message.results = [];
                    for (var i = 0; i < object.results.length; ++i) {
                        if (typeof object.results[i] !== "object")
                            throw TypeError(".protos.QueryResponse.results: object expected");
                        message.results[i] = $root.protos.QueryResultBytes.fromObject(object.results[i]);
                    }
                }
                if (object.has_more != null)
                    message.has_more = Boolean(object.has_more);
                if (object.id != null)
                    message.id = String(object.id);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a QueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryResponse
             * @static
             * @param {protos.QueryResponse} message QueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.results = [];
                if (options.defaults) {
                    object.has_more = false;
                    object.id = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.results && message.results.length) {
                    object.results = [];
                    for (var j = 0; j < message.results.length; ++j)
                        object.results[j] = $root.protos.QueryResultBytes.toObject(message.results[j], options);
                }
                if (message.has_more != null && message.hasOwnProperty("has_more"))
                    object.has_more = message.has_more;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this QueryResponse to JSON.
             * @function toJSON
             * @memberof protos.QueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryResponse;
        })();
    
        protos.QueryResponseMetadata = (function() {
    
            /**
             * Properties of a QueryResponseMetadata.
             * @memberof protos
             * @interface IQueryResponseMetadata
             * @property {number|null} [fetched_records_count] QueryResponseMetadata fetched_records_count
             * @property {string|null} [bookmark] QueryResponseMetadata bookmark
             */
    
            /**
             * Constructs a new QueryResponseMetadata.
             * @memberof protos
             * @classdesc Represents a QueryResponseMetadata.
             * @implements IQueryResponseMetadata
             * @constructor
             * @param {protos.IQueryResponseMetadata=} [properties] Properties to set
             */
            function QueryResponseMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryResponseMetadata fetched_records_count.
             * @member {number} fetched_records_count
             * @memberof protos.QueryResponseMetadata
             * @instance
             */
            QueryResponseMetadata.prototype.fetched_records_count = 0;
    
            /**
             * QueryResponseMetadata bookmark.
             * @member {string} bookmark
             * @memberof protos.QueryResponseMetadata
             * @instance
             */
            QueryResponseMetadata.prototype.bookmark = "";
    
            /**
             * Creates a new QueryResponseMetadata instance using the specified properties.
             * @function create
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {protos.IQueryResponseMetadata=} [properties] Properties to set
             * @returns {protos.QueryResponseMetadata} QueryResponseMetadata instance
             */
            QueryResponseMetadata.create = function create(properties) {
                return new QueryResponseMetadata(properties);
            };
    
            /**
             * Encodes the specified QueryResponseMetadata message. Does not implicitly {@link protos.QueryResponseMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {protos.IQueryResponseMetadata} message QueryResponseMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResponseMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fetched_records_count != null && Object.hasOwnProperty.call(message, "fetched_records_count"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fetched_records_count);
                if (message.bookmark != null && Object.hasOwnProperty.call(message, "bookmark"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.bookmark);
                return writer;
            };
    
            /**
             * Encodes the specified QueryResponseMetadata message, length delimited. Does not implicitly {@link protos.QueryResponseMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {protos.IQueryResponseMetadata} message QueryResponseMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResponseMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryResponseMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryResponseMetadata} QueryResponseMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResponseMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryResponseMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fetched_records_count = reader.int32();
                        break;
                    case 2:
                        message.bookmark = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryResponseMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryResponseMetadata} QueryResponseMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResponseMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryResponseMetadata message.
             * @function verify
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResponseMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fetched_records_count != null && message.hasOwnProperty("fetched_records_count"))
                    if (!$util.isInteger(message.fetched_records_count))
                        return "fetched_records_count: integer expected";
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    if (!$util.isString(message.bookmark))
                        return "bookmark: string expected";
                return null;
            };
    
            /**
             * Creates a QueryResponseMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryResponseMetadata} QueryResponseMetadata
             */
            QueryResponseMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryResponseMetadata)
                    return object;
                var message = new $root.protos.QueryResponseMetadata();
                if (object.fetched_records_count != null)
                    message.fetched_records_count = object.fetched_records_count | 0;
                if (object.bookmark != null)
                    message.bookmark = String(object.bookmark);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryResponseMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {protos.QueryResponseMetadata} message QueryResponseMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResponseMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fetched_records_count = 0;
                    object.bookmark = "";
                }
                if (message.fetched_records_count != null && message.hasOwnProperty("fetched_records_count"))
                    object.fetched_records_count = message.fetched_records_count;
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    object.bookmark = message.bookmark;
                return object;
            };
    
            /**
             * Converts this QueryResponseMetadata to JSON.
             * @function toJSON
             * @memberof protos.QueryResponseMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResponseMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryResponseMetadata;
        })();
    
        protos.StateMetadata = (function() {
    
            /**
             * Properties of a StateMetadata.
             * @memberof protos
             * @interface IStateMetadata
             * @property {string|null} [metakey] StateMetadata metakey
             * @property {Uint8Array|null} [value] StateMetadata value
             */
    
            /**
             * Constructs a new StateMetadata.
             * @memberof protos
             * @classdesc Represents a StateMetadata.
             * @implements IStateMetadata
             * @constructor
             * @param {protos.IStateMetadata=} [properties] Properties to set
             */
            function StateMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateMetadata metakey.
             * @member {string} metakey
             * @memberof protos.StateMetadata
             * @instance
             */
            StateMetadata.prototype.metakey = "";
    
            /**
             * StateMetadata value.
             * @member {Uint8Array} value
             * @memberof protos.StateMetadata
             * @instance
             */
            StateMetadata.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new StateMetadata instance using the specified properties.
             * @function create
             * @memberof protos.StateMetadata
             * @static
             * @param {protos.IStateMetadata=} [properties] Properties to set
             * @returns {protos.StateMetadata} StateMetadata instance
             */
            StateMetadata.create = function create(properties) {
                return new StateMetadata(properties);
            };
    
            /**
             * Encodes the specified StateMetadata message. Does not implicitly {@link protos.StateMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.StateMetadata
             * @static
             * @param {protos.IStateMetadata} message StateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metakey != null && Object.hasOwnProperty.call(message, "metakey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.metakey);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified StateMetadata message, length delimited. Does not implicitly {@link protos.StateMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.StateMetadata
             * @static
             * @param {protos.IStateMetadata} message StateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.StateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.StateMetadata} StateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StateMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.metakey = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.StateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.StateMetadata} StateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateMetadata message.
             * @function verify
             * @memberof protos.StateMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metakey != null && message.hasOwnProperty("metakey"))
                    if (!$util.isString(message.metakey))
                        return "metakey: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a StateMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.StateMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.StateMetadata} StateMetadata
             */
            StateMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.StateMetadata)
                    return object;
                var message = new $root.protos.StateMetadata();
                if (object.metakey != null)
                    message.metakey = String(object.metakey);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a StateMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.StateMetadata
             * @static
             * @param {protos.StateMetadata} message StateMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.metakey = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.metakey != null && message.hasOwnProperty("metakey"))
                    object.metakey = message.metakey;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this StateMetadata to JSON.
             * @function toJSON
             * @memberof protos.StateMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateMetadata;
        })();
    
        protos.StateMetadataResult = (function() {
    
            /**
             * Properties of a StateMetadataResult.
             * @memberof protos
             * @interface IStateMetadataResult
             * @property {Array.<protos.IStateMetadata>|null} [entries] StateMetadataResult entries
             */
    
            /**
             * Constructs a new StateMetadataResult.
             * @memberof protos
             * @classdesc Represents a StateMetadataResult.
             * @implements IStateMetadataResult
             * @constructor
             * @param {protos.IStateMetadataResult=} [properties] Properties to set
             */
            function StateMetadataResult(properties) {
                this.entries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateMetadataResult entries.
             * @member {Array.<protos.IStateMetadata>} entries
             * @memberof protos.StateMetadataResult
             * @instance
             */
            StateMetadataResult.prototype.entries = $util.emptyArray;
    
            /**
             * Creates a new StateMetadataResult instance using the specified properties.
             * @function create
             * @memberof protos.StateMetadataResult
             * @static
             * @param {protos.IStateMetadataResult=} [properties] Properties to set
             * @returns {protos.StateMetadataResult} StateMetadataResult instance
             */
            StateMetadataResult.create = function create(properties) {
                return new StateMetadataResult(properties);
            };
    
            /**
             * Encodes the specified StateMetadataResult message. Does not implicitly {@link protos.StateMetadataResult.verify|verify} messages.
             * @function encode
             * @memberof protos.StateMetadataResult
             * @static
             * @param {protos.IStateMetadataResult} message StateMetadataResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadataResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entries != null && message.entries.length)
                    for (var i = 0; i < message.entries.length; ++i)
                        $root.protos.StateMetadata.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StateMetadataResult message, length delimited. Does not implicitly {@link protos.StateMetadataResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.StateMetadataResult
             * @static
             * @param {protos.IStateMetadataResult} message StateMetadataResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadataResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateMetadataResult message from the specified reader or buffer.
             * @function decode
             * @memberof protos.StateMetadataResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.StateMetadataResult} StateMetadataResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadataResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StateMetadataResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.protos.StateMetadata.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateMetadataResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.StateMetadataResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.StateMetadataResult} StateMetadataResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadataResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateMetadataResult message.
             * @function verify
             * @memberof protos.StateMetadataResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateMetadataResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (var i = 0; i < message.entries.length; ++i) {
                        var error = $root.protos.StateMetadata.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StateMetadataResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.StateMetadataResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.StateMetadataResult} StateMetadataResult
             */
            StateMetadataResult.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.StateMetadataResult)
                    return object;
                var message = new $root.protos.StateMetadataResult();
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".protos.StateMetadataResult.entries: array expected");
                    message.entries = [];
                    for (var i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".protos.StateMetadataResult.entries: object expected");
                        message.entries[i] = $root.protos.StateMetadata.fromObject(object.entries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StateMetadataResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.StateMetadataResult
             * @static
             * @param {protos.StateMetadataResult} message StateMetadataResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateMetadataResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (var j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.protos.StateMetadata.toObject(message.entries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this StateMetadataResult to JSON.
             * @function toJSON
             * @memberof protos.StateMetadataResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateMetadataResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateMetadataResult;
        })();
    
        protos.ChaincodeSupport = (function() {
    
            /**
             * Constructs a new ChaincodeSupport service.
             * @memberof protos
             * @classdesc Represents a ChaincodeSupport
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ChaincodeSupport(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (ChaincodeSupport.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ChaincodeSupport;
    
            /**
             * Creates new ChaincodeSupport service using the specified rpc implementation.
             * @function create
             * @memberof protos.ChaincodeSupport
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ChaincodeSupport} RPC service. Useful where requests and/or responses are streamed.
             */
            ChaincodeSupport.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link protos.ChaincodeSupport#register}.
             * @memberof protos.ChaincodeSupport
             * @typedef RegisterCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.ChaincodeMessage} [response] ChaincodeMessage
             */
    
            /**
             * Calls Register.
             * @function register
             * @memberof protos.ChaincodeSupport
             * @instance
             * @param {protos.IChaincodeMessage} request ChaincodeMessage message or plain object
             * @param {protos.ChaincodeSupport.RegisterCallback} callback Node-style callback called with the error, if any, and ChaincodeMessage
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ChaincodeSupport.prototype.register = function register(request, callback) {
                return this.rpcCall(register, $root.protos.ChaincodeMessage, $root.protos.ChaincodeMessage, request, callback);
            }, "name", { value: "Register" });
    
            /**
             * Calls Register.
             * @function register
             * @memberof protos.ChaincodeSupport
             * @instance
             * @param {protos.IChaincodeMessage} request ChaincodeMessage message or plain object
             * @returns {Promise<protos.ChaincodeMessage>} Promise
             * @variation 2
             */
    
            return ChaincodeSupport;
        })();
    
        protos.Chaincode = (function() {
    
            /**
             * Constructs a new Chaincode service.
             * @memberof protos
             * @classdesc Represents a Chaincode
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Chaincode(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Chaincode.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Chaincode;
    
            /**
             * Creates new Chaincode service using the specified rpc implementation.
             * @function create
             * @memberof protos.Chaincode
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Chaincode} RPC service. Useful where requests and/or responses are streamed.
             */
            Chaincode.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link protos.Chaincode#connect}.
             * @memberof protos.Chaincode
             * @typedef ConnectCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.ChaincodeMessage} [response] ChaincodeMessage
             */
    
            /**
             * Calls Connect.
             * @function connect
             * @memberof protos.Chaincode
             * @instance
             * @param {protos.IChaincodeMessage} request ChaincodeMessage message or plain object
             * @param {protos.Chaincode.ConnectCallback} callback Node-style callback called with the error, if any, and ChaincodeMessage
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Chaincode.prototype.connect = function connect(request, callback) {
                return this.rpcCall(connect, $root.protos.ChaincodeMessage, $root.protos.ChaincodeMessage, request, callback);
            }, "name", { value: "Connect" });
    
            /**
             * Calls Connect.
             * @function connect
             * @memberof protos.Chaincode
             * @instance
             * @param {protos.IChaincodeMessage} request ChaincodeMessage message or plain object
             * @returns {Promise<protos.ChaincodeMessage>} Promise
             * @variation 2
             */
    
            return Chaincode;
        })();
    
        protos.SignedProposal = (function() {
    
            /**
             * Properties of a SignedProposal.
             * @memberof protos
             * @interface ISignedProposal
             * @property {Uint8Array|null} [proposal_bytes] SignedProposal proposal_bytes
             * @property {Uint8Array|null} [signature] SignedProposal signature
             */
    
            /**
             * Constructs a new SignedProposal.
             * @memberof protos
             * @classdesc Represents a SignedProposal.
             * @implements ISignedProposal
             * @constructor
             * @param {protos.ISignedProposal=} [properties] Properties to set
             */
            function SignedProposal(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignedProposal proposal_bytes.
             * @member {Uint8Array} proposal_bytes
             * @memberof protos.SignedProposal
             * @instance
             */
            SignedProposal.prototype.proposal_bytes = $util.newBuffer([]);
    
            /**
             * SignedProposal signature.
             * @member {Uint8Array} signature
             * @memberof protos.SignedProposal
             * @instance
             */
            SignedProposal.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new SignedProposal instance using the specified properties.
             * @function create
             * @memberof protos.SignedProposal
             * @static
             * @param {protos.ISignedProposal=} [properties] Properties to set
             * @returns {protos.SignedProposal} SignedProposal instance
             */
            SignedProposal.create = function create(properties) {
                return new SignedProposal(properties);
            };
    
            /**
             * Encodes the specified SignedProposal message. Does not implicitly {@link protos.SignedProposal.verify|verify} messages.
             * @function encode
             * @memberof protos.SignedProposal
             * @static
             * @param {protos.ISignedProposal} message SignedProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedProposal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.proposal_bytes != null && Object.hasOwnProperty.call(message, "proposal_bytes"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.proposal_bytes);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified SignedProposal message, length delimited. Does not implicitly {@link protos.SignedProposal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.SignedProposal
             * @static
             * @param {protos.ISignedProposal} message SignedProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedProposal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedProposal message from the specified reader or buffer.
             * @function decode
             * @memberof protos.SignedProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.SignedProposal} SignedProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedProposal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.SignedProposal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.proposal_bytes = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignedProposal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.SignedProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.SignedProposal} SignedProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedProposal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedProposal message.
             * @function verify
             * @memberof protos.SignedProposal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignedProposal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.proposal_bytes != null && message.hasOwnProperty("proposal_bytes"))
                    if (!(message.proposal_bytes && typeof message.proposal_bytes.length === "number" || $util.isString(message.proposal_bytes)))
                        return "proposal_bytes: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a SignedProposal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.SignedProposal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.SignedProposal} SignedProposal
             */
            SignedProposal.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.SignedProposal)
                    return object;
                var message = new $root.protos.SignedProposal();
                if (object.proposal_bytes != null)
                    if (typeof object.proposal_bytes === "string")
                        $util.base64.decode(object.proposal_bytes, message.proposal_bytes = $util.newBuffer($util.base64.length(object.proposal_bytes)), 0);
                    else if (object.proposal_bytes.length)
                        message.proposal_bytes = object.proposal_bytes;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a SignedProposal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.SignedProposal
             * @static
             * @param {protos.SignedProposal} message SignedProposal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedProposal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.proposal_bytes = "";
                    else {
                        object.proposal_bytes = [];
                        if (options.bytes !== Array)
                            object.proposal_bytes = $util.newBuffer(object.proposal_bytes);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.proposal_bytes != null && message.hasOwnProperty("proposal_bytes"))
                    object.proposal_bytes = options.bytes === String ? $util.base64.encode(message.proposal_bytes, 0, message.proposal_bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposal_bytes) : message.proposal_bytes;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this SignedProposal to JSON.
             * @function toJSON
             * @memberof protos.SignedProposal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedProposal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedProposal;
        })();
    
        protos.Proposal = (function() {
    
            /**
             * Properties of a Proposal.
             * @memberof protos
             * @interface IProposal
             * @property {Uint8Array|null} [header] Proposal header
             * @property {Uint8Array|null} [payload] Proposal payload
             * @property {Uint8Array|null} [extension] Proposal extension
             */
    
            /**
             * Constructs a new Proposal.
             * @memberof protos
             * @classdesc Represents a Proposal.
             * @implements IProposal
             * @constructor
             * @param {protos.IProposal=} [properties] Properties to set
             */
            function Proposal(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Proposal header.
             * @member {Uint8Array} header
             * @memberof protos.Proposal
             * @instance
             */
            Proposal.prototype.header = $util.newBuffer([]);
    
            /**
             * Proposal payload.
             * @member {Uint8Array} payload
             * @memberof protos.Proposal
             * @instance
             */
            Proposal.prototype.payload = $util.newBuffer([]);
    
            /**
             * Proposal extension.
             * @member {Uint8Array} extension
             * @memberof protos.Proposal
             * @instance
             */
            Proposal.prototype.extension = $util.newBuffer([]);
    
            /**
             * Creates a new Proposal instance using the specified properties.
             * @function create
             * @memberof protos.Proposal
             * @static
             * @param {protos.IProposal=} [properties] Properties to set
             * @returns {protos.Proposal} Proposal instance
             */
            Proposal.create = function create(properties) {
                return new Proposal(properties);
            };
    
            /**
             * Encodes the specified Proposal message. Does not implicitly {@link protos.Proposal.verify|verify} messages.
             * @function encode
             * @memberof protos.Proposal
             * @static
             * @param {protos.IProposal} message Proposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Proposal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.header);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                if (message.extension != null && Object.hasOwnProperty.call(message, "extension"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.extension);
                return writer;
            };
    
            /**
             * Encodes the specified Proposal message, length delimited. Does not implicitly {@link protos.Proposal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.Proposal
             * @static
             * @param {protos.IProposal} message Proposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Proposal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Proposal message from the specified reader or buffer.
             * @function decode
             * @memberof protos.Proposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.Proposal} Proposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Proposal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Proposal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = reader.bytes();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    case 3:
                        message.extension = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Proposal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.Proposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.Proposal} Proposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Proposal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Proposal message.
             * @function verify
             * @memberof protos.Proposal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Proposal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header"))
                    if (!(message.header && typeof message.header.length === "number" || $util.isString(message.header)))
                        return "header: buffer expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.extension != null && message.hasOwnProperty("extension"))
                    if (!(message.extension && typeof message.extension.length === "number" || $util.isString(message.extension)))
                        return "extension: buffer expected";
                return null;
            };
    
            /**
             * Creates a Proposal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.Proposal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.Proposal} Proposal
             */
            Proposal.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.Proposal)
                    return object;
                var message = new $root.protos.Proposal();
                if (object.header != null)
                    if (typeof object.header === "string")
                        $util.base64.decode(object.header, message.header = $util.newBuffer($util.base64.length(object.header)), 0);
                    else if (object.header.length)
                        message.header = object.header;
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.extension != null)
                    if (typeof object.extension === "string")
                        $util.base64.decode(object.extension, message.extension = $util.newBuffer($util.base64.length(object.extension)), 0);
                    else if (object.extension.length)
                        message.extension = object.extension;
                return message;
            };
    
            /**
             * Creates a plain object from a Proposal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.Proposal
             * @static
             * @param {protos.Proposal} message Proposal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Proposal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.header = "";
                    else {
                        object.header = [];
                        if (options.bytes !== Array)
                            object.header = $util.newBuffer(object.header);
                    }
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.extension = "";
                    else {
                        object.extension = [];
                        if (options.bytes !== Array)
                            object.extension = $util.newBuffer(object.extension);
                    }
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = options.bytes === String ? $util.base64.encode(message.header, 0, message.header.length) : options.bytes === Array ? Array.prototype.slice.call(message.header) : message.header;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.extension != null && message.hasOwnProperty("extension"))
                    object.extension = options.bytes === String ? $util.base64.encode(message.extension, 0, message.extension.length) : options.bytes === Array ? Array.prototype.slice.call(message.extension) : message.extension;
                return object;
            };
    
            /**
             * Converts this Proposal to JSON.
             * @function toJSON
             * @memberof protos.Proposal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Proposal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Proposal;
        })();
    
        protos.ChaincodeHeaderExtension = (function() {
    
            /**
             * Properties of a ChaincodeHeaderExtension.
             * @memberof protos
             * @interface IChaincodeHeaderExtension
             * @property {protos.IChaincodeID|null} [chaincode_id] ChaincodeHeaderExtension chaincode_id
             */
    
            /**
             * Constructs a new ChaincodeHeaderExtension.
             * @memberof protos
             * @classdesc Represents a ChaincodeHeaderExtension.
             * @implements IChaincodeHeaderExtension
             * @constructor
             * @param {protos.IChaincodeHeaderExtension=} [properties] Properties to set
             */
            function ChaincodeHeaderExtension(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeHeaderExtension chaincode_id.
             * @member {protos.IChaincodeID|null|undefined} chaincode_id
             * @memberof protos.ChaincodeHeaderExtension
             * @instance
             */
            ChaincodeHeaderExtension.prototype.chaincode_id = null;
    
            /**
             * Creates a new ChaincodeHeaderExtension instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {protos.IChaincodeHeaderExtension=} [properties] Properties to set
             * @returns {protos.ChaincodeHeaderExtension} ChaincodeHeaderExtension instance
             */
            ChaincodeHeaderExtension.create = function create(properties) {
                return new ChaincodeHeaderExtension(properties);
            };
    
            /**
             * Encodes the specified ChaincodeHeaderExtension message. Does not implicitly {@link protos.ChaincodeHeaderExtension.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {protos.IChaincodeHeaderExtension} message ChaincodeHeaderExtension message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeHeaderExtension.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_id != null && Object.hasOwnProperty.call(message, "chaincode_id"))
                    $root.protos.ChaincodeID.encode(message.chaincode_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeHeaderExtension message, length delimited. Does not implicitly {@link protos.ChaincodeHeaderExtension.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {protos.IChaincodeHeaderExtension} message ChaincodeHeaderExtension message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeHeaderExtension.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeHeaderExtension message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeHeaderExtension} ChaincodeHeaderExtension
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeHeaderExtension.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeHeaderExtension();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.chaincode_id = $root.protos.ChaincodeID.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeHeaderExtension message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeHeaderExtension} ChaincodeHeaderExtension
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeHeaderExtension.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeHeaderExtension message.
             * @function verify
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeHeaderExtension.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_id != null && message.hasOwnProperty("chaincode_id")) {
                    var error = $root.protos.ChaincodeID.verify(message.chaincode_id);
                    if (error)
                        return "chaincode_id." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeHeaderExtension message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeHeaderExtension} ChaincodeHeaderExtension
             */
            ChaincodeHeaderExtension.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeHeaderExtension)
                    return object;
                var message = new $root.protos.ChaincodeHeaderExtension();
                if (object.chaincode_id != null) {
                    if (typeof object.chaincode_id !== "object")
                        throw TypeError(".protos.ChaincodeHeaderExtension.chaincode_id: object expected");
                    message.chaincode_id = $root.protos.ChaincodeID.fromObject(object.chaincode_id);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeHeaderExtension message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {protos.ChaincodeHeaderExtension} message ChaincodeHeaderExtension
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeHeaderExtension.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chaincode_id = null;
                if (message.chaincode_id != null && message.hasOwnProperty("chaincode_id"))
                    object.chaincode_id = $root.protos.ChaincodeID.toObject(message.chaincode_id, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeHeaderExtension to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeHeaderExtension
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeHeaderExtension.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeHeaderExtension;
        })();
    
        protos.ChaincodeProposalPayload = (function() {
    
            /**
             * Properties of a ChaincodeProposalPayload.
             * @memberof protos
             * @interface IChaincodeProposalPayload
             * @property {Uint8Array|null} [input] ChaincodeProposalPayload input
             * @property {Object.<string,Uint8Array>|null} [TransientMap] ChaincodeProposalPayload TransientMap
             */
    
            /**
             * Constructs a new ChaincodeProposalPayload.
             * @memberof protos
             * @classdesc Represents a ChaincodeProposalPayload.
             * @implements IChaincodeProposalPayload
             * @constructor
             * @param {protos.IChaincodeProposalPayload=} [properties] Properties to set
             */
            function ChaincodeProposalPayload(properties) {
                this.TransientMap = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeProposalPayload input.
             * @member {Uint8Array} input
             * @memberof protos.ChaincodeProposalPayload
             * @instance
             */
            ChaincodeProposalPayload.prototype.input = $util.newBuffer([]);
    
            /**
             * ChaincodeProposalPayload TransientMap.
             * @member {Object.<string,Uint8Array>} TransientMap
             * @memberof protos.ChaincodeProposalPayload
             * @instance
             */
            ChaincodeProposalPayload.prototype.TransientMap = $util.emptyObject;
    
            /**
             * Creates a new ChaincodeProposalPayload instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {protos.IChaincodeProposalPayload=} [properties] Properties to set
             * @returns {protos.ChaincodeProposalPayload} ChaincodeProposalPayload instance
             */
            ChaincodeProposalPayload.create = function create(properties) {
                return new ChaincodeProposalPayload(properties);
            };
    
            /**
             * Encodes the specified ChaincodeProposalPayload message. Does not implicitly {@link protos.ChaincodeProposalPayload.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {protos.IChaincodeProposalPayload} message ChaincodeProposalPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeProposalPayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.input);
                if (message.TransientMap != null && Object.hasOwnProperty.call(message, "TransientMap"))
                    for (var keys = Object.keys(message.TransientMap), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.TransientMap[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeProposalPayload message, length delimited. Does not implicitly {@link protos.ChaincodeProposalPayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {protos.IChaincodeProposalPayload} message ChaincodeProposalPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeProposalPayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeProposalPayload message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeProposalPayload} ChaincodeProposalPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeProposalPayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeProposalPayload(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.input = reader.bytes();
                        break;
                    case 2:
                        if (message.TransientMap === $util.emptyObject)
                            message.TransientMap = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = [];
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.TransientMap[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeProposalPayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeProposalPayload} ChaincodeProposalPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeProposalPayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeProposalPayload message.
             * @function verify
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeProposalPayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.input != null && message.hasOwnProperty("input"))
                    if (!(message.input && typeof message.input.length === "number" || $util.isString(message.input)))
                        return "input: buffer expected";
                if (message.TransientMap != null && message.hasOwnProperty("TransientMap")) {
                    if (!$util.isObject(message.TransientMap))
                        return "TransientMap: object expected";
                    var key = Object.keys(message.TransientMap);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.TransientMap[key[i]] && typeof message.TransientMap[key[i]].length === "number" || $util.isString(message.TransientMap[key[i]])))
                            return "TransientMap: buffer{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeProposalPayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeProposalPayload} ChaincodeProposalPayload
             */
            ChaincodeProposalPayload.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeProposalPayload)
                    return object;
                var message = new $root.protos.ChaincodeProposalPayload();
                if (object.input != null)
                    if (typeof object.input === "string")
                        $util.base64.decode(object.input, message.input = $util.newBuffer($util.base64.length(object.input)), 0);
                    else if (object.input.length)
                        message.input = object.input;
                if (object.TransientMap) {
                    if (typeof object.TransientMap !== "object")
                        throw TypeError(".protos.ChaincodeProposalPayload.TransientMap: object expected");
                    message.TransientMap = {};
                    for (var keys = Object.keys(object.TransientMap), i = 0; i < keys.length; ++i)
                        if (typeof object.TransientMap[keys[i]] === "string")
                            $util.base64.decode(object.TransientMap[keys[i]], message.TransientMap[keys[i]] = $util.newBuffer($util.base64.length(object.TransientMap[keys[i]])), 0);
                        else if (object.TransientMap[keys[i]].length)
                            message.TransientMap[keys[i]] = object.TransientMap[keys[i]];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeProposalPayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {protos.ChaincodeProposalPayload} message ChaincodeProposalPayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeProposalPayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.TransientMap = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.input = "";
                    else {
                        object.input = [];
                        if (options.bytes !== Array)
                            object.input = $util.newBuffer(object.input);
                    }
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = options.bytes === String ? $util.base64.encode(message.input, 0, message.input.length) : options.bytes === Array ? Array.prototype.slice.call(message.input) : message.input;
                var keys2;
                if (message.TransientMap && (keys2 = Object.keys(message.TransientMap)).length) {
                    object.TransientMap = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.TransientMap[keys2[j]] = options.bytes === String ? $util.base64.encode(message.TransientMap[keys2[j]], 0, message.TransientMap[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.TransientMap[keys2[j]]) : message.TransientMap[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeProposalPayload to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeProposalPayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeProposalPayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeProposalPayload;
        })();
    
        protos.ChaincodeAction = (function() {
    
            /**
             * Properties of a ChaincodeAction.
             * @memberof protos
             * @interface IChaincodeAction
             * @property {Uint8Array|null} [results] ChaincodeAction results
             * @property {Uint8Array|null} [events] ChaincodeAction events
             * @property {protos.IResponse|null} [response] ChaincodeAction response
             * @property {protos.IChaincodeID|null} [chaincode_id] ChaincodeAction chaincode_id
             */
    
            /**
             * Constructs a new ChaincodeAction.
             * @memberof protos
             * @classdesc Represents a ChaincodeAction.
             * @implements IChaincodeAction
             * @constructor
             * @param {protos.IChaincodeAction=} [properties] Properties to set
             */
            function ChaincodeAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeAction results.
             * @member {Uint8Array} results
             * @memberof protos.ChaincodeAction
             * @instance
             */
            ChaincodeAction.prototype.results = $util.newBuffer([]);
    
            /**
             * ChaincodeAction events.
             * @member {Uint8Array} events
             * @memberof protos.ChaincodeAction
             * @instance
             */
            ChaincodeAction.prototype.events = $util.newBuffer([]);
    
            /**
             * ChaincodeAction response.
             * @member {protos.IResponse|null|undefined} response
             * @memberof protos.ChaincodeAction
             * @instance
             */
            ChaincodeAction.prototype.response = null;
    
            /**
             * ChaincodeAction chaincode_id.
             * @member {protos.IChaincodeID|null|undefined} chaincode_id
             * @memberof protos.ChaincodeAction
             * @instance
             */
            ChaincodeAction.prototype.chaincode_id = null;
    
            /**
             * Creates a new ChaincodeAction instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeAction
             * @static
             * @param {protos.IChaincodeAction=} [properties] Properties to set
             * @returns {protos.ChaincodeAction} ChaincodeAction instance
             */
            ChaincodeAction.create = function create(properties) {
                return new ChaincodeAction(properties);
            };
    
            /**
             * Encodes the specified ChaincodeAction message. Does not implicitly {@link protos.ChaincodeAction.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeAction
             * @static
             * @param {protos.IChaincodeAction} message ChaincodeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.results != null && Object.hasOwnProperty.call(message, "results"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.results);
                if (message.events != null && Object.hasOwnProperty.call(message, "events"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.events);
                if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                    $root.protos.Response.encode(message.response, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.chaincode_id != null && Object.hasOwnProperty.call(message, "chaincode_id"))
                    $root.protos.ChaincodeID.encode(message.chaincode_id, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeAction message, length delimited. Does not implicitly {@link protos.ChaincodeAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeAction
             * @static
             * @param {protos.IChaincodeAction} message ChaincodeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeAction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeAction} ChaincodeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.results = reader.bytes();
                        break;
                    case 2:
                        message.events = reader.bytes();
                        break;
                    case 3:
                        message.response = $root.protos.Response.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.chaincode_id = $root.protos.ChaincodeID.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeAction} ChaincodeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeAction message.
             * @function verify
             * @memberof protos.ChaincodeAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.results != null && message.hasOwnProperty("results"))
                    if (!(message.results && typeof message.results.length === "number" || $util.isString(message.results)))
                        return "results: buffer expected";
                if (message.events != null && message.hasOwnProperty("events"))
                    if (!(message.events && typeof message.events.length === "number" || $util.isString(message.events)))
                        return "events: buffer expected";
                if (message.response != null && message.hasOwnProperty("response")) {
                    var error = $root.protos.Response.verify(message.response);
                    if (error)
                        return "response." + error;
                }
                if (message.chaincode_id != null && message.hasOwnProperty("chaincode_id")) {
                    var error = $root.protos.ChaincodeID.verify(message.chaincode_id);
                    if (error)
                        return "chaincode_id." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeAction} ChaincodeAction
             */
            ChaincodeAction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeAction)
                    return object;
                var message = new $root.protos.ChaincodeAction();
                if (object.results != null)
                    if (typeof object.results === "string")
                        $util.base64.decode(object.results, message.results = $util.newBuffer($util.base64.length(object.results)), 0);
                    else if (object.results.length)
                        message.results = object.results;
                if (object.events != null)
                    if (typeof object.events === "string")
                        $util.base64.decode(object.events, message.events = $util.newBuffer($util.base64.length(object.events)), 0);
                    else if (object.events.length)
                        message.events = object.events;
                if (object.response != null) {
                    if (typeof object.response !== "object")
                        throw TypeError(".protos.ChaincodeAction.response: object expected");
                    message.response = $root.protos.Response.fromObject(object.response);
                }
                if (object.chaincode_id != null) {
                    if (typeof object.chaincode_id !== "object")
                        throw TypeError(".protos.ChaincodeAction.chaincode_id: object expected");
                    message.chaincode_id = $root.protos.ChaincodeID.fromObject(object.chaincode_id);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeAction
             * @static
             * @param {protos.ChaincodeAction} message ChaincodeAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.results = "";
                    else {
                        object.results = [];
                        if (options.bytes !== Array)
                            object.results = $util.newBuffer(object.results);
                    }
                    if (options.bytes === String)
                        object.events = "";
                    else {
                        object.events = [];
                        if (options.bytes !== Array)
                            object.events = $util.newBuffer(object.events);
                    }
                    object.response = null;
                    object.chaincode_id = null;
                }
                if (message.results != null && message.hasOwnProperty("results"))
                    object.results = options.bytes === String ? $util.base64.encode(message.results, 0, message.results.length) : options.bytes === Array ? Array.prototype.slice.call(message.results) : message.results;
                if (message.events != null && message.hasOwnProperty("events"))
                    object.events = options.bytes === String ? $util.base64.encode(message.events, 0, message.events.length) : options.bytes === Array ? Array.prototype.slice.call(message.events) : message.events;
                if (message.response != null && message.hasOwnProperty("response"))
                    object.response = $root.protos.Response.toObject(message.response, options);
                if (message.chaincode_id != null && message.hasOwnProperty("chaincode_id"))
                    object.chaincode_id = $root.protos.ChaincodeID.toObject(message.chaincode_id, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeAction to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeAction;
        })();
    
        protos.ChaincodeID = (function() {
    
            /**
             * Properties of a ChaincodeID.
             * @memberof protos
             * @interface IChaincodeID
             * @property {string|null} [path] ChaincodeID path
             * @property {string|null} [name] ChaincodeID name
             * @property {string|null} [version] ChaincodeID version
             */
    
            /**
             * Constructs a new ChaincodeID.
             * @memberof protos
             * @classdesc Represents a ChaincodeID.
             * @implements IChaincodeID
             * @constructor
             * @param {protos.IChaincodeID=} [properties] Properties to set
             */
            function ChaincodeID(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeID path.
             * @member {string} path
             * @memberof protos.ChaincodeID
             * @instance
             */
            ChaincodeID.prototype.path = "";
    
            /**
             * ChaincodeID name.
             * @member {string} name
             * @memberof protos.ChaincodeID
             * @instance
             */
            ChaincodeID.prototype.name = "";
    
            /**
             * ChaincodeID version.
             * @member {string} version
             * @memberof protos.ChaincodeID
             * @instance
             */
            ChaincodeID.prototype.version = "";
    
            /**
             * Creates a new ChaincodeID instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeID
             * @static
             * @param {protos.IChaincodeID=} [properties] Properties to set
             * @returns {protos.ChaincodeID} ChaincodeID instance
             */
            ChaincodeID.create = function create(properties) {
                return new ChaincodeID(properties);
            };
    
            /**
             * Encodes the specified ChaincodeID message. Does not implicitly {@link protos.ChaincodeID.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeID
             * @static
             * @param {protos.IChaincodeID} message ChaincodeID message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeID.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeID message, length delimited. Does not implicitly {@link protos.ChaincodeID.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeID
             * @static
             * @param {protos.IChaincodeID} message ChaincodeID message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeID.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeID message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeID
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeID} ChaincodeID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeID.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeID();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.version = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeID message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeID
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeID} ChaincodeID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeID.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeID message.
             * @function verify
             * @memberof protos.ChaincodeID
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeID.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeID message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeID
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeID} ChaincodeID
             */
            ChaincodeID.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeID)
                    return object;
                var message = new $root.protos.ChaincodeID();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeID message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeID
             * @static
             * @param {protos.ChaincodeID} message ChaincodeID
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeID.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.name = "";
                    object.version = "";
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };
    
            /**
             * Converts this ChaincodeID to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeID
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeID.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeID;
        })();
    
        protos.ChaincodeInput = (function() {
    
            /**
             * Properties of a ChaincodeInput.
             * @memberof protos
             * @interface IChaincodeInput
             * @property {Array.<Uint8Array>|null} [args] ChaincodeInput args
             * @property {Object.<string,Uint8Array>|null} [decorations] ChaincodeInput decorations
             * @property {boolean|null} [is_init] ChaincodeInput is_init
             */
    
            /**
             * Constructs a new ChaincodeInput.
             * @memberof protos
             * @classdesc Represents a ChaincodeInput.
             * @implements IChaincodeInput
             * @constructor
             * @param {protos.IChaincodeInput=} [properties] Properties to set
             */
            function ChaincodeInput(properties) {
                this.args = [];
                this.decorations = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeInput args.
             * @member {Array.<Uint8Array>} args
             * @memberof protos.ChaincodeInput
             * @instance
             */
            ChaincodeInput.prototype.args = $util.emptyArray;
    
            /**
             * ChaincodeInput decorations.
             * @member {Object.<string,Uint8Array>} decorations
             * @memberof protos.ChaincodeInput
             * @instance
             */
            ChaincodeInput.prototype.decorations = $util.emptyObject;
    
            /**
             * ChaincodeInput is_init.
             * @member {boolean} is_init
             * @memberof protos.ChaincodeInput
             * @instance
             */
            ChaincodeInput.prototype.is_init = false;
    
            /**
             * Creates a new ChaincodeInput instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeInput
             * @static
             * @param {protos.IChaincodeInput=} [properties] Properties to set
             * @returns {protos.ChaincodeInput} ChaincodeInput instance
             */
            ChaincodeInput.create = function create(properties) {
                return new ChaincodeInput(properties);
            };
    
            /**
             * Encodes the specified ChaincodeInput message. Does not implicitly {@link protos.ChaincodeInput.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeInput
             * @static
             * @param {protos.IChaincodeInput} message ChaincodeInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.args != null && message.args.length)
                    for (var i = 0; i < message.args.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.args[i]);
                if (message.decorations != null && Object.hasOwnProperty.call(message, "decorations"))
                    for (var keys = Object.keys(message.decorations), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.decorations[keys[i]]).ldelim();
                if (message.is_init != null && Object.hasOwnProperty.call(message, "is_init"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_init);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeInput message, length delimited. Does not implicitly {@link protos.ChaincodeInput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeInput
             * @static
             * @param {protos.IChaincodeInput} message ChaincodeInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeInput message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeInput} ChaincodeInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeInput(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.args && message.args.length))
                            message.args = [];
                        message.args.push(reader.bytes());
                        break;
                    case 2:
                        if (message.decorations === $util.emptyObject)
                            message.decorations = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = [];
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.decorations[key] = value;
                        break;
                    case 3:
                        message.is_init = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeInput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeInput} ChaincodeInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeInput message.
             * @function verify
             * @memberof protos.ChaincodeInput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeInput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.args != null && message.hasOwnProperty("args")) {
                    if (!Array.isArray(message.args))
                        return "args: array expected";
                    for (var i = 0; i < message.args.length; ++i)
                        if (!(message.args[i] && typeof message.args[i].length === "number" || $util.isString(message.args[i])))
                            return "args: buffer[] expected";
                }
                if (message.decorations != null && message.hasOwnProperty("decorations")) {
                    if (!$util.isObject(message.decorations))
                        return "decorations: object expected";
                    var key = Object.keys(message.decorations);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.decorations[key[i]] && typeof message.decorations[key[i]].length === "number" || $util.isString(message.decorations[key[i]])))
                            return "decorations: buffer{k:string} expected";
                }
                if (message.is_init != null && message.hasOwnProperty("is_init"))
                    if (typeof message.is_init !== "boolean")
                        return "is_init: boolean expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeInput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeInput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeInput} ChaincodeInput
             */
            ChaincodeInput.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeInput)
                    return object;
                var message = new $root.protos.ChaincodeInput();
                if (object.args) {
                    if (!Array.isArray(object.args))
                        throw TypeError(".protos.ChaincodeInput.args: array expected");
                    message.args = [];
                    for (var i = 0; i < object.args.length; ++i)
                        if (typeof object.args[i] === "string")
                            $util.base64.decode(object.args[i], message.args[i] = $util.newBuffer($util.base64.length(object.args[i])), 0);
                        else if (object.args[i].length)
                            message.args[i] = object.args[i];
                }
                if (object.decorations) {
                    if (typeof object.decorations !== "object")
                        throw TypeError(".protos.ChaincodeInput.decorations: object expected");
                    message.decorations = {};
                    for (var keys = Object.keys(object.decorations), i = 0; i < keys.length; ++i)
                        if (typeof object.decorations[keys[i]] === "string")
                            $util.base64.decode(object.decorations[keys[i]], message.decorations[keys[i]] = $util.newBuffer($util.base64.length(object.decorations[keys[i]])), 0);
                        else if (object.decorations[keys[i]].length)
                            message.decorations[keys[i]] = object.decorations[keys[i]];
                }
                if (object.is_init != null)
                    message.is_init = Boolean(object.is_init);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeInput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeInput
             * @static
             * @param {protos.ChaincodeInput} message ChaincodeInput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeInput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.args = [];
                if (options.objects || options.defaults)
                    object.decorations = {};
                if (options.defaults)
                    object.is_init = false;
                if (message.args && message.args.length) {
                    object.args = [];
                    for (var j = 0; j < message.args.length; ++j)
                        object.args[j] = options.bytes === String ? $util.base64.encode(message.args[j], 0, message.args[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.args[j]) : message.args[j];
                }
                var keys2;
                if (message.decorations && (keys2 = Object.keys(message.decorations)).length) {
                    object.decorations = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.decorations[keys2[j]] = options.bytes === String ? $util.base64.encode(message.decorations[keys2[j]], 0, message.decorations[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.decorations[keys2[j]]) : message.decorations[keys2[j]];
                }
                if (message.is_init != null && message.hasOwnProperty("is_init"))
                    object.is_init = message.is_init;
                return object;
            };
    
            /**
             * Converts this ChaincodeInput to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeInput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeInput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeInput;
        })();
    
        protos.ChaincodeSpec = (function() {
    
            /**
             * Properties of a ChaincodeSpec.
             * @memberof protos
             * @interface IChaincodeSpec
             * @property {protos.ChaincodeSpec.Type|null} [type] ChaincodeSpec type
             * @property {protos.IChaincodeID|null} [chaincode_id] ChaincodeSpec chaincode_id
             * @property {protos.IChaincodeInput|null} [input] ChaincodeSpec input
             * @property {number|null} [timeout] ChaincodeSpec timeout
             */
    
            /**
             * Constructs a new ChaincodeSpec.
             * @memberof protos
             * @classdesc Represents a ChaincodeSpec.
             * @implements IChaincodeSpec
             * @constructor
             * @param {protos.IChaincodeSpec=} [properties] Properties to set
             */
            function ChaincodeSpec(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeSpec type.
             * @member {protos.ChaincodeSpec.Type} type
             * @memberof protos.ChaincodeSpec
             * @instance
             */
            ChaincodeSpec.prototype.type = 0;
    
            /**
             * ChaincodeSpec chaincode_id.
             * @member {protos.IChaincodeID|null|undefined} chaincode_id
             * @memberof protos.ChaincodeSpec
             * @instance
             */
            ChaincodeSpec.prototype.chaincode_id = null;
    
            /**
             * ChaincodeSpec input.
             * @member {protos.IChaincodeInput|null|undefined} input
             * @memberof protos.ChaincodeSpec
             * @instance
             */
            ChaincodeSpec.prototype.input = null;
    
            /**
             * ChaincodeSpec timeout.
             * @member {number} timeout
             * @memberof protos.ChaincodeSpec
             * @instance
             */
            ChaincodeSpec.prototype.timeout = 0;
    
            /**
             * Creates a new ChaincodeSpec instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {protos.IChaincodeSpec=} [properties] Properties to set
             * @returns {protos.ChaincodeSpec} ChaincodeSpec instance
             */
            ChaincodeSpec.create = function create(properties) {
                return new ChaincodeSpec(properties);
            };
    
            /**
             * Encodes the specified ChaincodeSpec message. Does not implicitly {@link protos.ChaincodeSpec.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {protos.IChaincodeSpec} message ChaincodeSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.chaincode_id != null && Object.hasOwnProperty.call(message, "chaincode_id"))
                    $root.protos.ChaincodeID.encode(message.chaincode_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    $root.protos.ChaincodeInput.encode(message.input, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timeout);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeSpec message, length delimited. Does not implicitly {@link protos.ChaincodeSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {protos.IChaincodeSpec} message ChaincodeSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeSpec message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeSpec} ChaincodeSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.chaincode_id = $root.protos.ChaincodeID.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.input = $root.protos.ChaincodeInput.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.timeout = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeSpec} ChaincodeSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeSpec message.
             * @function verify
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.chaincode_id != null && message.hasOwnProperty("chaincode_id")) {
                    var error = $root.protos.ChaincodeID.verify(message.chaincode_id);
                    if (error)
                        return "chaincode_id." + error;
                }
                if (message.input != null && message.hasOwnProperty("input")) {
                    var error = $root.protos.ChaincodeInput.verify(message.input);
                    if (error)
                        return "input." + error;
                }
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (!$util.isInteger(message.timeout))
                        return "timeout: integer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeSpec} ChaincodeSpec
             */
            ChaincodeSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeSpec)
                    return object;
                var message = new $root.protos.ChaincodeSpec();
                switch (object.type) {
                case "UNDEFINED":
                case 0:
                    message.type = 0;
                    break;
                case "GOLANG":
                case 1:
                    message.type = 1;
                    break;
                case "NODE":
                case 2:
                    message.type = 2;
                    break;
                case "CAR":
                case 3:
                    message.type = 3;
                    break;
                case "JAVA":
                case 4:
                    message.type = 4;
                    break;
                }
                if (object.chaincode_id != null) {
                    if (typeof object.chaincode_id !== "object")
                        throw TypeError(".protos.ChaincodeSpec.chaincode_id: object expected");
                    message.chaincode_id = $root.protos.ChaincodeID.fromObject(object.chaincode_id);
                }
                if (object.input != null) {
                    if (typeof object.input !== "object")
                        throw TypeError(".protos.ChaincodeSpec.input: object expected");
                    message.input = $root.protos.ChaincodeInput.fromObject(object.input);
                }
                if (object.timeout != null)
                    message.timeout = object.timeout | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {protos.ChaincodeSpec} message ChaincodeSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNDEFINED" : 0;
                    object.chaincode_id = null;
                    object.input = null;
                    object.timeout = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.ChaincodeSpec.Type[message.type] : message.type;
                if (message.chaincode_id != null && message.hasOwnProperty("chaincode_id"))
                    object.chaincode_id = $root.protos.ChaincodeID.toObject(message.chaincode_id, options);
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = $root.protos.ChaincodeInput.toObject(message.input, options);
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    object.timeout = message.timeout;
                return object;
            };
    
            /**
             * Converts this ChaincodeSpec to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Type enum.
             * @name protos.ChaincodeSpec.Type
             * @enum {number}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} GOLANG=1 GOLANG value
             * @property {number} NODE=2 NODE value
             * @property {number} CAR=3 CAR value
             * @property {number} JAVA=4 JAVA value
             */
            ChaincodeSpec.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "GOLANG"] = 1;
                values[valuesById[2] = "NODE"] = 2;
                values[valuesById[3] = "CAR"] = 3;
                values[valuesById[4] = "JAVA"] = 4;
                return values;
            })();
    
            return ChaincodeSpec;
        })();
    
        protos.ChaincodeDeploymentSpec = (function() {
    
            /**
             * Properties of a ChaincodeDeploymentSpec.
             * @memberof protos
             * @interface IChaincodeDeploymentSpec
             * @property {protos.IChaincodeSpec|null} [chaincode_spec] ChaincodeDeploymentSpec chaincode_spec
             * @property {Uint8Array|null} [code_package] ChaincodeDeploymentSpec code_package
             */
    
            /**
             * Constructs a new ChaincodeDeploymentSpec.
             * @memberof protos
             * @classdesc Represents a ChaincodeDeploymentSpec.
             * @implements IChaincodeDeploymentSpec
             * @constructor
             * @param {protos.IChaincodeDeploymentSpec=} [properties] Properties to set
             */
            function ChaincodeDeploymentSpec(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeDeploymentSpec chaincode_spec.
             * @member {protos.IChaincodeSpec|null|undefined} chaincode_spec
             * @memberof protos.ChaincodeDeploymentSpec
             * @instance
             */
            ChaincodeDeploymentSpec.prototype.chaincode_spec = null;
    
            /**
             * ChaincodeDeploymentSpec code_package.
             * @member {Uint8Array} code_package
             * @memberof protos.ChaincodeDeploymentSpec
             * @instance
             */
            ChaincodeDeploymentSpec.prototype.code_package = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeDeploymentSpec instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {protos.IChaincodeDeploymentSpec=} [properties] Properties to set
             * @returns {protos.ChaincodeDeploymentSpec} ChaincodeDeploymentSpec instance
             */
            ChaincodeDeploymentSpec.create = function create(properties) {
                return new ChaincodeDeploymentSpec(properties);
            };
    
            /**
             * Encodes the specified ChaincodeDeploymentSpec message. Does not implicitly {@link protos.ChaincodeDeploymentSpec.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {protos.IChaincodeDeploymentSpec} message ChaincodeDeploymentSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeDeploymentSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_spec != null && Object.hasOwnProperty.call(message, "chaincode_spec"))
                    $root.protos.ChaincodeSpec.encode(message.chaincode_spec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.code_package != null && Object.hasOwnProperty.call(message, "code_package"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.code_package);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeDeploymentSpec message, length delimited. Does not implicitly {@link protos.ChaincodeDeploymentSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {protos.IChaincodeDeploymentSpec} message ChaincodeDeploymentSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeDeploymentSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeDeploymentSpec message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeDeploymentSpec} ChaincodeDeploymentSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeDeploymentSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeDeploymentSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_spec = $root.protos.ChaincodeSpec.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.code_package = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeDeploymentSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeDeploymentSpec} ChaincodeDeploymentSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeDeploymentSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeDeploymentSpec message.
             * @function verify
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeDeploymentSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_spec != null && message.hasOwnProperty("chaincode_spec")) {
                    var error = $root.protos.ChaincodeSpec.verify(message.chaincode_spec);
                    if (error)
                        return "chaincode_spec." + error;
                }
                if (message.code_package != null && message.hasOwnProperty("code_package"))
                    if (!(message.code_package && typeof message.code_package.length === "number" || $util.isString(message.code_package)))
                        return "code_package: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeDeploymentSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeDeploymentSpec} ChaincodeDeploymentSpec
             */
            ChaincodeDeploymentSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeDeploymentSpec)
                    return object;
                var message = new $root.protos.ChaincodeDeploymentSpec();
                if (object.chaincode_spec != null) {
                    if (typeof object.chaincode_spec !== "object")
                        throw TypeError(".protos.ChaincodeDeploymentSpec.chaincode_spec: object expected");
                    message.chaincode_spec = $root.protos.ChaincodeSpec.fromObject(object.chaincode_spec);
                }
                if (object.code_package != null)
                    if (typeof object.code_package === "string")
                        $util.base64.decode(object.code_package, message.code_package = $util.newBuffer($util.base64.length(object.code_package)), 0);
                    else if (object.code_package.length)
                        message.code_package = object.code_package;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeDeploymentSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {protos.ChaincodeDeploymentSpec} message ChaincodeDeploymentSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeDeploymentSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.chaincode_spec = null;
                    if (options.bytes === String)
                        object.code_package = "";
                    else {
                        object.code_package = [];
                        if (options.bytes !== Array)
                            object.code_package = $util.newBuffer(object.code_package);
                    }
                }
                if (message.chaincode_spec != null && message.hasOwnProperty("chaincode_spec"))
                    object.chaincode_spec = $root.protos.ChaincodeSpec.toObject(message.chaincode_spec, options);
                if (message.code_package != null && message.hasOwnProperty("code_package"))
                    object.code_package = options.bytes === String ? $util.base64.encode(message.code_package, 0, message.code_package.length) : options.bytes === Array ? Array.prototype.slice.call(message.code_package) : message.code_package;
                return object;
            };
    
            /**
             * Converts this ChaincodeDeploymentSpec to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeDeploymentSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeDeploymentSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeDeploymentSpec;
        })();
    
        protos.ChaincodeInvocationSpec = (function() {
    
            /**
             * Properties of a ChaincodeInvocationSpec.
             * @memberof protos
             * @interface IChaincodeInvocationSpec
             * @property {protos.IChaincodeSpec|null} [chaincode_spec] ChaincodeInvocationSpec chaincode_spec
             */
    
            /**
             * Constructs a new ChaincodeInvocationSpec.
             * @memberof protos
             * @classdesc Represents a ChaincodeInvocationSpec.
             * @implements IChaincodeInvocationSpec
             * @constructor
             * @param {protos.IChaincodeInvocationSpec=} [properties] Properties to set
             */
            function ChaincodeInvocationSpec(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeInvocationSpec chaincode_spec.
             * @member {protos.IChaincodeSpec|null|undefined} chaincode_spec
             * @memberof protos.ChaincodeInvocationSpec
             * @instance
             */
            ChaincodeInvocationSpec.prototype.chaincode_spec = null;
    
            /**
             * Creates a new ChaincodeInvocationSpec instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {protos.IChaincodeInvocationSpec=} [properties] Properties to set
             * @returns {protos.ChaincodeInvocationSpec} ChaincodeInvocationSpec instance
             */
            ChaincodeInvocationSpec.create = function create(properties) {
                return new ChaincodeInvocationSpec(properties);
            };
    
            /**
             * Encodes the specified ChaincodeInvocationSpec message. Does not implicitly {@link protos.ChaincodeInvocationSpec.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {protos.IChaincodeInvocationSpec} message ChaincodeInvocationSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInvocationSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_spec != null && Object.hasOwnProperty.call(message, "chaincode_spec"))
                    $root.protos.ChaincodeSpec.encode(message.chaincode_spec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeInvocationSpec message, length delimited. Does not implicitly {@link protos.ChaincodeInvocationSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {protos.IChaincodeInvocationSpec} message ChaincodeInvocationSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInvocationSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeInvocationSpec message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeInvocationSpec} ChaincodeInvocationSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInvocationSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeInvocationSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_spec = $root.protos.ChaincodeSpec.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeInvocationSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeInvocationSpec} ChaincodeInvocationSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInvocationSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeInvocationSpec message.
             * @function verify
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeInvocationSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_spec != null && message.hasOwnProperty("chaincode_spec")) {
                    var error = $root.protos.ChaincodeSpec.verify(message.chaincode_spec);
                    if (error)
                        return "chaincode_spec." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeInvocationSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeInvocationSpec} ChaincodeInvocationSpec
             */
            ChaincodeInvocationSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeInvocationSpec)
                    return object;
                var message = new $root.protos.ChaincodeInvocationSpec();
                if (object.chaincode_spec != null) {
                    if (typeof object.chaincode_spec !== "object")
                        throw TypeError(".protos.ChaincodeInvocationSpec.chaincode_spec: object expected");
                    message.chaincode_spec = $root.protos.ChaincodeSpec.fromObject(object.chaincode_spec);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeInvocationSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {protos.ChaincodeInvocationSpec} message ChaincodeInvocationSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeInvocationSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chaincode_spec = null;
                if (message.chaincode_spec != null && message.hasOwnProperty("chaincode_spec"))
                    object.chaincode_spec = $root.protos.ChaincodeSpec.toObject(message.chaincode_spec, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeInvocationSpec to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeInvocationSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeInvocationSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeInvocationSpec;
        })();
    
        protos.LifecycleEvent = (function() {
    
            /**
             * Properties of a LifecycleEvent.
             * @memberof protos
             * @interface ILifecycleEvent
             * @property {string|null} [chaincode_name] LifecycleEvent chaincode_name
             */
    
            /**
             * Constructs a new LifecycleEvent.
             * @memberof protos
             * @classdesc Represents a LifecycleEvent.
             * @implements ILifecycleEvent
             * @constructor
             * @param {protos.ILifecycleEvent=} [properties] Properties to set
             */
            function LifecycleEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LifecycleEvent chaincode_name.
             * @member {string} chaincode_name
             * @memberof protos.LifecycleEvent
             * @instance
             */
            LifecycleEvent.prototype.chaincode_name = "";
    
            /**
             * Creates a new LifecycleEvent instance using the specified properties.
             * @function create
             * @memberof protos.LifecycleEvent
             * @static
             * @param {protos.ILifecycleEvent=} [properties] Properties to set
             * @returns {protos.LifecycleEvent} LifecycleEvent instance
             */
            LifecycleEvent.create = function create(properties) {
                return new LifecycleEvent(properties);
            };
    
            /**
             * Encodes the specified LifecycleEvent message. Does not implicitly {@link protos.LifecycleEvent.verify|verify} messages.
             * @function encode
             * @memberof protos.LifecycleEvent
             * @static
             * @param {protos.ILifecycleEvent} message LifecycleEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LifecycleEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_name != null && Object.hasOwnProperty.call(message, "chaincode_name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.chaincode_name);
                return writer;
            };
    
            /**
             * Encodes the specified LifecycleEvent message, length delimited. Does not implicitly {@link protos.LifecycleEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.LifecycleEvent
             * @static
             * @param {protos.ILifecycleEvent} message LifecycleEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LifecycleEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LifecycleEvent message from the specified reader or buffer.
             * @function decode
             * @memberof protos.LifecycleEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.LifecycleEvent} LifecycleEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LifecycleEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.LifecycleEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LifecycleEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.LifecycleEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.LifecycleEvent} LifecycleEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LifecycleEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LifecycleEvent message.
             * @function verify
             * @memberof protos.LifecycleEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LifecycleEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_name != null && message.hasOwnProperty("chaincode_name"))
                    if (!$util.isString(message.chaincode_name))
                        return "chaincode_name: string expected";
                return null;
            };
    
            /**
             * Creates a LifecycleEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.LifecycleEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.LifecycleEvent} LifecycleEvent
             */
            LifecycleEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.LifecycleEvent)
                    return object;
                var message = new $root.protos.LifecycleEvent();
                if (object.chaincode_name != null)
                    message.chaincode_name = String(object.chaincode_name);
                return message;
            };
    
            /**
             * Creates a plain object from a LifecycleEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.LifecycleEvent
             * @static
             * @param {protos.LifecycleEvent} message LifecycleEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LifecycleEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chaincode_name = "";
                if (message.chaincode_name != null && message.hasOwnProperty("chaincode_name"))
                    object.chaincode_name = message.chaincode_name;
                return object;
            };
    
            /**
             * Converts this LifecycleEvent to JSON.
             * @function toJSON
             * @memberof protos.LifecycleEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LifecycleEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LifecycleEvent;
        })();
    
        protos.CDSData = (function() {
    
            /**
             * Properties of a CDSData.
             * @memberof protos
             * @interface ICDSData
             * @property {Uint8Array|null} [hash] CDSData hash
             * @property {Uint8Array|null} [metadatahash] CDSData metadatahash
             */
    
            /**
             * Constructs a new CDSData.
             * @memberof protos
             * @classdesc Represents a CDSData.
             * @implements ICDSData
             * @constructor
             * @param {protos.ICDSData=} [properties] Properties to set
             */
            function CDSData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CDSData hash.
             * @member {Uint8Array} hash
             * @memberof protos.CDSData
             * @instance
             */
            CDSData.prototype.hash = $util.newBuffer([]);
    
            /**
             * CDSData metadatahash.
             * @member {Uint8Array} metadatahash
             * @memberof protos.CDSData
             * @instance
             */
            CDSData.prototype.metadatahash = $util.newBuffer([]);
    
            /**
             * Creates a new CDSData instance using the specified properties.
             * @function create
             * @memberof protos.CDSData
             * @static
             * @param {protos.ICDSData=} [properties] Properties to set
             * @returns {protos.CDSData} CDSData instance
             */
            CDSData.create = function create(properties) {
                return new CDSData(properties);
            };
    
            /**
             * Encodes the specified CDSData message. Does not implicitly {@link protos.CDSData.verify|verify} messages.
             * @function encode
             * @memberof protos.CDSData
             * @static
             * @param {protos.ICDSData} message CDSData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CDSData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.metadatahash != null && Object.hasOwnProperty.call(message, "metadatahash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadatahash);
                return writer;
            };
    
            /**
             * Encodes the specified CDSData message, length delimited. Does not implicitly {@link protos.CDSData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.CDSData
             * @static
             * @param {protos.ICDSData} message CDSData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CDSData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CDSData message from the specified reader or buffer.
             * @function decode
             * @memberof protos.CDSData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.CDSData} CDSData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CDSData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CDSData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.metadatahash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CDSData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.CDSData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.CDSData} CDSData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CDSData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CDSData message.
             * @function verify
             * @memberof protos.CDSData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CDSData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.metadatahash != null && message.hasOwnProperty("metadatahash"))
                    if (!(message.metadatahash && typeof message.metadatahash.length === "number" || $util.isString(message.metadatahash)))
                        return "metadatahash: buffer expected";
                return null;
            };
    
            /**
             * Creates a CDSData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.CDSData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.CDSData} CDSData
             */
            CDSData.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.CDSData)
                    return object;
                var message = new $root.protos.CDSData();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.metadatahash != null)
                    if (typeof object.metadatahash === "string")
                        $util.base64.decode(object.metadatahash, message.metadatahash = $util.newBuffer($util.base64.length(object.metadatahash)), 0);
                    else if (object.metadatahash.length)
                        message.metadatahash = object.metadatahash;
                return message;
            };
    
            /**
             * Creates a plain object from a CDSData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.CDSData
             * @static
             * @param {protos.CDSData} message CDSData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CDSData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if (options.bytes === String)
                        object.metadatahash = "";
                    else {
                        object.metadatahash = [];
                        if (options.bytes !== Array)
                            object.metadatahash = $util.newBuffer(object.metadatahash);
                    }
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.metadatahash != null && message.hasOwnProperty("metadatahash"))
                    object.metadatahash = options.bytes === String ? $util.base64.encode(message.metadatahash, 0, message.metadatahash.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadatahash) : message.metadatahash;
                return object;
            };
    
            /**
             * Converts this CDSData to JSON.
             * @function toJSON
             * @memberof protos.CDSData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CDSData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CDSData;
        })();
    
        protos.ChaincodeData = (function() {
    
            /**
             * Properties of a ChaincodeData.
             * @memberof protos
             * @interface IChaincodeData
             * @property {string|null} [name] ChaincodeData name
             * @property {string|null} [version] ChaincodeData version
             * @property {string|null} [escc] ChaincodeData escc
             * @property {string|null} [vscc] ChaincodeData vscc
             * @property {common.ISignaturePolicyEnvelope|null} [policy] ChaincodeData policy
             * @property {Uint8Array|null} [data] ChaincodeData data
             * @property {Uint8Array|null} [id] ChaincodeData id
             * @property {common.ISignaturePolicyEnvelope|null} [instantiation_policy] ChaincodeData instantiation_policy
             */
    
            /**
             * Constructs a new ChaincodeData.
             * @memberof protos
             * @classdesc Represents a ChaincodeData.
             * @implements IChaincodeData
             * @constructor
             * @param {protos.IChaincodeData=} [properties] Properties to set
             */
            function ChaincodeData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeData name.
             * @member {string} name
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.name = "";
    
            /**
             * ChaincodeData version.
             * @member {string} version
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.version = "";
    
            /**
             * ChaincodeData escc.
             * @member {string} escc
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.escc = "";
    
            /**
             * ChaincodeData vscc.
             * @member {string} vscc
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.vscc = "";
    
            /**
             * ChaincodeData policy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} policy
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.policy = null;
    
            /**
             * ChaincodeData data.
             * @member {Uint8Array} data
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.data = $util.newBuffer([]);
    
            /**
             * ChaincodeData id.
             * @member {Uint8Array} id
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.id = $util.newBuffer([]);
    
            /**
             * ChaincodeData instantiation_policy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} instantiation_policy
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.instantiation_policy = null;
    
            /**
             * Creates a new ChaincodeData instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeData
             * @static
             * @param {protos.IChaincodeData=} [properties] Properties to set
             * @returns {protos.ChaincodeData} ChaincodeData instance
             */
            ChaincodeData.create = function create(properties) {
                return new ChaincodeData(properties);
            };
    
            /**
             * Encodes the specified ChaincodeData message. Does not implicitly {@link protos.ChaincodeData.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeData
             * @static
             * @param {protos.IChaincodeData} message ChaincodeData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.escc != null && Object.hasOwnProperty.call(message, "escc"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.escc);
                if (message.vscc != null && Object.hasOwnProperty.call(message, "vscc"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.vscc);
                if (message.policy != null && Object.hasOwnProperty.call(message, "policy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.policy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.data);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.id);
                if (message.instantiation_policy != null && Object.hasOwnProperty.call(message, "instantiation_policy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.instantiation_policy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeData message, length delimited. Does not implicitly {@link protos.ChaincodeData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeData
             * @static
             * @param {protos.IChaincodeData} message ChaincodeData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeData message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeData} ChaincodeData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.escc = reader.string();
                        break;
                    case 4:
                        message.vscc = reader.string();
                        break;
                    case 5:
                        message.policy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.data = reader.bytes();
                        break;
                    case 7:
                        message.id = reader.bytes();
                        break;
                    case 8:
                        message.instantiation_policy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeData} ChaincodeData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeData message.
             * @function verify
             * @memberof protos.ChaincodeData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.escc != null && message.hasOwnProperty("escc"))
                    if (!$util.isString(message.escc))
                        return "escc: string expected";
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    if (!$util.isString(message.vscc))
                        return "vscc: string expected";
                if (message.policy != null && message.hasOwnProperty("policy")) {
                    var error = $root.common.SignaturePolicyEnvelope.verify(message.policy);
                    if (error)
                        return "policy." + error;
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                if (message.instantiation_policy != null && message.hasOwnProperty("instantiation_policy")) {
                    var error = $root.common.SignaturePolicyEnvelope.verify(message.instantiation_policy);
                    if (error)
                        return "instantiation_policy." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeData} ChaincodeData
             */
            ChaincodeData.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeData)
                    return object;
                var message = new $root.protos.ChaincodeData();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.escc != null)
                    message.escc = String(object.escc);
                if (object.vscc != null)
                    message.vscc = String(object.vscc);
                if (object.policy != null) {
                    if (typeof object.policy !== "object")
                        throw TypeError(".protos.ChaincodeData.policy: object expected");
                    message.policy = $root.common.SignaturePolicyEnvelope.fromObject(object.policy);
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                if (object.instantiation_policy != null) {
                    if (typeof object.instantiation_policy !== "object")
                        throw TypeError(".protos.ChaincodeData.instantiation_policy: object expected");
                    message.instantiation_policy = $root.common.SignaturePolicyEnvelope.fromObject(object.instantiation_policy);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeData
             * @static
             * @param {protos.ChaincodeData} message ChaincodeData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.version = "";
                    object.escc = "";
                    object.vscc = "";
                    object.policy = null;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                    object.instantiation_policy = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.escc != null && message.hasOwnProperty("escc"))
                    object.escc = message.escc;
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    object.vscc = message.vscc;
                if (message.policy != null && message.hasOwnProperty("policy"))
                    object.policy = $root.common.SignaturePolicyEnvelope.toObject(message.policy, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                if (message.instantiation_policy != null && message.hasOwnProperty("instantiation_policy"))
                    object.instantiation_policy = $root.common.SignaturePolicyEnvelope.toObject(message.instantiation_policy, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeData to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeData;
        })();
    
        protos.ChaincodeIdentifier = (function() {
    
            /**
             * Properties of a ChaincodeIdentifier.
             * @memberof protos
             * @interface IChaincodeIdentifier
             * @property {Uint8Array|null} [hash] ChaincodeIdentifier hash
             * @property {string|null} [version] ChaincodeIdentifier version
             */
    
            /**
             * Constructs a new ChaincodeIdentifier.
             * @memberof protos
             * @classdesc Represents a ChaincodeIdentifier.
             * @implements IChaincodeIdentifier
             * @constructor
             * @param {protos.IChaincodeIdentifier=} [properties] Properties to set
             */
            function ChaincodeIdentifier(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeIdentifier hash.
             * @member {Uint8Array} hash
             * @memberof protos.ChaincodeIdentifier
             * @instance
             */
            ChaincodeIdentifier.prototype.hash = $util.newBuffer([]);
    
            /**
             * ChaincodeIdentifier version.
             * @member {string} version
             * @memberof protos.ChaincodeIdentifier
             * @instance
             */
            ChaincodeIdentifier.prototype.version = "";
    
            /**
             * Creates a new ChaincodeIdentifier instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {protos.IChaincodeIdentifier=} [properties] Properties to set
             * @returns {protos.ChaincodeIdentifier} ChaincodeIdentifier instance
             */
            ChaincodeIdentifier.create = function create(properties) {
                return new ChaincodeIdentifier(properties);
            };
    
            /**
             * Encodes the specified ChaincodeIdentifier message. Does not implicitly {@link protos.ChaincodeIdentifier.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {protos.IChaincodeIdentifier} message ChaincodeIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeIdentifier message, length delimited. Does not implicitly {@link protos.ChaincodeIdentifier.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {protos.IChaincodeIdentifier} message ChaincodeIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeIdentifier} ChaincodeIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeIdentifier();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeIdentifier message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeIdentifier} ChaincodeIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeIdentifier.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeIdentifier message.
             * @function verify
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeIdentifier message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeIdentifier} ChaincodeIdentifier
             */
            ChaincodeIdentifier.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeIdentifier)
                    return object;
                var message = new $root.protos.ChaincodeIdentifier();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.version != null)
                    message.version = String(object.version);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeIdentifier message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {protos.ChaincodeIdentifier} message ChaincodeIdentifier
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeIdentifier.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    object.version = "";
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };
    
            /**
             * Converts this ChaincodeIdentifier to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeIdentifier
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeIdentifier.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeIdentifier;
        })();
    
        protos.ChaincodeValidation = (function() {
    
            /**
             * Properties of a ChaincodeValidation.
             * @memberof protos
             * @interface IChaincodeValidation
             * @property {string|null} [name] ChaincodeValidation name
             * @property {Uint8Array|null} [argument] ChaincodeValidation argument
             */
    
            /**
             * Constructs a new ChaincodeValidation.
             * @memberof protos
             * @classdesc Represents a ChaincodeValidation.
             * @implements IChaincodeValidation
             * @constructor
             * @param {protos.IChaincodeValidation=} [properties] Properties to set
             */
            function ChaincodeValidation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeValidation name.
             * @member {string} name
             * @memberof protos.ChaincodeValidation
             * @instance
             */
            ChaincodeValidation.prototype.name = "";
    
            /**
             * ChaincodeValidation argument.
             * @member {Uint8Array} argument
             * @memberof protos.ChaincodeValidation
             * @instance
             */
            ChaincodeValidation.prototype.argument = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeValidation instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {protos.IChaincodeValidation=} [properties] Properties to set
             * @returns {protos.ChaincodeValidation} ChaincodeValidation instance
             */
            ChaincodeValidation.create = function create(properties) {
                return new ChaincodeValidation(properties);
            };
    
            /**
             * Encodes the specified ChaincodeValidation message. Does not implicitly {@link protos.ChaincodeValidation.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {protos.IChaincodeValidation} message ChaincodeValidation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeValidation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.argument != null && Object.hasOwnProperty.call(message, "argument"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.argument);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeValidation message, length delimited. Does not implicitly {@link protos.ChaincodeValidation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {protos.IChaincodeValidation} message ChaincodeValidation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeValidation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeValidation message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeValidation} ChaincodeValidation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeValidation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeValidation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.argument = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeValidation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeValidation} ChaincodeValidation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeValidation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeValidation message.
             * @function verify
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeValidation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.argument != null && message.hasOwnProperty("argument"))
                    if (!(message.argument && typeof message.argument.length === "number" || $util.isString(message.argument)))
                        return "argument: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeValidation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeValidation} ChaincodeValidation
             */
            ChaincodeValidation.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeValidation)
                    return object;
                var message = new $root.protos.ChaincodeValidation();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.argument != null)
                    if (typeof object.argument === "string")
                        $util.base64.decode(object.argument, message.argument = $util.newBuffer($util.base64.length(object.argument)), 0);
                    else if (object.argument.length)
                        message.argument = object.argument;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeValidation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {protos.ChaincodeValidation} message ChaincodeValidation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeValidation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if (options.bytes === String)
                        object.argument = "";
                    else {
                        object.argument = [];
                        if (options.bytes !== Array)
                            object.argument = $util.newBuffer(object.argument);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.argument != null && message.hasOwnProperty("argument"))
                    object.argument = options.bytes === String ? $util.base64.encode(message.argument, 0, message.argument.length) : options.bytes === Array ? Array.prototype.slice.call(message.argument) : message.argument;
                return object;
            };
    
            /**
             * Converts this ChaincodeValidation to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeValidation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeValidation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeValidation;
        })();
    
        protos.VSCCArgs = (function() {
    
            /**
             * Properties of a VSCCArgs.
             * @memberof protos
             * @interface IVSCCArgs
             * @property {string|null} [endorsement_policy_ref] VSCCArgs endorsement_policy_ref
             */
    
            /**
             * Constructs a new VSCCArgs.
             * @memberof protos
             * @classdesc Represents a VSCCArgs.
             * @implements IVSCCArgs
             * @constructor
             * @param {protos.IVSCCArgs=} [properties] Properties to set
             */
            function VSCCArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * VSCCArgs endorsement_policy_ref.
             * @member {string} endorsement_policy_ref
             * @memberof protos.VSCCArgs
             * @instance
             */
            VSCCArgs.prototype.endorsement_policy_ref = "";
    
            /**
             * Creates a new VSCCArgs instance using the specified properties.
             * @function create
             * @memberof protos.VSCCArgs
             * @static
             * @param {protos.IVSCCArgs=} [properties] Properties to set
             * @returns {protos.VSCCArgs} VSCCArgs instance
             */
            VSCCArgs.create = function create(properties) {
                return new VSCCArgs(properties);
            };
    
            /**
             * Encodes the specified VSCCArgs message. Does not implicitly {@link protos.VSCCArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.VSCCArgs
             * @static
             * @param {protos.IVSCCArgs} message VSCCArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VSCCArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endorsement_policy_ref != null && Object.hasOwnProperty.call(message, "endorsement_policy_ref"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.endorsement_policy_ref);
                return writer;
            };
    
            /**
             * Encodes the specified VSCCArgs message, length delimited. Does not implicitly {@link protos.VSCCArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.VSCCArgs
             * @static
             * @param {protos.IVSCCArgs} message VSCCArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VSCCArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a VSCCArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.VSCCArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.VSCCArgs} VSCCArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VSCCArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.VSCCArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endorsement_policy_ref = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a VSCCArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.VSCCArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.VSCCArgs} VSCCArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VSCCArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a VSCCArgs message.
             * @function verify
             * @memberof protos.VSCCArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VSCCArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endorsement_policy_ref != null && message.hasOwnProperty("endorsement_policy_ref"))
                    if (!$util.isString(message.endorsement_policy_ref))
                        return "endorsement_policy_ref: string expected";
                return null;
            };
    
            /**
             * Creates a VSCCArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.VSCCArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.VSCCArgs} VSCCArgs
             */
            VSCCArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.VSCCArgs)
                    return object;
                var message = new $root.protos.VSCCArgs();
                if (object.endorsement_policy_ref != null)
                    message.endorsement_policy_ref = String(object.endorsement_policy_ref);
                return message;
            };
    
            /**
             * Creates a plain object from a VSCCArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.VSCCArgs
             * @static
             * @param {protos.VSCCArgs} message VSCCArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VSCCArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.endorsement_policy_ref = "";
                if (message.endorsement_policy_ref != null && message.hasOwnProperty("endorsement_policy_ref"))
                    object.endorsement_policy_ref = message.endorsement_policy_ref;
                return object;
            };
    
            /**
             * Converts this VSCCArgs to JSON.
             * @function toJSON
             * @memberof protos.VSCCArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VSCCArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return VSCCArgs;
        })();
    
        protos.ChaincodeEndorsement = (function() {
    
            /**
             * Properties of a ChaincodeEndorsement.
             * @memberof protos
             * @interface IChaincodeEndorsement
             * @property {string|null} [name] ChaincodeEndorsement name
             */
    
            /**
             * Constructs a new ChaincodeEndorsement.
             * @memberof protos
             * @classdesc Represents a ChaincodeEndorsement.
             * @implements IChaincodeEndorsement
             * @constructor
             * @param {protos.IChaincodeEndorsement=} [properties] Properties to set
             */
            function ChaincodeEndorsement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeEndorsement name.
             * @member {string} name
             * @memberof protos.ChaincodeEndorsement
             * @instance
             */
            ChaincodeEndorsement.prototype.name = "";
    
            /**
             * Creates a new ChaincodeEndorsement instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {protos.IChaincodeEndorsement=} [properties] Properties to set
             * @returns {protos.ChaincodeEndorsement} ChaincodeEndorsement instance
             */
            ChaincodeEndorsement.create = function create(properties) {
                return new ChaincodeEndorsement(properties);
            };
    
            /**
             * Encodes the specified ChaincodeEndorsement message. Does not implicitly {@link protos.ChaincodeEndorsement.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {protos.IChaincodeEndorsement} message ChaincodeEndorsement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeEndorsement message, length delimited. Does not implicitly {@link protos.ChaincodeEndorsement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {protos.IChaincodeEndorsement} message ChaincodeEndorsement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeEndorsement message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeEndorsement} ChaincodeEndorsement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeEndorsement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeEndorsement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeEndorsement} ChaincodeEndorsement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeEndorsement message.
             * @function verify
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeEndorsement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeEndorsement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeEndorsement} ChaincodeEndorsement
             */
            ChaincodeEndorsement.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeEndorsement)
                    return object;
                var message = new $root.protos.ChaincodeEndorsement();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeEndorsement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {protos.ChaincodeEndorsement} message ChaincodeEndorsement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeEndorsement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this ChaincodeEndorsement to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeEndorsement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeEndorsement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeEndorsement;
        })();
    
        protos.ConfigTree = (function() {
    
            /**
             * Properties of a ConfigTree.
             * @memberof protos
             * @interface IConfigTree
             * @property {common.IConfig|null} [channel_config] ConfigTree channel_config
             * @property {common.IConfig|null} [resources_config] ConfigTree resources_config
             */
    
            /**
             * Constructs a new ConfigTree.
             * @memberof protos
             * @classdesc Represents a ConfigTree.
             * @implements IConfigTree
             * @constructor
             * @param {protos.IConfigTree=} [properties] Properties to set
             */
            function ConfigTree(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigTree channel_config.
             * @member {common.IConfig|null|undefined} channel_config
             * @memberof protos.ConfigTree
             * @instance
             */
            ConfigTree.prototype.channel_config = null;
    
            /**
             * ConfigTree resources_config.
             * @member {common.IConfig|null|undefined} resources_config
             * @memberof protos.ConfigTree
             * @instance
             */
            ConfigTree.prototype.resources_config = null;
    
            /**
             * Creates a new ConfigTree instance using the specified properties.
             * @function create
             * @memberof protos.ConfigTree
             * @static
             * @param {protos.IConfigTree=} [properties] Properties to set
             * @returns {protos.ConfigTree} ConfigTree instance
             */
            ConfigTree.create = function create(properties) {
                return new ConfigTree(properties);
            };
    
            /**
             * Encodes the specified ConfigTree message. Does not implicitly {@link protos.ConfigTree.verify|verify} messages.
             * @function encode
             * @memberof protos.ConfigTree
             * @static
             * @param {protos.IConfigTree} message ConfigTree message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigTree.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel_config != null && Object.hasOwnProperty.call(message, "channel_config"))
                    $root.common.Config.encode(message.channel_config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.resources_config != null && Object.hasOwnProperty.call(message, "resources_config"))
                    $root.common.Config.encode(message.resources_config, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigTree message, length delimited. Does not implicitly {@link protos.ConfigTree.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ConfigTree
             * @static
             * @param {protos.IConfigTree} message ConfigTree message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigTree.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigTree message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ConfigTree
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ConfigTree} ConfigTree
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigTree.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ConfigTree();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel_config = $root.common.Config.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.resources_config = $root.common.Config.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigTree message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ConfigTree
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ConfigTree} ConfigTree
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigTree.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigTree message.
             * @function verify
             * @memberof protos.ConfigTree
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigTree.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel_config != null && message.hasOwnProperty("channel_config")) {
                    var error = $root.common.Config.verify(message.channel_config);
                    if (error)
                        return "channel_config." + error;
                }
                if (message.resources_config != null && message.hasOwnProperty("resources_config")) {
                    var error = $root.common.Config.verify(message.resources_config);
                    if (error)
                        return "resources_config." + error;
                }
                return null;
            };
    
            /**
             * Creates a ConfigTree message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ConfigTree
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ConfigTree} ConfigTree
             */
            ConfigTree.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ConfigTree)
                    return object;
                var message = new $root.protos.ConfigTree();
                if (object.channel_config != null) {
                    if (typeof object.channel_config !== "object")
                        throw TypeError(".protos.ConfigTree.channel_config: object expected");
                    message.channel_config = $root.common.Config.fromObject(object.channel_config);
                }
                if (object.resources_config != null) {
                    if (typeof object.resources_config !== "object")
                        throw TypeError(".protos.ConfigTree.resources_config: object expected");
                    message.resources_config = $root.common.Config.fromObject(object.resources_config);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigTree message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ConfigTree
             * @static
             * @param {protos.ConfigTree} message ConfigTree
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigTree.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel_config = null;
                    object.resources_config = null;
                }
                if (message.channel_config != null && message.hasOwnProperty("channel_config"))
                    object.channel_config = $root.common.Config.toObject(message.channel_config, options);
                if (message.resources_config != null && message.hasOwnProperty("resources_config"))
                    object.resources_config = $root.common.Config.toObject(message.resources_config, options);
                return object;
            };
    
            /**
             * Converts this ConfigTree to JSON.
             * @function toJSON
             * @memberof protos.ConfigTree
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigTree.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigTree;
        })();
    
        protos.AnchorPeers = (function() {
    
            /**
             * Properties of an AnchorPeers.
             * @memberof protos
             * @interface IAnchorPeers
             * @property {Array.<protos.IAnchorPeer>|null} [anchor_peers] AnchorPeers anchor_peers
             */
    
            /**
             * Constructs a new AnchorPeers.
             * @memberof protos
             * @classdesc Represents an AnchorPeers.
             * @implements IAnchorPeers
             * @constructor
             * @param {protos.IAnchorPeers=} [properties] Properties to set
             */
            function AnchorPeers(properties) {
                this.anchor_peers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AnchorPeers anchor_peers.
             * @member {Array.<protos.IAnchorPeer>} anchor_peers
             * @memberof protos.AnchorPeers
             * @instance
             */
            AnchorPeers.prototype.anchor_peers = $util.emptyArray;
    
            /**
             * Creates a new AnchorPeers instance using the specified properties.
             * @function create
             * @memberof protos.AnchorPeers
             * @static
             * @param {protos.IAnchorPeers=} [properties] Properties to set
             * @returns {protos.AnchorPeers} AnchorPeers instance
             */
            AnchorPeers.create = function create(properties) {
                return new AnchorPeers(properties);
            };
    
            /**
             * Encodes the specified AnchorPeers message. Does not implicitly {@link protos.AnchorPeers.verify|verify} messages.
             * @function encode
             * @memberof protos.AnchorPeers
             * @static
             * @param {protos.IAnchorPeers} message AnchorPeers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorPeers.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.anchor_peers != null && message.anchor_peers.length)
                    for (var i = 0; i < message.anchor_peers.length; ++i)
                        $root.protos.AnchorPeer.encode(message.anchor_peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified AnchorPeers message, length delimited. Does not implicitly {@link protos.AnchorPeers.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.AnchorPeers
             * @static
             * @param {protos.IAnchorPeers} message AnchorPeers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorPeers.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AnchorPeers message from the specified reader or buffer.
             * @function decode
             * @memberof protos.AnchorPeers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.AnchorPeers} AnchorPeers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorPeers.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.AnchorPeers();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.anchor_peers && message.anchor_peers.length))
                            message.anchor_peers = [];
                        message.anchor_peers.push($root.protos.AnchorPeer.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AnchorPeers message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.AnchorPeers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.AnchorPeers} AnchorPeers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorPeers.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AnchorPeers message.
             * @function verify
             * @memberof protos.AnchorPeers
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnchorPeers.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.anchor_peers != null && message.hasOwnProperty("anchor_peers")) {
                    if (!Array.isArray(message.anchor_peers))
                        return "anchor_peers: array expected";
                    for (var i = 0; i < message.anchor_peers.length; ++i) {
                        var error = $root.protos.AnchorPeer.verify(message.anchor_peers[i]);
                        if (error)
                            return "anchor_peers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates an AnchorPeers message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.AnchorPeers
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.AnchorPeers} AnchorPeers
             */
            AnchorPeers.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.AnchorPeers)
                    return object;
                var message = new $root.protos.AnchorPeers();
                if (object.anchor_peers) {
                    if (!Array.isArray(object.anchor_peers))
                        throw TypeError(".protos.AnchorPeers.anchor_peers: array expected");
                    message.anchor_peers = [];
                    for (var i = 0; i < object.anchor_peers.length; ++i) {
                        if (typeof object.anchor_peers[i] !== "object")
                            throw TypeError(".protos.AnchorPeers.anchor_peers: object expected");
                        message.anchor_peers[i] = $root.protos.AnchorPeer.fromObject(object.anchor_peers[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from an AnchorPeers message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.AnchorPeers
             * @static
             * @param {protos.AnchorPeers} message AnchorPeers
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnchorPeers.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.anchor_peers = [];
                if (message.anchor_peers && message.anchor_peers.length) {
                    object.anchor_peers = [];
                    for (var j = 0; j < message.anchor_peers.length; ++j)
                        object.anchor_peers[j] = $root.protos.AnchorPeer.toObject(message.anchor_peers[j], options);
                }
                return object;
            };
    
            /**
             * Converts this AnchorPeers to JSON.
             * @function toJSON
             * @memberof protos.AnchorPeers
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnchorPeers.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AnchorPeers;
        })();
    
        protos.AnchorPeer = (function() {
    
            /**
             * Properties of an AnchorPeer.
             * @memberof protos
             * @interface IAnchorPeer
             * @property {string|null} [host] AnchorPeer host
             * @property {number|null} [port] AnchorPeer port
             */
    
            /**
             * Constructs a new AnchorPeer.
             * @memberof protos
             * @classdesc Represents an AnchorPeer.
             * @implements IAnchorPeer
             * @constructor
             * @param {protos.IAnchorPeer=} [properties] Properties to set
             */
            function AnchorPeer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AnchorPeer host.
             * @member {string} host
             * @memberof protos.AnchorPeer
             * @instance
             */
            AnchorPeer.prototype.host = "";
    
            /**
             * AnchorPeer port.
             * @member {number} port
             * @memberof protos.AnchorPeer
             * @instance
             */
            AnchorPeer.prototype.port = 0;
    
            /**
             * Creates a new AnchorPeer instance using the specified properties.
             * @function create
             * @memberof protos.AnchorPeer
             * @static
             * @param {protos.IAnchorPeer=} [properties] Properties to set
             * @returns {protos.AnchorPeer} AnchorPeer instance
             */
            AnchorPeer.create = function create(properties) {
                return new AnchorPeer(properties);
            };
    
            /**
             * Encodes the specified AnchorPeer message. Does not implicitly {@link protos.AnchorPeer.verify|verify} messages.
             * @function encode
             * @memberof protos.AnchorPeer
             * @static
             * @param {protos.IAnchorPeer} message AnchorPeer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorPeer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
                return writer;
            };
    
            /**
             * Encodes the specified AnchorPeer message, length delimited. Does not implicitly {@link protos.AnchorPeer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.AnchorPeer
             * @static
             * @param {protos.IAnchorPeer} message AnchorPeer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorPeer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AnchorPeer message from the specified reader or buffer.
             * @function decode
             * @memberof protos.AnchorPeer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.AnchorPeer} AnchorPeer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorPeer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.AnchorPeer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AnchorPeer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.AnchorPeer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.AnchorPeer} AnchorPeer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorPeer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AnchorPeer message.
             * @function verify
             * @memberof protos.AnchorPeer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnchorPeer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                return null;
            };
    
            /**
             * Creates an AnchorPeer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.AnchorPeer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.AnchorPeer} AnchorPeer
             */
            AnchorPeer.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.AnchorPeer)
                    return object;
                var message = new $root.protos.AnchorPeer();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                return message;
            };
    
            /**
             * Creates a plain object from an AnchorPeer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.AnchorPeer
             * @static
             * @param {protos.AnchorPeer} message AnchorPeer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnchorPeer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };
    
            /**
             * Converts this AnchorPeer to JSON.
             * @function toJSON
             * @memberof protos.AnchorPeer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnchorPeer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AnchorPeer;
        })();
    
        protos.APIResource = (function() {
    
            /**
             * Properties of a APIResource.
             * @memberof protos
             * @interface IAPIResource
             * @property {string|null} [policy_ref] APIResource policy_ref
             */
    
            /**
             * Constructs a new APIResource.
             * @memberof protos
             * @classdesc Represents a APIResource.
             * @implements IAPIResource
             * @constructor
             * @param {protos.IAPIResource=} [properties] Properties to set
             */
            function APIResource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * APIResource policy_ref.
             * @member {string} policy_ref
             * @memberof protos.APIResource
             * @instance
             */
            APIResource.prototype.policy_ref = "";
    
            /**
             * Creates a new APIResource instance using the specified properties.
             * @function create
             * @memberof protos.APIResource
             * @static
             * @param {protos.IAPIResource=} [properties] Properties to set
             * @returns {protos.APIResource} APIResource instance
             */
            APIResource.create = function create(properties) {
                return new APIResource(properties);
            };
    
            /**
             * Encodes the specified APIResource message. Does not implicitly {@link protos.APIResource.verify|verify} messages.
             * @function encode
             * @memberof protos.APIResource
             * @static
             * @param {protos.IAPIResource} message APIResource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            APIResource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.policy_ref != null && Object.hasOwnProperty.call(message, "policy_ref"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.policy_ref);
                return writer;
            };
    
            /**
             * Encodes the specified APIResource message, length delimited. Does not implicitly {@link protos.APIResource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.APIResource
             * @static
             * @param {protos.IAPIResource} message APIResource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            APIResource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a APIResource message from the specified reader or buffer.
             * @function decode
             * @memberof protos.APIResource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.APIResource} APIResource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            APIResource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.APIResource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.policy_ref = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a APIResource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.APIResource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.APIResource} APIResource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            APIResource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a APIResource message.
             * @function verify
             * @memberof protos.APIResource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            APIResource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.policy_ref != null && message.hasOwnProperty("policy_ref"))
                    if (!$util.isString(message.policy_ref))
                        return "policy_ref: string expected";
                return null;
            };
    
            /**
             * Creates a APIResource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.APIResource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.APIResource} APIResource
             */
            APIResource.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.APIResource)
                    return object;
                var message = new $root.protos.APIResource();
                if (object.policy_ref != null)
                    message.policy_ref = String(object.policy_ref);
                return message;
            };
    
            /**
             * Creates a plain object from a APIResource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.APIResource
             * @static
             * @param {protos.APIResource} message APIResource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            APIResource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.policy_ref = "";
                if (message.policy_ref != null && message.hasOwnProperty("policy_ref"))
                    object.policy_ref = message.policy_ref;
                return object;
            };
    
            /**
             * Converts this APIResource to JSON.
             * @function toJSON
             * @memberof protos.APIResource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            APIResource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return APIResource;
        })();
    
        protos.ACLs = (function() {
    
            /**
             * Properties of a ACLs.
             * @memberof protos
             * @interface IACLs
             * @property {Object.<string,protos.IAPIResource>|null} [acls] ACLs acls
             */
    
            /**
             * Constructs a new ACLs.
             * @memberof protos
             * @classdesc Represents a ACLs.
             * @implements IACLs
             * @constructor
             * @param {protos.IACLs=} [properties] Properties to set
             */
            function ACLs(properties) {
                this.acls = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ACLs acls.
             * @member {Object.<string,protos.IAPIResource>} acls
             * @memberof protos.ACLs
             * @instance
             */
            ACLs.prototype.acls = $util.emptyObject;
    
            /**
             * Creates a new ACLs instance using the specified properties.
             * @function create
             * @memberof protos.ACLs
             * @static
             * @param {protos.IACLs=} [properties] Properties to set
             * @returns {protos.ACLs} ACLs instance
             */
            ACLs.create = function create(properties) {
                return new ACLs(properties);
            };
    
            /**
             * Encodes the specified ACLs message. Does not implicitly {@link protos.ACLs.verify|verify} messages.
             * @function encode
             * @memberof protos.ACLs
             * @static
             * @param {protos.IACLs} message ACLs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ACLs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.acls != null && Object.hasOwnProperty.call(message, "acls"))
                    for (var keys = Object.keys(message.acls), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.protos.APIResource.encode(message.acls[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified ACLs message, length delimited. Does not implicitly {@link protos.ACLs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ACLs
             * @static
             * @param {protos.IACLs} message ACLs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ACLs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ACLs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ACLs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ACLs} ACLs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ACLs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ACLs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.acls === $util.emptyObject)
                            message.acls = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.protos.APIResource.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.acls[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ACLs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ACLs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ACLs} ACLs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ACLs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ACLs message.
             * @function verify
             * @memberof protos.ACLs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ACLs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.acls != null && message.hasOwnProperty("acls")) {
                    if (!$util.isObject(message.acls))
                        return "acls: object expected";
                    var key = Object.keys(message.acls);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.protos.APIResource.verify(message.acls[key[i]]);
                        if (error)
                            return "acls." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ACLs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ACLs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ACLs} ACLs
             */
            ACLs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ACLs)
                    return object;
                var message = new $root.protos.ACLs();
                if (object.acls) {
                    if (typeof object.acls !== "object")
                        throw TypeError(".protos.ACLs.acls: object expected");
                    message.acls = {};
                    for (var keys = Object.keys(object.acls), i = 0; i < keys.length; ++i) {
                        if (typeof object.acls[keys[i]] !== "object")
                            throw TypeError(".protos.ACLs.acls: object expected");
                        message.acls[keys[i]] = $root.protos.APIResource.fromObject(object.acls[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ACLs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ACLs
             * @static
             * @param {protos.ACLs} message ACLs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ACLs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.acls = {};
                var keys2;
                if (message.acls && (keys2 = Object.keys(message.acls)).length) {
                    object.acls = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.acls[keys2[j]] = $root.protos.APIResource.toObject(message.acls[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this ACLs to JSON.
             * @function toJSON
             * @memberof protos.ACLs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ACLs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ACLs;
        })();
    
        protos.Endorser = (function() {
    
            /**
             * Constructs a new Endorser service.
             * @memberof protos
             * @classdesc Represents an Endorser
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Endorser(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Endorser.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Endorser;
    
            /**
             * Creates new Endorser service using the specified rpc implementation.
             * @function create
             * @memberof protos.Endorser
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Endorser} RPC service. Useful where requests and/or responses are streamed.
             */
            Endorser.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link protos.Endorser#processProposal}.
             * @memberof protos.Endorser
             * @typedef ProcessProposalCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.ProposalResponse} [response] ProposalResponse
             */
    
            /**
             * Calls ProcessProposal.
             * @function processProposal
             * @memberof protos.Endorser
             * @instance
             * @param {protos.ISignedProposal} request SignedProposal message or plain object
             * @param {protos.Endorser.ProcessProposalCallback} callback Node-style callback called with the error, if any, and ProposalResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Endorser.prototype.processProposal = function processProposal(request, callback) {
                return this.rpcCall(processProposal, $root.protos.SignedProposal, $root.protos.ProposalResponse, request, callback);
            }, "name", { value: "ProcessProposal" });
    
            /**
             * Calls ProcessProposal.
             * @function processProposal
             * @memberof protos.Endorser
             * @instance
             * @param {protos.ISignedProposal} request SignedProposal message or plain object
             * @returns {Promise<protos.ProposalResponse>} Promise
             * @variation 2
             */
    
            return Endorser;
        })();
    
        protos.ChaincodeQueryResponse = (function() {
    
            /**
             * Properties of a ChaincodeQueryResponse.
             * @memberof protos
             * @interface IChaincodeQueryResponse
             * @property {Array.<protos.IChaincodeInfo>|null} [chaincodes] ChaincodeQueryResponse chaincodes
             */
    
            /**
             * Constructs a new ChaincodeQueryResponse.
             * @memberof protos
             * @classdesc Represents a ChaincodeQueryResponse.
             * @implements IChaincodeQueryResponse
             * @constructor
             * @param {protos.IChaincodeQueryResponse=} [properties] Properties to set
             */
            function ChaincodeQueryResponse(properties) {
                this.chaincodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeQueryResponse chaincodes.
             * @member {Array.<protos.IChaincodeInfo>} chaincodes
             * @memberof protos.ChaincodeQueryResponse
             * @instance
             */
            ChaincodeQueryResponse.prototype.chaincodes = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeQueryResponse instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {protos.IChaincodeQueryResponse=} [properties] Properties to set
             * @returns {protos.ChaincodeQueryResponse} ChaincodeQueryResponse instance
             */
            ChaincodeQueryResponse.create = function create(properties) {
                return new ChaincodeQueryResponse(properties);
            };
    
            /**
             * Encodes the specified ChaincodeQueryResponse message. Does not implicitly {@link protos.ChaincodeQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {protos.IChaincodeQueryResponse} message ChaincodeQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodes != null && message.chaincodes.length)
                    for (var i = 0; i < message.chaincodes.length; ++i)
                        $root.protos.ChaincodeInfo.encode(message.chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeQueryResponse message, length delimited. Does not implicitly {@link protos.ChaincodeQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {protos.IChaincodeQueryResponse} message ChaincodeQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeQueryResponse} ChaincodeQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.chaincodes && message.chaincodes.length))
                            message.chaincodes = [];
                        message.chaincodes.push($root.protos.ChaincodeInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeQueryResponse} ChaincodeQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeQueryResponse message.
             * @function verify
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                    if (!Array.isArray(message.chaincodes))
                        return "chaincodes: array expected";
                    for (var i = 0; i < message.chaincodes.length; ++i) {
                        var error = $root.protos.ChaincodeInfo.verify(message.chaincodes[i]);
                        if (error)
                            return "chaincodes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeQueryResponse} ChaincodeQueryResponse
             */
            ChaincodeQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeQueryResponse)
                    return object;
                var message = new $root.protos.ChaincodeQueryResponse();
                if (object.chaincodes) {
                    if (!Array.isArray(object.chaincodes))
                        throw TypeError(".protos.ChaincodeQueryResponse.chaincodes: array expected");
                    message.chaincodes = [];
                    for (var i = 0; i < object.chaincodes.length; ++i) {
                        if (typeof object.chaincodes[i] !== "object")
                            throw TypeError(".protos.ChaincodeQueryResponse.chaincodes: object expected");
                        message.chaincodes[i] = $root.protos.ChaincodeInfo.fromObject(object.chaincodes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {protos.ChaincodeQueryResponse} message ChaincodeQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincodes = [];
                if (message.chaincodes && message.chaincodes.length) {
                    object.chaincodes = [];
                    for (var j = 0; j < message.chaincodes.length; ++j)
                        object.chaincodes[j] = $root.protos.ChaincodeInfo.toObject(message.chaincodes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeQueryResponse to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeQueryResponse;
        })();
    
        protos.ChaincodeInfo = (function() {
    
            /**
             * Properties of a ChaincodeInfo.
             * @memberof protos
             * @interface IChaincodeInfo
             * @property {string|null} [name] ChaincodeInfo name
             * @property {string|null} [version] ChaincodeInfo version
             * @property {string|null} [path] ChaincodeInfo path
             * @property {string|null} [input] ChaincodeInfo input
             * @property {string|null} [escc] ChaincodeInfo escc
             * @property {string|null} [vscc] ChaincodeInfo vscc
             * @property {Uint8Array|null} [id] ChaincodeInfo id
             */
    
            /**
             * Constructs a new ChaincodeInfo.
             * @memberof protos
             * @classdesc Represents a ChaincodeInfo.
             * @implements IChaincodeInfo
             * @constructor
             * @param {protos.IChaincodeInfo=} [properties] Properties to set
             */
            function ChaincodeInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeInfo name.
             * @member {string} name
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.name = "";
    
            /**
             * ChaincodeInfo version.
             * @member {string} version
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.version = "";
    
            /**
             * ChaincodeInfo path.
             * @member {string} path
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.path = "";
    
            /**
             * ChaincodeInfo input.
             * @member {string} input
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.input = "";
    
            /**
             * ChaincodeInfo escc.
             * @member {string} escc
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.escc = "";
    
            /**
             * ChaincodeInfo vscc.
             * @member {string} vscc
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.vscc = "";
    
            /**
             * ChaincodeInfo id.
             * @member {Uint8Array} id
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.id = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeInfo instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {protos.IChaincodeInfo=} [properties] Properties to set
             * @returns {protos.ChaincodeInfo} ChaincodeInfo instance
             */
            ChaincodeInfo.create = function create(properties) {
                return new ChaincodeInfo(properties);
            };
    
            /**
             * Encodes the specified ChaincodeInfo message. Does not implicitly {@link protos.ChaincodeInfo.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {protos.IChaincodeInfo} message ChaincodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.path);
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.input);
                if (message.escc != null && Object.hasOwnProperty.call(message, "escc"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.escc);
                if (message.vscc != null && Object.hasOwnProperty.call(message, "vscc"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.vscc);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeInfo message, length delimited. Does not implicitly {@link protos.ChaincodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {protos.IChaincodeInfo} message ChaincodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeInfo} ChaincodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.path = reader.string();
                        break;
                    case 4:
                        message.input = reader.string();
                        break;
                    case 5:
                        message.escc = reader.string();
                        break;
                    case 6:
                        message.vscc = reader.string();
                        break;
                    case 7:
                        message.id = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeInfo} ChaincodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeInfo message.
             * @function verify
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.input != null && message.hasOwnProperty("input"))
                    if (!$util.isString(message.input))
                        return "input: string expected";
                if (message.escc != null && message.hasOwnProperty("escc"))
                    if (!$util.isString(message.escc))
                        return "escc: string expected";
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    if (!$util.isString(message.vscc))
                        return "vscc: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeInfo} ChaincodeInfo
             */
            ChaincodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeInfo)
                    return object;
                var message = new $root.protos.ChaincodeInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.input != null)
                    message.input = String(object.input);
                if (object.escc != null)
                    message.escc = String(object.escc);
                if (object.vscc != null)
                    message.vscc = String(object.vscc);
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {protos.ChaincodeInfo} message ChaincodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.version = "";
                    object.path = "";
                    object.input = "";
                    object.escc = "";
                    object.vscc = "";
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = message.input;
                if (message.escc != null && message.hasOwnProperty("escc"))
                    object.escc = message.escc;
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    object.vscc = message.vscc;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                return object;
            };
    
            /**
             * Converts this ChaincodeInfo to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeInfo;
        })();
    
        protos.ChannelQueryResponse = (function() {
    
            /**
             * Properties of a ChannelQueryResponse.
             * @memberof protos
             * @interface IChannelQueryResponse
             * @property {Array.<protos.IChannelInfo>|null} [channels] ChannelQueryResponse channels
             */
    
            /**
             * Constructs a new ChannelQueryResponse.
             * @memberof protos
             * @classdesc Represents a ChannelQueryResponse.
             * @implements IChannelQueryResponse
             * @constructor
             * @param {protos.IChannelQueryResponse=} [properties] Properties to set
             */
            function ChannelQueryResponse(properties) {
                this.channels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChannelQueryResponse channels.
             * @member {Array.<protos.IChannelInfo>} channels
             * @memberof protos.ChannelQueryResponse
             * @instance
             */
            ChannelQueryResponse.prototype.channels = $util.emptyArray;
    
            /**
             * Creates a new ChannelQueryResponse instance using the specified properties.
             * @function create
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {protos.IChannelQueryResponse=} [properties] Properties to set
             * @returns {protos.ChannelQueryResponse} ChannelQueryResponse instance
             */
            ChannelQueryResponse.create = function create(properties) {
                return new ChannelQueryResponse(properties);
            };
    
            /**
             * Encodes the specified ChannelQueryResponse message. Does not implicitly {@link protos.ChannelQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {protos.IChannelQueryResponse} message ChannelQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channels != null && message.channels.length)
                    for (var i = 0; i < message.channels.length; ++i)
                        $root.protos.ChannelInfo.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChannelQueryResponse message, length delimited. Does not implicitly {@link protos.ChannelQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {protos.IChannelQueryResponse} message ChannelQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChannelQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChannelQueryResponse} ChannelQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChannelQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.channels && message.channels.length))
                            message.channels = [];
                        message.channels.push($root.protos.ChannelInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChannelQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChannelQueryResponse} ChannelQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChannelQueryResponse message.
             * @function verify
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channels != null && message.hasOwnProperty("channels")) {
                    if (!Array.isArray(message.channels))
                        return "channels: array expected";
                    for (var i = 0; i < message.channels.length; ++i) {
                        var error = $root.protos.ChannelInfo.verify(message.channels[i]);
                        if (error)
                            return "channels." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChannelQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChannelQueryResponse} ChannelQueryResponse
             */
            ChannelQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChannelQueryResponse)
                    return object;
                var message = new $root.protos.ChannelQueryResponse();
                if (object.channels) {
                    if (!Array.isArray(object.channels))
                        throw TypeError(".protos.ChannelQueryResponse.channels: array expected");
                    message.channels = [];
                    for (var i = 0; i < object.channels.length; ++i) {
                        if (typeof object.channels[i] !== "object")
                            throw TypeError(".protos.ChannelQueryResponse.channels: object expected");
                        message.channels[i] = $root.protos.ChannelInfo.fromObject(object.channels[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChannelQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {protos.ChannelQueryResponse} message ChannelQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channels = [];
                if (message.channels && message.channels.length) {
                    object.channels = [];
                    for (var j = 0; j < message.channels.length; ++j)
                        object.channels[j] = $root.protos.ChannelInfo.toObject(message.channels[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChannelQueryResponse to JSON.
             * @function toJSON
             * @memberof protos.ChannelQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChannelQueryResponse;
        })();
    
        protos.ChannelInfo = (function() {
    
            /**
             * Properties of a ChannelInfo.
             * @memberof protos
             * @interface IChannelInfo
             * @property {string|null} [channel_id] ChannelInfo channel_id
             */
    
            /**
             * Constructs a new ChannelInfo.
             * @memberof protos
             * @classdesc Represents a ChannelInfo.
             * @implements IChannelInfo
             * @constructor
             * @param {protos.IChannelInfo=} [properties] Properties to set
             */
            function ChannelInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChannelInfo channel_id.
             * @member {string} channel_id
             * @memberof protos.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.channel_id = "";
    
            /**
             * Creates a new ChannelInfo instance using the specified properties.
             * @function create
             * @memberof protos.ChannelInfo
             * @static
             * @param {protos.IChannelInfo=} [properties] Properties to set
             * @returns {protos.ChannelInfo} ChannelInfo instance
             */
            ChannelInfo.create = function create(properties) {
                return new ChannelInfo(properties);
            };
    
            /**
             * Encodes the specified ChannelInfo message. Does not implicitly {@link protos.ChannelInfo.verify|verify} messages.
             * @function encode
             * @memberof protos.ChannelInfo
             * @static
             * @param {protos.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel_id != null && Object.hasOwnProperty.call(message, "channel_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel_id);
                return writer;
            };
    
            /**
             * Encodes the specified ChannelInfo message, length delimited. Does not implicitly {@link protos.ChannelInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChannelInfo
             * @static
             * @param {protos.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChannelInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChannelInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel_id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChannelInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChannelInfo message.
             * @function verify
             * @memberof protos.ChannelInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (!$util.isString(message.channel_id))
                        return "channel_id: string expected";
                return null;
            };
    
            /**
             * Creates a ChannelInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChannelInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChannelInfo} ChannelInfo
             */
            ChannelInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChannelInfo)
                    return object;
                var message = new $root.protos.ChannelInfo();
                if (object.channel_id != null)
                    message.channel_id = String(object.channel_id);
                return message;
            };
    
            /**
             * Creates a plain object from a ChannelInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChannelInfo
             * @static
             * @param {protos.ChannelInfo} message ChannelInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.channel_id = "";
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    object.channel_id = message.channel_id;
                return object;
            };
    
            /**
             * Converts this ChannelInfo to JSON.
             * @function toJSON
             * @memberof protos.ChannelInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChannelInfo;
        })();
    
        protos.SignedChaincodeDeploymentSpec = (function() {
    
            /**
             * Properties of a SignedChaincodeDeploymentSpec.
             * @memberof protos
             * @interface ISignedChaincodeDeploymentSpec
             * @property {Uint8Array|null} [chaincode_deployment_spec] SignedChaincodeDeploymentSpec chaincode_deployment_spec
             * @property {Uint8Array|null} [instantiation_policy] SignedChaincodeDeploymentSpec instantiation_policy
             * @property {Array.<protos.IEndorsement>|null} [owner_endorsements] SignedChaincodeDeploymentSpec owner_endorsements
             */
    
            /**
             * Constructs a new SignedChaincodeDeploymentSpec.
             * @memberof protos
             * @classdesc Represents a SignedChaincodeDeploymentSpec.
             * @implements ISignedChaincodeDeploymentSpec
             * @constructor
             * @param {protos.ISignedChaincodeDeploymentSpec=} [properties] Properties to set
             */
            function SignedChaincodeDeploymentSpec(properties) {
                this.owner_endorsements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignedChaincodeDeploymentSpec chaincode_deployment_spec.
             * @member {Uint8Array} chaincode_deployment_spec
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @instance
             */
            SignedChaincodeDeploymentSpec.prototype.chaincode_deployment_spec = $util.newBuffer([]);
    
            /**
             * SignedChaincodeDeploymentSpec instantiation_policy.
             * @member {Uint8Array} instantiation_policy
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @instance
             */
            SignedChaincodeDeploymentSpec.prototype.instantiation_policy = $util.newBuffer([]);
    
            /**
             * SignedChaincodeDeploymentSpec owner_endorsements.
             * @member {Array.<protos.IEndorsement>} owner_endorsements
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @instance
             */
            SignedChaincodeDeploymentSpec.prototype.owner_endorsements = $util.emptyArray;
    
            /**
             * Creates a new SignedChaincodeDeploymentSpec instance using the specified properties.
             * @function create
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {protos.ISignedChaincodeDeploymentSpec=} [properties] Properties to set
             * @returns {protos.SignedChaincodeDeploymentSpec} SignedChaincodeDeploymentSpec instance
             */
            SignedChaincodeDeploymentSpec.create = function create(properties) {
                return new SignedChaincodeDeploymentSpec(properties);
            };
    
            /**
             * Encodes the specified SignedChaincodeDeploymentSpec message. Does not implicitly {@link protos.SignedChaincodeDeploymentSpec.verify|verify} messages.
             * @function encode
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {protos.ISignedChaincodeDeploymentSpec} message SignedChaincodeDeploymentSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedChaincodeDeploymentSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_deployment_spec != null && Object.hasOwnProperty.call(message, "chaincode_deployment_spec"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chaincode_deployment_spec);
                if (message.instantiation_policy != null && Object.hasOwnProperty.call(message, "instantiation_policy"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.instantiation_policy);
                if (message.owner_endorsements != null && message.owner_endorsements.length)
                    for (var i = 0; i < message.owner_endorsements.length; ++i)
                        $root.protos.Endorsement.encode(message.owner_endorsements[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SignedChaincodeDeploymentSpec message, length delimited. Does not implicitly {@link protos.SignedChaincodeDeploymentSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {protos.ISignedChaincodeDeploymentSpec} message SignedChaincodeDeploymentSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedChaincodeDeploymentSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedChaincodeDeploymentSpec message from the specified reader or buffer.
             * @function decode
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.SignedChaincodeDeploymentSpec} SignedChaincodeDeploymentSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedChaincodeDeploymentSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.SignedChaincodeDeploymentSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_deployment_spec = reader.bytes();
                        break;
                    case 2:
                        message.instantiation_policy = reader.bytes();
                        break;
                    case 3:
                        if (!(message.owner_endorsements && message.owner_endorsements.length))
                            message.owner_endorsements = [];
                        message.owner_endorsements.push($root.protos.Endorsement.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignedChaincodeDeploymentSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.SignedChaincodeDeploymentSpec} SignedChaincodeDeploymentSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedChaincodeDeploymentSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedChaincodeDeploymentSpec message.
             * @function verify
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignedChaincodeDeploymentSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_deployment_spec != null && message.hasOwnProperty("chaincode_deployment_spec"))
                    if (!(message.chaincode_deployment_spec && typeof message.chaincode_deployment_spec.length === "number" || $util.isString(message.chaincode_deployment_spec)))
                        return "chaincode_deployment_spec: buffer expected";
                if (message.instantiation_policy != null && message.hasOwnProperty("instantiation_policy"))
                    if (!(message.instantiation_policy && typeof message.instantiation_policy.length === "number" || $util.isString(message.instantiation_policy)))
                        return "instantiation_policy: buffer expected";
                if (message.owner_endorsements != null && message.hasOwnProperty("owner_endorsements")) {
                    if (!Array.isArray(message.owner_endorsements))
                        return "owner_endorsements: array expected";
                    for (var i = 0; i < message.owner_endorsements.length; ++i) {
                        var error = $root.protos.Endorsement.verify(message.owner_endorsements[i]);
                        if (error)
                            return "owner_endorsements." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SignedChaincodeDeploymentSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.SignedChaincodeDeploymentSpec} SignedChaincodeDeploymentSpec
             */
            SignedChaincodeDeploymentSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.SignedChaincodeDeploymentSpec)
                    return object;
                var message = new $root.protos.SignedChaincodeDeploymentSpec();
                if (object.chaincode_deployment_spec != null)
                    if (typeof object.chaincode_deployment_spec === "string")
                        $util.base64.decode(object.chaincode_deployment_spec, message.chaincode_deployment_spec = $util.newBuffer($util.base64.length(object.chaincode_deployment_spec)), 0);
                    else if (object.chaincode_deployment_spec.length)
                        message.chaincode_deployment_spec = object.chaincode_deployment_spec;
                if (object.instantiation_policy != null)
                    if (typeof object.instantiation_policy === "string")
                        $util.base64.decode(object.instantiation_policy, message.instantiation_policy = $util.newBuffer($util.base64.length(object.instantiation_policy)), 0);
                    else if (object.instantiation_policy.length)
                        message.instantiation_policy = object.instantiation_policy;
                if (object.owner_endorsements) {
                    if (!Array.isArray(object.owner_endorsements))
                        throw TypeError(".protos.SignedChaincodeDeploymentSpec.owner_endorsements: array expected");
                    message.owner_endorsements = [];
                    for (var i = 0; i < object.owner_endorsements.length; ++i) {
                        if (typeof object.owner_endorsements[i] !== "object")
                            throw TypeError(".protos.SignedChaincodeDeploymentSpec.owner_endorsements: object expected");
                        message.owner_endorsements[i] = $root.protos.Endorsement.fromObject(object.owner_endorsements[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SignedChaincodeDeploymentSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {protos.SignedChaincodeDeploymentSpec} message SignedChaincodeDeploymentSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedChaincodeDeploymentSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.owner_endorsements = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.chaincode_deployment_spec = "";
                    else {
                        object.chaincode_deployment_spec = [];
                        if (options.bytes !== Array)
                            object.chaincode_deployment_spec = $util.newBuffer(object.chaincode_deployment_spec);
                    }
                    if (options.bytes === String)
                        object.instantiation_policy = "";
                    else {
                        object.instantiation_policy = [];
                        if (options.bytes !== Array)
                            object.instantiation_policy = $util.newBuffer(object.instantiation_policy);
                    }
                }
                if (message.chaincode_deployment_spec != null && message.hasOwnProperty("chaincode_deployment_spec"))
                    object.chaincode_deployment_spec = options.bytes === String ? $util.base64.encode(message.chaincode_deployment_spec, 0, message.chaincode_deployment_spec.length) : options.bytes === Array ? Array.prototype.slice.call(message.chaincode_deployment_spec) : message.chaincode_deployment_spec;
                if (message.instantiation_policy != null && message.hasOwnProperty("instantiation_policy"))
                    object.instantiation_policy = options.bytes === String ? $util.base64.encode(message.instantiation_policy, 0, message.instantiation_policy.length) : options.bytes === Array ? Array.prototype.slice.call(message.instantiation_policy) : message.instantiation_policy;
                if (message.owner_endorsements && message.owner_endorsements.length) {
                    object.owner_endorsements = [];
                    for (var j = 0; j < message.owner_endorsements.length; ++j)
                        object.owner_endorsements[j] = $root.protos.Endorsement.toObject(message.owner_endorsements[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SignedChaincodeDeploymentSpec to JSON.
             * @function toJSON
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedChaincodeDeploymentSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedChaincodeDeploymentSpec;
        })();
    
        return protos;
    })();
    
    $root.common = (function() {
    
        /**
         * Namespace common.
         * @exports common
         * @namespace
         */
        var common = {};
    
        common.Policy = (function() {
    
            /**
             * Properties of a Policy.
             * @memberof common
             * @interface IPolicy
             * @property {number|null} [type] Policy type
             * @property {Uint8Array|null} [value] Policy value
             */
    
            /**
             * Constructs a new Policy.
             * @memberof common
             * @classdesc Represents a Policy.
             * @implements IPolicy
             * @constructor
             * @param {common.IPolicy=} [properties] Properties to set
             */
            function Policy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Policy type.
             * @member {number} type
             * @memberof common.Policy
             * @instance
             */
            Policy.prototype.type = 0;
    
            /**
             * Policy value.
             * @member {Uint8Array} value
             * @memberof common.Policy
             * @instance
             */
            Policy.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new Policy instance using the specified properties.
             * @function create
             * @memberof common.Policy
             * @static
             * @param {common.IPolicy=} [properties] Properties to set
             * @returns {common.Policy} Policy instance
             */
            Policy.create = function create(properties) {
                return new Policy(properties);
            };
    
            /**
             * Encodes the specified Policy message. Does not implicitly {@link common.Policy.verify|verify} messages.
             * @function encode
             * @memberof common.Policy
             * @static
             * @param {common.IPolicy} message Policy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Policy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified Policy message, length delimited. Does not implicitly {@link common.Policy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Policy
             * @static
             * @param {common.IPolicy} message Policy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Policy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Policy message from the specified reader or buffer.
             * @function decode
             * @memberof common.Policy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Policy} Policy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Policy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Policy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Policy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Policy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Policy} Policy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Policy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Policy message.
             * @function verify
             * @memberof common.Policy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Policy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a Policy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Policy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Policy} Policy
             */
            Policy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Policy)
                    return object;
                var message = new $root.common.Policy();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a Policy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Policy
             * @static
             * @param {common.Policy} message Policy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Policy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this Policy to JSON.
             * @function toJSON
             * @memberof common.Policy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Policy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * PolicyType enum.
             * @name common.Policy.PolicyType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SIGNATURE=1 SIGNATURE value
             * @property {number} MSP=2 MSP value
             * @property {number} IMPLICIT_META=3 IMPLICIT_META value
             */
            Policy.PolicyType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SIGNATURE"] = 1;
                values[valuesById[2] = "MSP"] = 2;
                values[valuesById[3] = "IMPLICIT_META"] = 3;
                return values;
            })();
    
            return Policy;
        })();
    
        common.SignaturePolicyEnvelope = (function() {
    
            /**
             * Properties of a SignaturePolicyEnvelope.
             * @memberof common
             * @interface ISignaturePolicyEnvelope
             * @property {number|null} [version] SignaturePolicyEnvelope version
             * @property {common.ISignaturePolicy|null} [rule] SignaturePolicyEnvelope rule
             * @property {Array.<common.IMSPPrincipal>|null} [identities] SignaturePolicyEnvelope identities
             */
    
            /**
             * Constructs a new SignaturePolicyEnvelope.
             * @memberof common
             * @classdesc Represents a SignaturePolicyEnvelope.
             * @implements ISignaturePolicyEnvelope
             * @constructor
             * @param {common.ISignaturePolicyEnvelope=} [properties] Properties to set
             */
            function SignaturePolicyEnvelope(properties) {
                this.identities = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignaturePolicyEnvelope version.
             * @member {number} version
             * @memberof common.SignaturePolicyEnvelope
             * @instance
             */
            SignaturePolicyEnvelope.prototype.version = 0;
    
            /**
             * SignaturePolicyEnvelope rule.
             * @member {common.ISignaturePolicy|null|undefined} rule
             * @memberof common.SignaturePolicyEnvelope
             * @instance
             */
            SignaturePolicyEnvelope.prototype.rule = null;
    
            /**
             * SignaturePolicyEnvelope identities.
             * @member {Array.<common.IMSPPrincipal>} identities
             * @memberof common.SignaturePolicyEnvelope
             * @instance
             */
            SignaturePolicyEnvelope.prototype.identities = $util.emptyArray;
    
            /**
             * Creates a new SignaturePolicyEnvelope instance using the specified properties.
             * @function create
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {common.ISignaturePolicyEnvelope=} [properties] Properties to set
             * @returns {common.SignaturePolicyEnvelope} SignaturePolicyEnvelope instance
             */
            SignaturePolicyEnvelope.create = function create(properties) {
                return new SignaturePolicyEnvelope(properties);
            };
    
            /**
             * Encodes the specified SignaturePolicyEnvelope message. Does not implicitly {@link common.SignaturePolicyEnvelope.verify|verify} messages.
             * @function encode
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {common.ISignaturePolicyEnvelope} message SignaturePolicyEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignaturePolicyEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
                if (message.rule != null && Object.hasOwnProperty.call(message, "rule"))
                    $root.common.SignaturePolicy.encode(message.rule, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identities != null && message.identities.length)
                    for (var i = 0; i < message.identities.length; ++i)
                        $root.common.MSPPrincipal.encode(message.identities[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SignaturePolicyEnvelope message, length delimited. Does not implicitly {@link common.SignaturePolicyEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {common.ISignaturePolicyEnvelope} message SignaturePolicyEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignaturePolicyEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignaturePolicyEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.SignaturePolicyEnvelope} SignaturePolicyEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignaturePolicyEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SignaturePolicyEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.int32();
                        break;
                    case 2:
                        message.rule = $root.common.SignaturePolicy.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.identities && message.identities.length))
                            message.identities = [];
                        message.identities.push($root.common.MSPPrincipal.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignaturePolicyEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.SignaturePolicyEnvelope} SignaturePolicyEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignaturePolicyEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignaturePolicyEnvelope message.
             * @function verify
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignaturePolicyEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.rule != null && message.hasOwnProperty("rule")) {
                    var error = $root.common.SignaturePolicy.verify(message.rule);
                    if (error)
                        return "rule." + error;
                }
                if (message.identities != null && message.hasOwnProperty("identities")) {
                    if (!Array.isArray(message.identities))
                        return "identities: array expected";
                    for (var i = 0; i < message.identities.length; ++i) {
                        var error = $root.common.MSPPrincipal.verify(message.identities[i]);
                        if (error)
                            return "identities." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SignaturePolicyEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.SignaturePolicyEnvelope} SignaturePolicyEnvelope
             */
            SignaturePolicyEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.common.SignaturePolicyEnvelope)
                    return object;
                var message = new $root.common.SignaturePolicyEnvelope();
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.rule != null) {
                    if (typeof object.rule !== "object")
                        throw TypeError(".common.SignaturePolicyEnvelope.rule: object expected");
                    message.rule = $root.common.SignaturePolicy.fromObject(object.rule);
                }
                if (object.identities) {
                    if (!Array.isArray(object.identities))
                        throw TypeError(".common.SignaturePolicyEnvelope.identities: array expected");
                    message.identities = [];
                    for (var i = 0; i < object.identities.length; ++i) {
                        if (typeof object.identities[i] !== "object")
                            throw TypeError(".common.SignaturePolicyEnvelope.identities: object expected");
                        message.identities[i] = $root.common.MSPPrincipal.fromObject(object.identities[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SignaturePolicyEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {common.SignaturePolicyEnvelope} message SignaturePolicyEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignaturePolicyEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.identities = [];
                if (options.defaults) {
                    object.version = 0;
                    object.rule = null;
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.rule != null && message.hasOwnProperty("rule"))
                    object.rule = $root.common.SignaturePolicy.toObject(message.rule, options);
                if (message.identities && message.identities.length) {
                    object.identities = [];
                    for (var j = 0; j < message.identities.length; ++j)
                        object.identities[j] = $root.common.MSPPrincipal.toObject(message.identities[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SignaturePolicyEnvelope to JSON.
             * @function toJSON
             * @memberof common.SignaturePolicyEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignaturePolicyEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignaturePolicyEnvelope;
        })();
    
        common.SignaturePolicy = (function() {
    
            /**
             * Properties of a SignaturePolicy.
             * @memberof common
             * @interface ISignaturePolicy
             * @property {number|null} [signed_by] SignaturePolicy signed_by
             * @property {common.SignaturePolicy.INOutOf|null} [n_out_of] SignaturePolicy n_out_of
             */
    
            /**
             * Constructs a new SignaturePolicy.
             * @memberof common
             * @classdesc Represents a SignaturePolicy.
             * @implements ISignaturePolicy
             * @constructor
             * @param {common.ISignaturePolicy=} [properties] Properties to set
             */
            function SignaturePolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignaturePolicy signed_by.
             * @member {number|null|undefined} signed_by
             * @memberof common.SignaturePolicy
             * @instance
             */
            SignaturePolicy.prototype.signed_by = null;
    
            /**
             * SignaturePolicy n_out_of.
             * @member {common.SignaturePolicy.INOutOf|null|undefined} n_out_of
             * @memberof common.SignaturePolicy
             * @instance
             */
            SignaturePolicy.prototype.n_out_of = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * SignaturePolicy Type.
             * @member {"signed_by"|"n_out_of"|undefined} Type
             * @memberof common.SignaturePolicy
             * @instance
             */
            Object.defineProperty(SignaturePolicy.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["signed_by", "n_out_of"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new SignaturePolicy instance using the specified properties.
             * @function create
             * @memberof common.SignaturePolicy
             * @static
             * @param {common.ISignaturePolicy=} [properties] Properties to set
             * @returns {common.SignaturePolicy} SignaturePolicy instance
             */
            SignaturePolicy.create = function create(properties) {
                return new SignaturePolicy(properties);
            };
    
            /**
             * Encodes the specified SignaturePolicy message. Does not implicitly {@link common.SignaturePolicy.verify|verify} messages.
             * @function encode
             * @memberof common.SignaturePolicy
             * @static
             * @param {common.ISignaturePolicy} message SignaturePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignaturePolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signed_by != null && Object.hasOwnProperty.call(message, "signed_by"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signed_by);
                if (message.n_out_of != null && Object.hasOwnProperty.call(message, "n_out_of"))
                    $root.common.SignaturePolicy.NOutOf.encode(message.n_out_of, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SignaturePolicy message, length delimited. Does not implicitly {@link common.SignaturePolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.SignaturePolicy
             * @static
             * @param {common.ISignaturePolicy} message SignaturePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignaturePolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignaturePolicy message from the specified reader or buffer.
             * @function decode
             * @memberof common.SignaturePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.SignaturePolicy} SignaturePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignaturePolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SignaturePolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signed_by = reader.int32();
                        break;
                    case 2:
                        message.n_out_of = $root.common.SignaturePolicy.NOutOf.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignaturePolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.SignaturePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.SignaturePolicy} SignaturePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignaturePolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignaturePolicy message.
             * @function verify
             * @memberof common.SignaturePolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignaturePolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.signed_by != null && message.hasOwnProperty("signed_by")) {
                    properties.Type = 1;
                    if (!$util.isInteger(message.signed_by))
                        return "signed_by: integer expected";
                }
                if (message.n_out_of != null && message.hasOwnProperty("n_out_of")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.common.SignaturePolicy.NOutOf.verify(message.n_out_of);
                        if (error)
                            return "n_out_of." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SignaturePolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.SignaturePolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.SignaturePolicy} SignaturePolicy
             */
            SignaturePolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.SignaturePolicy)
                    return object;
                var message = new $root.common.SignaturePolicy();
                if (object.signed_by != null)
                    message.signed_by = object.signed_by | 0;
                if (object.n_out_of != null) {
                    if (typeof object.n_out_of !== "object")
                        throw TypeError(".common.SignaturePolicy.n_out_of: object expected");
                    message.n_out_of = $root.common.SignaturePolicy.NOutOf.fromObject(object.n_out_of);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SignaturePolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.SignaturePolicy
             * @static
             * @param {common.SignaturePolicy} message SignaturePolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignaturePolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.signed_by != null && message.hasOwnProperty("signed_by")) {
                    object.signed_by = message.signed_by;
                    if (options.oneofs)
                        object.Type = "signed_by";
                }
                if (message.n_out_of != null && message.hasOwnProperty("n_out_of")) {
                    object.n_out_of = $root.common.SignaturePolicy.NOutOf.toObject(message.n_out_of, options);
                    if (options.oneofs)
                        object.Type = "n_out_of";
                }
                return object;
            };
    
            /**
             * Converts this SignaturePolicy to JSON.
             * @function toJSON
             * @memberof common.SignaturePolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignaturePolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            SignaturePolicy.NOutOf = (function() {
    
                /**
                 * Properties of a NOutOf.
                 * @memberof common.SignaturePolicy
                 * @interface INOutOf
                 * @property {number|null} [n] NOutOf n
                 * @property {Array.<common.ISignaturePolicy>|null} [rules] NOutOf rules
                 */
    
                /**
                 * Constructs a new NOutOf.
                 * @memberof common.SignaturePolicy
                 * @classdesc Represents a NOutOf.
                 * @implements INOutOf
                 * @constructor
                 * @param {common.SignaturePolicy.INOutOf=} [properties] Properties to set
                 */
                function NOutOf(properties) {
                    this.rules = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NOutOf n.
                 * @member {number} n
                 * @memberof common.SignaturePolicy.NOutOf
                 * @instance
                 */
                NOutOf.prototype.n = 0;
    
                /**
                 * NOutOf rules.
                 * @member {Array.<common.ISignaturePolicy>} rules
                 * @memberof common.SignaturePolicy.NOutOf
                 * @instance
                 */
                NOutOf.prototype.rules = $util.emptyArray;
    
                /**
                 * Creates a new NOutOf instance using the specified properties.
                 * @function create
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {common.SignaturePolicy.INOutOf=} [properties] Properties to set
                 * @returns {common.SignaturePolicy.NOutOf} NOutOf instance
                 */
                NOutOf.create = function create(properties) {
                    return new NOutOf(properties);
                };
    
                /**
                 * Encodes the specified NOutOf message. Does not implicitly {@link common.SignaturePolicy.NOutOf.verify|verify} messages.
                 * @function encode
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {common.SignaturePolicy.INOutOf} message NOutOf message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NOutOf.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.n != null && Object.hasOwnProperty.call(message, "n"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.n);
                    if (message.rules != null && message.rules.length)
                        for (var i = 0; i < message.rules.length; ++i)
                            $root.common.SignaturePolicy.encode(message.rules[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NOutOf message, length delimited. Does not implicitly {@link common.SignaturePolicy.NOutOf.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {common.SignaturePolicy.INOutOf} message NOutOf message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NOutOf.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NOutOf message from the specified reader or buffer.
                 * @function decode
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {common.SignaturePolicy.NOutOf} NOutOf
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NOutOf.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SignaturePolicy.NOutOf();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.n = reader.int32();
                            break;
                        case 2:
                            if (!(message.rules && message.rules.length))
                                message.rules = [];
                            message.rules.push($root.common.SignaturePolicy.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NOutOf message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {common.SignaturePolicy.NOutOf} NOutOf
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NOutOf.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NOutOf message.
                 * @function verify
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NOutOf.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.n != null && message.hasOwnProperty("n"))
                        if (!$util.isInteger(message.n))
                            return "n: integer expected";
                    if (message.rules != null && message.hasOwnProperty("rules")) {
                        if (!Array.isArray(message.rules))
                            return "rules: array expected";
                        for (var i = 0; i < message.rules.length; ++i) {
                            var error = $root.common.SignaturePolicy.verify(message.rules[i]);
                            if (error)
                                return "rules." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NOutOf message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {common.SignaturePolicy.NOutOf} NOutOf
                 */
                NOutOf.fromObject = function fromObject(object) {
                    if (object instanceof $root.common.SignaturePolicy.NOutOf)
                        return object;
                    var message = new $root.common.SignaturePolicy.NOutOf();
                    if (object.n != null)
                        message.n = object.n | 0;
                    if (object.rules) {
                        if (!Array.isArray(object.rules))
                            throw TypeError(".common.SignaturePolicy.NOutOf.rules: array expected");
                        message.rules = [];
                        for (var i = 0; i < object.rules.length; ++i) {
                            if (typeof object.rules[i] !== "object")
                                throw TypeError(".common.SignaturePolicy.NOutOf.rules: object expected");
                            message.rules[i] = $root.common.SignaturePolicy.fromObject(object.rules[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NOutOf message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {common.SignaturePolicy.NOutOf} message NOutOf
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NOutOf.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rules = [];
                    if (options.defaults)
                        object.n = 0;
                    if (message.n != null && message.hasOwnProperty("n"))
                        object.n = message.n;
                    if (message.rules && message.rules.length) {
                        object.rules = [];
                        for (var j = 0; j < message.rules.length; ++j)
                            object.rules[j] = $root.common.SignaturePolicy.toObject(message.rules[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NOutOf to JSON.
                 * @function toJSON
                 * @memberof common.SignaturePolicy.NOutOf
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NOutOf.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NOutOf;
            })();
    
            return SignaturePolicy;
        })();
    
        common.ImplicitMetaPolicy = (function() {
    
            /**
             * Properties of an ImplicitMetaPolicy.
             * @memberof common
             * @interface IImplicitMetaPolicy
             * @property {string|null} [sub_policy] ImplicitMetaPolicy sub_policy
             * @property {common.ImplicitMetaPolicy.Rule|null} [rule] ImplicitMetaPolicy rule
             */
    
            /**
             * Constructs a new ImplicitMetaPolicy.
             * @memberof common
             * @classdesc Represents an ImplicitMetaPolicy.
             * @implements IImplicitMetaPolicy
             * @constructor
             * @param {common.IImplicitMetaPolicy=} [properties] Properties to set
             */
            function ImplicitMetaPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ImplicitMetaPolicy sub_policy.
             * @member {string} sub_policy
             * @memberof common.ImplicitMetaPolicy
             * @instance
             */
            ImplicitMetaPolicy.prototype.sub_policy = "";
    
            /**
             * ImplicitMetaPolicy rule.
             * @member {common.ImplicitMetaPolicy.Rule} rule
             * @memberof common.ImplicitMetaPolicy
             * @instance
             */
            ImplicitMetaPolicy.prototype.rule = 0;
    
            /**
             * Creates a new ImplicitMetaPolicy instance using the specified properties.
             * @function create
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {common.IImplicitMetaPolicy=} [properties] Properties to set
             * @returns {common.ImplicitMetaPolicy} ImplicitMetaPolicy instance
             */
            ImplicitMetaPolicy.create = function create(properties) {
                return new ImplicitMetaPolicy(properties);
            };
    
            /**
             * Encodes the specified ImplicitMetaPolicy message. Does not implicitly {@link common.ImplicitMetaPolicy.verify|verify} messages.
             * @function encode
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {common.IImplicitMetaPolicy} message ImplicitMetaPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplicitMetaPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sub_policy != null && Object.hasOwnProperty.call(message, "sub_policy"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sub_policy);
                if (message.rule != null && Object.hasOwnProperty.call(message, "rule"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rule);
                return writer;
            };
    
            /**
             * Encodes the specified ImplicitMetaPolicy message, length delimited. Does not implicitly {@link common.ImplicitMetaPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {common.IImplicitMetaPolicy} message ImplicitMetaPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplicitMetaPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ImplicitMetaPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ImplicitMetaPolicy} ImplicitMetaPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplicitMetaPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ImplicitMetaPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sub_policy = reader.string();
                        break;
                    case 2:
                        message.rule = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ImplicitMetaPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ImplicitMetaPolicy} ImplicitMetaPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplicitMetaPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ImplicitMetaPolicy message.
             * @function verify
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImplicitMetaPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sub_policy != null && message.hasOwnProperty("sub_policy"))
                    if (!$util.isString(message.sub_policy))
                        return "sub_policy: string expected";
                if (message.rule != null && message.hasOwnProperty("rule"))
                    switch (message.rule) {
                    default:
                        return "rule: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates an ImplicitMetaPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ImplicitMetaPolicy} ImplicitMetaPolicy
             */
            ImplicitMetaPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ImplicitMetaPolicy)
                    return object;
                var message = new $root.common.ImplicitMetaPolicy();
                if (object.sub_policy != null)
                    message.sub_policy = String(object.sub_policy);
                switch (object.rule) {
                case "ANY":
                case 0:
                    message.rule = 0;
                    break;
                case "ALL":
                case 1:
                    message.rule = 1;
                    break;
                case "MAJORITY":
                case 2:
                    message.rule = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from an ImplicitMetaPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {common.ImplicitMetaPolicy} message ImplicitMetaPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImplicitMetaPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sub_policy = "";
                    object.rule = options.enums === String ? "ANY" : 0;
                }
                if (message.sub_policy != null && message.hasOwnProperty("sub_policy"))
                    object.sub_policy = message.sub_policy;
                if (message.rule != null && message.hasOwnProperty("rule"))
                    object.rule = options.enums === String ? $root.common.ImplicitMetaPolicy.Rule[message.rule] : message.rule;
                return object;
            };
    
            /**
             * Converts this ImplicitMetaPolicy to JSON.
             * @function toJSON
             * @memberof common.ImplicitMetaPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImplicitMetaPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Rule enum.
             * @name common.ImplicitMetaPolicy.Rule
             * @enum {number}
             * @property {number} ANY=0 ANY value
             * @property {number} ALL=1 ALL value
             * @property {number} MAJORITY=2 MAJORITY value
             */
            ImplicitMetaPolicy.Rule = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ANY"] = 0;
                values[valuesById[1] = "ALL"] = 1;
                values[valuesById[2] = "MAJORITY"] = 2;
                return values;
            })();
    
            return ImplicitMetaPolicy;
        })();
    
        common.ApplicationPolicy = (function() {
    
            /**
             * Properties of an ApplicationPolicy.
             * @memberof common
             * @interface IApplicationPolicy
             * @property {common.ISignaturePolicyEnvelope|null} [signature_policy] ApplicationPolicy signature_policy
             * @property {string|null} [channel_config_policy_reference] ApplicationPolicy channel_config_policy_reference
             */
    
            /**
             * Constructs a new ApplicationPolicy.
             * @memberof common
             * @classdesc Represents an ApplicationPolicy.
             * @implements IApplicationPolicy
             * @constructor
             * @param {common.IApplicationPolicy=} [properties] Properties to set
             */
            function ApplicationPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ApplicationPolicy signature_policy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} signature_policy
             * @memberof common.ApplicationPolicy
             * @instance
             */
            ApplicationPolicy.prototype.signature_policy = null;
    
            /**
             * ApplicationPolicy channel_config_policy_reference.
             * @member {string|null|undefined} channel_config_policy_reference
             * @memberof common.ApplicationPolicy
             * @instance
             */
            ApplicationPolicy.prototype.channel_config_policy_reference = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * ApplicationPolicy Type.
             * @member {"signature_policy"|"channel_config_policy_reference"|undefined} Type
             * @memberof common.ApplicationPolicy
             * @instance
             */
            Object.defineProperty(ApplicationPolicy.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["signature_policy", "channel_config_policy_reference"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new ApplicationPolicy instance using the specified properties.
             * @function create
             * @memberof common.ApplicationPolicy
             * @static
             * @param {common.IApplicationPolicy=} [properties] Properties to set
             * @returns {common.ApplicationPolicy} ApplicationPolicy instance
             */
            ApplicationPolicy.create = function create(properties) {
                return new ApplicationPolicy(properties);
            };
    
            /**
             * Encodes the specified ApplicationPolicy message. Does not implicitly {@link common.ApplicationPolicy.verify|verify} messages.
             * @function encode
             * @memberof common.ApplicationPolicy
             * @static
             * @param {common.IApplicationPolicy} message ApplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplicationPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signature_policy != null && Object.hasOwnProperty.call(message, "signature_policy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.signature_policy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.channel_config_policy_reference != null && Object.hasOwnProperty.call(message, "channel_config_policy_reference"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel_config_policy_reference);
                return writer;
            };
    
            /**
             * Encodes the specified ApplicationPolicy message, length delimited. Does not implicitly {@link common.ApplicationPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ApplicationPolicy
             * @static
             * @param {common.IApplicationPolicy} message ApplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplicationPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ApplicationPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof common.ApplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ApplicationPolicy} ApplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplicationPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ApplicationPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signature_policy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.channel_config_policy_reference = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ApplicationPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ApplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ApplicationPolicy} ApplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplicationPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ApplicationPolicy message.
             * @function verify
             * @memberof common.ApplicationPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApplicationPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.signature_policy != null && message.hasOwnProperty("signature_policy")) {
                    properties.Type = 1;
                    {
                        var error = $root.common.SignaturePolicyEnvelope.verify(message.signature_policy);
                        if (error)
                            return "signature_policy." + error;
                    }
                }
                if (message.channel_config_policy_reference != null && message.hasOwnProperty("channel_config_policy_reference")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    if (!$util.isString(message.channel_config_policy_reference))
                        return "channel_config_policy_reference: string expected";
                }
                return null;
            };
    
            /**
             * Creates an ApplicationPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ApplicationPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ApplicationPolicy} ApplicationPolicy
             */
            ApplicationPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ApplicationPolicy)
                    return object;
                var message = new $root.common.ApplicationPolicy();
                if (object.signature_policy != null) {
                    if (typeof object.signature_policy !== "object")
                        throw TypeError(".common.ApplicationPolicy.signature_policy: object expected");
                    message.signature_policy = $root.common.SignaturePolicyEnvelope.fromObject(object.signature_policy);
                }
                if (object.channel_config_policy_reference != null)
                    message.channel_config_policy_reference = String(object.channel_config_policy_reference);
                return message;
            };
    
            /**
             * Creates a plain object from an ApplicationPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ApplicationPolicy
             * @static
             * @param {common.ApplicationPolicy} message ApplicationPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ApplicationPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.signature_policy != null && message.hasOwnProperty("signature_policy")) {
                    object.signature_policy = $root.common.SignaturePolicyEnvelope.toObject(message.signature_policy, options);
                    if (options.oneofs)
                        object.Type = "signature_policy";
                }
                if (message.channel_config_policy_reference != null && message.hasOwnProperty("channel_config_policy_reference")) {
                    object.channel_config_policy_reference = message.channel_config_policy_reference;
                    if (options.oneofs)
                        object.Type = "channel_config_policy_reference";
                }
                return object;
            };
    
            /**
             * Converts this ApplicationPolicy to JSON.
             * @function toJSON
             * @memberof common.ApplicationPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ApplicationPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ApplicationPolicy;
        })();
    
        common.MSPPrincipal = (function() {
    
            /**
             * Properties of a MSPPrincipal.
             * @memberof common
             * @interface IMSPPrincipal
             * @property {common.MSPPrincipal.Classification|null} [principal_classification] MSPPrincipal principal_classification
             * @property {Uint8Array|null} [principal] MSPPrincipal principal
             */
    
            /**
             * Constructs a new MSPPrincipal.
             * @memberof common
             * @classdesc Represents a MSPPrincipal.
             * @implements IMSPPrincipal
             * @constructor
             * @param {common.IMSPPrincipal=} [properties] Properties to set
             */
            function MSPPrincipal(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MSPPrincipal principal_classification.
             * @member {common.MSPPrincipal.Classification} principal_classification
             * @memberof common.MSPPrincipal
             * @instance
             */
            MSPPrincipal.prototype.principal_classification = 0;
    
            /**
             * MSPPrincipal principal.
             * @member {Uint8Array} principal
             * @memberof common.MSPPrincipal
             * @instance
             */
            MSPPrincipal.prototype.principal = $util.newBuffer([]);
    
            /**
             * Creates a new MSPPrincipal instance using the specified properties.
             * @function create
             * @memberof common.MSPPrincipal
             * @static
             * @param {common.IMSPPrincipal=} [properties] Properties to set
             * @returns {common.MSPPrincipal} MSPPrincipal instance
             */
            MSPPrincipal.create = function create(properties) {
                return new MSPPrincipal(properties);
            };
    
            /**
             * Encodes the specified MSPPrincipal message. Does not implicitly {@link common.MSPPrincipal.verify|verify} messages.
             * @function encode
             * @memberof common.MSPPrincipal
             * @static
             * @param {common.IMSPPrincipal} message MSPPrincipal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPPrincipal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.principal_classification != null && Object.hasOwnProperty.call(message, "principal_classification"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.principal_classification);
                if (message.principal != null && Object.hasOwnProperty.call(message, "principal"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.principal);
                return writer;
            };
    
            /**
             * Encodes the specified MSPPrincipal message, length delimited. Does not implicitly {@link common.MSPPrincipal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.MSPPrincipal
             * @static
             * @param {common.IMSPPrincipal} message MSPPrincipal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPPrincipal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MSPPrincipal message from the specified reader or buffer.
             * @function decode
             * @memberof common.MSPPrincipal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.MSPPrincipal} MSPPrincipal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPPrincipal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MSPPrincipal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.principal_classification = reader.int32();
                        break;
                    case 2:
                        message.principal = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MSPPrincipal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.MSPPrincipal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.MSPPrincipal} MSPPrincipal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPPrincipal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MSPPrincipal message.
             * @function verify
             * @memberof common.MSPPrincipal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MSPPrincipal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.principal_classification != null && message.hasOwnProperty("principal_classification"))
                    switch (message.principal_classification) {
                    default:
                        return "principal_classification: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.principal != null && message.hasOwnProperty("principal"))
                    if (!(message.principal && typeof message.principal.length === "number" || $util.isString(message.principal)))
                        return "principal: buffer expected";
                return null;
            };
    
            /**
             * Creates a MSPPrincipal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.MSPPrincipal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.MSPPrincipal} MSPPrincipal
             */
            MSPPrincipal.fromObject = function fromObject(object) {
                if (object instanceof $root.common.MSPPrincipal)
                    return object;
                var message = new $root.common.MSPPrincipal();
                switch (object.principal_classification) {
                case "ROLE":
                case 0:
                    message.principal_classification = 0;
                    break;
                case "ORGANIZATION_UNIT":
                case 1:
                    message.principal_classification = 1;
                    break;
                case "IDENTITY":
                case 2:
                    message.principal_classification = 2;
                    break;
                case "ANONYMITY":
                case 3:
                    message.principal_classification = 3;
                    break;
                case "COMBINED":
                case 4:
                    message.principal_classification = 4;
                    break;
                }
                if (object.principal != null)
                    if (typeof object.principal === "string")
                        $util.base64.decode(object.principal, message.principal = $util.newBuffer($util.base64.length(object.principal)), 0);
                    else if (object.principal.length)
                        message.principal = object.principal;
                return message;
            };
    
            /**
             * Creates a plain object from a MSPPrincipal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.MSPPrincipal
             * @static
             * @param {common.MSPPrincipal} message MSPPrincipal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MSPPrincipal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.principal_classification = options.enums === String ? "ROLE" : 0;
                    if (options.bytes === String)
                        object.principal = "";
                    else {
                        object.principal = [];
                        if (options.bytes !== Array)
                            object.principal = $util.newBuffer(object.principal);
                    }
                }
                if (message.principal_classification != null && message.hasOwnProperty("principal_classification"))
                    object.principal_classification = options.enums === String ? $root.common.MSPPrincipal.Classification[message.principal_classification] : message.principal_classification;
                if (message.principal != null && message.hasOwnProperty("principal"))
                    object.principal = options.bytes === String ? $util.base64.encode(message.principal, 0, message.principal.length) : options.bytes === Array ? Array.prototype.slice.call(message.principal) : message.principal;
                return object;
            };
    
            /**
             * Converts this MSPPrincipal to JSON.
             * @function toJSON
             * @memberof common.MSPPrincipal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MSPPrincipal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Classification enum.
             * @name common.MSPPrincipal.Classification
             * @enum {number}
             * @property {number} ROLE=0 ROLE value
             * @property {number} ORGANIZATION_UNIT=1 ORGANIZATION_UNIT value
             * @property {number} IDENTITY=2 IDENTITY value
             * @property {number} ANONYMITY=3 ANONYMITY value
             * @property {number} COMBINED=4 COMBINED value
             */
            MSPPrincipal.Classification = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ROLE"] = 0;
                values[valuesById[1] = "ORGANIZATION_UNIT"] = 1;
                values[valuesById[2] = "IDENTITY"] = 2;
                values[valuesById[3] = "ANONYMITY"] = 3;
                values[valuesById[4] = "COMBINED"] = 4;
                return values;
            })();
    
            return MSPPrincipal;
        })();
    
        common.OrganizationUnit = (function() {
    
            /**
             * Properties of an OrganizationUnit.
             * @memberof common
             * @interface IOrganizationUnit
             * @property {string|null} [msp_identifier] OrganizationUnit msp_identifier
             * @property {string|null} [organizational_unit_identifier] OrganizationUnit organizational_unit_identifier
             * @property {Uint8Array|null} [certifiers_identifier] OrganizationUnit certifiers_identifier
             */
    
            /**
             * Constructs a new OrganizationUnit.
             * @memberof common
             * @classdesc Represents an OrganizationUnit.
             * @implements IOrganizationUnit
             * @constructor
             * @param {common.IOrganizationUnit=} [properties] Properties to set
             */
            function OrganizationUnit(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OrganizationUnit msp_identifier.
             * @member {string} msp_identifier
             * @memberof common.OrganizationUnit
             * @instance
             */
            OrganizationUnit.prototype.msp_identifier = "";
    
            /**
             * OrganizationUnit organizational_unit_identifier.
             * @member {string} organizational_unit_identifier
             * @memberof common.OrganizationUnit
             * @instance
             */
            OrganizationUnit.prototype.organizational_unit_identifier = "";
    
            /**
             * OrganizationUnit certifiers_identifier.
             * @member {Uint8Array} certifiers_identifier
             * @memberof common.OrganizationUnit
             * @instance
             */
            OrganizationUnit.prototype.certifiers_identifier = $util.newBuffer([]);
    
            /**
             * Creates a new OrganizationUnit instance using the specified properties.
             * @function create
             * @memberof common.OrganizationUnit
             * @static
             * @param {common.IOrganizationUnit=} [properties] Properties to set
             * @returns {common.OrganizationUnit} OrganizationUnit instance
             */
            OrganizationUnit.create = function create(properties) {
                return new OrganizationUnit(properties);
            };
    
            /**
             * Encodes the specified OrganizationUnit message. Does not implicitly {@link common.OrganizationUnit.verify|verify} messages.
             * @function encode
             * @memberof common.OrganizationUnit
             * @static
             * @param {common.IOrganizationUnit} message OrganizationUnit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrganizationUnit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msp_identifier != null && Object.hasOwnProperty.call(message, "msp_identifier"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.msp_identifier);
                if (message.organizational_unit_identifier != null && Object.hasOwnProperty.call(message, "organizational_unit_identifier"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.organizational_unit_identifier);
                if (message.certifiers_identifier != null && Object.hasOwnProperty.call(message, "certifiers_identifier"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.certifiers_identifier);
                return writer;
            };
    
            /**
             * Encodes the specified OrganizationUnit message, length delimited. Does not implicitly {@link common.OrganizationUnit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.OrganizationUnit
             * @static
             * @param {common.IOrganizationUnit} message OrganizationUnit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrganizationUnit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OrganizationUnit message from the specified reader or buffer.
             * @function decode
             * @memberof common.OrganizationUnit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.OrganizationUnit} OrganizationUnit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrganizationUnit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrganizationUnit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.msp_identifier = reader.string();
                        break;
                    case 2:
                        message.organizational_unit_identifier = reader.string();
                        break;
                    case 3:
                        message.certifiers_identifier = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OrganizationUnit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.OrganizationUnit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.OrganizationUnit} OrganizationUnit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrganizationUnit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OrganizationUnit message.
             * @function verify
             * @memberof common.OrganizationUnit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrganizationUnit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msp_identifier != null && message.hasOwnProperty("msp_identifier"))
                    if (!$util.isString(message.msp_identifier))
                        return "msp_identifier: string expected";
                if (message.organizational_unit_identifier != null && message.hasOwnProperty("organizational_unit_identifier"))
                    if (!$util.isString(message.organizational_unit_identifier))
                        return "organizational_unit_identifier: string expected";
                if (message.certifiers_identifier != null && message.hasOwnProperty("certifiers_identifier"))
                    if (!(message.certifiers_identifier && typeof message.certifiers_identifier.length === "number" || $util.isString(message.certifiers_identifier)))
                        return "certifiers_identifier: buffer expected";
                return null;
            };
    
            /**
             * Creates an OrganizationUnit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.OrganizationUnit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.OrganizationUnit} OrganizationUnit
             */
            OrganizationUnit.fromObject = function fromObject(object) {
                if (object instanceof $root.common.OrganizationUnit)
                    return object;
                var message = new $root.common.OrganizationUnit();
                if (object.msp_identifier != null)
                    message.msp_identifier = String(object.msp_identifier);
                if (object.organizational_unit_identifier != null)
                    message.organizational_unit_identifier = String(object.organizational_unit_identifier);
                if (object.certifiers_identifier != null)
                    if (typeof object.certifiers_identifier === "string")
                        $util.base64.decode(object.certifiers_identifier, message.certifiers_identifier = $util.newBuffer($util.base64.length(object.certifiers_identifier)), 0);
                    else if (object.certifiers_identifier.length)
                        message.certifiers_identifier = object.certifiers_identifier;
                return message;
            };
    
            /**
             * Creates a plain object from an OrganizationUnit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.OrganizationUnit
             * @static
             * @param {common.OrganizationUnit} message OrganizationUnit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrganizationUnit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.msp_identifier = "";
                    object.organizational_unit_identifier = "";
                    if (options.bytes === String)
                        object.certifiers_identifier = "";
                    else {
                        object.certifiers_identifier = [];
                        if (options.bytes !== Array)
                            object.certifiers_identifier = $util.newBuffer(object.certifiers_identifier);
                    }
                }
                if (message.msp_identifier != null && message.hasOwnProperty("msp_identifier"))
                    object.msp_identifier = message.msp_identifier;
                if (message.organizational_unit_identifier != null && message.hasOwnProperty("organizational_unit_identifier"))
                    object.organizational_unit_identifier = message.organizational_unit_identifier;
                if (message.certifiers_identifier != null && message.hasOwnProperty("certifiers_identifier"))
                    object.certifiers_identifier = options.bytes === String ? $util.base64.encode(message.certifiers_identifier, 0, message.certifiers_identifier.length) : options.bytes === Array ? Array.prototype.slice.call(message.certifiers_identifier) : message.certifiers_identifier;
                return object;
            };
    
            /**
             * Converts this OrganizationUnit to JSON.
             * @function toJSON
             * @memberof common.OrganizationUnit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrganizationUnit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OrganizationUnit;
        })();
    
        common.MSPRole = (function() {
    
            /**
             * Properties of a MSPRole.
             * @memberof common
             * @interface IMSPRole
             * @property {string|null} [msp_identifier] MSPRole msp_identifier
             * @property {common.MSPRole.MSPRoleType|null} [role] MSPRole role
             */
    
            /**
             * Constructs a new MSPRole.
             * @memberof common
             * @classdesc Represents a MSPRole.
             * @implements IMSPRole
             * @constructor
             * @param {common.IMSPRole=} [properties] Properties to set
             */
            function MSPRole(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MSPRole msp_identifier.
             * @member {string} msp_identifier
             * @memberof common.MSPRole
             * @instance
             */
            MSPRole.prototype.msp_identifier = "";
    
            /**
             * MSPRole role.
             * @member {common.MSPRole.MSPRoleType} role
             * @memberof common.MSPRole
             * @instance
             */
            MSPRole.prototype.role = 0;
    
            /**
             * Creates a new MSPRole instance using the specified properties.
             * @function create
             * @memberof common.MSPRole
             * @static
             * @param {common.IMSPRole=} [properties] Properties to set
             * @returns {common.MSPRole} MSPRole instance
             */
            MSPRole.create = function create(properties) {
                return new MSPRole(properties);
            };
    
            /**
             * Encodes the specified MSPRole message. Does not implicitly {@link common.MSPRole.verify|verify} messages.
             * @function encode
             * @memberof common.MSPRole
             * @static
             * @param {common.IMSPRole} message MSPRole message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPRole.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msp_identifier != null && Object.hasOwnProperty.call(message, "msp_identifier"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.msp_identifier);
                if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);
                return writer;
            };
    
            /**
             * Encodes the specified MSPRole message, length delimited. Does not implicitly {@link common.MSPRole.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.MSPRole
             * @static
             * @param {common.IMSPRole} message MSPRole message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPRole.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MSPRole message from the specified reader or buffer.
             * @function decode
             * @memberof common.MSPRole
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.MSPRole} MSPRole
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPRole.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MSPRole();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.msp_identifier = reader.string();
                        break;
                    case 2:
                        message.role = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MSPRole message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.MSPRole
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.MSPRole} MSPRole
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPRole.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MSPRole message.
             * @function verify
             * @memberof common.MSPRole
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MSPRole.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msp_identifier != null && message.hasOwnProperty("msp_identifier"))
                    if (!$util.isString(message.msp_identifier))
                        return "msp_identifier: string expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    switch (message.role) {
                    default:
                        return "role: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a MSPRole message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.MSPRole
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.MSPRole} MSPRole
             */
            MSPRole.fromObject = function fromObject(object) {
                if (object instanceof $root.common.MSPRole)
                    return object;
                var message = new $root.common.MSPRole();
                if (object.msp_identifier != null)
                    message.msp_identifier = String(object.msp_identifier);
                switch (object.role) {
                case "MEMBER":
                case 0:
                    message.role = 0;
                    break;
                case "ADMIN":
                case 1:
                    message.role = 1;
                    break;
                case "CLIENT":
                case 2:
                    message.role = 2;
                    break;
                case "PEER":
                case 3:
                    message.role = 3;
                    break;
                case "ORDERER":
                case 4:
                    message.role = 4;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MSPRole message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.MSPRole
             * @static
             * @param {common.MSPRole} message MSPRole
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MSPRole.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.msp_identifier = "";
                    object.role = options.enums === String ? "MEMBER" : 0;
                }
                if (message.msp_identifier != null && message.hasOwnProperty("msp_identifier"))
                    object.msp_identifier = message.msp_identifier;
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = options.enums === String ? $root.common.MSPRole.MSPRoleType[message.role] : message.role;
                return object;
            };
    
            /**
             * Converts this MSPRole to JSON.
             * @function toJSON
             * @memberof common.MSPRole
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MSPRole.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * MSPRoleType enum.
             * @name common.MSPRole.MSPRoleType
             * @enum {number}
             * @property {number} MEMBER=0 MEMBER value
             * @property {number} ADMIN=1 ADMIN value
             * @property {number} CLIENT=2 CLIENT value
             * @property {number} PEER=3 PEER value
             * @property {number} ORDERER=4 ORDERER value
             */
            MSPRole.MSPRoleType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MEMBER"] = 0;
                values[valuesById[1] = "ADMIN"] = 1;
                values[valuesById[2] = "CLIENT"] = 2;
                values[valuesById[3] = "PEER"] = 3;
                values[valuesById[4] = "ORDERER"] = 4;
                return values;
            })();
    
            return MSPRole;
        })();
    
        common.MSPIdentityAnonymity = (function() {
    
            /**
             * Properties of a MSPIdentityAnonymity.
             * @memberof common
             * @interface IMSPIdentityAnonymity
             * @property {common.MSPIdentityAnonymity.MSPIdentityAnonymityType|null} [anonymity_type] MSPIdentityAnonymity anonymity_type
             */
    
            /**
             * Constructs a new MSPIdentityAnonymity.
             * @memberof common
             * @classdesc Represents a MSPIdentityAnonymity.
             * @implements IMSPIdentityAnonymity
             * @constructor
             * @param {common.IMSPIdentityAnonymity=} [properties] Properties to set
             */
            function MSPIdentityAnonymity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MSPIdentityAnonymity anonymity_type.
             * @member {common.MSPIdentityAnonymity.MSPIdentityAnonymityType} anonymity_type
             * @memberof common.MSPIdentityAnonymity
             * @instance
             */
            MSPIdentityAnonymity.prototype.anonymity_type = 0;
    
            /**
             * Creates a new MSPIdentityAnonymity instance using the specified properties.
             * @function create
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {common.IMSPIdentityAnonymity=} [properties] Properties to set
             * @returns {common.MSPIdentityAnonymity} MSPIdentityAnonymity instance
             */
            MSPIdentityAnonymity.create = function create(properties) {
                return new MSPIdentityAnonymity(properties);
            };
    
            /**
             * Encodes the specified MSPIdentityAnonymity message. Does not implicitly {@link common.MSPIdentityAnonymity.verify|verify} messages.
             * @function encode
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {common.IMSPIdentityAnonymity} message MSPIdentityAnonymity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPIdentityAnonymity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.anonymity_type != null && Object.hasOwnProperty.call(message, "anonymity_type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.anonymity_type);
                return writer;
            };
    
            /**
             * Encodes the specified MSPIdentityAnonymity message, length delimited. Does not implicitly {@link common.MSPIdentityAnonymity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {common.IMSPIdentityAnonymity} message MSPIdentityAnonymity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPIdentityAnonymity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MSPIdentityAnonymity message from the specified reader or buffer.
             * @function decode
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.MSPIdentityAnonymity} MSPIdentityAnonymity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPIdentityAnonymity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MSPIdentityAnonymity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.anonymity_type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MSPIdentityAnonymity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.MSPIdentityAnonymity} MSPIdentityAnonymity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPIdentityAnonymity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MSPIdentityAnonymity message.
             * @function verify
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MSPIdentityAnonymity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.anonymity_type != null && message.hasOwnProperty("anonymity_type"))
                    switch (message.anonymity_type) {
                    default:
                        return "anonymity_type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a MSPIdentityAnonymity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.MSPIdentityAnonymity} MSPIdentityAnonymity
             */
            MSPIdentityAnonymity.fromObject = function fromObject(object) {
                if (object instanceof $root.common.MSPIdentityAnonymity)
                    return object;
                var message = new $root.common.MSPIdentityAnonymity();
                switch (object.anonymity_type) {
                case "NOMINAL":
                case 0:
                    message.anonymity_type = 0;
                    break;
                case "ANONYMOUS":
                case 1:
                    message.anonymity_type = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MSPIdentityAnonymity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {common.MSPIdentityAnonymity} message MSPIdentityAnonymity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MSPIdentityAnonymity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.anonymity_type = options.enums === String ? "NOMINAL" : 0;
                if (message.anonymity_type != null && message.hasOwnProperty("anonymity_type"))
                    object.anonymity_type = options.enums === String ? $root.common.MSPIdentityAnonymity.MSPIdentityAnonymityType[message.anonymity_type] : message.anonymity_type;
                return object;
            };
    
            /**
             * Converts this MSPIdentityAnonymity to JSON.
             * @function toJSON
             * @memberof common.MSPIdentityAnonymity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MSPIdentityAnonymity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * MSPIdentityAnonymityType enum.
             * @name common.MSPIdentityAnonymity.MSPIdentityAnonymityType
             * @enum {number}
             * @property {number} NOMINAL=0 NOMINAL value
             * @property {number} ANONYMOUS=1 ANONYMOUS value
             */
            MSPIdentityAnonymity.MSPIdentityAnonymityType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NOMINAL"] = 0;
                values[valuesById[1] = "ANONYMOUS"] = 1;
                return values;
            })();
    
            return MSPIdentityAnonymity;
        })();
    
        common.CombinedPrincipal = (function() {
    
            /**
             * Properties of a CombinedPrincipal.
             * @memberof common
             * @interface ICombinedPrincipal
             * @property {Array.<common.IMSPPrincipal>|null} [principals] CombinedPrincipal principals
             */
    
            /**
             * Constructs a new CombinedPrincipal.
             * @memberof common
             * @classdesc Represents a CombinedPrincipal.
             * @implements ICombinedPrincipal
             * @constructor
             * @param {common.ICombinedPrincipal=} [properties] Properties to set
             */
            function CombinedPrincipal(properties) {
                this.principals = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CombinedPrincipal principals.
             * @member {Array.<common.IMSPPrincipal>} principals
             * @memberof common.CombinedPrincipal
             * @instance
             */
            CombinedPrincipal.prototype.principals = $util.emptyArray;
    
            /**
             * Creates a new CombinedPrincipal instance using the specified properties.
             * @function create
             * @memberof common.CombinedPrincipal
             * @static
             * @param {common.ICombinedPrincipal=} [properties] Properties to set
             * @returns {common.CombinedPrincipal} CombinedPrincipal instance
             */
            CombinedPrincipal.create = function create(properties) {
                return new CombinedPrincipal(properties);
            };
    
            /**
             * Encodes the specified CombinedPrincipal message. Does not implicitly {@link common.CombinedPrincipal.verify|verify} messages.
             * @function encode
             * @memberof common.CombinedPrincipal
             * @static
             * @param {common.ICombinedPrincipal} message CombinedPrincipal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CombinedPrincipal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.principals != null && message.principals.length)
                    for (var i = 0; i < message.principals.length; ++i)
                        $root.common.MSPPrincipal.encode(message.principals[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CombinedPrincipal message, length delimited. Does not implicitly {@link common.CombinedPrincipal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CombinedPrincipal
             * @static
             * @param {common.ICombinedPrincipal} message CombinedPrincipal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CombinedPrincipal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CombinedPrincipal message from the specified reader or buffer.
             * @function decode
             * @memberof common.CombinedPrincipal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CombinedPrincipal} CombinedPrincipal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CombinedPrincipal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CombinedPrincipal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.principals && message.principals.length))
                            message.principals = [];
                        message.principals.push($root.common.MSPPrincipal.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CombinedPrincipal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CombinedPrincipal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CombinedPrincipal} CombinedPrincipal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CombinedPrincipal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CombinedPrincipal message.
             * @function verify
             * @memberof common.CombinedPrincipal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CombinedPrincipal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.principals != null && message.hasOwnProperty("principals")) {
                    if (!Array.isArray(message.principals))
                        return "principals: array expected";
                    for (var i = 0; i < message.principals.length; ++i) {
                        var error = $root.common.MSPPrincipal.verify(message.principals[i]);
                        if (error)
                            return "principals." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CombinedPrincipal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CombinedPrincipal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CombinedPrincipal} CombinedPrincipal
             */
            CombinedPrincipal.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CombinedPrincipal)
                    return object;
                var message = new $root.common.CombinedPrincipal();
                if (object.principals) {
                    if (!Array.isArray(object.principals))
                        throw TypeError(".common.CombinedPrincipal.principals: array expected");
                    message.principals = [];
                    for (var i = 0; i < object.principals.length; ++i) {
                        if (typeof object.principals[i] !== "object")
                            throw TypeError(".common.CombinedPrincipal.principals: object expected");
                        message.principals[i] = $root.common.MSPPrincipal.fromObject(object.principals[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CombinedPrincipal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CombinedPrincipal
             * @static
             * @param {common.CombinedPrincipal} message CombinedPrincipal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CombinedPrincipal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.principals = [];
                if (message.principals && message.principals.length) {
                    object.principals = [];
                    for (var j = 0; j < message.principals.length; ++j)
                        object.principals[j] = $root.common.MSPPrincipal.toObject(message.principals[j], options);
                }
                return object;
            };
    
            /**
             * Converts this CombinedPrincipal to JSON.
             * @function toJSON
             * @memberof common.CombinedPrincipal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CombinedPrincipal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CombinedPrincipal;
        })();
    
        /**
         * Status enum.
         * @name common.Status
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SUCCESS=200 SUCCESS value
         * @property {number} BAD_REQUEST=400 BAD_REQUEST value
         * @property {number} FORBIDDEN=403 FORBIDDEN value
         * @property {number} NOT_FOUND=404 NOT_FOUND value
         * @property {number} REQUEST_ENTITY_TOO_LARGE=413 REQUEST_ENTITY_TOO_LARGE value
         * @property {number} INTERNAL_SERVER_ERROR=500 INTERNAL_SERVER_ERROR value
         * @property {number} NOT_IMPLEMENTED=501 NOT_IMPLEMENTED value
         * @property {number} SERVICE_UNAVAILABLE=503 SERVICE_UNAVAILABLE value
         */
        common.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[200] = "SUCCESS"] = 200;
            values[valuesById[400] = "BAD_REQUEST"] = 400;
            values[valuesById[403] = "FORBIDDEN"] = 403;
            values[valuesById[404] = "NOT_FOUND"] = 404;
            values[valuesById[413] = "REQUEST_ENTITY_TOO_LARGE"] = 413;
            values[valuesById[500] = "INTERNAL_SERVER_ERROR"] = 500;
            values[valuesById[501] = "NOT_IMPLEMENTED"] = 501;
            values[valuesById[503] = "SERVICE_UNAVAILABLE"] = 503;
            return values;
        })();
    
        /**
         * HeaderType enum.
         * @name common.HeaderType
         * @enum {number}
         * @property {number} MESSAGE=0 MESSAGE value
         * @property {number} CONFIG=1 CONFIG value
         * @property {number} CONFIG_UPDATE=2 CONFIG_UPDATE value
         * @property {number} ENDORSER_TRANSACTION=3 ENDORSER_TRANSACTION value
         * @property {number} ORDERER_TRANSACTION=4 ORDERER_TRANSACTION value
         * @property {number} DELIVER_SEEK_INFO=5 DELIVER_SEEK_INFO value
         * @property {number} CHAINCODE_PACKAGE=6 CHAINCODE_PACKAGE value
         * @property {number} PEER_ADMIN_OPERATION=8 PEER_ADMIN_OPERATION value
         */
        common.HeaderType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MESSAGE"] = 0;
            values[valuesById[1] = "CONFIG"] = 1;
            values[valuesById[2] = "CONFIG_UPDATE"] = 2;
            values[valuesById[3] = "ENDORSER_TRANSACTION"] = 3;
            values[valuesById[4] = "ORDERER_TRANSACTION"] = 4;
            values[valuesById[5] = "DELIVER_SEEK_INFO"] = 5;
            values[valuesById[6] = "CHAINCODE_PACKAGE"] = 6;
            values[valuesById[8] = "PEER_ADMIN_OPERATION"] = 8;
            return values;
        })();
    
        /**
         * BlockMetadataIndex enum.
         * @name common.BlockMetadataIndex
         * @enum {number}
         * @property {number} SIGNATURES=0 SIGNATURES value
         * @property {number} LAST_CONFIG=1 LAST_CONFIG value
         * @property {number} TRANSACTIONS_FILTER=2 TRANSACTIONS_FILTER value
         * @property {number} ORDERER=3 ORDERER value
         * @property {number} COMMIT_HASH=4 COMMIT_HASH value
         */
        common.BlockMetadataIndex = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SIGNATURES"] = 0;
            values[valuesById[1] = "LAST_CONFIG"] = 1;
            values[valuesById[2] = "TRANSACTIONS_FILTER"] = 2;
            values[valuesById[3] = "ORDERER"] = 3;
            values[valuesById[4] = "COMMIT_HASH"] = 4;
            return values;
        })();
    
        common.LastConfig = (function() {
    
            /**
             * Properties of a LastConfig.
             * @memberof common
             * @interface ILastConfig
             * @property {number|Long|null} [index] LastConfig index
             */
    
            /**
             * Constructs a new LastConfig.
             * @memberof common
             * @classdesc Represents a LastConfig.
             * @implements ILastConfig
             * @constructor
             * @param {common.ILastConfig=} [properties] Properties to set
             */
            function LastConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LastConfig index.
             * @member {number|Long} index
             * @memberof common.LastConfig
             * @instance
             */
            LastConfig.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new LastConfig instance using the specified properties.
             * @function create
             * @memberof common.LastConfig
             * @static
             * @param {common.ILastConfig=} [properties] Properties to set
             * @returns {common.LastConfig} LastConfig instance
             */
            LastConfig.create = function create(properties) {
                return new LastConfig(properties);
            };
    
            /**
             * Encodes the specified LastConfig message. Does not implicitly {@link common.LastConfig.verify|verify} messages.
             * @function encode
             * @memberof common.LastConfig
             * @static
             * @param {common.ILastConfig} message LastConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LastConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.index);
                return writer;
            };
    
            /**
             * Encodes the specified LastConfig message, length delimited. Does not implicitly {@link common.LastConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.LastConfig
             * @static
             * @param {common.ILastConfig} message LastConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LastConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LastConfig message from the specified reader or buffer.
             * @function decode
             * @memberof common.LastConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.LastConfig} LastConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LastConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.LastConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.index = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LastConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.LastConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.LastConfig} LastConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LastConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LastConfig message.
             * @function verify
             * @memberof common.LastConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LastConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                        return "index: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a LastConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.LastConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.LastConfig} LastConfig
             */
            LastConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.common.LastConfig)
                    return object;
                var message = new $root.common.LastConfig();
                if (object.index != null)
                    if ($util.Long)
                        (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                    else if (typeof object.index === "string")
                        message.index = parseInt(object.index, 10);
                    else if (typeof object.index === "number")
                        message.index = object.index;
                    else if (typeof object.index === "object")
                        message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a LastConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.LastConfig
             * @static
             * @param {common.LastConfig} message LastConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LastConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.index = options.longs === String ? "0" : 0;
                if (message.index != null && message.hasOwnProperty("index"))
                    if (typeof message.index === "number")
                        object.index = options.longs === String ? String(message.index) : message.index;
                    else
                        object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
                return object;
            };
    
            /**
             * Converts this LastConfig to JSON.
             * @function toJSON
             * @memberof common.LastConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LastConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LastConfig;
        })();
    
        common.Metadata = (function() {
    
            /**
             * Properties of a Metadata.
             * @memberof common
             * @interface IMetadata
             * @property {Uint8Array|null} [value] Metadata value
             * @property {Array.<common.IMetadataSignature>|null} [signatures] Metadata signatures
             */
    
            /**
             * Constructs a new Metadata.
             * @memberof common
             * @classdesc Represents a Metadata.
             * @implements IMetadata
             * @constructor
             * @param {common.IMetadata=} [properties] Properties to set
             */
            function Metadata(properties) {
                this.signatures = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Metadata value.
             * @member {Uint8Array} value
             * @memberof common.Metadata
             * @instance
             */
            Metadata.prototype.value = $util.newBuffer([]);
    
            /**
             * Metadata signatures.
             * @member {Array.<common.IMetadataSignature>} signatures
             * @memberof common.Metadata
             * @instance
             */
            Metadata.prototype.signatures = $util.emptyArray;
    
            /**
             * Creates a new Metadata instance using the specified properties.
             * @function create
             * @memberof common.Metadata
             * @static
             * @param {common.IMetadata=} [properties] Properties to set
             * @returns {common.Metadata} Metadata instance
             */
            Metadata.create = function create(properties) {
                return new Metadata(properties);
            };
    
            /**
             * Encodes the specified Metadata message. Does not implicitly {@link common.Metadata.verify|verify} messages.
             * @function encode
             * @memberof common.Metadata
             * @static
             * @param {common.IMetadata} message Metadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Metadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                if (message.signatures != null && message.signatures.length)
                    for (var i = 0; i < message.signatures.length; ++i)
                        $root.common.MetadataSignature.encode(message.signatures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Metadata message, length delimited. Does not implicitly {@link common.Metadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Metadata
             * @static
             * @param {common.IMetadata} message Metadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Metadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Metadata message from the specified reader or buffer.
             * @function decode
             * @memberof common.Metadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Metadata} Metadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Metadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Metadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    case 2:
                        if (!(message.signatures && message.signatures.length))
                            message.signatures = [];
                        message.signatures.push($root.common.MetadataSignature.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Metadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Metadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Metadata} Metadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Metadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Metadata message.
             * @function verify
             * @memberof common.Metadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Metadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.signatures != null && message.hasOwnProperty("signatures")) {
                    if (!Array.isArray(message.signatures))
                        return "signatures: array expected";
                    for (var i = 0; i < message.signatures.length; ++i) {
                        var error = $root.common.MetadataSignature.verify(message.signatures[i]);
                        if (error)
                            return "signatures." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Metadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Metadata} Metadata
             */
            Metadata.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Metadata)
                    return object;
                var message = new $root.common.Metadata();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.signatures) {
                    if (!Array.isArray(object.signatures))
                        throw TypeError(".common.Metadata.signatures: array expected");
                    message.signatures = [];
                    for (var i = 0; i < object.signatures.length; ++i) {
                        if (typeof object.signatures[i] !== "object")
                            throw TypeError(".common.Metadata.signatures: object expected");
                        message.signatures[i] = $root.common.MetadataSignature.fromObject(object.signatures[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Metadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Metadata
             * @static
             * @param {common.Metadata} message Metadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Metadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.signatures = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.signatures && message.signatures.length) {
                    object.signatures = [];
                    for (var j = 0; j < message.signatures.length; ++j)
                        object.signatures[j] = $root.common.MetadataSignature.toObject(message.signatures[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Metadata to JSON.
             * @function toJSON
             * @memberof common.Metadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Metadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Metadata;
        })();
    
        common.MetadataSignature = (function() {
    
            /**
             * Properties of a MetadataSignature.
             * @memberof common
             * @interface IMetadataSignature
             * @property {Uint8Array|null} [signature_header] MetadataSignature signature_header
             * @property {Uint8Array|null} [signature] MetadataSignature signature
             */
    
            /**
             * Constructs a new MetadataSignature.
             * @memberof common
             * @classdesc Represents a MetadataSignature.
             * @implements IMetadataSignature
             * @constructor
             * @param {common.IMetadataSignature=} [properties] Properties to set
             */
            function MetadataSignature(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MetadataSignature signature_header.
             * @member {Uint8Array} signature_header
             * @memberof common.MetadataSignature
             * @instance
             */
            MetadataSignature.prototype.signature_header = $util.newBuffer([]);
    
            /**
             * MetadataSignature signature.
             * @member {Uint8Array} signature
             * @memberof common.MetadataSignature
             * @instance
             */
            MetadataSignature.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new MetadataSignature instance using the specified properties.
             * @function create
             * @memberof common.MetadataSignature
             * @static
             * @param {common.IMetadataSignature=} [properties] Properties to set
             * @returns {common.MetadataSignature} MetadataSignature instance
             */
            MetadataSignature.create = function create(properties) {
                return new MetadataSignature(properties);
            };
    
            /**
             * Encodes the specified MetadataSignature message. Does not implicitly {@link common.MetadataSignature.verify|verify} messages.
             * @function encode
             * @memberof common.MetadataSignature
             * @static
             * @param {common.IMetadataSignature} message MetadataSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataSignature.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signature_header != null && Object.hasOwnProperty.call(message, "signature_header"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature_header);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified MetadataSignature message, length delimited. Does not implicitly {@link common.MetadataSignature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.MetadataSignature
             * @static
             * @param {common.IMetadataSignature} message MetadataSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataSignature.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MetadataSignature message from the specified reader or buffer.
             * @function decode
             * @memberof common.MetadataSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.MetadataSignature} MetadataSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataSignature.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MetadataSignature();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signature_header = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MetadataSignature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.MetadataSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.MetadataSignature} MetadataSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataSignature.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MetadataSignature message.
             * @function verify
             * @memberof common.MetadataSignature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetadataSignature.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.signature_header != null && message.hasOwnProperty("signature_header"))
                    if (!(message.signature_header && typeof message.signature_header.length === "number" || $util.isString(message.signature_header)))
                        return "signature_header: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a MetadataSignature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.MetadataSignature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.MetadataSignature} MetadataSignature
             */
            MetadataSignature.fromObject = function fromObject(object) {
                if (object instanceof $root.common.MetadataSignature)
                    return object;
                var message = new $root.common.MetadataSignature();
                if (object.signature_header != null)
                    if (typeof object.signature_header === "string")
                        $util.base64.decode(object.signature_header, message.signature_header = $util.newBuffer($util.base64.length(object.signature_header)), 0);
                    else if (object.signature_header.length)
                        message.signature_header = object.signature_header;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a MetadataSignature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.MetadataSignature
             * @static
             * @param {common.MetadataSignature} message MetadataSignature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetadataSignature.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.signature_header = "";
                    else {
                        object.signature_header = [];
                        if (options.bytes !== Array)
                            object.signature_header = $util.newBuffer(object.signature_header);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.signature_header != null && message.hasOwnProperty("signature_header"))
                    object.signature_header = options.bytes === String ? $util.base64.encode(message.signature_header, 0, message.signature_header.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature_header) : message.signature_header;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this MetadataSignature to JSON.
             * @function toJSON
             * @memberof common.MetadataSignature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetadataSignature.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MetadataSignature;
        })();
    
        common.Header = (function() {
    
            /**
             * Properties of a Header.
             * @memberof common
             * @interface IHeader
             * @property {Uint8Array|null} [channel_header] Header channel_header
             * @property {Uint8Array|null} [signature_header] Header signature_header
             */
    
            /**
             * Constructs a new Header.
             * @memberof common
             * @classdesc Represents a Header.
             * @implements IHeader
             * @constructor
             * @param {common.IHeader=} [properties] Properties to set
             */
            function Header(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Header channel_header.
             * @member {Uint8Array} channel_header
             * @memberof common.Header
             * @instance
             */
            Header.prototype.channel_header = $util.newBuffer([]);
    
            /**
             * Header signature_header.
             * @member {Uint8Array} signature_header
             * @memberof common.Header
             * @instance
             */
            Header.prototype.signature_header = $util.newBuffer([]);
    
            /**
             * Creates a new Header instance using the specified properties.
             * @function create
             * @memberof common.Header
             * @static
             * @param {common.IHeader=} [properties] Properties to set
             * @returns {common.Header} Header instance
             */
            Header.create = function create(properties) {
                return new Header(properties);
            };
    
            /**
             * Encodes the specified Header message. Does not implicitly {@link common.Header.verify|verify} messages.
             * @function encode
             * @memberof common.Header
             * @static
             * @param {common.IHeader} message Header message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Header.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel_header != null && Object.hasOwnProperty.call(message, "channel_header"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channel_header);
                if (message.signature_header != null && Object.hasOwnProperty.call(message, "signature_header"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature_header);
                return writer;
            };
    
            /**
             * Encodes the specified Header message, length delimited. Does not implicitly {@link common.Header.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Header
             * @static
             * @param {common.IHeader} message Header message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Header.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Header message from the specified reader or buffer.
             * @function decode
             * @memberof common.Header
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Header} Header
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Header.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Header();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel_header = reader.bytes();
                        break;
                    case 2:
                        message.signature_header = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Header message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Header
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Header} Header
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Header.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Header message.
             * @function verify
             * @memberof common.Header
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Header.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel_header != null && message.hasOwnProperty("channel_header"))
                    if (!(message.channel_header && typeof message.channel_header.length === "number" || $util.isString(message.channel_header)))
                        return "channel_header: buffer expected";
                if (message.signature_header != null && message.hasOwnProperty("signature_header"))
                    if (!(message.signature_header && typeof message.signature_header.length === "number" || $util.isString(message.signature_header)))
                        return "signature_header: buffer expected";
                return null;
            };
    
            /**
             * Creates a Header message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Header
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Header} Header
             */
            Header.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Header)
                    return object;
                var message = new $root.common.Header();
                if (object.channel_header != null)
                    if (typeof object.channel_header === "string")
                        $util.base64.decode(object.channel_header, message.channel_header = $util.newBuffer($util.base64.length(object.channel_header)), 0);
                    else if (object.channel_header.length)
                        message.channel_header = object.channel_header;
                if (object.signature_header != null)
                    if (typeof object.signature_header === "string")
                        $util.base64.decode(object.signature_header, message.signature_header = $util.newBuffer($util.base64.length(object.signature_header)), 0);
                    else if (object.signature_header.length)
                        message.signature_header = object.signature_header;
                return message;
            };
    
            /**
             * Creates a plain object from a Header message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Header
             * @static
             * @param {common.Header} message Header
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Header.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.channel_header = "";
                    else {
                        object.channel_header = [];
                        if (options.bytes !== Array)
                            object.channel_header = $util.newBuffer(object.channel_header);
                    }
                    if (options.bytes === String)
                        object.signature_header = "";
                    else {
                        object.signature_header = [];
                        if (options.bytes !== Array)
                            object.signature_header = $util.newBuffer(object.signature_header);
                    }
                }
                if (message.channel_header != null && message.hasOwnProperty("channel_header"))
                    object.channel_header = options.bytes === String ? $util.base64.encode(message.channel_header, 0, message.channel_header.length) : options.bytes === Array ? Array.prototype.slice.call(message.channel_header) : message.channel_header;
                if (message.signature_header != null && message.hasOwnProperty("signature_header"))
                    object.signature_header = options.bytes === String ? $util.base64.encode(message.signature_header, 0, message.signature_header.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature_header) : message.signature_header;
                return object;
            };
    
            /**
             * Converts this Header to JSON.
             * @function toJSON
             * @memberof common.Header
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Header.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Header;
        })();
    
        common.ChannelHeader = (function() {
    
            /**
             * Properties of a ChannelHeader.
             * @memberof common
             * @interface IChannelHeader
             * @property {number|null} [type] ChannelHeader type
             * @property {number|null} [version] ChannelHeader version
             * @property {google.protobuf.ITimestamp|null} [timestamp] ChannelHeader timestamp
             * @property {string|null} [channel_id] ChannelHeader channel_id
             * @property {string|null} [tx_id] ChannelHeader tx_id
             * @property {number|Long|null} [epoch] ChannelHeader epoch
             * @property {Uint8Array|null} [extension] ChannelHeader extension
             * @property {Uint8Array|null} [tls_cert_hash] ChannelHeader tls_cert_hash
             */
    
            /**
             * Constructs a new ChannelHeader.
             * @memberof common
             * @classdesc Represents a ChannelHeader.
             * @implements IChannelHeader
             * @constructor
             * @param {common.IChannelHeader=} [properties] Properties to set
             */
            function ChannelHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChannelHeader type.
             * @member {number} type
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.type = 0;
    
            /**
             * ChannelHeader version.
             * @member {number} version
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.version = 0;
    
            /**
             * ChannelHeader timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.timestamp = null;
    
            /**
             * ChannelHeader channel_id.
             * @member {string} channel_id
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.channel_id = "";
    
            /**
             * ChannelHeader tx_id.
             * @member {string} tx_id
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.tx_id = "";
    
            /**
             * ChannelHeader epoch.
             * @member {number|Long} epoch
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.epoch = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ChannelHeader extension.
             * @member {Uint8Array} extension
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.extension = $util.newBuffer([]);
    
            /**
             * ChannelHeader tls_cert_hash.
             * @member {Uint8Array} tls_cert_hash
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.tls_cert_hash = $util.newBuffer([]);
    
            /**
             * Creates a new ChannelHeader instance using the specified properties.
             * @function create
             * @memberof common.ChannelHeader
             * @static
             * @param {common.IChannelHeader=} [properties] Properties to set
             * @returns {common.ChannelHeader} ChannelHeader instance
             */
            ChannelHeader.create = function create(properties) {
                return new ChannelHeader(properties);
            };
    
            /**
             * Encodes the specified ChannelHeader message. Does not implicitly {@link common.ChannelHeader.verify|verify} messages.
             * @function encode
             * @memberof common.ChannelHeader
             * @static
             * @param {common.IChannelHeader} message ChannelHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.channel_id != null && Object.hasOwnProperty.call(message, "channel_id"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.channel_id);
                if (message.tx_id != null && Object.hasOwnProperty.call(message, "tx_id"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tx_id);
                if (message.epoch != null && Object.hasOwnProperty.call(message, "epoch"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.epoch);
                if (message.extension != null && Object.hasOwnProperty.call(message, "extension"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.extension);
                if (message.tls_cert_hash != null && Object.hasOwnProperty.call(message, "tls_cert_hash"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.tls_cert_hash);
                return writer;
            };
    
            /**
             * Encodes the specified ChannelHeader message, length delimited. Does not implicitly {@link common.ChannelHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ChannelHeader
             * @static
             * @param {common.IChannelHeader} message ChannelHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChannelHeader message from the specified reader or buffer.
             * @function decode
             * @memberof common.ChannelHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ChannelHeader} ChannelHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ChannelHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.version = reader.int32();
                        break;
                    case 3:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.channel_id = reader.string();
                        break;
                    case 5:
                        message.tx_id = reader.string();
                        break;
                    case 6:
                        message.epoch = reader.uint64();
                        break;
                    case 7:
                        message.extension = reader.bytes();
                        break;
                    case 8:
                        message.tls_cert_hash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChannelHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ChannelHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ChannelHeader} ChannelHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChannelHeader message.
             * @function verify
             * @memberof common.ChannelHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (!$util.isString(message.channel_id))
                        return "channel_id: string expected";
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    if (!$util.isString(message.tx_id))
                        return "tx_id: string expected";
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (!$util.isInteger(message.epoch) && !(message.epoch && $util.isInteger(message.epoch.low) && $util.isInteger(message.epoch.high)))
                        return "epoch: integer|Long expected";
                if (message.extension != null && message.hasOwnProperty("extension"))
                    if (!(message.extension && typeof message.extension.length === "number" || $util.isString(message.extension)))
                        return "extension: buffer expected";
                if (message.tls_cert_hash != null && message.hasOwnProperty("tls_cert_hash"))
                    if (!(message.tls_cert_hash && typeof message.tls_cert_hash.length === "number" || $util.isString(message.tls_cert_hash)))
                        return "tls_cert_hash: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChannelHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ChannelHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ChannelHeader} ChannelHeader
             */
            ChannelHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ChannelHeader)
                    return object;
                var message = new $root.common.ChannelHeader();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".common.ChannelHeader.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.channel_id != null)
                    message.channel_id = String(object.channel_id);
                if (object.tx_id != null)
                    message.tx_id = String(object.tx_id);
                if (object.epoch != null)
                    if ($util.Long)
                        (message.epoch = $util.Long.fromValue(object.epoch)).unsigned = true;
                    else if (typeof object.epoch === "string")
                        message.epoch = parseInt(object.epoch, 10);
                    else if (typeof object.epoch === "number")
                        message.epoch = object.epoch;
                    else if (typeof object.epoch === "object")
                        message.epoch = new $util.LongBits(object.epoch.low >>> 0, object.epoch.high >>> 0).toNumber(true);
                if (object.extension != null)
                    if (typeof object.extension === "string")
                        $util.base64.decode(object.extension, message.extension = $util.newBuffer($util.base64.length(object.extension)), 0);
                    else if (object.extension.length)
                        message.extension = object.extension;
                if (object.tls_cert_hash != null)
                    if (typeof object.tls_cert_hash === "string")
                        $util.base64.decode(object.tls_cert_hash, message.tls_cert_hash = $util.newBuffer($util.base64.length(object.tls_cert_hash)), 0);
                    else if (object.tls_cert_hash.length)
                        message.tls_cert_hash = object.tls_cert_hash;
                return message;
            };
    
            /**
             * Creates a plain object from a ChannelHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ChannelHeader
             * @static
             * @param {common.ChannelHeader} message ChannelHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.version = 0;
                    object.timestamp = null;
                    object.channel_id = "";
                    object.tx_id = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.epoch = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.extension = "";
                    else {
                        object.extension = [];
                        if (options.bytes !== Array)
                            object.extension = $util.newBuffer(object.extension);
                    }
                    if (options.bytes === String)
                        object.tls_cert_hash = "";
                    else {
                        object.tls_cert_hash = [];
                        if (options.bytes !== Array)
                            object.tls_cert_hash = $util.newBuffer(object.tls_cert_hash);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    object.channel_id = message.channel_id;
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    object.tx_id = message.tx_id;
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (typeof message.epoch === "number")
                        object.epoch = options.longs === String ? String(message.epoch) : message.epoch;
                    else
                        object.epoch = options.longs === String ? $util.Long.prototype.toString.call(message.epoch) : options.longs === Number ? new $util.LongBits(message.epoch.low >>> 0, message.epoch.high >>> 0).toNumber(true) : message.epoch;
                if (message.extension != null && message.hasOwnProperty("extension"))
                    object.extension = options.bytes === String ? $util.base64.encode(message.extension, 0, message.extension.length) : options.bytes === Array ? Array.prototype.slice.call(message.extension) : message.extension;
                if (message.tls_cert_hash != null && message.hasOwnProperty("tls_cert_hash"))
                    object.tls_cert_hash = options.bytes === String ? $util.base64.encode(message.tls_cert_hash, 0, message.tls_cert_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.tls_cert_hash) : message.tls_cert_hash;
                return object;
            };
    
            /**
             * Converts this ChannelHeader to JSON.
             * @function toJSON
             * @memberof common.ChannelHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChannelHeader;
        })();
    
        common.SignatureHeader = (function() {
    
            /**
             * Properties of a SignatureHeader.
             * @memberof common
             * @interface ISignatureHeader
             * @property {Uint8Array|null} [creator] SignatureHeader creator
             * @property {Uint8Array|null} [nonce] SignatureHeader nonce
             */
    
            /**
             * Constructs a new SignatureHeader.
             * @memberof common
             * @classdesc Represents a SignatureHeader.
             * @implements ISignatureHeader
             * @constructor
             * @param {common.ISignatureHeader=} [properties] Properties to set
             */
            function SignatureHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignatureHeader creator.
             * @member {Uint8Array} creator
             * @memberof common.SignatureHeader
             * @instance
             */
            SignatureHeader.prototype.creator = $util.newBuffer([]);
    
            /**
             * SignatureHeader nonce.
             * @member {Uint8Array} nonce
             * @memberof common.SignatureHeader
             * @instance
             */
            SignatureHeader.prototype.nonce = $util.newBuffer([]);
    
            /**
             * Creates a new SignatureHeader instance using the specified properties.
             * @function create
             * @memberof common.SignatureHeader
             * @static
             * @param {common.ISignatureHeader=} [properties] Properties to set
             * @returns {common.SignatureHeader} SignatureHeader instance
             */
            SignatureHeader.create = function create(properties) {
                return new SignatureHeader(properties);
            };
    
            /**
             * Encodes the specified SignatureHeader message. Does not implicitly {@link common.SignatureHeader.verify|verify} messages.
             * @function encode
             * @memberof common.SignatureHeader
             * @static
             * @param {common.ISignatureHeader} message SignatureHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignatureHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.creator != null && Object.hasOwnProperty.call(message, "creator"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.creator);
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
                return writer;
            };
    
            /**
             * Encodes the specified SignatureHeader message, length delimited. Does not implicitly {@link common.SignatureHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.SignatureHeader
             * @static
             * @param {common.ISignatureHeader} message SignatureHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignatureHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignatureHeader message from the specified reader or buffer.
             * @function decode
             * @memberof common.SignatureHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.SignatureHeader} SignatureHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignatureHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SignatureHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.creator = reader.bytes();
                        break;
                    case 2:
                        message.nonce = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignatureHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.SignatureHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.SignatureHeader} SignatureHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignatureHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignatureHeader message.
             * @function verify
             * @memberof common.SignatureHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignatureHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.creator != null && message.hasOwnProperty("creator"))
                    if (!(message.creator && typeof message.creator.length === "number" || $util.isString(message.creator)))
                        return "creator: buffer expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                        return "nonce: buffer expected";
                return null;
            };
    
            /**
             * Creates a SignatureHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.SignatureHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.SignatureHeader} SignatureHeader
             */
            SignatureHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.common.SignatureHeader)
                    return object;
                var message = new $root.common.SignatureHeader();
                if (object.creator != null)
                    if (typeof object.creator === "string")
                        $util.base64.decode(object.creator, message.creator = $util.newBuffer($util.base64.length(object.creator)), 0);
                    else if (object.creator.length)
                        message.creator = object.creator;
                if (object.nonce != null)
                    if (typeof object.nonce === "string")
                        $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                    else if (object.nonce.length)
                        message.nonce = object.nonce;
                return message;
            };
    
            /**
             * Creates a plain object from a SignatureHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.SignatureHeader
             * @static
             * @param {common.SignatureHeader} message SignatureHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignatureHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.creator = "";
                    else {
                        object.creator = [];
                        if (options.bytes !== Array)
                            object.creator = $util.newBuffer(object.creator);
                    }
                    if (options.bytes === String)
                        object.nonce = "";
                    else {
                        object.nonce = [];
                        if (options.bytes !== Array)
                            object.nonce = $util.newBuffer(object.nonce);
                    }
                }
                if (message.creator != null && message.hasOwnProperty("creator"))
                    object.creator = options.bytes === String ? $util.base64.encode(message.creator, 0, message.creator.length) : options.bytes === Array ? Array.prototype.slice.call(message.creator) : message.creator;
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                return object;
            };
    
            /**
             * Converts this SignatureHeader to JSON.
             * @function toJSON
             * @memberof common.SignatureHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignatureHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignatureHeader;
        })();
    
        common.Payload = (function() {
    
            /**
             * Properties of a Payload.
             * @memberof common
             * @interface IPayload
             * @property {common.IHeader|null} [header] Payload header
             * @property {Uint8Array|null} [data] Payload data
             */
    
            /**
             * Constructs a new Payload.
             * @memberof common
             * @classdesc Represents a Payload.
             * @implements IPayload
             * @constructor
             * @param {common.IPayload=} [properties] Properties to set
             */
            function Payload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Payload header.
             * @member {common.IHeader|null|undefined} header
             * @memberof common.Payload
             * @instance
             */
            Payload.prototype.header = null;
    
            /**
             * Payload data.
             * @member {Uint8Array} data
             * @memberof common.Payload
             * @instance
             */
            Payload.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new Payload instance using the specified properties.
             * @function create
             * @memberof common.Payload
             * @static
             * @param {common.IPayload=} [properties] Properties to set
             * @returns {common.Payload} Payload instance
             */
            Payload.create = function create(properties) {
                return new Payload(properties);
            };
    
            /**
             * Encodes the specified Payload message. Does not implicitly {@link common.Payload.verify|verify} messages.
             * @function encode
             * @memberof common.Payload
             * @static
             * @param {common.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    $root.common.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified Payload message, length delimited. Does not implicitly {@link common.Payload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Payload
             * @static
             * @param {common.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Payload message from the specified reader or buffer.
             * @function decode
             * @memberof common.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Payload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = $root.common.Header.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Payload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Payload message.
             * @function verify
             * @memberof common.Payload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Payload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.common.Header.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };
    
            /**
             * Creates a Payload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Payload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Payload} Payload
             */
            Payload.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Payload)
                    return object;
                var message = new $root.common.Payload();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".common.Payload.header: object expected");
                    message.header = $root.common.Header.fromObject(object.header);
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };
    
            /**
             * Creates a plain object from a Payload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Payload
             * @static
             * @param {common.Payload} message Payload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Payload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.header = null;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.Header.toObject(message.header, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };
    
            /**
             * Converts this Payload to JSON.
             * @function toJSON
             * @memberof common.Payload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Payload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Payload;
        })();
    
        common.Envelope = (function() {
    
            /**
             * Properties of an Envelope.
             * @memberof common
             * @interface IEnvelope
             * @property {Uint8Array|null} [payload] Envelope payload
             * @property {Uint8Array|null} [signature] Envelope signature
             */
    
            /**
             * Constructs a new Envelope.
             * @memberof common
             * @classdesc Represents an Envelope.
             * @implements IEnvelope
             * @constructor
             * @param {common.IEnvelope=} [properties] Properties to set
             */
            function Envelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Envelope payload.
             * @member {Uint8Array} payload
             * @memberof common.Envelope
             * @instance
             */
            Envelope.prototype.payload = $util.newBuffer([]);
    
            /**
             * Envelope signature.
             * @member {Uint8Array} signature
             * @memberof common.Envelope
             * @instance
             */
            Envelope.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new Envelope instance using the specified properties.
             * @function create
             * @memberof common.Envelope
             * @static
             * @param {common.IEnvelope=} [properties] Properties to set
             * @returns {common.Envelope} Envelope instance
             */
            Envelope.create = function create(properties) {
                return new Envelope(properties);
            };
    
            /**
             * Encodes the specified Envelope message. Does not implicitly {@link common.Envelope.verify|verify} messages.
             * @function encode
             * @memberof common.Envelope
             * @static
             * @param {common.IEnvelope} message Envelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Envelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified Envelope message, length delimited. Does not implicitly {@link common.Envelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Envelope
             * @static
             * @param {common.IEnvelope} message Envelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Envelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Envelope message from the specified reader or buffer.
             * @function decode
             * @memberof common.Envelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Envelope} Envelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Envelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Envelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Envelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Envelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Envelope} Envelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Envelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Envelope message.
             * @function verify
             * @memberof common.Envelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Envelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Envelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Envelope} Envelope
             */
            Envelope.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Envelope)
                    return object;
                var message = new $root.common.Envelope();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from an Envelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Envelope
             * @static
             * @param {common.Envelope} message Envelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Envelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this Envelope to JSON.
             * @function toJSON
             * @memberof common.Envelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Envelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Envelope;
        })();
    
        common.Block = (function() {
    
            /**
             * Properties of a Block.
             * @memberof common
             * @interface IBlock
             * @property {common.IBlockHeader|null} [header] Block header
             * @property {common.IBlockData|null} [data] Block data
             * @property {common.IBlockMetadata|null} [metadata] Block metadata
             */
    
            /**
             * Constructs a new Block.
             * @memberof common
             * @classdesc Represents a Block.
             * @implements IBlock
             * @constructor
             * @param {common.IBlock=} [properties] Properties to set
             */
            function Block(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Block header.
             * @member {common.IBlockHeader|null|undefined} header
             * @memberof common.Block
             * @instance
             */
            Block.prototype.header = null;
    
            /**
             * Block data.
             * @member {common.IBlockData|null|undefined} data
             * @memberof common.Block
             * @instance
             */
            Block.prototype.data = null;
    
            /**
             * Block metadata.
             * @member {common.IBlockMetadata|null|undefined} metadata
             * @memberof common.Block
             * @instance
             */
            Block.prototype.metadata = null;
    
            /**
             * Creates a new Block instance using the specified properties.
             * @function create
             * @memberof common.Block
             * @static
             * @param {common.IBlock=} [properties] Properties to set
             * @returns {common.Block} Block instance
             */
            Block.create = function create(properties) {
                return new Block(properties);
            };
    
            /**
             * Encodes the specified Block message. Does not implicitly {@link common.Block.verify|verify} messages.
             * @function encode
             * @memberof common.Block
             * @static
             * @param {common.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    $root.common.BlockHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.common.BlockData.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.common.BlockMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Block message, length delimited. Does not implicitly {@link common.Block.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Block
             * @static
             * @param {common.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Block message from the specified reader or buffer.
             * @function decode
             * @memberof common.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Block();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = $root.common.BlockHeader.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.data = $root.common.BlockData.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.metadata = $root.common.BlockMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Block message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Block message.
             * @function verify
             * @memberof common.Block
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Block.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.common.BlockHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.common.BlockData.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    var error = $root.common.BlockMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };
    
            /**
             * Creates a Block message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Block
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Block} Block
             */
            Block.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Block)
                    return object;
                var message = new $root.common.Block();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".common.Block.header: object expected");
                    message.header = $root.common.BlockHeader.fromObject(object.header);
                }
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".common.Block.data: object expected");
                    message.data = $root.common.BlockData.fromObject(object.data);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".common.Block.metadata: object expected");
                    message.metadata = $root.common.BlockMetadata.fromObject(object.metadata);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Block message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Block
             * @static
             * @param {common.Block} message Block
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Block.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.header = null;
                    object.data = null;
                    object.metadata = null;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.BlockHeader.toObject(message.header, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.common.BlockData.toObject(message.data, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.common.BlockMetadata.toObject(message.metadata, options);
                return object;
            };
    
            /**
             * Converts this Block to JSON.
             * @function toJSON
             * @memberof common.Block
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Block.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Block;
        })();
    
        common.BlockHeader = (function() {
    
            /**
             * Properties of a BlockHeader.
             * @memberof common
             * @interface IBlockHeader
             * @property {number|Long|null} [number] BlockHeader number
             * @property {Uint8Array|null} [previous_hash] BlockHeader previous_hash
             * @property {Uint8Array|null} [data_hash] BlockHeader data_hash
             */
    
            /**
             * Constructs a new BlockHeader.
             * @memberof common
             * @classdesc Represents a BlockHeader.
             * @implements IBlockHeader
             * @constructor
             * @param {common.IBlockHeader=} [properties] Properties to set
             */
            function BlockHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockHeader number.
             * @member {number|Long} number
             * @memberof common.BlockHeader
             * @instance
             */
            BlockHeader.prototype.number = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * BlockHeader previous_hash.
             * @member {Uint8Array} previous_hash
             * @memberof common.BlockHeader
             * @instance
             */
            BlockHeader.prototype.previous_hash = $util.newBuffer([]);
    
            /**
             * BlockHeader data_hash.
             * @member {Uint8Array} data_hash
             * @memberof common.BlockHeader
             * @instance
             */
            BlockHeader.prototype.data_hash = $util.newBuffer([]);
    
            /**
             * Creates a new BlockHeader instance using the specified properties.
             * @function create
             * @memberof common.BlockHeader
             * @static
             * @param {common.IBlockHeader=} [properties] Properties to set
             * @returns {common.BlockHeader} BlockHeader instance
             */
            BlockHeader.create = function create(properties) {
                return new BlockHeader(properties);
            };
    
            /**
             * Encodes the specified BlockHeader message. Does not implicitly {@link common.BlockHeader.verify|verify} messages.
             * @function encode
             * @memberof common.BlockHeader
             * @static
             * @param {common.IBlockHeader} message BlockHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.number);
                if (message.previous_hash != null && Object.hasOwnProperty.call(message, "previous_hash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.previous_hash);
                if (message.data_hash != null && Object.hasOwnProperty.call(message, "data_hash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data_hash);
                return writer;
            };
    
            /**
             * Encodes the specified BlockHeader message, length delimited. Does not implicitly {@link common.BlockHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockHeader
             * @static
             * @param {common.IBlockHeader} message BlockHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockHeader message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockHeader} BlockHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.number = reader.uint64();
                        break;
                    case 2:
                        message.previous_hash = reader.bytes();
                        break;
                    case 3:
                        message.data_hash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockHeader} BlockHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockHeader message.
             * @function verify
             * @memberof common.BlockHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                if (message.previous_hash != null && message.hasOwnProperty("previous_hash"))
                    if (!(message.previous_hash && typeof message.previous_hash.length === "number" || $util.isString(message.previous_hash)))
                        return "previous_hash: buffer expected";
                if (message.data_hash != null && message.hasOwnProperty("data_hash"))
                    if (!(message.data_hash && typeof message.data_hash.length === "number" || $util.isString(message.data_hash)))
                        return "data_hash: buffer expected";
                return null;
            };
    
            /**
             * Creates a BlockHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockHeader} BlockHeader
             */
            BlockHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockHeader)
                    return object;
                var message = new $root.common.BlockHeader();
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = true;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber(true);
                if (object.previous_hash != null)
                    if (typeof object.previous_hash === "string")
                        $util.base64.decode(object.previous_hash, message.previous_hash = $util.newBuffer($util.base64.length(object.previous_hash)), 0);
                    else if (object.previous_hash.length)
                        message.previous_hash = object.previous_hash;
                if (object.data_hash != null)
                    if (typeof object.data_hash === "string")
                        $util.base64.decode(object.data_hash, message.data_hash = $util.newBuffer($util.base64.length(object.data_hash)), 0);
                    else if (object.data_hash.length)
                        message.data_hash = object.data_hash;
                return message;
            };
    
            /**
             * Creates a plain object from a BlockHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockHeader
             * @static
             * @param {common.BlockHeader} message BlockHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.previous_hash = "";
                    else {
                        object.previous_hash = [];
                        if (options.bytes !== Array)
                            object.previous_hash = $util.newBuffer(object.previous_hash);
                    }
                    if (options.bytes === String)
                        object.data_hash = "";
                    else {
                        object.data_hash = [];
                        if (options.bytes !== Array)
                            object.data_hash = $util.newBuffer(object.data_hash);
                    }
                }
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber(true) : message.number;
                if (message.previous_hash != null && message.hasOwnProperty("previous_hash"))
                    object.previous_hash = options.bytes === String ? $util.base64.encode(message.previous_hash, 0, message.previous_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.previous_hash) : message.previous_hash;
                if (message.data_hash != null && message.hasOwnProperty("data_hash"))
                    object.data_hash = options.bytes === String ? $util.base64.encode(message.data_hash, 0, message.data_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.data_hash) : message.data_hash;
                return object;
            };
    
            /**
             * Converts this BlockHeader to JSON.
             * @function toJSON
             * @memberof common.BlockHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockHeader;
        })();
    
        common.BlockData = (function() {
    
            /**
             * Properties of a BlockData.
             * @memberof common
             * @interface IBlockData
             * @property {Array.<Uint8Array>|null} [data] BlockData data
             */
    
            /**
             * Constructs a new BlockData.
             * @memberof common
             * @classdesc Represents a BlockData.
             * @implements IBlockData
             * @constructor
             * @param {common.IBlockData=} [properties] Properties to set
             */
            function BlockData(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockData data.
             * @member {Array.<Uint8Array>} data
             * @memberof common.BlockData
             * @instance
             */
            BlockData.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new BlockData instance using the specified properties.
             * @function create
             * @memberof common.BlockData
             * @static
             * @param {common.IBlockData=} [properties] Properties to set
             * @returns {common.BlockData} BlockData instance
             */
            BlockData.create = function create(properties) {
                return new BlockData(properties);
            };
    
            /**
             * Encodes the specified BlockData message. Does not implicitly {@link common.BlockData.verify|verify} messages.
             * @function encode
             * @memberof common.BlockData
             * @static
             * @param {common.IBlockData} message BlockData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data[i]);
                return writer;
            };
    
            /**
             * Encodes the specified BlockData message, length delimited. Does not implicitly {@link common.BlockData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockData
             * @static
             * @param {common.IBlockData} message BlockData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockData message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockData} BlockData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        message.data.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockData} BlockData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockData message.
             * @function verify
             * @memberof common.BlockData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!(message.data[i] && typeof message.data[i].length === "number" || $util.isString(message.data[i])))
                            return "data: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a BlockData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockData} BlockData
             */
            BlockData.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockData)
                    return object;
                var message = new $root.common.BlockData();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".common.BlockData.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        if (typeof object.data[i] === "string")
                            $util.base64.decode(object.data[i], message.data[i] = $util.newBuffer($util.base64.length(object.data[i])), 0);
                        else if (object.data[i].length)
                            message.data[i] = object.data[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a BlockData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockData
             * @static
             * @param {common.BlockData} message BlockData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = options.bytes === String ? $util.base64.encode(message.data[j], 0, message.data[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.data[j]) : message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this BlockData to JSON.
             * @function toJSON
             * @memberof common.BlockData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockData;
        })();
    
        common.BlockMetadata = (function() {
    
            /**
             * Properties of a BlockMetadata.
             * @memberof common
             * @interface IBlockMetadata
             * @property {Array.<Uint8Array>|null} [metadata] BlockMetadata metadata
             */
    
            /**
             * Constructs a new BlockMetadata.
             * @memberof common
             * @classdesc Represents a BlockMetadata.
             * @implements IBlockMetadata
             * @constructor
             * @param {common.IBlockMetadata=} [properties] Properties to set
             */
            function BlockMetadata(properties) {
                this.metadata = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockMetadata metadata.
             * @member {Array.<Uint8Array>} metadata
             * @memberof common.BlockMetadata
             * @instance
             */
            BlockMetadata.prototype.metadata = $util.emptyArray;
    
            /**
             * Creates a new BlockMetadata instance using the specified properties.
             * @function create
             * @memberof common.BlockMetadata
             * @static
             * @param {common.IBlockMetadata=} [properties] Properties to set
             * @returns {common.BlockMetadata} BlockMetadata instance
             */
            BlockMetadata.create = function create(properties) {
                return new BlockMetadata(properties);
            };
    
            /**
             * Encodes the specified BlockMetadata message. Does not implicitly {@link common.BlockMetadata.verify|verify} messages.
             * @function encode
             * @memberof common.BlockMetadata
             * @static
             * @param {common.IBlockMetadata} message BlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && message.metadata.length)
                    for (var i = 0; i < message.metadata.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.metadata[i]);
                return writer;
            };
    
            /**
             * Encodes the specified BlockMetadata message, length delimited. Does not implicitly {@link common.BlockMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockMetadata
             * @static
             * @param {common.IBlockMetadata} message BlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockMetadata} BlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.metadata && message.metadata.length))
                            message.metadata = [];
                        message.metadata.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockMetadata} BlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockMetadata message.
             * @function verify
             * @memberof common.BlockMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!Array.isArray(message.metadata))
                        return "metadata: array expected";
                    for (var i = 0; i < message.metadata.length; ++i)
                        if (!(message.metadata[i] && typeof message.metadata[i].length === "number" || $util.isString(message.metadata[i])))
                            return "metadata: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a BlockMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockMetadata} BlockMetadata
             */
            BlockMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockMetadata)
                    return object;
                var message = new $root.common.BlockMetadata();
                if (object.metadata) {
                    if (!Array.isArray(object.metadata))
                        throw TypeError(".common.BlockMetadata.metadata: array expected");
                    message.metadata = [];
                    for (var i = 0; i < object.metadata.length; ++i)
                        if (typeof object.metadata[i] === "string")
                            $util.base64.decode(object.metadata[i], message.metadata[i] = $util.newBuffer($util.base64.length(object.metadata[i])), 0);
                        else if (object.metadata[i].length)
                            message.metadata[i] = object.metadata[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a BlockMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockMetadata
             * @static
             * @param {common.BlockMetadata} message BlockMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.metadata = [];
                if (message.metadata && message.metadata.length) {
                    object.metadata = [];
                    for (var j = 0; j < message.metadata.length; ++j)
                        object.metadata[j] = options.bytes === String ? $util.base64.encode(message.metadata[j], 0, message.metadata[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata[j]) : message.metadata[j];
                }
                return object;
            };
    
            /**
             * Converts this BlockMetadata to JSON.
             * @function toJSON
             * @memberof common.BlockMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockMetadata;
        })();
    
        common.OrdererBlockMetadata = (function() {
    
            /**
             * Properties of an OrdererBlockMetadata.
             * @memberof common
             * @interface IOrdererBlockMetadata
             * @property {common.ILastConfig|null} [last_config] OrdererBlockMetadata last_config
             * @property {Uint8Array|null} [consenter_metadata] OrdererBlockMetadata consenter_metadata
             */
    
            /**
             * Constructs a new OrdererBlockMetadata.
             * @memberof common
             * @classdesc Represents an OrdererBlockMetadata.
             * @implements IOrdererBlockMetadata
             * @constructor
             * @param {common.IOrdererBlockMetadata=} [properties] Properties to set
             */
            function OrdererBlockMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OrdererBlockMetadata last_config.
             * @member {common.ILastConfig|null|undefined} last_config
             * @memberof common.OrdererBlockMetadata
             * @instance
             */
            OrdererBlockMetadata.prototype.last_config = null;
    
            /**
             * OrdererBlockMetadata consenter_metadata.
             * @member {Uint8Array} consenter_metadata
             * @memberof common.OrdererBlockMetadata
             * @instance
             */
            OrdererBlockMetadata.prototype.consenter_metadata = $util.newBuffer([]);
    
            /**
             * Creates a new OrdererBlockMetadata instance using the specified properties.
             * @function create
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {common.IOrdererBlockMetadata=} [properties] Properties to set
             * @returns {common.OrdererBlockMetadata} OrdererBlockMetadata instance
             */
            OrdererBlockMetadata.create = function create(properties) {
                return new OrdererBlockMetadata(properties);
            };
    
            /**
             * Encodes the specified OrdererBlockMetadata message. Does not implicitly {@link common.OrdererBlockMetadata.verify|verify} messages.
             * @function encode
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {common.IOrdererBlockMetadata} message OrdererBlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrdererBlockMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.last_config != null && Object.hasOwnProperty.call(message, "last_config"))
                    $root.common.LastConfig.encode(message.last_config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.consenter_metadata != null && Object.hasOwnProperty.call(message, "consenter_metadata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.consenter_metadata);
                return writer;
            };
    
            /**
             * Encodes the specified OrdererBlockMetadata message, length delimited. Does not implicitly {@link common.OrdererBlockMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {common.IOrdererBlockMetadata} message OrdererBlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrdererBlockMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OrdererBlockMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.OrdererBlockMetadata} OrdererBlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrdererBlockMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrdererBlockMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.last_config = $root.common.LastConfig.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.consenter_metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OrdererBlockMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.OrdererBlockMetadata} OrdererBlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrdererBlockMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OrdererBlockMetadata message.
             * @function verify
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrdererBlockMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.last_config != null && message.hasOwnProperty("last_config")) {
                    var error = $root.common.LastConfig.verify(message.last_config);
                    if (error)
                        return "last_config." + error;
                }
                if (message.consenter_metadata != null && message.hasOwnProperty("consenter_metadata"))
                    if (!(message.consenter_metadata && typeof message.consenter_metadata.length === "number" || $util.isString(message.consenter_metadata)))
                        return "consenter_metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates an OrdererBlockMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.OrdererBlockMetadata} OrdererBlockMetadata
             */
            OrdererBlockMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.common.OrdererBlockMetadata)
                    return object;
                var message = new $root.common.OrdererBlockMetadata();
                if (object.last_config != null) {
                    if (typeof object.last_config !== "object")
                        throw TypeError(".common.OrdererBlockMetadata.last_config: object expected");
                    message.last_config = $root.common.LastConfig.fromObject(object.last_config);
                }
                if (object.consenter_metadata != null)
                    if (typeof object.consenter_metadata === "string")
                        $util.base64.decode(object.consenter_metadata, message.consenter_metadata = $util.newBuffer($util.base64.length(object.consenter_metadata)), 0);
                    else if (object.consenter_metadata.length)
                        message.consenter_metadata = object.consenter_metadata;
                return message;
            };
    
            /**
             * Creates a plain object from an OrdererBlockMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {common.OrdererBlockMetadata} message OrdererBlockMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrdererBlockMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.last_config = null;
                    if (options.bytes === String)
                        object.consenter_metadata = "";
                    else {
                        object.consenter_metadata = [];
                        if (options.bytes !== Array)
                            object.consenter_metadata = $util.newBuffer(object.consenter_metadata);
                    }
                }
                if (message.last_config != null && message.hasOwnProperty("last_config"))
                    object.last_config = $root.common.LastConfig.toObject(message.last_config, options);
                if (message.consenter_metadata != null && message.hasOwnProperty("consenter_metadata"))
                    object.consenter_metadata = options.bytes === String ? $util.base64.encode(message.consenter_metadata, 0, message.consenter_metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.consenter_metadata) : message.consenter_metadata;
                return object;
            };
    
            /**
             * Converts this OrdererBlockMetadata to JSON.
             * @function toJSON
             * @memberof common.OrdererBlockMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrdererBlockMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OrdererBlockMetadata;
        })();
    
        common.ConfigEnvelope = (function() {
    
            /**
             * Properties of a ConfigEnvelope.
             * @memberof common
             * @interface IConfigEnvelope
             * @property {common.IConfig|null} [config] ConfigEnvelope config
             * @property {common.IEnvelope|null} [last_update] ConfigEnvelope last_update
             */
    
            /**
             * Constructs a new ConfigEnvelope.
             * @memberof common
             * @classdesc Represents a ConfigEnvelope.
             * @implements IConfigEnvelope
             * @constructor
             * @param {common.IConfigEnvelope=} [properties] Properties to set
             */
            function ConfigEnvelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigEnvelope config.
             * @member {common.IConfig|null|undefined} config
             * @memberof common.ConfigEnvelope
             * @instance
             */
            ConfigEnvelope.prototype.config = null;
    
            /**
             * ConfigEnvelope last_update.
             * @member {common.IEnvelope|null|undefined} last_update
             * @memberof common.ConfigEnvelope
             * @instance
             */
            ConfigEnvelope.prototype.last_update = null;
    
            /**
             * Creates a new ConfigEnvelope instance using the specified properties.
             * @function create
             * @memberof common.ConfigEnvelope
             * @static
             * @param {common.IConfigEnvelope=} [properties] Properties to set
             * @returns {common.ConfigEnvelope} ConfigEnvelope instance
             */
            ConfigEnvelope.create = function create(properties) {
                return new ConfigEnvelope(properties);
            };
    
            /**
             * Encodes the specified ConfigEnvelope message. Does not implicitly {@link common.ConfigEnvelope.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigEnvelope
             * @static
             * @param {common.IConfigEnvelope} message ConfigEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                    $root.common.Config.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.last_update != null && Object.hasOwnProperty.call(message, "last_update"))
                    $root.common.Envelope.encode(message.last_update, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigEnvelope message, length delimited. Does not implicitly {@link common.ConfigEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigEnvelope
             * @static
             * @param {common.IConfigEnvelope} message ConfigEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigEnvelope} ConfigEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.config = $root.common.Config.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.last_update = $root.common.Envelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigEnvelope} ConfigEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigEnvelope message.
             * @function verify
             * @memberof common.ConfigEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.config != null && message.hasOwnProperty("config")) {
                    var error = $root.common.Config.verify(message.config);
                    if (error)
                        return "config." + error;
                }
                if (message.last_update != null && message.hasOwnProperty("last_update")) {
                    var error = $root.common.Envelope.verify(message.last_update);
                    if (error)
                        return "last_update." + error;
                }
                return null;
            };
    
            /**
             * Creates a ConfigEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigEnvelope} ConfigEnvelope
             */
            ConfigEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigEnvelope)
                    return object;
                var message = new $root.common.ConfigEnvelope();
                if (object.config != null) {
                    if (typeof object.config !== "object")
                        throw TypeError(".common.ConfigEnvelope.config: object expected");
                    message.config = $root.common.Config.fromObject(object.config);
                }
                if (object.last_update != null) {
                    if (typeof object.last_update !== "object")
                        throw TypeError(".common.ConfigEnvelope.last_update: object expected");
                    message.last_update = $root.common.Envelope.fromObject(object.last_update);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigEnvelope
             * @static
             * @param {common.ConfigEnvelope} message ConfigEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.config = null;
                    object.last_update = null;
                }
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = $root.common.Config.toObject(message.config, options);
                if (message.last_update != null && message.hasOwnProperty("last_update"))
                    object.last_update = $root.common.Envelope.toObject(message.last_update, options);
                return object;
            };
    
            /**
             * Converts this ConfigEnvelope to JSON.
             * @function toJSON
             * @memberof common.ConfigEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigEnvelope;
        })();
    
        common.Config = (function() {
    
            /**
             * Properties of a Config.
             * @memberof common
             * @interface IConfig
             * @property {number|Long|null} [sequence] Config sequence
             * @property {common.IConfigGroup|null} [channel_group] Config channel_group
             */
    
            /**
             * Constructs a new Config.
             * @memberof common
             * @classdesc Represents a Config.
             * @implements IConfig
             * @constructor
             * @param {common.IConfig=} [properties] Properties to set
             */
            function Config(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Config sequence.
             * @member {number|Long} sequence
             * @memberof common.Config
             * @instance
             */
            Config.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Config channel_group.
             * @member {common.IConfigGroup|null|undefined} channel_group
             * @memberof common.Config
             * @instance
             */
            Config.prototype.channel_group = null;
    
            /**
             * Creates a new Config instance using the specified properties.
             * @function create
             * @memberof common.Config
             * @static
             * @param {common.IConfig=} [properties] Properties to set
             * @returns {common.Config} Config instance
             */
            Config.create = function create(properties) {
                return new Config(properties);
            };
    
            /**
             * Encodes the specified Config message. Does not implicitly {@link common.Config.verify|verify} messages.
             * @function encode
             * @memberof common.Config
             * @static
             * @param {common.IConfig} message Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Config.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sequence);
                if (message.channel_group != null && Object.hasOwnProperty.call(message, "channel_group"))
                    $root.common.ConfigGroup.encode(message.channel_group, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Config message, length delimited. Does not implicitly {@link common.Config.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Config
             * @static
             * @param {common.IConfig} message Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Config.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Config message from the specified reader or buffer.
             * @function decode
             * @memberof common.Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Config} Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Config.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Config();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.uint64();
                        break;
                    case 2:
                        message.channel_group = $root.common.ConfigGroup.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Config message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Config} Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Config.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Config message.
             * @function verify
             * @memberof common.Config
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Config.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.channel_group != null && message.hasOwnProperty("channel_group")) {
                    var error = $root.common.ConfigGroup.verify(message.channel_group);
                    if (error)
                        return "channel_group." + error;
                }
                return null;
            };
    
            /**
             * Creates a Config message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Config
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Config} Config
             */
            Config.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Config)
                    return object;
                var message = new $root.common.Config();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
                if (object.channel_group != null) {
                    if (typeof object.channel_group !== "object")
                        throw TypeError(".common.Config.channel_group: object expected");
                    message.channel_group = $root.common.ConfigGroup.fromObject(object.channel_group);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Config message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Config
             * @static
             * @param {common.Config} message Config
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Config.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.channel_group = null;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true) : message.sequence;
                if (message.channel_group != null && message.hasOwnProperty("channel_group"))
                    object.channel_group = $root.common.ConfigGroup.toObject(message.channel_group, options);
                return object;
            };
    
            /**
             * Converts this Config to JSON.
             * @function toJSON
             * @memberof common.Config
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Config.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Config;
        })();
    
        common.ConfigUpdateEnvelope = (function() {
    
            /**
             * Properties of a ConfigUpdateEnvelope.
             * @memberof common
             * @interface IConfigUpdateEnvelope
             * @property {Uint8Array|null} [config_update] ConfigUpdateEnvelope config_update
             * @property {Array.<common.IConfigSignature>|null} [signatures] ConfigUpdateEnvelope signatures
             */
    
            /**
             * Constructs a new ConfigUpdateEnvelope.
             * @memberof common
             * @classdesc Represents a ConfigUpdateEnvelope.
             * @implements IConfigUpdateEnvelope
             * @constructor
             * @param {common.IConfigUpdateEnvelope=} [properties] Properties to set
             */
            function ConfigUpdateEnvelope(properties) {
                this.signatures = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigUpdateEnvelope config_update.
             * @member {Uint8Array} config_update
             * @memberof common.ConfigUpdateEnvelope
             * @instance
             */
            ConfigUpdateEnvelope.prototype.config_update = $util.newBuffer([]);
    
            /**
             * ConfigUpdateEnvelope signatures.
             * @member {Array.<common.IConfigSignature>} signatures
             * @memberof common.ConfigUpdateEnvelope
             * @instance
             */
            ConfigUpdateEnvelope.prototype.signatures = $util.emptyArray;
    
            /**
             * Creates a new ConfigUpdateEnvelope instance using the specified properties.
             * @function create
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {common.IConfigUpdateEnvelope=} [properties] Properties to set
             * @returns {common.ConfigUpdateEnvelope} ConfigUpdateEnvelope instance
             */
            ConfigUpdateEnvelope.create = function create(properties) {
                return new ConfigUpdateEnvelope(properties);
            };
    
            /**
             * Encodes the specified ConfigUpdateEnvelope message. Does not implicitly {@link common.ConfigUpdateEnvelope.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {common.IConfigUpdateEnvelope} message ConfigUpdateEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigUpdateEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.config_update != null && Object.hasOwnProperty.call(message, "config_update"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.config_update);
                if (message.signatures != null && message.signatures.length)
                    for (var i = 0; i < message.signatures.length; ++i)
                        $root.common.ConfigSignature.encode(message.signatures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigUpdateEnvelope message, length delimited. Does not implicitly {@link common.ConfigUpdateEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {common.IConfigUpdateEnvelope} message ConfigUpdateEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigUpdateEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigUpdateEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigUpdateEnvelope} ConfigUpdateEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigUpdateEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigUpdateEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.config_update = reader.bytes();
                        break;
                    case 2:
                        if (!(message.signatures && message.signatures.length))
                            message.signatures = [];
                        message.signatures.push($root.common.ConfigSignature.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigUpdateEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigUpdateEnvelope} ConfigUpdateEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigUpdateEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigUpdateEnvelope message.
             * @function verify
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigUpdateEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.config_update != null && message.hasOwnProperty("config_update"))
                    if (!(message.config_update && typeof message.config_update.length === "number" || $util.isString(message.config_update)))
                        return "config_update: buffer expected";
                if (message.signatures != null && message.hasOwnProperty("signatures")) {
                    if (!Array.isArray(message.signatures))
                        return "signatures: array expected";
                    for (var i = 0; i < message.signatures.length; ++i) {
                        var error = $root.common.ConfigSignature.verify(message.signatures[i]);
                        if (error)
                            return "signatures." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ConfigUpdateEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigUpdateEnvelope} ConfigUpdateEnvelope
             */
            ConfigUpdateEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigUpdateEnvelope)
                    return object;
                var message = new $root.common.ConfigUpdateEnvelope();
                if (object.config_update != null)
                    if (typeof object.config_update === "string")
                        $util.base64.decode(object.config_update, message.config_update = $util.newBuffer($util.base64.length(object.config_update)), 0);
                    else if (object.config_update.length)
                        message.config_update = object.config_update;
                if (object.signatures) {
                    if (!Array.isArray(object.signatures))
                        throw TypeError(".common.ConfigUpdateEnvelope.signatures: array expected");
                    message.signatures = [];
                    for (var i = 0; i < object.signatures.length; ++i) {
                        if (typeof object.signatures[i] !== "object")
                            throw TypeError(".common.ConfigUpdateEnvelope.signatures: object expected");
                        message.signatures[i] = $root.common.ConfigSignature.fromObject(object.signatures[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigUpdateEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {common.ConfigUpdateEnvelope} message ConfigUpdateEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigUpdateEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.signatures = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.config_update = "";
                    else {
                        object.config_update = [];
                        if (options.bytes !== Array)
                            object.config_update = $util.newBuffer(object.config_update);
                    }
                if (message.config_update != null && message.hasOwnProperty("config_update"))
                    object.config_update = options.bytes === String ? $util.base64.encode(message.config_update, 0, message.config_update.length) : options.bytes === Array ? Array.prototype.slice.call(message.config_update) : message.config_update;
                if (message.signatures && message.signatures.length) {
                    object.signatures = [];
                    for (var j = 0; j < message.signatures.length; ++j)
                        object.signatures[j] = $root.common.ConfigSignature.toObject(message.signatures[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ConfigUpdateEnvelope to JSON.
             * @function toJSON
             * @memberof common.ConfigUpdateEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigUpdateEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigUpdateEnvelope;
        })();
    
        common.ConfigUpdate = (function() {
    
            /**
             * Properties of a ConfigUpdate.
             * @memberof common
             * @interface IConfigUpdate
             * @property {string|null} [channel_id] ConfigUpdate channel_id
             * @property {common.IConfigGroup|null} [read_set] ConfigUpdate read_set
             * @property {common.IConfigGroup|null} [write_set] ConfigUpdate write_set
             * @property {Object.<string,Uint8Array>|null} [isolated_data] ConfigUpdate isolated_data
             */
    
            /**
             * Constructs a new ConfigUpdate.
             * @memberof common
             * @classdesc Represents a ConfigUpdate.
             * @implements IConfigUpdate
             * @constructor
             * @param {common.IConfigUpdate=} [properties] Properties to set
             */
            function ConfigUpdate(properties) {
                this.isolated_data = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigUpdate channel_id.
             * @member {string} channel_id
             * @memberof common.ConfigUpdate
             * @instance
             */
            ConfigUpdate.prototype.channel_id = "";
    
            /**
             * ConfigUpdate read_set.
             * @member {common.IConfigGroup|null|undefined} read_set
             * @memberof common.ConfigUpdate
             * @instance
             */
            ConfigUpdate.prototype.read_set = null;
    
            /**
             * ConfigUpdate write_set.
             * @member {common.IConfigGroup|null|undefined} write_set
             * @memberof common.ConfigUpdate
             * @instance
             */
            ConfigUpdate.prototype.write_set = null;
    
            /**
             * ConfigUpdate isolated_data.
             * @member {Object.<string,Uint8Array>} isolated_data
             * @memberof common.ConfigUpdate
             * @instance
             */
            ConfigUpdate.prototype.isolated_data = $util.emptyObject;
    
            /**
             * Creates a new ConfigUpdate instance using the specified properties.
             * @function create
             * @memberof common.ConfigUpdate
             * @static
             * @param {common.IConfigUpdate=} [properties] Properties to set
             * @returns {common.ConfigUpdate} ConfigUpdate instance
             */
            ConfigUpdate.create = function create(properties) {
                return new ConfigUpdate(properties);
            };
    
            /**
             * Encodes the specified ConfigUpdate message. Does not implicitly {@link common.ConfigUpdate.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigUpdate
             * @static
             * @param {common.IConfigUpdate} message ConfigUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel_id != null && Object.hasOwnProperty.call(message, "channel_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel_id);
                if (message.read_set != null && Object.hasOwnProperty.call(message, "read_set"))
                    $root.common.ConfigGroup.encode(message.read_set, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.write_set != null && Object.hasOwnProperty.call(message, "write_set"))
                    $root.common.ConfigGroup.encode(message.write_set, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.isolated_data != null && Object.hasOwnProperty.call(message, "isolated_data"))
                    for (var keys = Object.keys(message.isolated_data), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.isolated_data[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigUpdate message, length delimited. Does not implicitly {@link common.ConfigUpdate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigUpdate
             * @static
             * @param {common.IConfigUpdate} message ConfigUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigUpdate message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigUpdate} ConfigUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigUpdate(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel_id = reader.string();
                        break;
                    case 2:
                        message.read_set = $root.common.ConfigGroup.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.write_set = $root.common.ConfigGroup.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (message.isolated_data === $util.emptyObject)
                            message.isolated_data = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = [];
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.isolated_data[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigUpdate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigUpdate} ConfigUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigUpdate message.
             * @function verify
             * @memberof common.ConfigUpdate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (!$util.isString(message.channel_id))
                        return "channel_id: string expected";
                if (message.read_set != null && message.hasOwnProperty("read_set")) {
                    var error = $root.common.ConfigGroup.verify(message.read_set);
                    if (error)
                        return "read_set." + error;
                }
                if (message.write_set != null && message.hasOwnProperty("write_set")) {
                    var error = $root.common.ConfigGroup.verify(message.write_set);
                    if (error)
                        return "write_set." + error;
                }
                if (message.isolated_data != null && message.hasOwnProperty("isolated_data")) {
                    if (!$util.isObject(message.isolated_data))
                        return "isolated_data: object expected";
                    var key = Object.keys(message.isolated_data);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.isolated_data[key[i]] && typeof message.isolated_data[key[i]].length === "number" || $util.isString(message.isolated_data[key[i]])))
                            return "isolated_data: buffer{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a ConfigUpdate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigUpdate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigUpdate} ConfigUpdate
             */
            ConfigUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigUpdate)
                    return object;
                var message = new $root.common.ConfigUpdate();
                if (object.channel_id != null)
                    message.channel_id = String(object.channel_id);
                if (object.read_set != null) {
                    if (typeof object.read_set !== "object")
                        throw TypeError(".common.ConfigUpdate.read_set: object expected");
                    message.read_set = $root.common.ConfigGroup.fromObject(object.read_set);
                }
                if (object.write_set != null) {
                    if (typeof object.write_set !== "object")
                        throw TypeError(".common.ConfigUpdate.write_set: object expected");
                    message.write_set = $root.common.ConfigGroup.fromObject(object.write_set);
                }
                if (object.isolated_data) {
                    if (typeof object.isolated_data !== "object")
                        throw TypeError(".common.ConfigUpdate.isolated_data: object expected");
                    message.isolated_data = {};
                    for (var keys = Object.keys(object.isolated_data), i = 0; i < keys.length; ++i)
                        if (typeof object.isolated_data[keys[i]] === "string")
                            $util.base64.decode(object.isolated_data[keys[i]], message.isolated_data[keys[i]] = $util.newBuffer($util.base64.length(object.isolated_data[keys[i]])), 0);
                        else if (object.isolated_data[keys[i]].length)
                            message.isolated_data[keys[i]] = object.isolated_data[keys[i]];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigUpdate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigUpdate
             * @static
             * @param {common.ConfigUpdate} message ConfigUpdate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.isolated_data = {};
                if (options.defaults) {
                    object.channel_id = "";
                    object.read_set = null;
                    object.write_set = null;
                }
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    object.channel_id = message.channel_id;
                if (message.read_set != null && message.hasOwnProperty("read_set"))
                    object.read_set = $root.common.ConfigGroup.toObject(message.read_set, options);
                if (message.write_set != null && message.hasOwnProperty("write_set"))
                    object.write_set = $root.common.ConfigGroup.toObject(message.write_set, options);
                var keys2;
                if (message.isolated_data && (keys2 = Object.keys(message.isolated_data)).length) {
                    object.isolated_data = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.isolated_data[keys2[j]] = options.bytes === String ? $util.base64.encode(message.isolated_data[keys2[j]], 0, message.isolated_data[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.isolated_data[keys2[j]]) : message.isolated_data[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this ConfigUpdate to JSON.
             * @function toJSON
             * @memberof common.ConfigUpdate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigUpdate;
        })();
    
        common.ConfigGroup = (function() {
    
            /**
             * Properties of a ConfigGroup.
             * @memberof common
             * @interface IConfigGroup
             * @property {number|Long|null} [version] ConfigGroup version
             * @property {Object.<string,common.IConfigGroup>|null} [groups] ConfigGroup groups
             * @property {Object.<string,common.IConfigValue>|null} [values] ConfigGroup values
             * @property {Object.<string,common.IConfigPolicy>|null} [policies] ConfigGroup policies
             * @property {string|null} [mod_policy] ConfigGroup mod_policy
             */
    
            /**
             * Constructs a new ConfigGroup.
             * @memberof common
             * @classdesc Represents a ConfigGroup.
             * @implements IConfigGroup
             * @constructor
             * @param {common.IConfigGroup=} [properties] Properties to set
             */
            function ConfigGroup(properties) {
                this.groups = {};
                this.values = {};
                this.policies = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigGroup version.
             * @member {number|Long} version
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ConfigGroup groups.
             * @member {Object.<string,common.IConfigGroup>} groups
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.groups = $util.emptyObject;
    
            /**
             * ConfigGroup values.
             * @member {Object.<string,common.IConfigValue>} values
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.values = $util.emptyObject;
    
            /**
             * ConfigGroup policies.
             * @member {Object.<string,common.IConfigPolicy>} policies
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.policies = $util.emptyObject;
    
            /**
             * ConfigGroup mod_policy.
             * @member {string} mod_policy
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.mod_policy = "";
    
            /**
             * Creates a new ConfigGroup instance using the specified properties.
             * @function create
             * @memberof common.ConfigGroup
             * @static
             * @param {common.IConfigGroup=} [properties] Properties to set
             * @returns {common.ConfigGroup} ConfigGroup instance
             */
            ConfigGroup.create = function create(properties) {
                return new ConfigGroup(properties);
            };
    
            /**
             * Encodes the specified ConfigGroup message. Does not implicitly {@link common.ConfigGroup.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigGroup
             * @static
             * @param {common.IConfigGroup} message ConfigGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigGroup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
                if (message.groups != null && Object.hasOwnProperty.call(message, "groups"))
                    for (var keys = Object.keys(message.groups), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigGroup.encode(message.groups[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.values != null && Object.hasOwnProperty.call(message, "values"))
                    for (var keys = Object.keys(message.values), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigValue.encode(message.values[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.policies != null && Object.hasOwnProperty.call(message, "policies"))
                    for (var keys = Object.keys(message.policies), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigPolicy.encode(message.policies[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.mod_policy != null && Object.hasOwnProperty.call(message, "mod_policy"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.mod_policy);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigGroup message, length delimited. Does not implicitly {@link common.ConfigGroup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigGroup
             * @static
             * @param {common.IConfigGroup} message ConfigGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigGroup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigGroup message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigGroup} ConfigGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigGroup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigGroup(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.uint64();
                        break;
                    case 2:
                        if (message.groups === $util.emptyObject)
                            message.groups = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.common.ConfigGroup.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.groups[key] = value;
                        break;
                    case 3:
                        if (message.values === $util.emptyObject)
                            message.values = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.common.ConfigValue.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.values[key] = value;
                        break;
                    case 4:
                        if (message.policies === $util.emptyObject)
                            message.policies = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.common.ConfigPolicy.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.policies[key] = value;
                        break;
                    case 5:
                        message.mod_policy = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigGroup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigGroup} ConfigGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigGroup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigGroup message.
             * @function verify
             * @memberof common.ConfigGroup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigGroup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                        return "version: integer|Long expected";
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!$util.isObject(message.groups))
                        return "groups: object expected";
                    var key = Object.keys(message.groups);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigGroup.verify(message.groups[key[i]]);
                        if (error)
                            return "groups." + error;
                    }
                }
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!$util.isObject(message.values))
                        return "values: object expected";
                    var key = Object.keys(message.values);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigValue.verify(message.values[key[i]]);
                        if (error)
                            return "values." + error;
                    }
                }
                if (message.policies != null && message.hasOwnProperty("policies")) {
                    if (!$util.isObject(message.policies))
                        return "policies: object expected";
                    var key = Object.keys(message.policies);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigPolicy.verify(message.policies[key[i]]);
                        if (error)
                            return "policies." + error;
                    }
                }
                if (message.mod_policy != null && message.hasOwnProperty("mod_policy"))
                    if (!$util.isString(message.mod_policy))
                        return "mod_policy: string expected";
                return null;
            };
    
            /**
             * Creates a ConfigGroup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigGroup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigGroup} ConfigGroup
             */
            ConfigGroup.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigGroup)
                    return object;
                var message = new $root.common.ConfigGroup();
                if (object.version != null)
                    if ($util.Long)
                        (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                    else if (typeof object.version === "string")
                        message.version = parseInt(object.version, 10);
                    else if (typeof object.version === "number")
                        message.version = object.version;
                    else if (typeof object.version === "object")
                        message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
                if (object.groups) {
                    if (typeof object.groups !== "object")
                        throw TypeError(".common.ConfigGroup.groups: object expected");
                    message.groups = {};
                    for (var keys = Object.keys(object.groups), i = 0; i < keys.length; ++i) {
                        if (typeof object.groups[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroup.groups: object expected");
                        message.groups[keys[i]] = $root.common.ConfigGroup.fromObject(object.groups[keys[i]]);
                    }
                }
                if (object.values) {
                    if (typeof object.values !== "object")
                        throw TypeError(".common.ConfigGroup.values: object expected");
                    message.values = {};
                    for (var keys = Object.keys(object.values), i = 0; i < keys.length; ++i) {
                        if (typeof object.values[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroup.values: object expected");
                        message.values[keys[i]] = $root.common.ConfigValue.fromObject(object.values[keys[i]]);
                    }
                }
                if (object.policies) {
                    if (typeof object.policies !== "object")
                        throw TypeError(".common.ConfigGroup.policies: object expected");
                    message.policies = {};
                    for (var keys = Object.keys(object.policies), i = 0; i < keys.length; ++i) {
                        if (typeof object.policies[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroup.policies: object expected");
                        message.policies[keys[i]] = $root.common.ConfigPolicy.fromObject(object.policies[keys[i]]);
                    }
                }
                if (object.mod_policy != null)
                    message.mod_policy = String(object.mod_policy);
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigGroup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigGroup
             * @static
             * @param {common.ConfigGroup} message ConfigGroup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigGroup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults) {
                    object.groups = {};
                    object.values = {};
                    object.policies = {};
                }
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.version = options.longs === String ? "0" : 0;
                    object.mod_policy = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version === "number")
                        object.version = options.longs === String ? String(message.version) : message.version;
                    else
                        object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
                var keys2;
                if (message.groups && (keys2 = Object.keys(message.groups)).length) {
                    object.groups = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.groups[keys2[j]] = $root.common.ConfigGroup.toObject(message.groups[keys2[j]], options);
                }
                if (message.values && (keys2 = Object.keys(message.values)).length) {
                    object.values = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.values[keys2[j]] = $root.common.ConfigValue.toObject(message.values[keys2[j]], options);
                }
                if (message.policies && (keys2 = Object.keys(message.policies)).length) {
                    object.policies = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.policies[keys2[j]] = $root.common.ConfigPolicy.toObject(message.policies[keys2[j]], options);
                }
                if (message.mod_policy != null && message.hasOwnProperty("mod_policy"))
                    object.mod_policy = message.mod_policy;
                return object;
            };
    
            /**
             * Converts this ConfigGroup to JSON.
             * @function toJSON
             * @memberof common.ConfigGroup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigGroup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigGroup;
        })();
    
        common.ConfigValue = (function() {
    
            /**
             * Properties of a ConfigValue.
             * @memberof common
             * @interface IConfigValue
             * @property {number|Long|null} [version] ConfigValue version
             * @property {Uint8Array|null} [value] ConfigValue value
             * @property {string|null} [mod_policy] ConfigValue mod_policy
             */
    
            /**
             * Constructs a new ConfigValue.
             * @memberof common
             * @classdesc Represents a ConfigValue.
             * @implements IConfigValue
             * @constructor
             * @param {common.IConfigValue=} [properties] Properties to set
             */
            function ConfigValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigValue version.
             * @member {number|Long} version
             * @memberof common.ConfigValue
             * @instance
             */
            ConfigValue.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ConfigValue value.
             * @member {Uint8Array} value
             * @memberof common.ConfigValue
             * @instance
             */
            ConfigValue.prototype.value = $util.newBuffer([]);
    
            /**
             * ConfigValue mod_policy.
             * @member {string} mod_policy
             * @memberof common.ConfigValue
             * @instance
             */
            ConfigValue.prototype.mod_policy = "";
    
            /**
             * Creates a new ConfigValue instance using the specified properties.
             * @function create
             * @memberof common.ConfigValue
             * @static
             * @param {common.IConfigValue=} [properties] Properties to set
             * @returns {common.ConfigValue} ConfigValue instance
             */
            ConfigValue.create = function create(properties) {
                return new ConfigValue(properties);
            };
    
            /**
             * Encodes the specified ConfigValue message. Does not implicitly {@link common.ConfigValue.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigValue
             * @static
             * @param {common.IConfigValue} message ConfigValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.mod_policy != null && Object.hasOwnProperty.call(message, "mod_policy"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.mod_policy);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigValue message, length delimited. Does not implicitly {@link common.ConfigValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigValue
             * @static
             * @param {common.IConfigValue} message ConfigValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigValue message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigValue} ConfigValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.uint64();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.mod_policy = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigValue} ConfigValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigValue message.
             * @function verify
             * @memberof common.ConfigValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                        return "version: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.mod_policy != null && message.hasOwnProperty("mod_policy"))
                    if (!$util.isString(message.mod_policy))
                        return "mod_policy: string expected";
                return null;
            };
    
            /**
             * Creates a ConfigValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigValue} ConfigValue
             */
            ConfigValue.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigValue)
                    return object;
                var message = new $root.common.ConfigValue();
                if (object.version != null)
                    if ($util.Long)
                        (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                    else if (typeof object.version === "string")
                        message.version = parseInt(object.version, 10);
                    else if (typeof object.version === "number")
                        message.version = object.version;
                    else if (typeof object.version === "object")
                        message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.mod_policy != null)
                    message.mod_policy = String(object.mod_policy);
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigValue
             * @static
             * @param {common.ConfigValue} message ConfigValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.version = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.mod_policy = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version === "number")
                        object.version = options.longs === String ? String(message.version) : message.version;
                    else
                        object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.mod_policy != null && message.hasOwnProperty("mod_policy"))
                    object.mod_policy = message.mod_policy;
                return object;
            };
    
            /**
             * Converts this ConfigValue to JSON.
             * @function toJSON
             * @memberof common.ConfigValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigValue;
        })();
    
        common.ConfigPolicy = (function() {
    
            /**
             * Properties of a ConfigPolicy.
             * @memberof common
             * @interface IConfigPolicy
             * @property {number|Long|null} [version] ConfigPolicy version
             * @property {common.IPolicy|null} [policy] ConfigPolicy policy
             * @property {string|null} [mod_policy] ConfigPolicy mod_policy
             */
    
            /**
             * Constructs a new ConfigPolicy.
             * @memberof common
             * @classdesc Represents a ConfigPolicy.
             * @implements IConfigPolicy
             * @constructor
             * @param {common.IConfigPolicy=} [properties] Properties to set
             */
            function ConfigPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigPolicy version.
             * @member {number|Long} version
             * @memberof common.ConfigPolicy
             * @instance
             */
            ConfigPolicy.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ConfigPolicy policy.
             * @member {common.IPolicy|null|undefined} policy
             * @memberof common.ConfigPolicy
             * @instance
             */
            ConfigPolicy.prototype.policy = null;
    
            /**
             * ConfigPolicy mod_policy.
             * @member {string} mod_policy
             * @memberof common.ConfigPolicy
             * @instance
             */
            ConfigPolicy.prototype.mod_policy = "";
    
            /**
             * Creates a new ConfigPolicy instance using the specified properties.
             * @function create
             * @memberof common.ConfigPolicy
             * @static
             * @param {common.IConfigPolicy=} [properties] Properties to set
             * @returns {common.ConfigPolicy} ConfigPolicy instance
             */
            ConfigPolicy.create = function create(properties) {
                return new ConfigPolicy(properties);
            };
    
            /**
             * Encodes the specified ConfigPolicy message. Does not implicitly {@link common.ConfigPolicy.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigPolicy
             * @static
             * @param {common.IConfigPolicy} message ConfigPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
                if (message.policy != null && Object.hasOwnProperty.call(message, "policy"))
                    $root.common.Policy.encode(message.policy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.mod_policy != null && Object.hasOwnProperty.call(message, "mod_policy"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.mod_policy);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigPolicy message, length delimited. Does not implicitly {@link common.ConfigPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigPolicy
             * @static
             * @param {common.IConfigPolicy} message ConfigPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigPolicy} ConfigPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.uint64();
                        break;
                    case 2:
                        message.policy = $root.common.Policy.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.mod_policy = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigPolicy} ConfigPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigPolicy message.
             * @function verify
             * @memberof common.ConfigPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                        return "version: integer|Long expected";
                if (message.policy != null && message.hasOwnProperty("policy")) {
                    var error = $root.common.Policy.verify(message.policy);
                    if (error)
                        return "policy." + error;
                }
                if (message.mod_policy != null && message.hasOwnProperty("mod_policy"))
                    if (!$util.isString(message.mod_policy))
                        return "mod_policy: string expected";
                return null;
            };
    
            /**
             * Creates a ConfigPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigPolicy} ConfigPolicy
             */
            ConfigPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigPolicy)
                    return object;
                var message = new $root.common.ConfigPolicy();
                if (object.version != null)
                    if ($util.Long)
                        (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                    else if (typeof object.version === "string")
                        message.version = parseInt(object.version, 10);
                    else if (typeof object.version === "number")
                        message.version = object.version;
                    else if (typeof object.version === "object")
                        message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
                if (object.policy != null) {
                    if (typeof object.policy !== "object")
                        throw TypeError(".common.ConfigPolicy.policy: object expected");
                    message.policy = $root.common.Policy.fromObject(object.policy);
                }
                if (object.mod_policy != null)
                    message.mod_policy = String(object.mod_policy);
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigPolicy
             * @static
             * @param {common.ConfigPolicy} message ConfigPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.version = options.longs === String ? "0" : 0;
                    object.policy = null;
                    object.mod_policy = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version === "number")
                        object.version = options.longs === String ? String(message.version) : message.version;
                    else
                        object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
                if (message.policy != null && message.hasOwnProperty("policy"))
                    object.policy = $root.common.Policy.toObject(message.policy, options);
                if (message.mod_policy != null && message.hasOwnProperty("mod_policy"))
                    object.mod_policy = message.mod_policy;
                return object;
            };
    
            /**
             * Converts this ConfigPolicy to JSON.
             * @function toJSON
             * @memberof common.ConfigPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigPolicy;
        })();
    
        common.ConfigSignature = (function() {
    
            /**
             * Properties of a ConfigSignature.
             * @memberof common
             * @interface IConfigSignature
             * @property {Uint8Array|null} [signature_header] ConfigSignature signature_header
             * @property {Uint8Array|null} [signature] ConfigSignature signature
             */
    
            /**
             * Constructs a new ConfigSignature.
             * @memberof common
             * @classdesc Represents a ConfigSignature.
             * @implements IConfigSignature
             * @constructor
             * @param {common.IConfigSignature=} [properties] Properties to set
             */
            function ConfigSignature(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigSignature signature_header.
             * @member {Uint8Array} signature_header
             * @memberof common.ConfigSignature
             * @instance
             */
            ConfigSignature.prototype.signature_header = $util.newBuffer([]);
    
            /**
             * ConfigSignature signature.
             * @member {Uint8Array} signature
             * @memberof common.ConfigSignature
             * @instance
             */
            ConfigSignature.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new ConfigSignature instance using the specified properties.
             * @function create
             * @memberof common.ConfigSignature
             * @static
             * @param {common.IConfigSignature=} [properties] Properties to set
             * @returns {common.ConfigSignature} ConfigSignature instance
             */
            ConfigSignature.create = function create(properties) {
                return new ConfigSignature(properties);
            };
    
            /**
             * Encodes the specified ConfigSignature message. Does not implicitly {@link common.ConfigSignature.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigSignature
             * @static
             * @param {common.IConfigSignature} message ConfigSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigSignature.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signature_header != null && Object.hasOwnProperty.call(message, "signature_header"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature_header);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigSignature message, length delimited. Does not implicitly {@link common.ConfigSignature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigSignature
             * @static
             * @param {common.IConfigSignature} message ConfigSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigSignature.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigSignature message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigSignature} ConfigSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigSignature.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigSignature();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signature_header = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigSignature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigSignature} ConfigSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigSignature.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigSignature message.
             * @function verify
             * @memberof common.ConfigSignature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigSignature.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.signature_header != null && message.hasOwnProperty("signature_header"))
                    if (!(message.signature_header && typeof message.signature_header.length === "number" || $util.isString(message.signature_header)))
                        return "signature_header: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a ConfigSignature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigSignature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigSignature} ConfigSignature
             */
            ConfigSignature.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigSignature)
                    return object;
                var message = new $root.common.ConfigSignature();
                if (object.signature_header != null)
                    if (typeof object.signature_header === "string")
                        $util.base64.decode(object.signature_header, message.signature_header = $util.newBuffer($util.base64.length(object.signature_header)), 0);
                    else if (object.signature_header.length)
                        message.signature_header = object.signature_header;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigSignature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigSignature
             * @static
             * @param {common.ConfigSignature} message ConfigSignature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigSignature.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.signature_header = "";
                    else {
                        object.signature_header = [];
                        if (options.bytes !== Array)
                            object.signature_header = $util.newBuffer(object.signature_header);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.signature_header != null && message.hasOwnProperty("signature_header"))
                    object.signature_header = options.bytes === String ? $util.base64.encode(message.signature_header, 0, message.signature_header.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature_header) : message.signature_header;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this ConfigSignature to JSON.
             * @function toJSON
             * @memberof common.ConfigSignature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigSignature.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigSignature;
        })();
    
        common.BlockchainInfo = (function() {
    
            /**
             * Properties of a BlockchainInfo.
             * @memberof common
             * @interface IBlockchainInfo
             * @property {number|Long|null} [height] BlockchainInfo height
             * @property {Uint8Array|null} [currentBlockHash] BlockchainInfo currentBlockHash
             * @property {Uint8Array|null} [previousBlockHash] BlockchainInfo previousBlockHash
             */
    
            /**
             * Constructs a new BlockchainInfo.
             * @memberof common
             * @classdesc Represents a BlockchainInfo.
             * @implements IBlockchainInfo
             * @constructor
             * @param {common.IBlockchainInfo=} [properties] Properties to set
             */
            function BlockchainInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockchainInfo height.
             * @member {number|Long} height
             * @memberof common.BlockchainInfo
             * @instance
             */
            BlockchainInfo.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * BlockchainInfo currentBlockHash.
             * @member {Uint8Array} currentBlockHash
             * @memberof common.BlockchainInfo
             * @instance
             */
            BlockchainInfo.prototype.currentBlockHash = $util.newBuffer([]);
    
            /**
             * BlockchainInfo previousBlockHash.
             * @member {Uint8Array} previousBlockHash
             * @memberof common.BlockchainInfo
             * @instance
             */
            BlockchainInfo.prototype.previousBlockHash = $util.newBuffer([]);
    
            /**
             * Creates a new BlockchainInfo instance using the specified properties.
             * @function create
             * @memberof common.BlockchainInfo
             * @static
             * @param {common.IBlockchainInfo=} [properties] Properties to set
             * @returns {common.BlockchainInfo} BlockchainInfo instance
             */
            BlockchainInfo.create = function create(properties) {
                return new BlockchainInfo(properties);
            };
    
            /**
             * Encodes the specified BlockchainInfo message. Does not implicitly {@link common.BlockchainInfo.verify|verify} messages.
             * @function encode
             * @memberof common.BlockchainInfo
             * @static
             * @param {common.IBlockchainInfo} message BlockchainInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockchainInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.height);
                if (message.currentBlockHash != null && Object.hasOwnProperty.call(message, "currentBlockHash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.currentBlockHash);
                if (message.previousBlockHash != null && Object.hasOwnProperty.call(message, "previousBlockHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.previousBlockHash);
                return writer;
            };
    
            /**
             * Encodes the specified BlockchainInfo message, length delimited. Does not implicitly {@link common.BlockchainInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockchainInfo
             * @static
             * @param {common.IBlockchainInfo} message BlockchainInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockchainInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockchainInfo message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockchainInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockchainInfo} BlockchainInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockchainInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockchainInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.height = reader.uint64();
                        break;
                    case 2:
                        message.currentBlockHash = reader.bytes();
                        break;
                    case 3:
                        message.previousBlockHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockchainInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockchainInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockchainInfo} BlockchainInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockchainInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockchainInfo message.
             * @function verify
             * @memberof common.BlockchainInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockchainInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                        return "height: integer|Long expected";
                if (message.currentBlockHash != null && message.hasOwnProperty("currentBlockHash"))
                    if (!(message.currentBlockHash && typeof message.currentBlockHash.length === "number" || $util.isString(message.currentBlockHash)))
                        return "currentBlockHash: buffer expected";
                if (message.previousBlockHash != null && message.hasOwnProperty("previousBlockHash"))
                    if (!(message.previousBlockHash && typeof message.previousBlockHash.length === "number" || $util.isString(message.previousBlockHash)))
                        return "previousBlockHash: buffer expected";
                return null;
            };
    
            /**
             * Creates a BlockchainInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockchainInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockchainInfo} BlockchainInfo
             */
            BlockchainInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockchainInfo)
                    return object;
                var message = new $root.common.BlockchainInfo();
                if (object.height != null)
                    if ($util.Long)
                        (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                    else if (typeof object.height === "string")
                        message.height = parseInt(object.height, 10);
                    else if (typeof object.height === "number")
                        message.height = object.height;
                    else if (typeof object.height === "object")
                        message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                if (object.currentBlockHash != null)
                    if (typeof object.currentBlockHash === "string")
                        $util.base64.decode(object.currentBlockHash, message.currentBlockHash = $util.newBuffer($util.base64.length(object.currentBlockHash)), 0);
                    else if (object.currentBlockHash.length)
                        message.currentBlockHash = object.currentBlockHash;
                if (object.previousBlockHash != null)
                    if (typeof object.previousBlockHash === "string")
                        $util.base64.decode(object.previousBlockHash, message.previousBlockHash = $util.newBuffer($util.base64.length(object.previousBlockHash)), 0);
                    else if (object.previousBlockHash.length)
                        message.previousBlockHash = object.previousBlockHash;
                return message;
            };
    
            /**
             * Creates a plain object from a BlockchainInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockchainInfo
             * @static
             * @param {common.BlockchainInfo} message BlockchainInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockchainInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.height = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.currentBlockHash = "";
                    else {
                        object.currentBlockHash = [];
                        if (options.bytes !== Array)
                            object.currentBlockHash = $util.newBuffer(object.currentBlockHash);
                    }
                    if (options.bytes === String)
                        object.previousBlockHash = "";
                    else {
                        object.previousBlockHash = [];
                        if (options.bytes !== Array)
                            object.previousBlockHash = $util.newBuffer(object.previousBlockHash);
                    }
                }
                if (message.height != null && message.hasOwnProperty("height"))
                    if (typeof message.height === "number")
                        object.height = options.longs === String ? String(message.height) : message.height;
                    else
                        object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                if (message.currentBlockHash != null && message.hasOwnProperty("currentBlockHash"))
                    object.currentBlockHash = options.bytes === String ? $util.base64.encode(message.currentBlockHash, 0, message.currentBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.currentBlockHash) : message.currentBlockHash;
                if (message.previousBlockHash != null && message.hasOwnProperty("previousBlockHash"))
                    object.previousBlockHash = options.bytes === String ? $util.base64.encode(message.previousBlockHash, 0, message.previousBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.previousBlockHash) : message.previousBlockHash;
                return object;
            };
    
            /**
             * Converts this BlockchainInfo to JSON.
             * @function toJSON
             * @memberof common.BlockchainInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockchainInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockchainInfo;
        })();
    
        common.HashingAlgorithm = (function() {
    
            /**
             * Properties of a HashingAlgorithm.
             * @memberof common
             * @interface IHashingAlgorithm
             * @property {string|null} [name] HashingAlgorithm name
             */
    
            /**
             * Constructs a new HashingAlgorithm.
             * @memberof common
             * @classdesc Represents a HashingAlgorithm.
             * @implements IHashingAlgorithm
             * @constructor
             * @param {common.IHashingAlgorithm=} [properties] Properties to set
             */
            function HashingAlgorithm(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * HashingAlgorithm name.
             * @member {string} name
             * @memberof common.HashingAlgorithm
             * @instance
             */
            HashingAlgorithm.prototype.name = "";
    
            /**
             * Creates a new HashingAlgorithm instance using the specified properties.
             * @function create
             * @memberof common.HashingAlgorithm
             * @static
             * @param {common.IHashingAlgorithm=} [properties] Properties to set
             * @returns {common.HashingAlgorithm} HashingAlgorithm instance
             */
            HashingAlgorithm.create = function create(properties) {
                return new HashingAlgorithm(properties);
            };
    
            /**
             * Encodes the specified HashingAlgorithm message. Does not implicitly {@link common.HashingAlgorithm.verify|verify} messages.
             * @function encode
             * @memberof common.HashingAlgorithm
             * @static
             * @param {common.IHashingAlgorithm} message HashingAlgorithm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashingAlgorithm.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified HashingAlgorithm message, length delimited. Does not implicitly {@link common.HashingAlgorithm.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.HashingAlgorithm
             * @static
             * @param {common.IHashingAlgorithm} message HashingAlgorithm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashingAlgorithm.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a HashingAlgorithm message from the specified reader or buffer.
             * @function decode
             * @memberof common.HashingAlgorithm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.HashingAlgorithm} HashingAlgorithm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashingAlgorithm.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.HashingAlgorithm();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a HashingAlgorithm message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.HashingAlgorithm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.HashingAlgorithm} HashingAlgorithm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashingAlgorithm.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a HashingAlgorithm message.
             * @function verify
             * @memberof common.HashingAlgorithm
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HashingAlgorithm.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a HashingAlgorithm message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.HashingAlgorithm
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.HashingAlgorithm} HashingAlgorithm
             */
            HashingAlgorithm.fromObject = function fromObject(object) {
                if (object instanceof $root.common.HashingAlgorithm)
                    return object;
                var message = new $root.common.HashingAlgorithm();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a HashingAlgorithm message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.HashingAlgorithm
             * @static
             * @param {common.HashingAlgorithm} message HashingAlgorithm
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HashingAlgorithm.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this HashingAlgorithm to JSON.
             * @function toJSON
             * @memberof common.HashingAlgorithm
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HashingAlgorithm.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return HashingAlgorithm;
        })();
    
        common.BlockDataHashingStructure = (function() {
    
            /**
             * Properties of a BlockDataHashingStructure.
             * @memberof common
             * @interface IBlockDataHashingStructure
             * @property {number|null} [width] BlockDataHashingStructure width
             */
    
            /**
             * Constructs a new BlockDataHashingStructure.
             * @memberof common
             * @classdesc Represents a BlockDataHashingStructure.
             * @implements IBlockDataHashingStructure
             * @constructor
             * @param {common.IBlockDataHashingStructure=} [properties] Properties to set
             */
            function BlockDataHashingStructure(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockDataHashingStructure width.
             * @member {number} width
             * @memberof common.BlockDataHashingStructure
             * @instance
             */
            BlockDataHashingStructure.prototype.width = 0;
    
            /**
             * Creates a new BlockDataHashingStructure instance using the specified properties.
             * @function create
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {common.IBlockDataHashingStructure=} [properties] Properties to set
             * @returns {common.BlockDataHashingStructure} BlockDataHashingStructure instance
             */
            BlockDataHashingStructure.create = function create(properties) {
                return new BlockDataHashingStructure(properties);
            };
    
            /**
             * Encodes the specified BlockDataHashingStructure message. Does not implicitly {@link common.BlockDataHashingStructure.verify|verify} messages.
             * @function encode
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {common.IBlockDataHashingStructure} message BlockDataHashingStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockDataHashingStructure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.width);
                return writer;
            };
    
            /**
             * Encodes the specified BlockDataHashingStructure message, length delimited. Does not implicitly {@link common.BlockDataHashingStructure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {common.IBlockDataHashingStructure} message BlockDataHashingStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockDataHashingStructure.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockDataHashingStructure message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockDataHashingStructure} BlockDataHashingStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockDataHashingStructure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockDataHashingStructure();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.width = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockDataHashingStructure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockDataHashingStructure} BlockDataHashingStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockDataHashingStructure.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockDataHashingStructure message.
             * @function verify
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockDataHashingStructure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                return null;
            };
    
            /**
             * Creates a BlockDataHashingStructure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockDataHashingStructure} BlockDataHashingStructure
             */
            BlockDataHashingStructure.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockDataHashingStructure)
                    return object;
                var message = new $root.common.BlockDataHashingStructure();
                if (object.width != null)
                    message.width = object.width >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a BlockDataHashingStructure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {common.BlockDataHashingStructure} message BlockDataHashingStructure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockDataHashingStructure.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.width = 0;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = message.width;
                return object;
            };
    
            /**
             * Converts this BlockDataHashingStructure to JSON.
             * @function toJSON
             * @memberof common.BlockDataHashingStructure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockDataHashingStructure.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockDataHashingStructure;
        })();
    
        common.OrdererAddresses = (function() {
    
            /**
             * Properties of an OrdererAddresses.
             * @memberof common
             * @interface IOrdererAddresses
             * @property {Array.<string>|null} [addresses] OrdererAddresses addresses
             */
    
            /**
             * Constructs a new OrdererAddresses.
             * @memberof common
             * @classdesc Represents an OrdererAddresses.
             * @implements IOrdererAddresses
             * @constructor
             * @param {common.IOrdererAddresses=} [properties] Properties to set
             */
            function OrdererAddresses(properties) {
                this.addresses = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OrdererAddresses addresses.
             * @member {Array.<string>} addresses
             * @memberof common.OrdererAddresses
             * @instance
             */
            OrdererAddresses.prototype.addresses = $util.emptyArray;
    
            /**
             * Creates a new OrdererAddresses instance using the specified properties.
             * @function create
             * @memberof common.OrdererAddresses
             * @static
             * @param {common.IOrdererAddresses=} [properties] Properties to set
             * @returns {common.OrdererAddresses} OrdererAddresses instance
             */
            OrdererAddresses.create = function create(properties) {
                return new OrdererAddresses(properties);
            };
    
            /**
             * Encodes the specified OrdererAddresses message. Does not implicitly {@link common.OrdererAddresses.verify|verify} messages.
             * @function encode
             * @memberof common.OrdererAddresses
             * @static
             * @param {common.IOrdererAddresses} message OrdererAddresses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrdererAddresses.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.addresses != null && message.addresses.length)
                    for (var i = 0; i < message.addresses.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.addresses[i]);
                return writer;
            };
    
            /**
             * Encodes the specified OrdererAddresses message, length delimited. Does not implicitly {@link common.OrdererAddresses.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.OrdererAddresses
             * @static
             * @param {common.IOrdererAddresses} message OrdererAddresses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrdererAddresses.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OrdererAddresses message from the specified reader or buffer.
             * @function decode
             * @memberof common.OrdererAddresses
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.OrdererAddresses} OrdererAddresses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrdererAddresses.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrdererAddresses();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.addresses && message.addresses.length))
                            message.addresses = [];
                        message.addresses.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OrdererAddresses message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.OrdererAddresses
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.OrdererAddresses} OrdererAddresses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrdererAddresses.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OrdererAddresses message.
             * @function verify
             * @memberof common.OrdererAddresses
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrdererAddresses.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.addresses != null && message.hasOwnProperty("addresses")) {
                    if (!Array.isArray(message.addresses))
                        return "addresses: array expected";
                    for (var i = 0; i < message.addresses.length; ++i)
                        if (!$util.isString(message.addresses[i]))
                            return "addresses: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates an OrdererAddresses message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.OrdererAddresses
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.OrdererAddresses} OrdererAddresses
             */
            OrdererAddresses.fromObject = function fromObject(object) {
                if (object instanceof $root.common.OrdererAddresses)
                    return object;
                var message = new $root.common.OrdererAddresses();
                if (object.addresses) {
                    if (!Array.isArray(object.addresses))
                        throw TypeError(".common.OrdererAddresses.addresses: array expected");
                    message.addresses = [];
                    for (var i = 0; i < object.addresses.length; ++i)
                        message.addresses[i] = String(object.addresses[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an OrdererAddresses message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.OrdererAddresses
             * @static
             * @param {common.OrdererAddresses} message OrdererAddresses
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrdererAddresses.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.addresses = [];
                if (message.addresses && message.addresses.length) {
                    object.addresses = [];
                    for (var j = 0; j < message.addresses.length; ++j)
                        object.addresses[j] = message.addresses[j];
                }
                return object;
            };
    
            /**
             * Converts this OrdererAddresses to JSON.
             * @function toJSON
             * @memberof common.OrdererAddresses
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrdererAddresses.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OrdererAddresses;
        })();
    
        common.Consortium = (function() {
    
            /**
             * Properties of a Consortium.
             * @memberof common
             * @interface IConsortium
             * @property {string|null} [name] Consortium name
             */
    
            /**
             * Constructs a new Consortium.
             * @memberof common
             * @classdesc Represents a Consortium.
             * @implements IConsortium
             * @constructor
             * @param {common.IConsortium=} [properties] Properties to set
             */
            function Consortium(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Consortium name.
             * @member {string} name
             * @memberof common.Consortium
             * @instance
             */
            Consortium.prototype.name = "";
    
            /**
             * Creates a new Consortium instance using the specified properties.
             * @function create
             * @memberof common.Consortium
             * @static
             * @param {common.IConsortium=} [properties] Properties to set
             * @returns {common.Consortium} Consortium instance
             */
            Consortium.create = function create(properties) {
                return new Consortium(properties);
            };
    
            /**
             * Encodes the specified Consortium message. Does not implicitly {@link common.Consortium.verify|verify} messages.
             * @function encode
             * @memberof common.Consortium
             * @static
             * @param {common.IConsortium} message Consortium message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Consortium.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified Consortium message, length delimited. Does not implicitly {@link common.Consortium.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Consortium
             * @static
             * @param {common.IConsortium} message Consortium message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Consortium.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Consortium message from the specified reader or buffer.
             * @function decode
             * @memberof common.Consortium
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Consortium} Consortium
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Consortium.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Consortium();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Consortium message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Consortium
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Consortium} Consortium
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Consortium.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Consortium message.
             * @function verify
             * @memberof common.Consortium
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Consortium.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a Consortium message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Consortium
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Consortium} Consortium
             */
            Consortium.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Consortium)
                    return object;
                var message = new $root.common.Consortium();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a Consortium message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Consortium
             * @static
             * @param {common.Consortium} message Consortium
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Consortium.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this Consortium to JSON.
             * @function toJSON
             * @memberof common.Consortium
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Consortium.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Consortium;
        })();
    
        common.Capabilities = (function() {
    
            /**
             * Properties of a Capabilities.
             * @memberof common
             * @interface ICapabilities
             * @property {Object.<string,common.ICapability>|null} [capabilities] Capabilities capabilities
             */
    
            /**
             * Constructs a new Capabilities.
             * @memberof common
             * @classdesc Represents a Capabilities.
             * @implements ICapabilities
             * @constructor
             * @param {common.ICapabilities=} [properties] Properties to set
             */
            function Capabilities(properties) {
                this.capabilities = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Capabilities capabilities.
             * @member {Object.<string,common.ICapability>} capabilities
             * @memberof common.Capabilities
             * @instance
             */
            Capabilities.prototype.capabilities = $util.emptyObject;
    
            /**
             * Creates a new Capabilities instance using the specified properties.
             * @function create
             * @memberof common.Capabilities
             * @static
             * @param {common.ICapabilities=} [properties] Properties to set
             * @returns {common.Capabilities} Capabilities instance
             */
            Capabilities.create = function create(properties) {
                return new Capabilities(properties);
            };
    
            /**
             * Encodes the specified Capabilities message. Does not implicitly {@link common.Capabilities.verify|verify} messages.
             * @function encode
             * @memberof common.Capabilities
             * @static
             * @param {common.ICapabilities} message Capabilities message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capabilities.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.capabilities != null && Object.hasOwnProperty.call(message, "capabilities"))
                    for (var keys = Object.keys(message.capabilities), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.Capability.encode(message.capabilities[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified Capabilities message, length delimited. Does not implicitly {@link common.Capabilities.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Capabilities
             * @static
             * @param {common.ICapabilities} message Capabilities message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capabilities.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Capabilities message from the specified reader or buffer.
             * @function decode
             * @memberof common.Capabilities
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Capabilities} Capabilities
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capabilities.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Capabilities(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.capabilities === $util.emptyObject)
                            message.capabilities = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.common.Capability.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.capabilities[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Capabilities message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Capabilities
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Capabilities} Capabilities
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capabilities.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Capabilities message.
             * @function verify
             * @memberof common.Capabilities
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Capabilities.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.capabilities != null && message.hasOwnProperty("capabilities")) {
                    if (!$util.isObject(message.capabilities))
                        return "capabilities: object expected";
                    var key = Object.keys(message.capabilities);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.Capability.verify(message.capabilities[key[i]]);
                        if (error)
                            return "capabilities." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Capabilities message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Capabilities
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Capabilities} Capabilities
             */
            Capabilities.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Capabilities)
                    return object;
                var message = new $root.common.Capabilities();
                if (object.capabilities) {
                    if (typeof object.capabilities !== "object")
                        throw TypeError(".common.Capabilities.capabilities: object expected");
                    message.capabilities = {};
                    for (var keys = Object.keys(object.capabilities), i = 0; i < keys.length; ++i) {
                        if (typeof object.capabilities[keys[i]] !== "object")
                            throw TypeError(".common.Capabilities.capabilities: object expected");
                        message.capabilities[keys[i]] = $root.common.Capability.fromObject(object.capabilities[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Capabilities message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Capabilities
             * @static
             * @param {common.Capabilities} message Capabilities
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Capabilities.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.capabilities = {};
                var keys2;
                if (message.capabilities && (keys2 = Object.keys(message.capabilities)).length) {
                    object.capabilities = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.capabilities[keys2[j]] = $root.common.Capability.toObject(message.capabilities[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this Capabilities to JSON.
             * @function toJSON
             * @memberof common.Capabilities
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Capabilities.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Capabilities;
        })();
    
        common.Capability = (function() {
    
            /**
             * Properties of a Capability.
             * @memberof common
             * @interface ICapability
             */
    
            /**
             * Constructs a new Capability.
             * @memberof common
             * @classdesc Represents a Capability.
             * @implements ICapability
             * @constructor
             * @param {common.ICapability=} [properties] Properties to set
             */
            function Capability(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Capability instance using the specified properties.
             * @function create
             * @memberof common.Capability
             * @static
             * @param {common.ICapability=} [properties] Properties to set
             * @returns {common.Capability} Capability instance
             */
            Capability.create = function create(properties) {
                return new Capability(properties);
            };
    
            /**
             * Encodes the specified Capability message. Does not implicitly {@link common.Capability.verify|verify} messages.
             * @function encode
             * @memberof common.Capability
             * @static
             * @param {common.ICapability} message Capability message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capability.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Capability message, length delimited. Does not implicitly {@link common.Capability.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Capability
             * @static
             * @param {common.ICapability} message Capability message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capability.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Capability message from the specified reader or buffer.
             * @function decode
             * @memberof common.Capability
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Capability} Capability
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capability.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Capability();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Capability message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Capability
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Capability} Capability
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capability.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Capability message.
             * @function verify
             * @memberof common.Capability
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Capability.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a Capability message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Capability
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Capability} Capability
             */
            Capability.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Capability)
                    return object;
                return new $root.common.Capability();
            };
    
            /**
             * Creates a plain object from a Capability message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Capability
             * @static
             * @param {common.Capability} message Capability
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Capability.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Capability to JSON.
             * @function toJSON
             * @memberof common.Capability
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Capability.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Capability;
        })();
    
        common.CollectionConfigPackage = (function() {
    
            /**
             * Properties of a CollectionConfigPackage.
             * @memberof common
             * @interface ICollectionConfigPackage
             * @property {Array.<common.ICollectionConfig>|null} [config] CollectionConfigPackage config
             */
    
            /**
             * Constructs a new CollectionConfigPackage.
             * @memberof common
             * @classdesc Represents a CollectionConfigPackage.
             * @implements ICollectionConfigPackage
             * @constructor
             * @param {common.ICollectionConfigPackage=} [properties] Properties to set
             */
            function CollectionConfigPackage(properties) {
                this.config = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionConfigPackage config.
             * @member {Array.<common.ICollectionConfig>} config
             * @memberof common.CollectionConfigPackage
             * @instance
             */
            CollectionConfigPackage.prototype.config = $util.emptyArray;
    
            /**
             * Creates a new CollectionConfigPackage instance using the specified properties.
             * @function create
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {common.ICollectionConfigPackage=} [properties] Properties to set
             * @returns {common.CollectionConfigPackage} CollectionConfigPackage instance
             */
            CollectionConfigPackage.create = function create(properties) {
                return new CollectionConfigPackage(properties);
            };
    
            /**
             * Encodes the specified CollectionConfigPackage message. Does not implicitly {@link common.CollectionConfigPackage.verify|verify} messages.
             * @function encode
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {common.ICollectionConfigPackage} message CollectionConfigPackage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfigPackage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.config != null && message.config.length)
                    for (var i = 0; i < message.config.length; ++i)
                        $root.common.CollectionConfig.encode(message.config[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionConfigPackage message, length delimited. Does not implicitly {@link common.CollectionConfigPackage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {common.ICollectionConfigPackage} message CollectionConfigPackage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfigPackage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionConfigPackage message from the specified reader or buffer.
             * @function decode
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CollectionConfigPackage} CollectionConfigPackage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfigPackage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CollectionConfigPackage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.config && message.config.length))
                            message.config = [];
                        message.config.push($root.common.CollectionConfig.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionConfigPackage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CollectionConfigPackage} CollectionConfigPackage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfigPackage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionConfigPackage message.
             * @function verify
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionConfigPackage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.config != null && message.hasOwnProperty("config")) {
                    if (!Array.isArray(message.config))
                        return "config: array expected";
                    for (var i = 0; i < message.config.length; ++i) {
                        var error = $root.common.CollectionConfig.verify(message.config[i]);
                        if (error)
                            return "config." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionConfigPackage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CollectionConfigPackage} CollectionConfigPackage
             */
            CollectionConfigPackage.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CollectionConfigPackage)
                    return object;
                var message = new $root.common.CollectionConfigPackage();
                if (object.config) {
                    if (!Array.isArray(object.config))
                        throw TypeError(".common.CollectionConfigPackage.config: array expected");
                    message.config = [];
                    for (var i = 0; i < object.config.length; ++i) {
                        if (typeof object.config[i] !== "object")
                            throw TypeError(".common.CollectionConfigPackage.config: object expected");
                        message.config[i] = $root.common.CollectionConfig.fromObject(object.config[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionConfigPackage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {common.CollectionConfigPackage} message CollectionConfigPackage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionConfigPackage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.config = [];
                if (message.config && message.config.length) {
                    object.config = [];
                    for (var j = 0; j < message.config.length; ++j)
                        object.config[j] = $root.common.CollectionConfig.toObject(message.config[j], options);
                }
                return object;
            };
    
            /**
             * Converts this CollectionConfigPackage to JSON.
             * @function toJSON
             * @memberof common.CollectionConfigPackage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionConfigPackage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionConfigPackage;
        })();
    
        common.CollectionConfig = (function() {
    
            /**
             * Properties of a CollectionConfig.
             * @memberof common
             * @interface ICollectionConfig
             * @property {common.IStaticCollectionConfig|null} [static_collection_config] CollectionConfig static_collection_config
             */
    
            /**
             * Constructs a new CollectionConfig.
             * @memberof common
             * @classdesc Represents a CollectionConfig.
             * @implements ICollectionConfig
             * @constructor
             * @param {common.ICollectionConfig=} [properties] Properties to set
             */
            function CollectionConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionConfig static_collection_config.
             * @member {common.IStaticCollectionConfig|null|undefined} static_collection_config
             * @memberof common.CollectionConfig
             * @instance
             */
            CollectionConfig.prototype.static_collection_config = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * CollectionConfig payload.
             * @member {"static_collection_config"|undefined} payload
             * @memberof common.CollectionConfig
             * @instance
             */
            Object.defineProperty(CollectionConfig.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["static_collection_config"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new CollectionConfig instance using the specified properties.
             * @function create
             * @memberof common.CollectionConfig
             * @static
             * @param {common.ICollectionConfig=} [properties] Properties to set
             * @returns {common.CollectionConfig} CollectionConfig instance
             */
            CollectionConfig.create = function create(properties) {
                return new CollectionConfig(properties);
            };
    
            /**
             * Encodes the specified CollectionConfig message. Does not implicitly {@link common.CollectionConfig.verify|verify} messages.
             * @function encode
             * @memberof common.CollectionConfig
             * @static
             * @param {common.ICollectionConfig} message CollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.static_collection_config != null && Object.hasOwnProperty.call(message, "static_collection_config"))
                    $root.common.StaticCollectionConfig.encode(message.static_collection_config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionConfig message, length delimited. Does not implicitly {@link common.CollectionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CollectionConfig
             * @static
             * @param {common.ICollectionConfig} message CollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof common.CollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CollectionConfig} CollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CollectionConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.static_collection_config = $root.common.StaticCollectionConfig.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CollectionConfig} CollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionConfig message.
             * @function verify
             * @memberof common.CollectionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.static_collection_config != null && message.hasOwnProperty("static_collection_config")) {
                    properties.payload = 1;
                    {
                        var error = $root.common.StaticCollectionConfig.verify(message.static_collection_config);
                        if (error)
                            return "static_collection_config." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CollectionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CollectionConfig} CollectionConfig
             */
            CollectionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CollectionConfig)
                    return object;
                var message = new $root.common.CollectionConfig();
                if (object.static_collection_config != null) {
                    if (typeof object.static_collection_config !== "object")
                        throw TypeError(".common.CollectionConfig.static_collection_config: object expected");
                    message.static_collection_config = $root.common.StaticCollectionConfig.fromObject(object.static_collection_config);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CollectionConfig
             * @static
             * @param {common.CollectionConfig} message CollectionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.static_collection_config != null && message.hasOwnProperty("static_collection_config")) {
                    object.static_collection_config = $root.common.StaticCollectionConfig.toObject(message.static_collection_config, options);
                    if (options.oneofs)
                        object.payload = "static_collection_config";
                }
                return object;
            };
    
            /**
             * Converts this CollectionConfig to JSON.
             * @function toJSON
             * @memberof common.CollectionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionConfig;
        })();
    
        common.StaticCollectionConfig = (function() {
    
            /**
             * Properties of a StaticCollectionConfig.
             * @memberof common
             * @interface IStaticCollectionConfig
             * @property {string|null} [name] StaticCollectionConfig name
             * @property {common.ICollectionPolicyConfig|null} [member_orgs_policy] StaticCollectionConfig member_orgs_policy
             * @property {number|null} [required_peer_count] StaticCollectionConfig required_peer_count
             * @property {number|null} [maximum_peer_count] StaticCollectionConfig maximum_peer_count
             * @property {number|Long|null} [block_to_live] StaticCollectionConfig block_to_live
             * @property {boolean|null} [member_only_read] StaticCollectionConfig member_only_read
             * @property {boolean|null} [member_only_write] StaticCollectionConfig member_only_write
             * @property {common.IApplicationPolicy|null} [endorsement_policy] StaticCollectionConfig endorsement_policy
             */
    
            /**
             * Constructs a new StaticCollectionConfig.
             * @memberof common
             * @classdesc Represents a StaticCollectionConfig.
             * @implements IStaticCollectionConfig
             * @constructor
             * @param {common.IStaticCollectionConfig=} [properties] Properties to set
             */
            function StaticCollectionConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StaticCollectionConfig name.
             * @member {string} name
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.name = "";
    
            /**
             * StaticCollectionConfig member_orgs_policy.
             * @member {common.ICollectionPolicyConfig|null|undefined} member_orgs_policy
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.member_orgs_policy = null;
    
            /**
             * StaticCollectionConfig required_peer_count.
             * @member {number} required_peer_count
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.required_peer_count = 0;
    
            /**
             * StaticCollectionConfig maximum_peer_count.
             * @member {number} maximum_peer_count
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.maximum_peer_count = 0;
    
            /**
             * StaticCollectionConfig block_to_live.
             * @member {number|Long} block_to_live
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.block_to_live = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * StaticCollectionConfig member_only_read.
             * @member {boolean} member_only_read
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.member_only_read = false;
    
            /**
             * StaticCollectionConfig member_only_write.
             * @member {boolean} member_only_write
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.member_only_write = false;
    
            /**
             * StaticCollectionConfig endorsement_policy.
             * @member {common.IApplicationPolicy|null|undefined} endorsement_policy
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.endorsement_policy = null;
    
            /**
             * Creates a new StaticCollectionConfig instance using the specified properties.
             * @function create
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {common.IStaticCollectionConfig=} [properties] Properties to set
             * @returns {common.StaticCollectionConfig} StaticCollectionConfig instance
             */
            StaticCollectionConfig.create = function create(properties) {
                return new StaticCollectionConfig(properties);
            };
    
            /**
             * Encodes the specified StaticCollectionConfig message. Does not implicitly {@link common.StaticCollectionConfig.verify|verify} messages.
             * @function encode
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {common.IStaticCollectionConfig} message StaticCollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaticCollectionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.member_orgs_policy != null && Object.hasOwnProperty.call(message, "member_orgs_policy"))
                    $root.common.CollectionPolicyConfig.encode(message.member_orgs_policy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.required_peer_count != null && Object.hasOwnProperty.call(message, "required_peer_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.required_peer_count);
                if (message.maximum_peer_count != null && Object.hasOwnProperty.call(message, "maximum_peer_count"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maximum_peer_count);
                if (message.block_to_live != null && Object.hasOwnProperty.call(message, "block_to_live"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.block_to_live);
                if (message.member_only_read != null && Object.hasOwnProperty.call(message, "member_only_read"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.member_only_read);
                if (message.member_only_write != null && Object.hasOwnProperty.call(message, "member_only_write"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.member_only_write);
                if (message.endorsement_policy != null && Object.hasOwnProperty.call(message, "endorsement_policy"))
                    $root.common.ApplicationPolicy.encode(message.endorsement_policy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StaticCollectionConfig message, length delimited. Does not implicitly {@link common.StaticCollectionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {common.IStaticCollectionConfig} message StaticCollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaticCollectionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StaticCollectionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.StaticCollectionConfig} StaticCollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaticCollectionConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.StaticCollectionConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.member_orgs_policy = $root.common.CollectionPolicyConfig.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.required_peer_count = reader.int32();
                        break;
                    case 4:
                        message.maximum_peer_count = reader.int32();
                        break;
                    case 5:
                        message.block_to_live = reader.uint64();
                        break;
                    case 6:
                        message.member_only_read = reader.bool();
                        break;
                    case 7:
                        message.member_only_write = reader.bool();
                        break;
                    case 8:
                        message.endorsement_policy = $root.common.ApplicationPolicy.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StaticCollectionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.StaticCollectionConfig} StaticCollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaticCollectionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StaticCollectionConfig message.
             * @function verify
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StaticCollectionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.member_orgs_policy != null && message.hasOwnProperty("member_orgs_policy")) {
                    var error = $root.common.CollectionPolicyConfig.verify(message.member_orgs_policy);
                    if (error)
                        return "member_orgs_policy." + error;
                }
                if (message.required_peer_count != null && message.hasOwnProperty("required_peer_count"))
                    if (!$util.isInteger(message.required_peer_count))
                        return "required_peer_count: integer expected";
                if (message.maximum_peer_count != null && message.hasOwnProperty("maximum_peer_count"))
                    if (!$util.isInteger(message.maximum_peer_count))
                        return "maximum_peer_count: integer expected";
                if (message.block_to_live != null && message.hasOwnProperty("block_to_live"))
                    if (!$util.isInteger(message.block_to_live) && !(message.block_to_live && $util.isInteger(message.block_to_live.low) && $util.isInteger(message.block_to_live.high)))
                        return "block_to_live: integer|Long expected";
                if (message.member_only_read != null && message.hasOwnProperty("member_only_read"))
                    if (typeof message.member_only_read !== "boolean")
                        return "member_only_read: boolean expected";
                if (message.member_only_write != null && message.hasOwnProperty("member_only_write"))
                    if (typeof message.member_only_write !== "boolean")
                        return "member_only_write: boolean expected";
                if (message.endorsement_policy != null && message.hasOwnProperty("endorsement_policy")) {
                    var error = $root.common.ApplicationPolicy.verify(message.endorsement_policy);
                    if (error)
                        return "endorsement_policy." + error;
                }
                return null;
            };
    
            /**
             * Creates a StaticCollectionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.StaticCollectionConfig} StaticCollectionConfig
             */
            StaticCollectionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.common.StaticCollectionConfig)
                    return object;
                var message = new $root.common.StaticCollectionConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.member_orgs_policy != null) {
                    if (typeof object.member_orgs_policy !== "object")
                        throw TypeError(".common.StaticCollectionConfig.member_orgs_policy: object expected");
                    message.member_orgs_policy = $root.common.CollectionPolicyConfig.fromObject(object.member_orgs_policy);
                }
                if (object.required_peer_count != null)
                    message.required_peer_count = object.required_peer_count | 0;
                if (object.maximum_peer_count != null)
                    message.maximum_peer_count = object.maximum_peer_count | 0;
                if (object.block_to_live != null)
                    if ($util.Long)
                        (message.block_to_live = $util.Long.fromValue(object.block_to_live)).unsigned = true;
                    else if (typeof object.block_to_live === "string")
                        message.block_to_live = parseInt(object.block_to_live, 10);
                    else if (typeof object.block_to_live === "number")
                        message.block_to_live = object.block_to_live;
                    else if (typeof object.block_to_live === "object")
                        message.block_to_live = new $util.LongBits(object.block_to_live.low >>> 0, object.block_to_live.high >>> 0).toNumber(true);
                if (object.member_only_read != null)
                    message.member_only_read = Boolean(object.member_only_read);
                if (object.member_only_write != null)
                    message.member_only_write = Boolean(object.member_only_write);
                if (object.endorsement_policy != null) {
                    if (typeof object.endorsement_policy !== "object")
                        throw TypeError(".common.StaticCollectionConfig.endorsement_policy: object expected");
                    message.endorsement_policy = $root.common.ApplicationPolicy.fromObject(object.endorsement_policy);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StaticCollectionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {common.StaticCollectionConfig} message StaticCollectionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StaticCollectionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.member_orgs_policy = null;
                    object.required_peer_count = 0;
                    object.maximum_peer_count = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.block_to_live = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_to_live = options.longs === String ? "0" : 0;
                    object.member_only_read = false;
                    object.member_only_write = false;
                    object.endorsement_policy = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.member_orgs_policy != null && message.hasOwnProperty("member_orgs_policy"))
                    object.member_orgs_policy = $root.common.CollectionPolicyConfig.toObject(message.member_orgs_policy, options);
                if (message.required_peer_count != null && message.hasOwnProperty("required_peer_count"))
                    object.required_peer_count = message.required_peer_count;
                if (message.maximum_peer_count != null && message.hasOwnProperty("maximum_peer_count"))
                    object.maximum_peer_count = message.maximum_peer_count;
                if (message.block_to_live != null && message.hasOwnProperty("block_to_live"))
                    if (typeof message.block_to_live === "number")
                        object.block_to_live = options.longs === String ? String(message.block_to_live) : message.block_to_live;
                    else
                        object.block_to_live = options.longs === String ? $util.Long.prototype.toString.call(message.block_to_live) : options.longs === Number ? new $util.LongBits(message.block_to_live.low >>> 0, message.block_to_live.high >>> 0).toNumber(true) : message.block_to_live;
                if (message.member_only_read != null && message.hasOwnProperty("member_only_read"))
                    object.member_only_read = message.member_only_read;
                if (message.member_only_write != null && message.hasOwnProperty("member_only_write"))
                    object.member_only_write = message.member_only_write;
                if (message.endorsement_policy != null && message.hasOwnProperty("endorsement_policy"))
                    object.endorsement_policy = $root.common.ApplicationPolicy.toObject(message.endorsement_policy, options);
                return object;
            };
    
            /**
             * Converts this StaticCollectionConfig to JSON.
             * @function toJSON
             * @memberof common.StaticCollectionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StaticCollectionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StaticCollectionConfig;
        })();
    
        common.CollectionPolicyConfig = (function() {
    
            /**
             * Properties of a CollectionPolicyConfig.
             * @memberof common
             * @interface ICollectionPolicyConfig
             * @property {common.ISignaturePolicyEnvelope|null} [signature_policy] CollectionPolicyConfig signature_policy
             */
    
            /**
             * Constructs a new CollectionPolicyConfig.
             * @memberof common
             * @classdesc Represents a CollectionPolicyConfig.
             * @implements ICollectionPolicyConfig
             * @constructor
             * @param {common.ICollectionPolicyConfig=} [properties] Properties to set
             */
            function CollectionPolicyConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionPolicyConfig signature_policy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} signature_policy
             * @memberof common.CollectionPolicyConfig
             * @instance
             */
            CollectionPolicyConfig.prototype.signature_policy = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * CollectionPolicyConfig payload.
             * @member {"signature_policy"|undefined} payload
             * @memberof common.CollectionPolicyConfig
             * @instance
             */
            Object.defineProperty(CollectionPolicyConfig.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["signature_policy"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new CollectionPolicyConfig instance using the specified properties.
             * @function create
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {common.ICollectionPolicyConfig=} [properties] Properties to set
             * @returns {common.CollectionPolicyConfig} CollectionPolicyConfig instance
             */
            CollectionPolicyConfig.create = function create(properties) {
                return new CollectionPolicyConfig(properties);
            };
    
            /**
             * Encodes the specified CollectionPolicyConfig message. Does not implicitly {@link common.CollectionPolicyConfig.verify|verify} messages.
             * @function encode
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {common.ICollectionPolicyConfig} message CollectionPolicyConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPolicyConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signature_policy != null && Object.hasOwnProperty.call(message, "signature_policy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.signature_policy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionPolicyConfig message, length delimited. Does not implicitly {@link common.CollectionPolicyConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {common.ICollectionPolicyConfig} message CollectionPolicyConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPolicyConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionPolicyConfig message from the specified reader or buffer.
             * @function decode
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CollectionPolicyConfig} CollectionPolicyConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPolicyConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CollectionPolicyConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signature_policy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionPolicyConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CollectionPolicyConfig} CollectionPolicyConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPolicyConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionPolicyConfig message.
             * @function verify
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionPolicyConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.signature_policy != null && message.hasOwnProperty("signature_policy")) {
                    properties.payload = 1;
                    {
                        var error = $root.common.SignaturePolicyEnvelope.verify(message.signature_policy);
                        if (error)
                            return "signature_policy." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionPolicyConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CollectionPolicyConfig} CollectionPolicyConfig
             */
            CollectionPolicyConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CollectionPolicyConfig)
                    return object;
                var message = new $root.common.CollectionPolicyConfig();
                if (object.signature_policy != null) {
                    if (typeof object.signature_policy !== "object")
                        throw TypeError(".common.CollectionPolicyConfig.signature_policy: object expected");
                    message.signature_policy = $root.common.SignaturePolicyEnvelope.fromObject(object.signature_policy);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionPolicyConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {common.CollectionPolicyConfig} message CollectionPolicyConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionPolicyConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.signature_policy != null && message.hasOwnProperty("signature_policy")) {
                    object.signature_policy = $root.common.SignaturePolicyEnvelope.toObject(message.signature_policy, options);
                    if (options.oneofs)
                        object.payload = "signature_policy";
                }
                return object;
            };
    
            /**
             * Converts this CollectionPolicyConfig to JSON.
             * @function toJSON
             * @memberof common.CollectionPolicyConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionPolicyConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionPolicyConfig;
        })();
    
        return common;
    })();
    
    $root.discovery = (function() {
    
        /**
         * Namespace discovery.
         * @exports discovery
         * @namespace
         */
        var discovery = {};
    
        discovery.Discovery = (function() {
    
            /**
             * Constructs a new Discovery service.
             * @memberof discovery
             * @classdesc Represents a Discovery
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Discovery(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Discovery.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Discovery;
    
            /**
             * Creates new Discovery service using the specified rpc implementation.
             * @function create
             * @memberof discovery.Discovery
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Discovery} RPC service. Useful where requests and/or responses are streamed.
             */
            Discovery.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link discovery.Discovery#discover}.
             * @memberof discovery.Discovery
             * @typedef DiscoverCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {discovery.Response} [response] Response
             */
    
            /**
             * Calls Discover.
             * @function discover
             * @memberof discovery.Discovery
             * @instance
             * @param {discovery.ISignedRequest} request SignedRequest message or plain object
             * @param {discovery.Discovery.DiscoverCallback} callback Node-style callback called with the error, if any, and Response
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Discovery.prototype.discover = function discover(request, callback) {
                return this.rpcCall(discover, $root.discovery.SignedRequest, $root.discovery.Response, request, callback);
            }, "name", { value: "Discover" });
    
            /**
             * Calls Discover.
             * @function discover
             * @memberof discovery.Discovery
             * @instance
             * @param {discovery.ISignedRequest} request SignedRequest message or plain object
             * @returns {Promise<discovery.Response>} Promise
             * @variation 2
             */
    
            return Discovery;
        })();
    
        discovery.SignedRequest = (function() {
    
            /**
             * Properties of a SignedRequest.
             * @memberof discovery
             * @interface ISignedRequest
             * @property {Uint8Array|null} [payload] SignedRequest payload
             * @property {Uint8Array|null} [signature] SignedRequest signature
             */
    
            /**
             * Constructs a new SignedRequest.
             * @memberof discovery
             * @classdesc Represents a SignedRequest.
             * @implements ISignedRequest
             * @constructor
             * @param {discovery.ISignedRequest=} [properties] Properties to set
             */
            function SignedRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignedRequest payload.
             * @member {Uint8Array} payload
             * @memberof discovery.SignedRequest
             * @instance
             */
            SignedRequest.prototype.payload = $util.newBuffer([]);
    
            /**
             * SignedRequest signature.
             * @member {Uint8Array} signature
             * @memberof discovery.SignedRequest
             * @instance
             */
            SignedRequest.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new SignedRequest instance using the specified properties.
             * @function create
             * @memberof discovery.SignedRequest
             * @static
             * @param {discovery.ISignedRequest=} [properties] Properties to set
             * @returns {discovery.SignedRequest} SignedRequest instance
             */
            SignedRequest.create = function create(properties) {
                return new SignedRequest(properties);
            };
    
            /**
             * Encodes the specified SignedRequest message. Does not implicitly {@link discovery.SignedRequest.verify|verify} messages.
             * @function encode
             * @memberof discovery.SignedRequest
             * @static
             * @param {discovery.ISignedRequest} message SignedRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified SignedRequest message, length delimited. Does not implicitly {@link discovery.SignedRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.SignedRequest
             * @static
             * @param {discovery.ISignedRequest} message SignedRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedRequest message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.SignedRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.SignedRequest} SignedRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.SignedRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignedRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.SignedRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.SignedRequest} SignedRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedRequest message.
             * @function verify
             * @memberof discovery.SignedRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignedRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a SignedRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.SignedRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.SignedRequest} SignedRequest
             */
            SignedRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.SignedRequest)
                    return object;
                var message = new $root.discovery.SignedRequest();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a SignedRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.SignedRequest
             * @static
             * @param {discovery.SignedRequest} message SignedRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this SignedRequest to JSON.
             * @function toJSON
             * @memberof discovery.SignedRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedRequest;
        })();
    
        discovery.Request = (function() {
    
            /**
             * Properties of a Request.
             * @memberof discovery
             * @interface IRequest
             * @property {discovery.IAuthInfo|null} [authentication] Request authentication
             * @property {Array.<discovery.IQuery>|null} [queries] Request queries
             */
    
            /**
             * Constructs a new Request.
             * @memberof discovery
             * @classdesc Represents a Request.
             * @implements IRequest
             * @constructor
             * @param {discovery.IRequest=} [properties] Properties to set
             */
            function Request(properties) {
                this.queries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Request authentication.
             * @member {discovery.IAuthInfo|null|undefined} authentication
             * @memberof discovery.Request
             * @instance
             */
            Request.prototype.authentication = null;
    
            /**
             * Request queries.
             * @member {Array.<discovery.IQuery>} queries
             * @memberof discovery.Request
             * @instance
             */
            Request.prototype.queries = $util.emptyArray;
    
            /**
             * Creates a new Request instance using the specified properties.
             * @function create
             * @memberof discovery.Request
             * @static
             * @param {discovery.IRequest=} [properties] Properties to set
             * @returns {discovery.Request} Request instance
             */
            Request.create = function create(properties) {
                return new Request(properties);
            };
    
            /**
             * Encodes the specified Request message. Does not implicitly {@link discovery.Request.verify|verify} messages.
             * @function encode
             * @memberof discovery.Request
             * @static
             * @param {discovery.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.authentication != null && Object.hasOwnProperty.call(message, "authentication"))
                    $root.discovery.AuthInfo.encode(message.authentication, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.queries != null && message.queries.length)
                    for (var i = 0; i < message.queries.length; ++i)
                        $root.discovery.Query.encode(message.queries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Request message, length delimited. Does not implicitly {@link discovery.Request.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Request
             * @static
             * @param {discovery.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Request message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Request();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.authentication = $root.discovery.AuthInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.queries && message.queries.length))
                            message.queries = [];
                        message.queries.push($root.discovery.Query.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Request message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Request message.
             * @function verify
             * @memberof discovery.Request
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Request.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.authentication != null && message.hasOwnProperty("authentication")) {
                    var error = $root.discovery.AuthInfo.verify(message.authentication);
                    if (error)
                        return "authentication." + error;
                }
                if (message.queries != null && message.hasOwnProperty("queries")) {
                    if (!Array.isArray(message.queries))
                        return "queries: array expected";
                    for (var i = 0; i < message.queries.length; ++i) {
                        var error = $root.discovery.Query.verify(message.queries[i]);
                        if (error)
                            return "queries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Request message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Request
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Request} Request
             */
            Request.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Request)
                    return object;
                var message = new $root.discovery.Request();
                if (object.authentication != null) {
                    if (typeof object.authentication !== "object")
                        throw TypeError(".discovery.Request.authentication: object expected");
                    message.authentication = $root.discovery.AuthInfo.fromObject(object.authentication);
                }
                if (object.queries) {
                    if (!Array.isArray(object.queries))
                        throw TypeError(".discovery.Request.queries: array expected");
                    message.queries = [];
                    for (var i = 0; i < object.queries.length; ++i) {
                        if (typeof object.queries[i] !== "object")
                            throw TypeError(".discovery.Request.queries: object expected");
                        message.queries[i] = $root.discovery.Query.fromObject(object.queries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Request message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Request
             * @static
             * @param {discovery.Request} message Request
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.queries = [];
                if (options.defaults)
                    object.authentication = null;
                if (message.authentication != null && message.hasOwnProperty("authentication"))
                    object.authentication = $root.discovery.AuthInfo.toObject(message.authentication, options);
                if (message.queries && message.queries.length) {
                    object.queries = [];
                    for (var j = 0; j < message.queries.length; ++j)
                        object.queries[j] = $root.discovery.Query.toObject(message.queries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Request to JSON.
             * @function toJSON
             * @memberof discovery.Request
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Request;
        })();
    
        discovery.Response = (function() {
    
            /**
             * Properties of a Response.
             * @memberof discovery
             * @interface IResponse
             * @property {Array.<discovery.IQueryResult>|null} [results] Response results
             */
    
            /**
             * Constructs a new Response.
             * @memberof discovery
             * @classdesc Represents a Response.
             * @implements IResponse
             * @constructor
             * @param {discovery.IResponse=} [properties] Properties to set
             */
            function Response(properties) {
                this.results = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Response results.
             * @member {Array.<discovery.IQueryResult>} results
             * @memberof discovery.Response
             * @instance
             */
            Response.prototype.results = $util.emptyArray;
    
            /**
             * Creates a new Response instance using the specified properties.
             * @function create
             * @memberof discovery.Response
             * @static
             * @param {discovery.IResponse=} [properties] Properties to set
             * @returns {discovery.Response} Response instance
             */
            Response.create = function create(properties) {
                return new Response(properties);
            };
    
            /**
             * Encodes the specified Response message. Does not implicitly {@link discovery.Response.verify|verify} messages.
             * @function encode
             * @memberof discovery.Response
             * @static
             * @param {discovery.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.results != null && message.results.length)
                    for (var i = 0; i < message.results.length; ++i)
                        $root.discovery.QueryResult.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Response message, length delimited. Does not implicitly {@link discovery.Response.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Response
             * @static
             * @param {discovery.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Response message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Response();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.results && message.results.length))
                            message.results = [];
                        message.results.push($root.discovery.QueryResult.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Response message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Response message.
             * @function verify
             * @memberof discovery.Response
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.results != null && message.hasOwnProperty("results")) {
                    if (!Array.isArray(message.results))
                        return "results: array expected";
                    for (var i = 0; i < message.results.length; ++i) {
                        var error = $root.discovery.QueryResult.verify(message.results[i]);
                        if (error)
                            return "results." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Response message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Response
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Response} Response
             */
            Response.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Response)
                    return object;
                var message = new $root.discovery.Response();
                if (object.results) {
                    if (!Array.isArray(object.results))
                        throw TypeError(".discovery.Response.results: array expected");
                    message.results = [];
                    for (var i = 0; i < object.results.length; ++i) {
                        if (typeof object.results[i] !== "object")
                            throw TypeError(".discovery.Response.results: object expected");
                        message.results[i] = $root.discovery.QueryResult.fromObject(object.results[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Response message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Response
             * @static
             * @param {discovery.Response} message Response
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.results = [];
                if (message.results && message.results.length) {
                    object.results = [];
                    for (var j = 0; j < message.results.length; ++j)
                        object.results[j] = $root.discovery.QueryResult.toObject(message.results[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Response to JSON.
             * @function toJSON
             * @memberof discovery.Response
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Response;
        })();
    
        discovery.AuthInfo = (function() {
    
            /**
             * Properties of an AuthInfo.
             * @memberof discovery
             * @interface IAuthInfo
             * @property {Uint8Array|null} [client_identity] AuthInfo client_identity
             * @property {Uint8Array|null} [client_tls_cert_hash] AuthInfo client_tls_cert_hash
             */
    
            /**
             * Constructs a new AuthInfo.
             * @memberof discovery
             * @classdesc Represents an AuthInfo.
             * @implements IAuthInfo
             * @constructor
             * @param {discovery.IAuthInfo=} [properties] Properties to set
             */
            function AuthInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AuthInfo client_identity.
             * @member {Uint8Array} client_identity
             * @memberof discovery.AuthInfo
             * @instance
             */
            AuthInfo.prototype.client_identity = $util.newBuffer([]);
    
            /**
             * AuthInfo client_tls_cert_hash.
             * @member {Uint8Array} client_tls_cert_hash
             * @memberof discovery.AuthInfo
             * @instance
             */
            AuthInfo.prototype.client_tls_cert_hash = $util.newBuffer([]);
    
            /**
             * Creates a new AuthInfo instance using the specified properties.
             * @function create
             * @memberof discovery.AuthInfo
             * @static
             * @param {discovery.IAuthInfo=} [properties] Properties to set
             * @returns {discovery.AuthInfo} AuthInfo instance
             */
            AuthInfo.create = function create(properties) {
                return new AuthInfo(properties);
            };
    
            /**
             * Encodes the specified AuthInfo message. Does not implicitly {@link discovery.AuthInfo.verify|verify} messages.
             * @function encode
             * @memberof discovery.AuthInfo
             * @static
             * @param {discovery.IAuthInfo} message AuthInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.client_identity != null && Object.hasOwnProperty.call(message, "client_identity"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.client_identity);
                if (message.client_tls_cert_hash != null && Object.hasOwnProperty.call(message, "client_tls_cert_hash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.client_tls_cert_hash);
                return writer;
            };
    
            /**
             * Encodes the specified AuthInfo message, length delimited. Does not implicitly {@link discovery.AuthInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.AuthInfo
             * @static
             * @param {discovery.IAuthInfo} message AuthInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AuthInfo message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.AuthInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.AuthInfo} AuthInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.AuthInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.client_identity = reader.bytes();
                        break;
                    case 2:
                        message.client_tls_cert_hash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AuthInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.AuthInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.AuthInfo} AuthInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AuthInfo message.
             * @function verify
             * @memberof discovery.AuthInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.client_identity != null && message.hasOwnProperty("client_identity"))
                    if (!(message.client_identity && typeof message.client_identity.length === "number" || $util.isString(message.client_identity)))
                        return "client_identity: buffer expected";
                if (message.client_tls_cert_hash != null && message.hasOwnProperty("client_tls_cert_hash"))
                    if (!(message.client_tls_cert_hash && typeof message.client_tls_cert_hash.length === "number" || $util.isString(message.client_tls_cert_hash)))
                        return "client_tls_cert_hash: buffer expected";
                return null;
            };
    
            /**
             * Creates an AuthInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.AuthInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.AuthInfo} AuthInfo
             */
            AuthInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.AuthInfo)
                    return object;
                var message = new $root.discovery.AuthInfo();
                if (object.client_identity != null)
                    if (typeof object.client_identity === "string")
                        $util.base64.decode(object.client_identity, message.client_identity = $util.newBuffer($util.base64.length(object.client_identity)), 0);
                    else if (object.client_identity.length)
                        message.client_identity = object.client_identity;
                if (object.client_tls_cert_hash != null)
                    if (typeof object.client_tls_cert_hash === "string")
                        $util.base64.decode(object.client_tls_cert_hash, message.client_tls_cert_hash = $util.newBuffer($util.base64.length(object.client_tls_cert_hash)), 0);
                    else if (object.client_tls_cert_hash.length)
                        message.client_tls_cert_hash = object.client_tls_cert_hash;
                return message;
            };
    
            /**
             * Creates a plain object from an AuthInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.AuthInfo
             * @static
             * @param {discovery.AuthInfo} message AuthInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuthInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.client_identity = "";
                    else {
                        object.client_identity = [];
                        if (options.bytes !== Array)
                            object.client_identity = $util.newBuffer(object.client_identity);
                    }
                    if (options.bytes === String)
                        object.client_tls_cert_hash = "";
                    else {
                        object.client_tls_cert_hash = [];
                        if (options.bytes !== Array)
                            object.client_tls_cert_hash = $util.newBuffer(object.client_tls_cert_hash);
                    }
                }
                if (message.client_identity != null && message.hasOwnProperty("client_identity"))
                    object.client_identity = options.bytes === String ? $util.base64.encode(message.client_identity, 0, message.client_identity.length) : options.bytes === Array ? Array.prototype.slice.call(message.client_identity) : message.client_identity;
                if (message.client_tls_cert_hash != null && message.hasOwnProperty("client_tls_cert_hash"))
                    object.client_tls_cert_hash = options.bytes === String ? $util.base64.encode(message.client_tls_cert_hash, 0, message.client_tls_cert_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.client_tls_cert_hash) : message.client_tls_cert_hash;
                return object;
            };
    
            /**
             * Converts this AuthInfo to JSON.
             * @function toJSON
             * @memberof discovery.AuthInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuthInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AuthInfo;
        })();
    
        discovery.Query = (function() {
    
            /**
             * Properties of a Query.
             * @memberof discovery
             * @interface IQuery
             * @property {string|null} [channel] Query channel
             * @property {discovery.IConfigQuery|null} [config_query] Query config_query
             * @property {discovery.IPeerMembershipQuery|null} [peer_query] Query peer_query
             * @property {discovery.IChaincodeQuery|null} [cc_query] Query cc_query
             * @property {discovery.ILocalPeerQuery|null} [local_peers] Query local_peers
             */
    
            /**
             * Constructs a new Query.
             * @memberof discovery
             * @classdesc Represents a Query.
             * @implements IQuery
             * @constructor
             * @param {discovery.IQuery=} [properties] Properties to set
             */
            function Query(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Query channel.
             * @member {string} channel
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.channel = "";
    
            /**
             * Query config_query.
             * @member {discovery.IConfigQuery|null|undefined} config_query
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.config_query = null;
    
            /**
             * Query peer_query.
             * @member {discovery.IPeerMembershipQuery|null|undefined} peer_query
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.peer_query = null;
    
            /**
             * Query cc_query.
             * @member {discovery.IChaincodeQuery|null|undefined} cc_query
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.cc_query = null;
    
            /**
             * Query local_peers.
             * @member {discovery.ILocalPeerQuery|null|undefined} local_peers
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.local_peers = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Query query.
             * @member {"config_query"|"peer_query"|"cc_query"|"local_peers"|undefined} query
             * @memberof discovery.Query
             * @instance
             */
            Object.defineProperty(Query.prototype, "query", {
                get: $util.oneOfGetter($oneOfFields = ["config_query", "peer_query", "cc_query", "local_peers"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Query instance using the specified properties.
             * @function create
             * @memberof discovery.Query
             * @static
             * @param {discovery.IQuery=} [properties] Properties to set
             * @returns {discovery.Query} Query instance
             */
            Query.create = function create(properties) {
                return new Query(properties);
            };
    
            /**
             * Encodes the specified Query message. Does not implicitly {@link discovery.Query.verify|verify} messages.
             * @function encode
             * @memberof discovery.Query
             * @static
             * @param {discovery.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.config_query != null && Object.hasOwnProperty.call(message, "config_query"))
                    $root.discovery.ConfigQuery.encode(message.config_query, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.peer_query != null && Object.hasOwnProperty.call(message, "peer_query"))
                    $root.discovery.PeerMembershipQuery.encode(message.peer_query, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.cc_query != null && Object.hasOwnProperty.call(message, "cc_query"))
                    $root.discovery.ChaincodeQuery.encode(message.cc_query, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.local_peers != null && Object.hasOwnProperty.call(message, "local_peers"))
                    $root.discovery.LocalPeerQuery.encode(message.local_peers, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Query message, length delimited. Does not implicitly {@link discovery.Query.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Query
             * @static
             * @param {discovery.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Query message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Query();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.config_query = $root.discovery.ConfigQuery.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.peer_query = $root.discovery.PeerMembershipQuery.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.cc_query = $root.discovery.ChaincodeQuery.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.local_peers = $root.discovery.LocalPeerQuery.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Query message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Query message.
             * @function verify
             * @memberof discovery.Query
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Query.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.config_query != null && message.hasOwnProperty("config_query")) {
                    properties.query = 1;
                    {
                        var error = $root.discovery.ConfigQuery.verify(message.config_query);
                        if (error)
                            return "config_query." + error;
                    }
                }
                if (message.peer_query != null && message.hasOwnProperty("peer_query")) {
                    if (properties.query === 1)
                        return "query: multiple values";
                    properties.query = 1;
                    {
                        var error = $root.discovery.PeerMembershipQuery.verify(message.peer_query);
                        if (error)
                            return "peer_query." + error;
                    }
                }
                if (message.cc_query != null && message.hasOwnProperty("cc_query")) {
                    if (properties.query === 1)
                        return "query: multiple values";
                    properties.query = 1;
                    {
                        var error = $root.discovery.ChaincodeQuery.verify(message.cc_query);
                        if (error)
                            return "cc_query." + error;
                    }
                }
                if (message.local_peers != null && message.hasOwnProperty("local_peers")) {
                    if (properties.query === 1)
                        return "query: multiple values";
                    properties.query = 1;
                    {
                        var error = $root.discovery.LocalPeerQuery.verify(message.local_peers);
                        if (error)
                            return "local_peers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Query message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Query
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Query} Query
             */
            Query.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Query)
                    return object;
                var message = new $root.discovery.Query();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.config_query != null) {
                    if (typeof object.config_query !== "object")
                        throw TypeError(".discovery.Query.config_query: object expected");
                    message.config_query = $root.discovery.ConfigQuery.fromObject(object.config_query);
                }
                if (object.peer_query != null) {
                    if (typeof object.peer_query !== "object")
                        throw TypeError(".discovery.Query.peer_query: object expected");
                    message.peer_query = $root.discovery.PeerMembershipQuery.fromObject(object.peer_query);
                }
                if (object.cc_query != null) {
                    if (typeof object.cc_query !== "object")
                        throw TypeError(".discovery.Query.cc_query: object expected");
                    message.cc_query = $root.discovery.ChaincodeQuery.fromObject(object.cc_query);
                }
                if (object.local_peers != null) {
                    if (typeof object.local_peers !== "object")
                        throw TypeError(".discovery.Query.local_peers: object expected");
                    message.local_peers = $root.discovery.LocalPeerQuery.fromObject(object.local_peers);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Query message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Query
             * @static
             * @param {discovery.Query} message Query
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Query.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.channel = "";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.config_query != null && message.hasOwnProperty("config_query")) {
                    object.config_query = $root.discovery.ConfigQuery.toObject(message.config_query, options);
                    if (options.oneofs)
                        object.query = "config_query";
                }
                if (message.peer_query != null && message.hasOwnProperty("peer_query")) {
                    object.peer_query = $root.discovery.PeerMembershipQuery.toObject(message.peer_query, options);
                    if (options.oneofs)
                        object.query = "peer_query";
                }
                if (message.cc_query != null && message.hasOwnProperty("cc_query")) {
                    object.cc_query = $root.discovery.ChaincodeQuery.toObject(message.cc_query, options);
                    if (options.oneofs)
                        object.query = "cc_query";
                }
                if (message.local_peers != null && message.hasOwnProperty("local_peers")) {
                    object.local_peers = $root.discovery.LocalPeerQuery.toObject(message.local_peers, options);
                    if (options.oneofs)
                        object.query = "local_peers";
                }
                return object;
            };
    
            /**
             * Converts this Query to JSON.
             * @function toJSON
             * @memberof discovery.Query
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Query.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Query;
        })();
    
        discovery.QueryResult = (function() {
    
            /**
             * Properties of a QueryResult.
             * @memberof discovery
             * @interface IQueryResult
             * @property {discovery.IError|null} [error] QueryResult error
             * @property {discovery.IConfigResult|null} [config_result] QueryResult config_result
             * @property {discovery.IChaincodeQueryResult|null} [cc_query_res] QueryResult cc_query_res
             * @property {discovery.IPeerMembershipResult|null} [members] QueryResult members
             */
    
            /**
             * Constructs a new QueryResult.
             * @memberof discovery
             * @classdesc Represents a QueryResult.
             * @implements IQueryResult
             * @constructor
             * @param {discovery.IQueryResult=} [properties] Properties to set
             */
            function QueryResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryResult error.
             * @member {discovery.IError|null|undefined} error
             * @memberof discovery.QueryResult
             * @instance
             */
            QueryResult.prototype.error = null;
    
            /**
             * QueryResult config_result.
             * @member {discovery.IConfigResult|null|undefined} config_result
             * @memberof discovery.QueryResult
             * @instance
             */
            QueryResult.prototype.config_result = null;
    
            /**
             * QueryResult cc_query_res.
             * @member {discovery.IChaincodeQueryResult|null|undefined} cc_query_res
             * @memberof discovery.QueryResult
             * @instance
             */
            QueryResult.prototype.cc_query_res = null;
    
            /**
             * QueryResult members.
             * @member {discovery.IPeerMembershipResult|null|undefined} members
             * @memberof discovery.QueryResult
             * @instance
             */
            QueryResult.prototype.members = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * QueryResult result.
             * @member {"error"|"config_result"|"cc_query_res"|"members"|undefined} result
             * @memberof discovery.QueryResult
             * @instance
             */
            Object.defineProperty(QueryResult.prototype, "result", {
                get: $util.oneOfGetter($oneOfFields = ["error", "config_result", "cc_query_res", "members"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new QueryResult instance using the specified properties.
             * @function create
             * @memberof discovery.QueryResult
             * @static
             * @param {discovery.IQueryResult=} [properties] Properties to set
             * @returns {discovery.QueryResult} QueryResult instance
             */
            QueryResult.create = function create(properties) {
                return new QueryResult(properties);
            };
    
            /**
             * Encodes the specified QueryResult message. Does not implicitly {@link discovery.QueryResult.verify|verify} messages.
             * @function encode
             * @memberof discovery.QueryResult
             * @static
             * @param {discovery.IQueryResult} message QueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    $root.discovery.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.config_result != null && Object.hasOwnProperty.call(message, "config_result"))
                    $root.discovery.ConfigResult.encode(message.config_result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cc_query_res != null && Object.hasOwnProperty.call(message, "cc_query_res"))
                    $root.discovery.ChaincodeQueryResult.encode(message.cc_query_res, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.members != null && Object.hasOwnProperty.call(message, "members"))
                    $root.discovery.PeerMembershipResult.encode(message.members, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryResult message, length delimited. Does not implicitly {@link discovery.QueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.QueryResult
             * @static
             * @param {discovery.IQueryResult} message QueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.QueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.QueryResult} QueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.QueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.discovery.Error.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.config_result = $root.discovery.ConfigResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.cc_query_res = $root.discovery.ChaincodeQueryResult.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.members = $root.discovery.PeerMembershipResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.QueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.QueryResult} QueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryResult message.
             * @function verify
             * @memberof discovery.QueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.result = 1;
                    {
                        var error = $root.discovery.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.config_result != null && message.hasOwnProperty("config_result")) {
                    if (properties.result === 1)
                        return "result: multiple values";
                    properties.result = 1;
                    {
                        var error = $root.discovery.ConfigResult.verify(message.config_result);
                        if (error)
                            return "config_result." + error;
                    }
                }
                if (message.cc_query_res != null && message.hasOwnProperty("cc_query_res")) {
                    if (properties.result === 1)
                        return "result: multiple values";
                    properties.result = 1;
                    {
                        var error = $root.discovery.ChaincodeQueryResult.verify(message.cc_query_res);
                        if (error)
                            return "cc_query_res." + error;
                    }
                }
                if (message.members != null && message.hasOwnProperty("members")) {
                    if (properties.result === 1)
                        return "result: multiple values";
                    properties.result = 1;
                    {
                        var error = $root.discovery.PeerMembershipResult.verify(message.members);
                        if (error)
                            return "members." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.QueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.QueryResult} QueryResult
             */
            QueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.QueryResult)
                    return object;
                var message = new $root.discovery.QueryResult();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".discovery.QueryResult.error: object expected");
                    message.error = $root.discovery.Error.fromObject(object.error);
                }
                if (object.config_result != null) {
                    if (typeof object.config_result !== "object")
                        throw TypeError(".discovery.QueryResult.config_result: object expected");
                    message.config_result = $root.discovery.ConfigResult.fromObject(object.config_result);
                }
                if (object.cc_query_res != null) {
                    if (typeof object.cc_query_res !== "object")
                        throw TypeError(".discovery.QueryResult.cc_query_res: object expected");
                    message.cc_query_res = $root.discovery.ChaincodeQueryResult.fromObject(object.cc_query_res);
                }
                if (object.members != null) {
                    if (typeof object.members !== "object")
                        throw TypeError(".discovery.QueryResult.members: object expected");
                    message.members = $root.discovery.PeerMembershipResult.fromObject(object.members);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.QueryResult
             * @static
             * @param {discovery.QueryResult} message QueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.discovery.Error.toObject(message.error, options);
                    if (options.oneofs)
                        object.result = "error";
                }
                if (message.config_result != null && message.hasOwnProperty("config_result")) {
                    object.config_result = $root.discovery.ConfigResult.toObject(message.config_result, options);
                    if (options.oneofs)
                        object.result = "config_result";
                }
                if (message.cc_query_res != null && message.hasOwnProperty("cc_query_res")) {
                    object.cc_query_res = $root.discovery.ChaincodeQueryResult.toObject(message.cc_query_res, options);
                    if (options.oneofs)
                        object.result = "cc_query_res";
                }
                if (message.members != null && message.hasOwnProperty("members")) {
                    object.members = $root.discovery.PeerMembershipResult.toObject(message.members, options);
                    if (options.oneofs)
                        object.result = "members";
                }
                return object;
            };
    
            /**
             * Converts this QueryResult to JSON.
             * @function toJSON
             * @memberof discovery.QueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryResult;
        })();
    
        discovery.ConfigQuery = (function() {
    
            /**
             * Properties of a ConfigQuery.
             * @memberof discovery
             * @interface IConfigQuery
             */
    
            /**
             * Constructs a new ConfigQuery.
             * @memberof discovery
             * @classdesc Represents a ConfigQuery.
             * @implements IConfigQuery
             * @constructor
             * @param {discovery.IConfigQuery=} [properties] Properties to set
             */
            function ConfigQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ConfigQuery instance using the specified properties.
             * @function create
             * @memberof discovery.ConfigQuery
             * @static
             * @param {discovery.IConfigQuery=} [properties] Properties to set
             * @returns {discovery.ConfigQuery} ConfigQuery instance
             */
            ConfigQuery.create = function create(properties) {
                return new ConfigQuery(properties);
            };
    
            /**
             * Encodes the specified ConfigQuery message. Does not implicitly {@link discovery.ConfigQuery.verify|verify} messages.
             * @function encode
             * @memberof discovery.ConfigQuery
             * @static
             * @param {discovery.IConfigQuery} message ConfigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigQuery message, length delimited. Does not implicitly {@link discovery.ConfigQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ConfigQuery
             * @static
             * @param {discovery.IConfigQuery} message ConfigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigQuery message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ConfigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ConfigQuery} ConfigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ConfigQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ConfigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ConfigQuery} ConfigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigQuery message.
             * @function verify
             * @memberof discovery.ConfigQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ConfigQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ConfigQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ConfigQuery} ConfigQuery
             */
            ConfigQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ConfigQuery)
                    return object;
                return new $root.discovery.ConfigQuery();
            };
    
            /**
             * Creates a plain object from a ConfigQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ConfigQuery
             * @static
             * @param {discovery.ConfigQuery} message ConfigQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigQuery.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ConfigQuery to JSON.
             * @function toJSON
             * @memberof discovery.ConfigQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigQuery;
        })();
    
        discovery.ConfigResult = (function() {
    
            /**
             * Properties of a ConfigResult.
             * @memberof discovery
             * @interface IConfigResult
             * @property {Object.<string,msp.IFabricMSPConfig>|null} [msps] ConfigResult msps
             * @property {Object.<string,discovery.IEndpoints>|null} [orderers] ConfigResult orderers
             */
    
            /**
             * Constructs a new ConfigResult.
             * @memberof discovery
             * @classdesc Represents a ConfigResult.
             * @implements IConfigResult
             * @constructor
             * @param {discovery.IConfigResult=} [properties] Properties to set
             */
            function ConfigResult(properties) {
                this.msps = {};
                this.orderers = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigResult msps.
             * @member {Object.<string,msp.IFabricMSPConfig>} msps
             * @memberof discovery.ConfigResult
             * @instance
             */
            ConfigResult.prototype.msps = $util.emptyObject;
    
            /**
             * ConfigResult orderers.
             * @member {Object.<string,discovery.IEndpoints>} orderers
             * @memberof discovery.ConfigResult
             * @instance
             */
            ConfigResult.prototype.orderers = $util.emptyObject;
    
            /**
             * Creates a new ConfigResult instance using the specified properties.
             * @function create
             * @memberof discovery.ConfigResult
             * @static
             * @param {discovery.IConfigResult=} [properties] Properties to set
             * @returns {discovery.ConfigResult} ConfigResult instance
             */
            ConfigResult.create = function create(properties) {
                return new ConfigResult(properties);
            };
    
            /**
             * Encodes the specified ConfigResult message. Does not implicitly {@link discovery.ConfigResult.verify|verify} messages.
             * @function encode
             * @memberof discovery.ConfigResult
             * @static
             * @param {discovery.IConfigResult} message ConfigResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msps != null && Object.hasOwnProperty.call(message, "msps"))
                    for (var keys = Object.keys(message.msps), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.msp.FabricMSPConfig.encode(message.msps[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.orderers != null && Object.hasOwnProperty.call(message, "orderers"))
                    for (var keys = Object.keys(message.orderers), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.discovery.Endpoints.encode(message.orderers[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified ConfigResult message, length delimited. Does not implicitly {@link discovery.ConfigResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ConfigResult
             * @static
             * @param {discovery.IConfigResult} message ConfigResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigResult message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ConfigResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ConfigResult} ConfigResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ConfigResult(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.msps === $util.emptyObject)
                            message.msps = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.msp.FabricMSPConfig.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.msps[key] = value;
                        break;
                    case 2:
                        if (message.orderers === $util.emptyObject)
                            message.orderers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.discovery.Endpoints.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.orderers[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ConfigResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ConfigResult} ConfigResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigResult message.
             * @function verify
             * @memberof discovery.ConfigResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msps != null && message.hasOwnProperty("msps")) {
                    if (!$util.isObject(message.msps))
                        return "msps: object expected";
                    var key = Object.keys(message.msps);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.msp.FabricMSPConfig.verify(message.msps[key[i]]);
                        if (error)
                            return "msps." + error;
                    }
                }
                if (message.orderers != null && message.hasOwnProperty("orderers")) {
                    if (!$util.isObject(message.orderers))
                        return "orderers: object expected";
                    var key = Object.keys(message.orderers);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.discovery.Endpoints.verify(message.orderers[key[i]]);
                        if (error)
                            return "orderers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ConfigResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ConfigResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ConfigResult} ConfigResult
             */
            ConfigResult.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ConfigResult)
                    return object;
                var message = new $root.discovery.ConfigResult();
                if (object.msps) {
                    if (typeof object.msps !== "object")
                        throw TypeError(".discovery.ConfigResult.msps: object expected");
                    message.msps = {};
                    for (var keys = Object.keys(object.msps), i = 0; i < keys.length; ++i) {
                        if (typeof object.msps[keys[i]] !== "object")
                            throw TypeError(".discovery.ConfigResult.msps: object expected");
                        message.msps[keys[i]] = $root.msp.FabricMSPConfig.fromObject(object.msps[keys[i]]);
                    }
                }
                if (object.orderers) {
                    if (typeof object.orderers !== "object")
                        throw TypeError(".discovery.ConfigResult.orderers: object expected");
                    message.orderers = {};
                    for (var keys = Object.keys(object.orderers), i = 0; i < keys.length; ++i) {
                        if (typeof object.orderers[keys[i]] !== "object")
                            throw TypeError(".discovery.ConfigResult.orderers: object expected");
                        message.orderers[keys[i]] = $root.discovery.Endpoints.fromObject(object.orderers[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ConfigResult
             * @static
             * @param {discovery.ConfigResult} message ConfigResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults) {
                    object.msps = {};
                    object.orderers = {};
                }
                var keys2;
                if (message.msps && (keys2 = Object.keys(message.msps)).length) {
                    object.msps = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.msps[keys2[j]] = $root.msp.FabricMSPConfig.toObject(message.msps[keys2[j]], options);
                }
                if (message.orderers && (keys2 = Object.keys(message.orderers)).length) {
                    object.orderers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.orderers[keys2[j]] = $root.discovery.Endpoints.toObject(message.orderers[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this ConfigResult to JSON.
             * @function toJSON
             * @memberof discovery.ConfigResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigResult;
        })();
    
        discovery.PeerMembershipQuery = (function() {
    
            /**
             * Properties of a PeerMembershipQuery.
             * @memberof discovery
             * @interface IPeerMembershipQuery
             * @property {discovery.IChaincodeInterest|null} [filter] PeerMembershipQuery filter
             */
    
            /**
             * Constructs a new PeerMembershipQuery.
             * @memberof discovery
             * @classdesc Represents a PeerMembershipQuery.
             * @implements IPeerMembershipQuery
             * @constructor
             * @param {discovery.IPeerMembershipQuery=} [properties] Properties to set
             */
            function PeerMembershipQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerMembershipQuery filter.
             * @member {discovery.IChaincodeInterest|null|undefined} filter
             * @memberof discovery.PeerMembershipQuery
             * @instance
             */
            PeerMembershipQuery.prototype.filter = null;
    
            /**
             * Creates a new PeerMembershipQuery instance using the specified properties.
             * @function create
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {discovery.IPeerMembershipQuery=} [properties] Properties to set
             * @returns {discovery.PeerMembershipQuery} PeerMembershipQuery instance
             */
            PeerMembershipQuery.create = function create(properties) {
                return new PeerMembershipQuery(properties);
            };
    
            /**
             * Encodes the specified PeerMembershipQuery message. Does not implicitly {@link discovery.PeerMembershipQuery.verify|verify} messages.
             * @function encode
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {discovery.IPeerMembershipQuery} message PeerMembershipQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerMembershipQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    $root.discovery.ChaincodeInterest.encode(message.filter, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PeerMembershipQuery message, length delimited. Does not implicitly {@link discovery.PeerMembershipQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {discovery.IPeerMembershipQuery} message PeerMembershipQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerMembershipQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerMembershipQuery message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.PeerMembershipQuery} PeerMembershipQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerMembershipQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.PeerMembershipQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.filter = $root.discovery.ChaincodeInterest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerMembershipQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.PeerMembershipQuery} PeerMembershipQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerMembershipQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerMembershipQuery message.
             * @function verify
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerMembershipQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.discovery.ChaincodeInterest.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                return null;
            };
    
            /**
             * Creates a PeerMembershipQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.PeerMembershipQuery} PeerMembershipQuery
             */
            PeerMembershipQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.PeerMembershipQuery)
                    return object;
                var message = new $root.discovery.PeerMembershipQuery();
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".discovery.PeerMembershipQuery.filter: object expected");
                    message.filter = $root.discovery.ChaincodeInterest.fromObject(object.filter);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PeerMembershipQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {discovery.PeerMembershipQuery} message PeerMembershipQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerMembershipQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.filter = null;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.discovery.ChaincodeInterest.toObject(message.filter, options);
                return object;
            };
    
            /**
             * Converts this PeerMembershipQuery to JSON.
             * @function toJSON
             * @memberof discovery.PeerMembershipQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerMembershipQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PeerMembershipQuery;
        })();
    
        discovery.PeerMembershipResult = (function() {
    
            /**
             * Properties of a PeerMembershipResult.
             * @memberof discovery
             * @interface IPeerMembershipResult
             * @property {Object.<string,discovery.IPeers>|null} [peers_by_org] PeerMembershipResult peers_by_org
             */
    
            /**
             * Constructs a new PeerMembershipResult.
             * @memberof discovery
             * @classdesc Represents a PeerMembershipResult.
             * @implements IPeerMembershipResult
             * @constructor
             * @param {discovery.IPeerMembershipResult=} [properties] Properties to set
             */
            function PeerMembershipResult(properties) {
                this.peers_by_org = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerMembershipResult peers_by_org.
             * @member {Object.<string,discovery.IPeers>} peers_by_org
             * @memberof discovery.PeerMembershipResult
             * @instance
             */
            PeerMembershipResult.prototype.peers_by_org = $util.emptyObject;
    
            /**
             * Creates a new PeerMembershipResult instance using the specified properties.
             * @function create
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {discovery.IPeerMembershipResult=} [properties] Properties to set
             * @returns {discovery.PeerMembershipResult} PeerMembershipResult instance
             */
            PeerMembershipResult.create = function create(properties) {
                return new PeerMembershipResult(properties);
            };
    
            /**
             * Encodes the specified PeerMembershipResult message. Does not implicitly {@link discovery.PeerMembershipResult.verify|verify} messages.
             * @function encode
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {discovery.IPeerMembershipResult} message PeerMembershipResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerMembershipResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peers_by_org != null && Object.hasOwnProperty.call(message, "peers_by_org"))
                    for (var keys = Object.keys(message.peers_by_org), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.discovery.Peers.encode(message.peers_by_org[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified PeerMembershipResult message, length delimited. Does not implicitly {@link discovery.PeerMembershipResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {discovery.IPeerMembershipResult} message PeerMembershipResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerMembershipResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerMembershipResult message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.PeerMembershipResult} PeerMembershipResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerMembershipResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.PeerMembershipResult(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.peers_by_org === $util.emptyObject)
                            message.peers_by_org = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.discovery.Peers.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.peers_by_org[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerMembershipResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.PeerMembershipResult} PeerMembershipResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerMembershipResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerMembershipResult message.
             * @function verify
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerMembershipResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peers_by_org != null && message.hasOwnProperty("peers_by_org")) {
                    if (!$util.isObject(message.peers_by_org))
                        return "peers_by_org: object expected";
                    var key = Object.keys(message.peers_by_org);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.discovery.Peers.verify(message.peers_by_org[key[i]]);
                        if (error)
                            return "peers_by_org." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a PeerMembershipResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.PeerMembershipResult} PeerMembershipResult
             */
            PeerMembershipResult.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.PeerMembershipResult)
                    return object;
                var message = new $root.discovery.PeerMembershipResult();
                if (object.peers_by_org) {
                    if (typeof object.peers_by_org !== "object")
                        throw TypeError(".discovery.PeerMembershipResult.peers_by_org: object expected");
                    message.peers_by_org = {};
                    for (var keys = Object.keys(object.peers_by_org), i = 0; i < keys.length; ++i) {
                        if (typeof object.peers_by_org[keys[i]] !== "object")
                            throw TypeError(".discovery.PeerMembershipResult.peers_by_org: object expected");
                        message.peers_by_org[keys[i]] = $root.discovery.Peers.fromObject(object.peers_by_org[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PeerMembershipResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {discovery.PeerMembershipResult} message PeerMembershipResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerMembershipResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.peers_by_org = {};
                var keys2;
                if (message.peers_by_org && (keys2 = Object.keys(message.peers_by_org)).length) {
                    object.peers_by_org = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.peers_by_org[keys2[j]] = $root.discovery.Peers.toObject(message.peers_by_org[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this PeerMembershipResult to JSON.
             * @function toJSON
             * @memberof discovery.PeerMembershipResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerMembershipResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PeerMembershipResult;
        })();
    
        discovery.ChaincodeQuery = (function() {
    
            /**
             * Properties of a ChaincodeQuery.
             * @memberof discovery
             * @interface IChaincodeQuery
             * @property {Array.<discovery.IChaincodeInterest>|null} [interests] ChaincodeQuery interests
             */
    
            /**
             * Constructs a new ChaincodeQuery.
             * @memberof discovery
             * @classdesc Represents a ChaincodeQuery.
             * @implements IChaincodeQuery
             * @constructor
             * @param {discovery.IChaincodeQuery=} [properties] Properties to set
             */
            function ChaincodeQuery(properties) {
                this.interests = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeQuery interests.
             * @member {Array.<discovery.IChaincodeInterest>} interests
             * @memberof discovery.ChaincodeQuery
             * @instance
             */
            ChaincodeQuery.prototype.interests = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeQuery instance using the specified properties.
             * @function create
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {discovery.IChaincodeQuery=} [properties] Properties to set
             * @returns {discovery.ChaincodeQuery} ChaincodeQuery instance
             */
            ChaincodeQuery.create = function create(properties) {
                return new ChaincodeQuery(properties);
            };
    
            /**
             * Encodes the specified ChaincodeQuery message. Does not implicitly {@link discovery.ChaincodeQuery.verify|verify} messages.
             * @function encode
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {discovery.IChaincodeQuery} message ChaincodeQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.interests != null && message.interests.length)
                    for (var i = 0; i < message.interests.length; ++i)
                        $root.discovery.ChaincodeInterest.encode(message.interests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeQuery message, length delimited. Does not implicitly {@link discovery.ChaincodeQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {discovery.IChaincodeQuery} message ChaincodeQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeQuery message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ChaincodeQuery} ChaincodeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ChaincodeQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.interests && message.interests.length))
                            message.interests = [];
                        message.interests.push($root.discovery.ChaincodeInterest.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ChaincodeQuery} ChaincodeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeQuery message.
             * @function verify
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.interests != null && message.hasOwnProperty("interests")) {
                    if (!Array.isArray(message.interests))
                        return "interests: array expected";
                    for (var i = 0; i < message.interests.length; ++i) {
                        var error = $root.discovery.ChaincodeInterest.verify(message.interests[i]);
                        if (error)
                            return "interests." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ChaincodeQuery} ChaincodeQuery
             */
            ChaincodeQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ChaincodeQuery)
                    return object;
                var message = new $root.discovery.ChaincodeQuery();
                if (object.interests) {
                    if (!Array.isArray(object.interests))
                        throw TypeError(".discovery.ChaincodeQuery.interests: array expected");
                    message.interests = [];
                    for (var i = 0; i < object.interests.length; ++i) {
                        if (typeof object.interests[i] !== "object")
                            throw TypeError(".discovery.ChaincodeQuery.interests: object expected");
                        message.interests[i] = $root.discovery.ChaincodeInterest.fromObject(object.interests[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {discovery.ChaincodeQuery} message ChaincodeQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.interests = [];
                if (message.interests && message.interests.length) {
                    object.interests = [];
                    for (var j = 0; j < message.interests.length; ++j)
                        object.interests[j] = $root.discovery.ChaincodeInterest.toObject(message.interests[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeQuery to JSON.
             * @function toJSON
             * @memberof discovery.ChaincodeQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeQuery;
        })();
    
        discovery.ChaincodeInterest = (function() {
    
            /**
             * Properties of a ChaincodeInterest.
             * @memberof discovery
             * @interface IChaincodeInterest
             * @property {Array.<discovery.IChaincodeCall>|null} [chaincodes] ChaincodeInterest chaincodes
             */
    
            /**
             * Constructs a new ChaincodeInterest.
             * @memberof discovery
             * @classdesc Represents a ChaincodeInterest.
             * @implements IChaincodeInterest
             * @constructor
             * @param {discovery.IChaincodeInterest=} [properties] Properties to set
             */
            function ChaincodeInterest(properties) {
                this.chaincodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeInterest chaincodes.
             * @member {Array.<discovery.IChaincodeCall>} chaincodes
             * @memberof discovery.ChaincodeInterest
             * @instance
             */
            ChaincodeInterest.prototype.chaincodes = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeInterest instance using the specified properties.
             * @function create
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {discovery.IChaincodeInterest=} [properties] Properties to set
             * @returns {discovery.ChaincodeInterest} ChaincodeInterest instance
             */
            ChaincodeInterest.create = function create(properties) {
                return new ChaincodeInterest(properties);
            };
    
            /**
             * Encodes the specified ChaincodeInterest message. Does not implicitly {@link discovery.ChaincodeInterest.verify|verify} messages.
             * @function encode
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {discovery.IChaincodeInterest} message ChaincodeInterest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInterest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodes != null && message.chaincodes.length)
                    for (var i = 0; i < message.chaincodes.length; ++i)
                        $root.discovery.ChaincodeCall.encode(message.chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeInterest message, length delimited. Does not implicitly {@link discovery.ChaincodeInterest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {discovery.IChaincodeInterest} message ChaincodeInterest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInterest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeInterest message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ChaincodeInterest} ChaincodeInterest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInterest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ChaincodeInterest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.chaincodes && message.chaincodes.length))
                            message.chaincodes = [];
                        message.chaincodes.push($root.discovery.ChaincodeCall.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeInterest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ChaincodeInterest} ChaincodeInterest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInterest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeInterest message.
             * @function verify
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeInterest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                    if (!Array.isArray(message.chaincodes))
                        return "chaincodes: array expected";
                    for (var i = 0; i < message.chaincodes.length; ++i) {
                        var error = $root.discovery.ChaincodeCall.verify(message.chaincodes[i]);
                        if (error)
                            return "chaincodes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeInterest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ChaincodeInterest} ChaincodeInterest
             */
            ChaincodeInterest.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ChaincodeInterest)
                    return object;
                var message = new $root.discovery.ChaincodeInterest();
                if (object.chaincodes) {
                    if (!Array.isArray(object.chaincodes))
                        throw TypeError(".discovery.ChaincodeInterest.chaincodes: array expected");
                    message.chaincodes = [];
                    for (var i = 0; i < object.chaincodes.length; ++i) {
                        if (typeof object.chaincodes[i] !== "object")
                            throw TypeError(".discovery.ChaincodeInterest.chaincodes: object expected");
                        message.chaincodes[i] = $root.discovery.ChaincodeCall.fromObject(object.chaincodes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeInterest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {discovery.ChaincodeInterest} message ChaincodeInterest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeInterest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincodes = [];
                if (message.chaincodes && message.chaincodes.length) {
                    object.chaincodes = [];
                    for (var j = 0; j < message.chaincodes.length; ++j)
                        object.chaincodes[j] = $root.discovery.ChaincodeCall.toObject(message.chaincodes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeInterest to JSON.
             * @function toJSON
             * @memberof discovery.ChaincodeInterest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeInterest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeInterest;
        })();
    
        discovery.ChaincodeCall = (function() {
    
            /**
             * Properties of a ChaincodeCall.
             * @memberof discovery
             * @interface IChaincodeCall
             * @property {string|null} [name] ChaincodeCall name
             * @property {Array.<string>|null} [collection_names] ChaincodeCall collection_names
             * @property {boolean|null} [no_private_reads] ChaincodeCall no_private_reads
             * @property {boolean|null} [no_public_writes] ChaincodeCall no_public_writes
             */
    
            /**
             * Constructs a new ChaincodeCall.
             * @memberof discovery
             * @classdesc Represents a ChaincodeCall.
             * @implements IChaincodeCall
             * @constructor
             * @param {discovery.IChaincodeCall=} [properties] Properties to set
             */
            function ChaincodeCall(properties) {
                this.collection_names = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeCall name.
             * @member {string} name
             * @memberof discovery.ChaincodeCall
             * @instance
             */
            ChaincodeCall.prototype.name = "";
    
            /**
             * ChaincodeCall collection_names.
             * @member {Array.<string>} collection_names
             * @memberof discovery.ChaincodeCall
             * @instance
             */
            ChaincodeCall.prototype.collection_names = $util.emptyArray;
    
            /**
             * ChaincodeCall no_private_reads.
             * @member {boolean} no_private_reads
             * @memberof discovery.ChaincodeCall
             * @instance
             */
            ChaincodeCall.prototype.no_private_reads = false;
    
            /**
             * ChaincodeCall no_public_writes.
             * @member {boolean} no_public_writes
             * @memberof discovery.ChaincodeCall
             * @instance
             */
            ChaincodeCall.prototype.no_public_writes = false;
    
            /**
             * Creates a new ChaincodeCall instance using the specified properties.
             * @function create
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {discovery.IChaincodeCall=} [properties] Properties to set
             * @returns {discovery.ChaincodeCall} ChaincodeCall instance
             */
            ChaincodeCall.create = function create(properties) {
                return new ChaincodeCall(properties);
            };
    
            /**
             * Encodes the specified ChaincodeCall message. Does not implicitly {@link discovery.ChaincodeCall.verify|verify} messages.
             * @function encode
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {discovery.IChaincodeCall} message ChaincodeCall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeCall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.collection_names != null && message.collection_names.length)
                    for (var i = 0; i < message.collection_names.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection_names[i]);
                if (message.no_private_reads != null && Object.hasOwnProperty.call(message, "no_private_reads"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.no_private_reads);
                if (message.no_public_writes != null && Object.hasOwnProperty.call(message, "no_public_writes"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.no_public_writes);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeCall message, length delimited. Does not implicitly {@link discovery.ChaincodeCall.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {discovery.IChaincodeCall} message ChaincodeCall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeCall.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeCall message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ChaincodeCall} ChaincodeCall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeCall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ChaincodeCall();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.collection_names && message.collection_names.length))
                            message.collection_names = [];
                        message.collection_names.push(reader.string());
                        break;
                    case 3:
                        message.no_private_reads = reader.bool();
                        break;
                    case 4:
                        message.no_public_writes = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeCall message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ChaincodeCall} ChaincodeCall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeCall.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeCall message.
             * @function verify
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeCall.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.collection_names != null && message.hasOwnProperty("collection_names")) {
                    if (!Array.isArray(message.collection_names))
                        return "collection_names: array expected";
                    for (var i = 0; i < message.collection_names.length; ++i)
                        if (!$util.isString(message.collection_names[i]))
                            return "collection_names: string[] expected";
                }
                if (message.no_private_reads != null && message.hasOwnProperty("no_private_reads"))
                    if (typeof message.no_private_reads !== "boolean")
                        return "no_private_reads: boolean expected";
                if (message.no_public_writes != null && message.hasOwnProperty("no_public_writes"))
                    if (typeof message.no_public_writes !== "boolean")
                        return "no_public_writes: boolean expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeCall message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ChaincodeCall} ChaincodeCall
             */
            ChaincodeCall.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ChaincodeCall)
                    return object;
                var message = new $root.discovery.ChaincodeCall();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.collection_names) {
                    if (!Array.isArray(object.collection_names))
                        throw TypeError(".discovery.ChaincodeCall.collection_names: array expected");
                    message.collection_names = [];
                    for (var i = 0; i < object.collection_names.length; ++i)
                        message.collection_names[i] = String(object.collection_names[i]);
                }
                if (object.no_private_reads != null)
                    message.no_private_reads = Boolean(object.no_private_reads);
                if (object.no_public_writes != null)
                    message.no_public_writes = Boolean(object.no_public_writes);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeCall message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {discovery.ChaincodeCall} message ChaincodeCall
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeCall.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collection_names = [];
                if (options.defaults) {
                    object.name = "";
                    object.no_private_reads = false;
                    object.no_public_writes = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.collection_names && message.collection_names.length) {
                    object.collection_names = [];
                    for (var j = 0; j < message.collection_names.length; ++j)
                        object.collection_names[j] = message.collection_names[j];
                }
                if (message.no_private_reads != null && message.hasOwnProperty("no_private_reads"))
                    object.no_private_reads = message.no_private_reads;
                if (message.no_public_writes != null && message.hasOwnProperty("no_public_writes"))
                    object.no_public_writes = message.no_public_writes;
                return object;
            };
    
            /**
             * Converts this ChaincodeCall to JSON.
             * @function toJSON
             * @memberof discovery.ChaincodeCall
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeCall.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeCall;
        })();
    
        discovery.ChaincodeQueryResult = (function() {
    
            /**
             * Properties of a ChaincodeQueryResult.
             * @memberof discovery
             * @interface IChaincodeQueryResult
             * @property {Array.<discovery.IEndorsementDescriptor>|null} [content] ChaincodeQueryResult content
             */
    
            /**
             * Constructs a new ChaincodeQueryResult.
             * @memberof discovery
             * @classdesc Represents a ChaincodeQueryResult.
             * @implements IChaincodeQueryResult
             * @constructor
             * @param {discovery.IChaincodeQueryResult=} [properties] Properties to set
             */
            function ChaincodeQueryResult(properties) {
                this.content = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeQueryResult content.
             * @member {Array.<discovery.IEndorsementDescriptor>} content
             * @memberof discovery.ChaincodeQueryResult
             * @instance
             */
            ChaincodeQueryResult.prototype.content = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeQueryResult instance using the specified properties.
             * @function create
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {discovery.IChaincodeQueryResult=} [properties] Properties to set
             * @returns {discovery.ChaincodeQueryResult} ChaincodeQueryResult instance
             */
            ChaincodeQueryResult.create = function create(properties) {
                return new ChaincodeQueryResult(properties);
            };
    
            /**
             * Encodes the specified ChaincodeQueryResult message. Does not implicitly {@link discovery.ChaincodeQueryResult.verify|verify} messages.
             * @function encode
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {discovery.IChaincodeQueryResult} message ChaincodeQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.content != null && message.content.length)
                    for (var i = 0; i < message.content.length; ++i)
                        $root.discovery.EndorsementDescriptor.encode(message.content[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeQueryResult message, length delimited. Does not implicitly {@link discovery.ChaincodeQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {discovery.IChaincodeQueryResult} message ChaincodeQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ChaincodeQueryResult} ChaincodeQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ChaincodeQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.content && message.content.length))
                            message.content = [];
                        message.content.push($root.discovery.EndorsementDescriptor.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ChaincodeQueryResult} ChaincodeQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeQueryResult message.
             * @function verify
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.content != null && message.hasOwnProperty("content")) {
                    if (!Array.isArray(message.content))
                        return "content: array expected";
                    for (var i = 0; i < message.content.length; ++i) {
                        var error = $root.discovery.EndorsementDescriptor.verify(message.content[i]);
                        if (error)
                            return "content." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ChaincodeQueryResult} ChaincodeQueryResult
             */
            ChaincodeQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ChaincodeQueryResult)
                    return object;
                var message = new $root.discovery.ChaincodeQueryResult();
                if (object.content) {
                    if (!Array.isArray(object.content))
                        throw TypeError(".discovery.ChaincodeQueryResult.content: array expected");
                    message.content = [];
                    for (var i = 0; i < object.content.length; ++i) {
                        if (typeof object.content[i] !== "object")
                            throw TypeError(".discovery.ChaincodeQueryResult.content: object expected");
                        message.content[i] = $root.discovery.EndorsementDescriptor.fromObject(object.content[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {discovery.ChaincodeQueryResult} message ChaincodeQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.content = [];
                if (message.content && message.content.length) {
                    object.content = [];
                    for (var j = 0; j < message.content.length; ++j)
                        object.content[j] = $root.discovery.EndorsementDescriptor.toObject(message.content[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeQueryResult to JSON.
             * @function toJSON
             * @memberof discovery.ChaincodeQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeQueryResult;
        })();
    
        discovery.LocalPeerQuery = (function() {
    
            /**
             * Properties of a LocalPeerQuery.
             * @memberof discovery
             * @interface ILocalPeerQuery
             */
    
            /**
             * Constructs a new LocalPeerQuery.
             * @memberof discovery
             * @classdesc Represents a LocalPeerQuery.
             * @implements ILocalPeerQuery
             * @constructor
             * @param {discovery.ILocalPeerQuery=} [properties] Properties to set
             */
            function LocalPeerQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new LocalPeerQuery instance using the specified properties.
             * @function create
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {discovery.ILocalPeerQuery=} [properties] Properties to set
             * @returns {discovery.LocalPeerQuery} LocalPeerQuery instance
             */
            LocalPeerQuery.create = function create(properties) {
                return new LocalPeerQuery(properties);
            };
    
            /**
             * Encodes the specified LocalPeerQuery message. Does not implicitly {@link discovery.LocalPeerQuery.verify|verify} messages.
             * @function encode
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {discovery.ILocalPeerQuery} message LocalPeerQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalPeerQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified LocalPeerQuery message, length delimited. Does not implicitly {@link discovery.LocalPeerQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {discovery.ILocalPeerQuery} message LocalPeerQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalPeerQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LocalPeerQuery message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.LocalPeerQuery} LocalPeerQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalPeerQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.LocalPeerQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LocalPeerQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.LocalPeerQuery} LocalPeerQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalPeerQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LocalPeerQuery message.
             * @function verify
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocalPeerQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a LocalPeerQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.LocalPeerQuery} LocalPeerQuery
             */
            LocalPeerQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.LocalPeerQuery)
                    return object;
                return new $root.discovery.LocalPeerQuery();
            };
    
            /**
             * Creates a plain object from a LocalPeerQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {discovery.LocalPeerQuery} message LocalPeerQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocalPeerQuery.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this LocalPeerQuery to JSON.
             * @function toJSON
             * @memberof discovery.LocalPeerQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocalPeerQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LocalPeerQuery;
        })();
    
        discovery.EndorsementDescriptor = (function() {
    
            /**
             * Properties of an EndorsementDescriptor.
             * @memberof discovery
             * @interface IEndorsementDescriptor
             * @property {string|null} [chaincode] EndorsementDescriptor chaincode
             * @property {Object.<string,discovery.IPeers>|null} [endorsers_by_groups] EndorsementDescriptor endorsers_by_groups
             * @property {Array.<discovery.ILayout>|null} [layouts] EndorsementDescriptor layouts
             */
    
            /**
             * Constructs a new EndorsementDescriptor.
             * @memberof discovery
             * @classdesc Represents an EndorsementDescriptor.
             * @implements IEndorsementDescriptor
             * @constructor
             * @param {discovery.IEndorsementDescriptor=} [properties] Properties to set
             */
            function EndorsementDescriptor(properties) {
                this.endorsers_by_groups = {};
                this.layouts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * EndorsementDescriptor chaincode.
             * @member {string} chaincode
             * @memberof discovery.EndorsementDescriptor
             * @instance
             */
            EndorsementDescriptor.prototype.chaincode = "";
    
            /**
             * EndorsementDescriptor endorsers_by_groups.
             * @member {Object.<string,discovery.IPeers>} endorsers_by_groups
             * @memberof discovery.EndorsementDescriptor
             * @instance
             */
            EndorsementDescriptor.prototype.endorsers_by_groups = $util.emptyObject;
    
            /**
             * EndorsementDescriptor layouts.
             * @member {Array.<discovery.ILayout>} layouts
             * @memberof discovery.EndorsementDescriptor
             * @instance
             */
            EndorsementDescriptor.prototype.layouts = $util.emptyArray;
    
            /**
             * Creates a new EndorsementDescriptor instance using the specified properties.
             * @function create
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {discovery.IEndorsementDescriptor=} [properties] Properties to set
             * @returns {discovery.EndorsementDescriptor} EndorsementDescriptor instance
             */
            EndorsementDescriptor.create = function create(properties) {
                return new EndorsementDescriptor(properties);
            };
    
            /**
             * Encodes the specified EndorsementDescriptor message. Does not implicitly {@link discovery.EndorsementDescriptor.verify|verify} messages.
             * @function encode
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {discovery.IEndorsementDescriptor} message EndorsementDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndorsementDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode != null && Object.hasOwnProperty.call(message, "chaincode"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.chaincode);
                if (message.endorsers_by_groups != null && Object.hasOwnProperty.call(message, "endorsers_by_groups"))
                    for (var keys = Object.keys(message.endorsers_by_groups), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.discovery.Peers.encode(message.endorsers_by_groups[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.layouts != null && message.layouts.length)
                    for (var i = 0; i < message.layouts.length; ++i)
                        $root.discovery.Layout.encode(message.layouts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified EndorsementDescriptor message, length delimited. Does not implicitly {@link discovery.EndorsementDescriptor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {discovery.IEndorsementDescriptor} message EndorsementDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndorsementDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an EndorsementDescriptor message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.EndorsementDescriptor} EndorsementDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndorsementDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.EndorsementDescriptor(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode = reader.string();
                        break;
                    case 2:
                        if (message.endorsers_by_groups === $util.emptyObject)
                            message.endorsers_by_groups = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.discovery.Peers.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.endorsers_by_groups[key] = value;
                        break;
                    case 3:
                        if (!(message.layouts && message.layouts.length))
                            message.layouts = [];
                        message.layouts.push($root.discovery.Layout.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an EndorsementDescriptor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.EndorsementDescriptor} EndorsementDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndorsementDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an EndorsementDescriptor message.
             * @function verify
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EndorsementDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode != null && message.hasOwnProperty("chaincode"))
                    if (!$util.isString(message.chaincode))
                        return "chaincode: string expected";
                if (message.endorsers_by_groups != null && message.hasOwnProperty("endorsers_by_groups")) {
                    if (!$util.isObject(message.endorsers_by_groups))
                        return "endorsers_by_groups: object expected";
                    var key = Object.keys(message.endorsers_by_groups);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.discovery.Peers.verify(message.endorsers_by_groups[key[i]]);
                        if (error)
                            return "endorsers_by_groups." + error;
                    }
                }
                if (message.layouts != null && message.hasOwnProperty("layouts")) {
                    if (!Array.isArray(message.layouts))
                        return "layouts: array expected";
                    for (var i = 0; i < message.layouts.length; ++i) {
                        var error = $root.discovery.Layout.verify(message.layouts[i]);
                        if (error)
                            return "layouts." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates an EndorsementDescriptor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.EndorsementDescriptor} EndorsementDescriptor
             */
            EndorsementDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.EndorsementDescriptor)
                    return object;
                var message = new $root.discovery.EndorsementDescriptor();
                if (object.chaincode != null)
                    message.chaincode = String(object.chaincode);
                if (object.endorsers_by_groups) {
                    if (typeof object.endorsers_by_groups !== "object")
                        throw TypeError(".discovery.EndorsementDescriptor.endorsers_by_groups: object expected");
                    message.endorsers_by_groups = {};
                    for (var keys = Object.keys(object.endorsers_by_groups), i = 0; i < keys.length; ++i) {
                        if (typeof object.endorsers_by_groups[keys[i]] !== "object")
                            throw TypeError(".discovery.EndorsementDescriptor.endorsers_by_groups: object expected");
                        message.endorsers_by_groups[keys[i]] = $root.discovery.Peers.fromObject(object.endorsers_by_groups[keys[i]]);
                    }
                }
                if (object.layouts) {
                    if (!Array.isArray(object.layouts))
                        throw TypeError(".discovery.EndorsementDescriptor.layouts: array expected");
                    message.layouts = [];
                    for (var i = 0; i < object.layouts.length; ++i) {
                        if (typeof object.layouts[i] !== "object")
                            throw TypeError(".discovery.EndorsementDescriptor.layouts: object expected");
                        message.layouts[i] = $root.discovery.Layout.fromObject(object.layouts[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from an EndorsementDescriptor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {discovery.EndorsementDescriptor} message EndorsementDescriptor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EndorsementDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.layouts = [];
                if (options.objects || options.defaults)
                    object.endorsers_by_groups = {};
                if (options.defaults)
                    object.chaincode = "";
                if (message.chaincode != null && message.hasOwnProperty("chaincode"))
                    object.chaincode = message.chaincode;
                var keys2;
                if (message.endorsers_by_groups && (keys2 = Object.keys(message.endorsers_by_groups)).length) {
                    object.endorsers_by_groups = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.endorsers_by_groups[keys2[j]] = $root.discovery.Peers.toObject(message.endorsers_by_groups[keys2[j]], options);
                }
                if (message.layouts && message.layouts.length) {
                    object.layouts = [];
                    for (var j = 0; j < message.layouts.length; ++j)
                        object.layouts[j] = $root.discovery.Layout.toObject(message.layouts[j], options);
                }
                return object;
            };
    
            /**
             * Converts this EndorsementDescriptor to JSON.
             * @function toJSON
             * @memberof discovery.EndorsementDescriptor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EndorsementDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return EndorsementDescriptor;
        })();
    
        discovery.Layout = (function() {
    
            /**
             * Properties of a Layout.
             * @memberof discovery
             * @interface ILayout
             * @property {Object.<string,number>|null} [quantities_by_group] Layout quantities_by_group
             */
    
            /**
             * Constructs a new Layout.
             * @memberof discovery
             * @classdesc Represents a Layout.
             * @implements ILayout
             * @constructor
             * @param {discovery.ILayout=} [properties] Properties to set
             */
            function Layout(properties) {
                this.quantities_by_group = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Layout quantities_by_group.
             * @member {Object.<string,number>} quantities_by_group
             * @memberof discovery.Layout
             * @instance
             */
            Layout.prototype.quantities_by_group = $util.emptyObject;
    
            /**
             * Creates a new Layout instance using the specified properties.
             * @function create
             * @memberof discovery.Layout
             * @static
             * @param {discovery.ILayout=} [properties] Properties to set
             * @returns {discovery.Layout} Layout instance
             */
            Layout.create = function create(properties) {
                return new Layout(properties);
            };
    
            /**
             * Encodes the specified Layout message. Does not implicitly {@link discovery.Layout.verify|verify} messages.
             * @function encode
             * @memberof discovery.Layout
             * @static
             * @param {discovery.ILayout} message Layout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Layout.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.quantities_by_group != null && Object.hasOwnProperty.call(message, "quantities_by_group"))
                    for (var keys = Object.keys(message.quantities_by_group), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint32(message.quantities_by_group[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Layout message, length delimited. Does not implicitly {@link discovery.Layout.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Layout
             * @static
             * @param {discovery.ILayout} message Layout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Layout.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Layout message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Layout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Layout} Layout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Layout.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Layout(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.quantities_by_group === $util.emptyObject)
                            message.quantities_by_group = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.quantities_by_group[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Layout message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Layout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Layout} Layout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Layout.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Layout message.
             * @function verify
             * @memberof discovery.Layout
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Layout.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.quantities_by_group != null && message.hasOwnProperty("quantities_by_group")) {
                    if (!$util.isObject(message.quantities_by_group))
                        return "quantities_by_group: object expected";
                    var key = Object.keys(message.quantities_by_group);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isInteger(message.quantities_by_group[key[i]]))
                            return "quantities_by_group: integer{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a Layout message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Layout
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Layout} Layout
             */
            Layout.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Layout)
                    return object;
                var message = new $root.discovery.Layout();
                if (object.quantities_by_group) {
                    if (typeof object.quantities_by_group !== "object")
                        throw TypeError(".discovery.Layout.quantities_by_group: object expected");
                    message.quantities_by_group = {};
                    for (var keys = Object.keys(object.quantities_by_group), i = 0; i < keys.length; ++i)
                        message.quantities_by_group[keys[i]] = object.quantities_by_group[keys[i]] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Layout message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Layout
             * @static
             * @param {discovery.Layout} message Layout
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Layout.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.quantities_by_group = {};
                var keys2;
                if (message.quantities_by_group && (keys2 = Object.keys(message.quantities_by_group)).length) {
                    object.quantities_by_group = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.quantities_by_group[keys2[j]] = message.quantities_by_group[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this Layout to JSON.
             * @function toJSON
             * @memberof discovery.Layout
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Layout.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Layout;
        })();
    
        discovery.Peers = (function() {
    
            /**
             * Properties of a Peers.
             * @memberof discovery
             * @interface IPeers
             * @property {Array.<discovery.IPeer>|null} [peers] Peers peers
             */
    
            /**
             * Constructs a new Peers.
             * @memberof discovery
             * @classdesc Represents a Peers.
             * @implements IPeers
             * @constructor
             * @param {discovery.IPeers=} [properties] Properties to set
             */
            function Peers(properties) {
                this.peers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Peers peers.
             * @member {Array.<discovery.IPeer>} peers
             * @memberof discovery.Peers
             * @instance
             */
            Peers.prototype.peers = $util.emptyArray;
    
            /**
             * Creates a new Peers instance using the specified properties.
             * @function create
             * @memberof discovery.Peers
             * @static
             * @param {discovery.IPeers=} [properties] Properties to set
             * @returns {discovery.Peers} Peers instance
             */
            Peers.create = function create(properties) {
                return new Peers(properties);
            };
    
            /**
             * Encodes the specified Peers message. Does not implicitly {@link discovery.Peers.verify|verify} messages.
             * @function encode
             * @memberof discovery.Peers
             * @static
             * @param {discovery.IPeers} message Peers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Peers.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peers != null && message.peers.length)
                    for (var i = 0; i < message.peers.length; ++i)
                        $root.discovery.Peer.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Peers message, length delimited. Does not implicitly {@link discovery.Peers.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Peers
             * @static
             * @param {discovery.IPeers} message Peers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Peers.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Peers message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Peers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Peers} Peers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Peers.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Peers();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.peers && message.peers.length))
                            message.peers = [];
                        message.peers.push($root.discovery.Peer.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Peers message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Peers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Peers} Peers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Peers.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Peers message.
             * @function verify
             * @memberof discovery.Peers
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Peers.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peers != null && message.hasOwnProperty("peers")) {
                    if (!Array.isArray(message.peers))
                        return "peers: array expected";
                    for (var i = 0; i < message.peers.length; ++i) {
                        var error = $root.discovery.Peer.verify(message.peers[i]);
                        if (error)
                            return "peers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Peers message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Peers
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Peers} Peers
             */
            Peers.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Peers)
                    return object;
                var message = new $root.discovery.Peers();
                if (object.peers) {
                    if (!Array.isArray(object.peers))
                        throw TypeError(".discovery.Peers.peers: array expected");
                    message.peers = [];
                    for (var i = 0; i < object.peers.length; ++i) {
                        if (typeof object.peers[i] !== "object")
                            throw TypeError(".discovery.Peers.peers: object expected");
                        message.peers[i] = $root.discovery.Peer.fromObject(object.peers[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Peers message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Peers
             * @static
             * @param {discovery.Peers} message Peers
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Peers.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.peers = [];
                if (message.peers && message.peers.length) {
                    object.peers = [];
                    for (var j = 0; j < message.peers.length; ++j)
                        object.peers[j] = $root.discovery.Peer.toObject(message.peers[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Peers to JSON.
             * @function toJSON
             * @memberof discovery.Peers
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Peers.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Peers;
        })();
    
        discovery.Peer = (function() {
    
            /**
             * Properties of a Peer.
             * @memberof discovery
             * @interface IPeer
             * @property {gossip.IEnvelope|null} [state_info] Peer state_info
             * @property {gossip.IEnvelope|null} [membership_info] Peer membership_info
             * @property {Uint8Array|null} [identity] Peer identity
             */
    
            /**
             * Constructs a new Peer.
             * @memberof discovery
             * @classdesc Represents a Peer.
             * @implements IPeer
             * @constructor
             * @param {discovery.IPeer=} [properties] Properties to set
             */
            function Peer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Peer state_info.
             * @member {gossip.IEnvelope|null|undefined} state_info
             * @memberof discovery.Peer
             * @instance
             */
            Peer.prototype.state_info = null;
    
            /**
             * Peer membership_info.
             * @member {gossip.IEnvelope|null|undefined} membership_info
             * @memberof discovery.Peer
             * @instance
             */
            Peer.prototype.membership_info = null;
    
            /**
             * Peer identity.
             * @member {Uint8Array} identity
             * @memberof discovery.Peer
             * @instance
             */
            Peer.prototype.identity = $util.newBuffer([]);
    
            /**
             * Creates a new Peer instance using the specified properties.
             * @function create
             * @memberof discovery.Peer
             * @static
             * @param {discovery.IPeer=} [properties] Properties to set
             * @returns {discovery.Peer} Peer instance
             */
            Peer.create = function create(properties) {
                return new Peer(properties);
            };
    
            /**
             * Encodes the specified Peer message. Does not implicitly {@link discovery.Peer.verify|verify} messages.
             * @function encode
             * @memberof discovery.Peer
             * @static
             * @param {discovery.IPeer} message Peer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Peer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state_info != null && Object.hasOwnProperty.call(message, "state_info"))
                    $root.gossip.Envelope.encode(message.state_info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.membership_info != null && Object.hasOwnProperty.call(message, "membership_info"))
                    $root.gossip.Envelope.encode(message.membership_info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identity != null && Object.hasOwnProperty.call(message, "identity"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.identity);
                return writer;
            };
    
            /**
             * Encodes the specified Peer message, length delimited. Does not implicitly {@link discovery.Peer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Peer
             * @static
             * @param {discovery.IPeer} message Peer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Peer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Peer message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Peer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Peer} Peer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Peer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Peer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.state_info = $root.gossip.Envelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.membership_info = $root.gossip.Envelope.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.identity = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Peer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Peer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Peer} Peer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Peer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Peer message.
             * @function verify
             * @memberof discovery.Peer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Peer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state_info != null && message.hasOwnProperty("state_info")) {
                    var error = $root.gossip.Envelope.verify(message.state_info);
                    if (error)
                        return "state_info." + error;
                }
                if (message.membership_info != null && message.hasOwnProperty("membership_info")) {
                    var error = $root.gossip.Envelope.verify(message.membership_info);
                    if (error)
                        return "membership_info." + error;
                }
                if (message.identity != null && message.hasOwnProperty("identity"))
                    if (!(message.identity && typeof message.identity.length === "number" || $util.isString(message.identity)))
                        return "identity: buffer expected";
                return null;
            };
    
            /**
             * Creates a Peer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Peer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Peer} Peer
             */
            Peer.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Peer)
                    return object;
                var message = new $root.discovery.Peer();
                if (object.state_info != null) {
                    if (typeof object.state_info !== "object")
                        throw TypeError(".discovery.Peer.state_info: object expected");
                    message.state_info = $root.gossip.Envelope.fromObject(object.state_info);
                }
                if (object.membership_info != null) {
                    if (typeof object.membership_info !== "object")
                        throw TypeError(".discovery.Peer.membership_info: object expected");
                    message.membership_info = $root.gossip.Envelope.fromObject(object.membership_info);
                }
                if (object.identity != null)
                    if (typeof object.identity === "string")
                        $util.base64.decode(object.identity, message.identity = $util.newBuffer($util.base64.length(object.identity)), 0);
                    else if (object.identity.length)
                        message.identity = object.identity;
                return message;
            };
    
            /**
             * Creates a plain object from a Peer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Peer
             * @static
             * @param {discovery.Peer} message Peer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Peer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.state_info = null;
                    object.membership_info = null;
                    if (options.bytes === String)
                        object.identity = "";
                    else {
                        object.identity = [];
                        if (options.bytes !== Array)
                            object.identity = $util.newBuffer(object.identity);
                    }
                }
                if (message.state_info != null && message.hasOwnProperty("state_info"))
                    object.state_info = $root.gossip.Envelope.toObject(message.state_info, options);
                if (message.membership_info != null && message.hasOwnProperty("membership_info"))
                    object.membership_info = $root.gossip.Envelope.toObject(message.membership_info, options);
                if (message.identity != null && message.hasOwnProperty("identity"))
                    object.identity = options.bytes === String ? $util.base64.encode(message.identity, 0, message.identity.length) : options.bytes === Array ? Array.prototype.slice.call(message.identity) : message.identity;
                return object;
            };
    
            /**
             * Converts this Peer to JSON.
             * @function toJSON
             * @memberof discovery.Peer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Peer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Peer;
        })();
    
        discovery.Error = (function() {
    
            /**
             * Properties of an Error.
             * @memberof discovery
             * @interface IError
             * @property {string|null} [content] Error content
             */
    
            /**
             * Constructs a new Error.
             * @memberof discovery
             * @classdesc Represents an Error.
             * @implements IError
             * @constructor
             * @param {discovery.IError=} [properties] Properties to set
             */
            function Error(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Error content.
             * @member {string} content
             * @memberof discovery.Error
             * @instance
             */
            Error.prototype.content = "";
    
            /**
             * Creates a new Error instance using the specified properties.
             * @function create
             * @memberof discovery.Error
             * @static
             * @param {discovery.IError=} [properties] Properties to set
             * @returns {discovery.Error} Error instance
             */
            Error.create = function create(properties) {
                return new Error(properties);
            };
    
            /**
             * Encodes the specified Error message. Does not implicitly {@link discovery.Error.verify|verify} messages.
             * @function encode
             * @memberof discovery.Error
             * @static
             * @param {discovery.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
                return writer;
            };
    
            /**
             * Encodes the specified Error message, length delimited. Does not implicitly {@link discovery.Error.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Error
             * @static
             * @param {discovery.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Error message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Error();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.content = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Error message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Error message.
             * @function verify
             * @memberof discovery.Error
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Error.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                return null;
            };
    
            /**
             * Creates an Error message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Error
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Error} Error
             */
            Error.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Error)
                    return object;
                var message = new $root.discovery.Error();
                if (object.content != null)
                    message.content = String(object.content);
                return message;
            };
    
            /**
             * Creates a plain object from an Error message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Error
             * @static
             * @param {discovery.Error} message Error
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Error.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.content = "";
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                return object;
            };
    
            /**
             * Converts this Error to JSON.
             * @function toJSON
             * @memberof discovery.Error
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Error.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Error;
        })();
    
        discovery.Endpoints = (function() {
    
            /**
             * Properties of an Endpoints.
             * @memberof discovery
             * @interface IEndpoints
             * @property {Array.<discovery.IEndpoint>|null} [endpoint] Endpoints endpoint
             */
    
            /**
             * Constructs a new Endpoints.
             * @memberof discovery
             * @classdesc Represents an Endpoints.
             * @implements IEndpoints
             * @constructor
             * @param {discovery.IEndpoints=} [properties] Properties to set
             */
            function Endpoints(properties) {
                this.endpoint = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Endpoints endpoint.
             * @member {Array.<discovery.IEndpoint>} endpoint
             * @memberof discovery.Endpoints
             * @instance
             */
            Endpoints.prototype.endpoint = $util.emptyArray;
    
            /**
             * Creates a new Endpoints instance using the specified properties.
             * @function create
             * @memberof discovery.Endpoints
             * @static
             * @param {discovery.IEndpoints=} [properties] Properties to set
             * @returns {discovery.Endpoints} Endpoints instance
             */
            Endpoints.create = function create(properties) {
                return new Endpoints(properties);
            };
    
            /**
             * Encodes the specified Endpoints message. Does not implicitly {@link discovery.Endpoints.verify|verify} messages.
             * @function encode
             * @memberof discovery.Endpoints
             * @static
             * @param {discovery.IEndpoints} message Endpoints message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endpoints.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endpoint != null && message.endpoint.length)
                    for (var i = 0; i < message.endpoint.length; ++i)
                        $root.discovery.Endpoint.encode(message.endpoint[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Endpoints message, length delimited. Does not implicitly {@link discovery.Endpoints.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Endpoints
             * @static
             * @param {discovery.IEndpoints} message Endpoints message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endpoints.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Endpoints message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Endpoints
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Endpoints} Endpoints
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endpoints.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Endpoints();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.endpoint && message.endpoint.length))
                            message.endpoint = [];
                        message.endpoint.push($root.discovery.Endpoint.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Endpoints message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Endpoints
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Endpoints} Endpoints
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endpoints.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Endpoints message.
             * @function verify
             * @memberof discovery.Endpoints
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Endpoints.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endpoint != null && message.hasOwnProperty("endpoint")) {
                    if (!Array.isArray(message.endpoint))
                        return "endpoint: array expected";
                    for (var i = 0; i < message.endpoint.length; ++i) {
                        var error = $root.discovery.Endpoint.verify(message.endpoint[i]);
                        if (error)
                            return "endpoint." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates an Endpoints message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Endpoints
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Endpoints} Endpoints
             */
            Endpoints.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Endpoints)
                    return object;
                var message = new $root.discovery.Endpoints();
                if (object.endpoint) {
                    if (!Array.isArray(object.endpoint))
                        throw TypeError(".discovery.Endpoints.endpoint: array expected");
                    message.endpoint = [];
                    for (var i = 0; i < object.endpoint.length; ++i) {
                        if (typeof object.endpoint[i] !== "object")
                            throw TypeError(".discovery.Endpoints.endpoint: object expected");
                        message.endpoint[i] = $root.discovery.Endpoint.fromObject(object.endpoint[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Endpoints message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Endpoints
             * @static
             * @param {discovery.Endpoints} message Endpoints
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Endpoints.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.endpoint = [];
                if (message.endpoint && message.endpoint.length) {
                    object.endpoint = [];
                    for (var j = 0; j < message.endpoint.length; ++j)
                        object.endpoint[j] = $root.discovery.Endpoint.toObject(message.endpoint[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Endpoints to JSON.
             * @function toJSON
             * @memberof discovery.Endpoints
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Endpoints.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Endpoints;
        })();
    
        discovery.Endpoint = (function() {
    
            /**
             * Properties of an Endpoint.
             * @memberof discovery
             * @interface IEndpoint
             * @property {string|null} [host] Endpoint host
             * @property {number|null} [port] Endpoint port
             */
    
            /**
             * Constructs a new Endpoint.
             * @memberof discovery
             * @classdesc Represents an Endpoint.
             * @implements IEndpoint
             * @constructor
             * @param {discovery.IEndpoint=} [properties] Properties to set
             */
            function Endpoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Endpoint host.
             * @member {string} host
             * @memberof discovery.Endpoint
             * @instance
             */
            Endpoint.prototype.host = "";
    
            /**
             * Endpoint port.
             * @member {number} port
             * @memberof discovery.Endpoint
             * @instance
             */
            Endpoint.prototype.port = 0;
    
            /**
             * Creates a new Endpoint instance using the specified properties.
             * @function create
             * @memberof discovery.Endpoint
             * @static
             * @param {discovery.IEndpoint=} [properties] Properties to set
             * @returns {discovery.Endpoint} Endpoint instance
             */
            Endpoint.create = function create(properties) {
                return new Endpoint(properties);
            };
    
            /**
             * Encodes the specified Endpoint message. Does not implicitly {@link discovery.Endpoint.verify|verify} messages.
             * @function encode
             * @memberof discovery.Endpoint
             * @static
             * @param {discovery.IEndpoint} message Endpoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endpoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                return writer;
            };
    
            /**
             * Encodes the specified Endpoint message, length delimited. Does not implicitly {@link discovery.Endpoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Endpoint
             * @static
             * @param {discovery.IEndpoint} message Endpoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endpoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Endpoint message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Endpoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Endpoint} Endpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endpoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Endpoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Endpoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Endpoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Endpoint} Endpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endpoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Endpoint message.
             * @function verify
             * @memberof discovery.Endpoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Endpoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                return null;
            };
    
            /**
             * Creates an Endpoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Endpoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Endpoint} Endpoint
             */
            Endpoint.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Endpoint)
                    return object;
                var message = new $root.discovery.Endpoint();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from an Endpoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Endpoint
             * @static
             * @param {discovery.Endpoint} message Endpoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Endpoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };
    
            /**
             * Converts this Endpoint to JSON.
             * @function toJSON
             * @memberof discovery.Endpoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Endpoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Endpoint;
        })();
    
        return discovery;
    })();
    
    $root.gossip = (function() {
    
        /**
         * Namespace gossip.
         * @exports gossip
         * @namespace
         */
        var gossip = {};
    
        gossip.Gossip = (function() {
    
            /**
             * Constructs a new Gossip service.
             * @memberof gossip
             * @classdesc Represents a Gossip
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Gossip(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Gossip.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Gossip;
    
            /**
             * Creates new Gossip service using the specified rpc implementation.
             * @function create
             * @memberof gossip.Gossip
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Gossip} RPC service. Useful where requests and/or responses are streamed.
             */
            Gossip.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link gossip.Gossip#gossipStream}.
             * @memberof gossip.Gossip
             * @typedef GossipStreamCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gossip.Envelope} [response] Envelope
             */
    
            /**
             * Calls GossipStream.
             * @function gossipStream
             * @memberof gossip.Gossip
             * @instance
             * @param {gossip.IEnvelope} request Envelope message or plain object
             * @param {gossip.Gossip.GossipStreamCallback} callback Node-style callback called with the error, if any, and Envelope
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Gossip.prototype.gossipStream = function gossipStream(request, callback) {
                return this.rpcCall(gossipStream, $root.gossip.Envelope, $root.gossip.Envelope, request, callback);
            }, "name", { value: "GossipStream" });
    
            /**
             * Calls GossipStream.
             * @function gossipStream
             * @memberof gossip.Gossip
             * @instance
             * @param {gossip.IEnvelope} request Envelope message or plain object
             * @returns {Promise<gossip.Envelope>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link gossip.Gossip#ping}.
             * @memberof gossip.Gossip
             * @typedef PingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gossip.Empty} [response] Empty
             */
    
            /**
             * Calls Ping.
             * @function ping
             * @memberof gossip.Gossip
             * @instance
             * @param {gossip.IEmpty} request Empty message or plain object
             * @param {gossip.Gossip.PingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Gossip.prototype.ping = function ping(request, callback) {
                return this.rpcCall(ping, $root.gossip.Empty, $root.gossip.Empty, request, callback);
            }, "name", { value: "Ping" });
    
            /**
             * Calls Ping.
             * @function ping
             * @memberof gossip.Gossip
             * @instance
             * @param {gossip.IEmpty} request Empty message or plain object
             * @returns {Promise<gossip.Empty>} Promise
             * @variation 2
             */
    
            return Gossip;
        })();
    
        gossip.Envelope = (function() {
    
            /**
             * Properties of an Envelope.
             * @memberof gossip
             * @interface IEnvelope
             * @property {Uint8Array|null} [payload] Envelope payload
             * @property {Uint8Array|null} [signature] Envelope signature
             * @property {gossip.ISecretEnvelope|null} [secret_envelope] Envelope secret_envelope
             */
    
            /**
             * Constructs a new Envelope.
             * @memberof gossip
             * @classdesc Represents an Envelope.
             * @implements IEnvelope
             * @constructor
             * @param {gossip.IEnvelope=} [properties] Properties to set
             */
            function Envelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Envelope payload.
             * @member {Uint8Array} payload
             * @memberof gossip.Envelope
             * @instance
             */
            Envelope.prototype.payload = $util.newBuffer([]);
    
            /**
             * Envelope signature.
             * @member {Uint8Array} signature
             * @memberof gossip.Envelope
             * @instance
             */
            Envelope.prototype.signature = $util.newBuffer([]);
    
            /**
             * Envelope secret_envelope.
             * @member {gossip.ISecretEnvelope|null|undefined} secret_envelope
             * @memberof gossip.Envelope
             * @instance
             */
            Envelope.prototype.secret_envelope = null;
    
            /**
             * Creates a new Envelope instance using the specified properties.
             * @function create
             * @memberof gossip.Envelope
             * @static
             * @param {gossip.IEnvelope=} [properties] Properties to set
             * @returns {gossip.Envelope} Envelope instance
             */
            Envelope.create = function create(properties) {
                return new Envelope(properties);
            };
    
            /**
             * Encodes the specified Envelope message. Does not implicitly {@link gossip.Envelope.verify|verify} messages.
             * @function encode
             * @memberof gossip.Envelope
             * @static
             * @param {gossip.IEnvelope} message Envelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Envelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                if (message.secret_envelope != null && Object.hasOwnProperty.call(message, "secret_envelope"))
                    $root.gossip.SecretEnvelope.encode(message.secret_envelope, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Envelope message, length delimited. Does not implicitly {@link gossip.Envelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Envelope
             * @static
             * @param {gossip.IEnvelope} message Envelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Envelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Envelope message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Envelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Envelope} Envelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Envelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Envelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    case 3:
                        message.secret_envelope = $root.gossip.SecretEnvelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Envelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Envelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Envelope} Envelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Envelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Envelope message.
             * @function verify
             * @memberof gossip.Envelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Envelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.secret_envelope != null && message.hasOwnProperty("secret_envelope")) {
                    var error = $root.gossip.SecretEnvelope.verify(message.secret_envelope);
                    if (error)
                        return "secret_envelope." + error;
                }
                return null;
            };
    
            /**
             * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Envelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Envelope} Envelope
             */
            Envelope.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Envelope)
                    return object;
                var message = new $root.gossip.Envelope();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                if (object.secret_envelope != null) {
                    if (typeof object.secret_envelope !== "object")
                        throw TypeError(".gossip.Envelope.secret_envelope: object expected");
                    message.secret_envelope = $root.gossip.SecretEnvelope.fromObject(object.secret_envelope);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Envelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Envelope
             * @static
             * @param {gossip.Envelope} message Envelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Envelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    object.secret_envelope = null;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.secret_envelope != null && message.hasOwnProperty("secret_envelope"))
                    object.secret_envelope = $root.gossip.SecretEnvelope.toObject(message.secret_envelope, options);
                return object;
            };
    
            /**
             * Converts this Envelope to JSON.
             * @function toJSON
             * @memberof gossip.Envelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Envelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Envelope;
        })();
    
        gossip.SecretEnvelope = (function() {
    
            /**
             * Properties of a SecretEnvelope.
             * @memberof gossip
             * @interface ISecretEnvelope
             * @property {Uint8Array|null} [payload] SecretEnvelope payload
             * @property {Uint8Array|null} [signature] SecretEnvelope signature
             */
    
            /**
             * Constructs a new SecretEnvelope.
             * @memberof gossip
             * @classdesc Represents a SecretEnvelope.
             * @implements ISecretEnvelope
             * @constructor
             * @param {gossip.ISecretEnvelope=} [properties] Properties to set
             */
            function SecretEnvelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SecretEnvelope payload.
             * @member {Uint8Array} payload
             * @memberof gossip.SecretEnvelope
             * @instance
             */
            SecretEnvelope.prototype.payload = $util.newBuffer([]);
    
            /**
             * SecretEnvelope signature.
             * @member {Uint8Array} signature
             * @memberof gossip.SecretEnvelope
             * @instance
             */
            SecretEnvelope.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new SecretEnvelope instance using the specified properties.
             * @function create
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {gossip.ISecretEnvelope=} [properties] Properties to set
             * @returns {gossip.SecretEnvelope} SecretEnvelope instance
             */
            SecretEnvelope.create = function create(properties) {
                return new SecretEnvelope(properties);
            };
    
            /**
             * Encodes the specified SecretEnvelope message. Does not implicitly {@link gossip.SecretEnvelope.verify|verify} messages.
             * @function encode
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {gossip.ISecretEnvelope} message SecretEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecretEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified SecretEnvelope message, length delimited. Does not implicitly {@link gossip.SecretEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {gossip.ISecretEnvelope} message SecretEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecretEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SecretEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.SecretEnvelope} SecretEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecretEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.SecretEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SecretEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.SecretEnvelope} SecretEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecretEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SecretEnvelope message.
             * @function verify
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SecretEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a SecretEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.SecretEnvelope} SecretEnvelope
             */
            SecretEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.SecretEnvelope)
                    return object;
                var message = new $root.gossip.SecretEnvelope();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a SecretEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {gossip.SecretEnvelope} message SecretEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SecretEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this SecretEnvelope to JSON.
             * @function toJSON
             * @memberof gossip.SecretEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SecretEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SecretEnvelope;
        })();
    
        gossip.Secret = (function() {
    
            /**
             * Properties of a Secret.
             * @memberof gossip
             * @interface ISecret
             * @property {string|null} [internalEndpoint] Secret internalEndpoint
             */
    
            /**
             * Constructs a new Secret.
             * @memberof gossip
             * @classdesc Represents a Secret.
             * @implements ISecret
             * @constructor
             * @param {gossip.ISecret=} [properties] Properties to set
             */
            function Secret(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Secret internalEndpoint.
             * @member {string|null|undefined} internalEndpoint
             * @memberof gossip.Secret
             * @instance
             */
            Secret.prototype.internalEndpoint = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Secret content.
             * @member {"internalEndpoint"|undefined} content
             * @memberof gossip.Secret
             * @instance
             */
            Object.defineProperty(Secret.prototype, "content", {
                get: $util.oneOfGetter($oneOfFields = ["internalEndpoint"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Secret instance using the specified properties.
             * @function create
             * @memberof gossip.Secret
             * @static
             * @param {gossip.ISecret=} [properties] Properties to set
             * @returns {gossip.Secret} Secret instance
             */
            Secret.create = function create(properties) {
                return new Secret(properties);
            };
    
            /**
             * Encodes the specified Secret message. Does not implicitly {@link gossip.Secret.verify|verify} messages.
             * @function encode
             * @memberof gossip.Secret
             * @static
             * @param {gossip.ISecret} message Secret message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Secret.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.internalEndpoint != null && Object.hasOwnProperty.call(message, "internalEndpoint"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.internalEndpoint);
                return writer;
            };
    
            /**
             * Encodes the specified Secret message, length delimited. Does not implicitly {@link gossip.Secret.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Secret
             * @static
             * @param {gossip.ISecret} message Secret message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Secret.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Secret message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Secret
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Secret} Secret
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Secret.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Secret();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.internalEndpoint = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Secret message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Secret
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Secret} Secret
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Secret.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Secret message.
             * @function verify
             * @memberof gossip.Secret
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Secret.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.internalEndpoint != null && message.hasOwnProperty("internalEndpoint")) {
                    properties.content = 1;
                    if (!$util.isString(message.internalEndpoint))
                        return "internalEndpoint: string expected";
                }
                return null;
            };
    
            /**
             * Creates a Secret message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Secret
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Secret} Secret
             */
            Secret.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Secret)
                    return object;
                var message = new $root.gossip.Secret();
                if (object.internalEndpoint != null)
                    message.internalEndpoint = String(object.internalEndpoint);
                return message;
            };
    
            /**
             * Creates a plain object from a Secret message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Secret
             * @static
             * @param {gossip.Secret} message Secret
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Secret.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.internalEndpoint != null && message.hasOwnProperty("internalEndpoint")) {
                    object.internalEndpoint = message.internalEndpoint;
                    if (options.oneofs)
                        object.content = "internalEndpoint";
                }
                return object;
            };
    
            /**
             * Converts this Secret to JSON.
             * @function toJSON
             * @memberof gossip.Secret
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Secret.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Secret;
        })();
    
        gossip.GossipMessage = (function() {
    
            /**
             * Properties of a GossipMessage.
             * @memberof gossip
             * @interface IGossipMessage
             * @property {number|Long|null} [nonce] GossipMessage nonce
             * @property {Uint8Array|null} [channel] GossipMessage channel
             * @property {gossip.GossipMessage.Tag|null} [tag] GossipMessage tag
             * @property {gossip.IAliveMessage|null} [alive_msg] GossipMessage alive_msg
             * @property {gossip.IMembershipRequest|null} [mem_req] GossipMessage mem_req
             * @property {gossip.IMembershipResponse|null} [mem_res] GossipMessage mem_res
             * @property {gossip.IDataMessage|null} [data_msg] GossipMessage data_msg
             * @property {gossip.IGossipHello|null} [hello] GossipMessage hello
             * @property {gossip.IDataDigest|null} [data_dig] GossipMessage data_dig
             * @property {gossip.IDataRequest|null} [data_req] GossipMessage data_req
             * @property {gossip.IDataUpdate|null} [data_update] GossipMessage data_update
             * @property {gossip.IEmpty|null} [empty] GossipMessage empty
             * @property {gossip.IConnEstablish|null} [conn] GossipMessage conn
             * @property {gossip.IStateInfo|null} [state_info] GossipMessage state_info
             * @property {gossip.IStateInfoSnapshot|null} [state_snapshot] GossipMessage state_snapshot
             * @property {gossip.IStateInfoPullRequest|null} [state_info_pull_req] GossipMessage state_info_pull_req
             * @property {gossip.IRemoteStateRequest|null} [state_request] GossipMessage state_request
             * @property {gossip.IRemoteStateResponse|null} [state_response] GossipMessage state_response
             * @property {gossip.ILeadershipMessage|null} [leadership_msg] GossipMessage leadership_msg
             * @property {gossip.IPeerIdentity|null} [peer_identity] GossipMessage peer_identity
             * @property {gossip.IAcknowledgement|null} [ack] GossipMessage ack
             * @property {gossip.IRemotePvtDataRequest|null} [privateReq] GossipMessage privateReq
             * @property {gossip.IRemotePvtDataResponse|null} [privateRes] GossipMessage privateRes
             * @property {gossip.IPrivateDataMessage|null} [private_data] GossipMessage private_data
             */
    
            /**
             * Constructs a new GossipMessage.
             * @memberof gossip
             * @classdesc Represents a GossipMessage.
             * @implements IGossipMessage
             * @constructor
             * @param {gossip.IGossipMessage=} [properties] Properties to set
             */
            function GossipMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GossipMessage nonce.
             * @member {number|Long} nonce
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * GossipMessage channel.
             * @member {Uint8Array} channel
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.channel = $util.newBuffer([]);
    
            /**
             * GossipMessage tag.
             * @member {gossip.GossipMessage.Tag} tag
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.tag = 0;
    
            /**
             * GossipMessage alive_msg.
             * @member {gossip.IAliveMessage|null|undefined} alive_msg
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.alive_msg = null;
    
            /**
             * GossipMessage mem_req.
             * @member {gossip.IMembershipRequest|null|undefined} mem_req
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.mem_req = null;
    
            /**
             * GossipMessage mem_res.
             * @member {gossip.IMembershipResponse|null|undefined} mem_res
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.mem_res = null;
    
            /**
             * GossipMessage data_msg.
             * @member {gossip.IDataMessage|null|undefined} data_msg
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.data_msg = null;
    
            /**
             * GossipMessage hello.
             * @member {gossip.IGossipHello|null|undefined} hello
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.hello = null;
    
            /**
             * GossipMessage data_dig.
             * @member {gossip.IDataDigest|null|undefined} data_dig
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.data_dig = null;
    
            /**
             * GossipMessage data_req.
             * @member {gossip.IDataRequest|null|undefined} data_req
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.data_req = null;
    
            /**
             * GossipMessage data_update.
             * @member {gossip.IDataUpdate|null|undefined} data_update
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.data_update = null;
    
            /**
             * GossipMessage empty.
             * @member {gossip.IEmpty|null|undefined} empty
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.empty = null;
    
            /**
             * GossipMessage conn.
             * @member {gossip.IConnEstablish|null|undefined} conn
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.conn = null;
    
            /**
             * GossipMessage state_info.
             * @member {gossip.IStateInfo|null|undefined} state_info
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.state_info = null;
    
            /**
             * GossipMessage state_snapshot.
             * @member {gossip.IStateInfoSnapshot|null|undefined} state_snapshot
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.state_snapshot = null;
    
            /**
             * GossipMessage state_info_pull_req.
             * @member {gossip.IStateInfoPullRequest|null|undefined} state_info_pull_req
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.state_info_pull_req = null;
    
            /**
             * GossipMessage state_request.
             * @member {gossip.IRemoteStateRequest|null|undefined} state_request
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.state_request = null;
    
            /**
             * GossipMessage state_response.
             * @member {gossip.IRemoteStateResponse|null|undefined} state_response
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.state_response = null;
    
            /**
             * GossipMessage leadership_msg.
             * @member {gossip.ILeadershipMessage|null|undefined} leadership_msg
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.leadership_msg = null;
    
            /**
             * GossipMessage peer_identity.
             * @member {gossip.IPeerIdentity|null|undefined} peer_identity
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.peer_identity = null;
    
            /**
             * GossipMessage ack.
             * @member {gossip.IAcknowledgement|null|undefined} ack
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.ack = null;
    
            /**
             * GossipMessage privateReq.
             * @member {gossip.IRemotePvtDataRequest|null|undefined} privateReq
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.privateReq = null;
    
            /**
             * GossipMessage privateRes.
             * @member {gossip.IRemotePvtDataResponse|null|undefined} privateRes
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.privateRes = null;
    
            /**
             * GossipMessage private_data.
             * @member {gossip.IPrivateDataMessage|null|undefined} private_data
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.private_data = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * GossipMessage content.
             * @member {"alive_msg"|"mem_req"|"mem_res"|"data_msg"|"hello"|"data_dig"|"data_req"|"data_update"|"empty"|"conn"|"state_info"|"state_snapshot"|"state_info_pull_req"|"state_request"|"state_response"|"leadership_msg"|"peer_identity"|"ack"|"privateReq"|"privateRes"|"private_data"|undefined} content
             * @memberof gossip.GossipMessage
             * @instance
             */
            Object.defineProperty(GossipMessage.prototype, "content", {
                get: $util.oneOfGetter($oneOfFields = ["alive_msg", "mem_req", "mem_res", "data_msg", "hello", "data_dig", "data_req", "data_update", "empty", "conn", "state_info", "state_snapshot", "state_info_pull_req", "state_request", "state_response", "leadership_msg", "peer_identity", "ack", "privateReq", "privateRes", "private_data"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new GossipMessage instance using the specified properties.
             * @function create
             * @memberof gossip.GossipMessage
             * @static
             * @param {gossip.IGossipMessage=} [properties] Properties to set
             * @returns {gossip.GossipMessage} GossipMessage instance
             */
            GossipMessage.create = function create(properties) {
                return new GossipMessage(properties);
            };
    
            /**
             * Encodes the specified GossipMessage message. Does not implicitly {@link gossip.GossipMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.GossipMessage
             * @static
             * @param {gossip.IGossipMessage} message GossipMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GossipMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.channel);
                if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tag);
                if (message.alive_msg != null && Object.hasOwnProperty.call(message, "alive_msg"))
                    $root.gossip.AliveMessage.encode(message.alive_msg, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.mem_req != null && Object.hasOwnProperty.call(message, "mem_req"))
                    $root.gossip.MembershipRequest.encode(message.mem_req, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.mem_res != null && Object.hasOwnProperty.call(message, "mem_res"))
                    $root.gossip.MembershipResponse.encode(message.mem_res, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.data_msg != null && Object.hasOwnProperty.call(message, "data_msg"))
                    $root.gossip.DataMessage.encode(message.data_msg, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.hello != null && Object.hasOwnProperty.call(message, "hello"))
                    $root.gossip.GossipHello.encode(message.hello, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.data_dig != null && Object.hasOwnProperty.call(message, "data_dig"))
                    $root.gossip.DataDigest.encode(message.data_dig, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.data_req != null && Object.hasOwnProperty.call(message, "data_req"))
                    $root.gossip.DataRequest.encode(message.data_req, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.data_update != null && Object.hasOwnProperty.call(message, "data_update"))
                    $root.gossip.DataUpdate.encode(message.data_update, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.empty != null && Object.hasOwnProperty.call(message, "empty"))
                    $root.gossip.Empty.encode(message.empty, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.conn != null && Object.hasOwnProperty.call(message, "conn"))
                    $root.gossip.ConnEstablish.encode(message.conn, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.state_info != null && Object.hasOwnProperty.call(message, "state_info"))
                    $root.gossip.StateInfo.encode(message.state_info, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.state_snapshot != null && Object.hasOwnProperty.call(message, "state_snapshot"))
                    $root.gossip.StateInfoSnapshot.encode(message.state_snapshot, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.state_info_pull_req != null && Object.hasOwnProperty.call(message, "state_info_pull_req"))
                    $root.gossip.StateInfoPullRequest.encode(message.state_info_pull_req, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.state_request != null && Object.hasOwnProperty.call(message, "state_request"))
                    $root.gossip.RemoteStateRequest.encode(message.state_request, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.state_response != null && Object.hasOwnProperty.call(message, "state_response"))
                    $root.gossip.RemoteStateResponse.encode(message.state_response, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.leadership_msg != null && Object.hasOwnProperty.call(message, "leadership_msg"))
                    $root.gossip.LeadershipMessage.encode(message.leadership_msg, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.peer_identity != null && Object.hasOwnProperty.call(message, "peer_identity"))
                    $root.gossip.PeerIdentity.encode(message.peer_identity, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.ack != null && Object.hasOwnProperty.call(message, "ack"))
                    $root.gossip.Acknowledgement.encode(message.ack, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.privateReq != null && Object.hasOwnProperty.call(message, "privateReq"))
                    $root.gossip.RemotePvtDataRequest.encode(message.privateReq, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.privateRes != null && Object.hasOwnProperty.call(message, "privateRes"))
                    $root.gossip.RemotePvtDataResponse.encode(message.privateRes, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.private_data != null && Object.hasOwnProperty.call(message, "private_data"))
                    $root.gossip.PrivateDataMessage.encode(message.private_data, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified GossipMessage message, length delimited. Does not implicitly {@link gossip.GossipMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.GossipMessage
             * @static
             * @param {gossip.IGossipMessage} message GossipMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GossipMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GossipMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.GossipMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.GossipMessage} GossipMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GossipMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.GossipMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.channel = reader.bytes();
                        break;
                    case 3:
                        message.tag = reader.int32();
                        break;
                    case 5:
                        message.alive_msg = $root.gossip.AliveMessage.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.mem_req = $root.gossip.MembershipRequest.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.mem_res = $root.gossip.MembershipResponse.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.data_msg = $root.gossip.DataMessage.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.hello = $root.gossip.GossipHello.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.data_dig = $root.gossip.DataDigest.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.data_req = $root.gossip.DataRequest.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.data_update = $root.gossip.DataUpdate.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.empty = $root.gossip.Empty.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.conn = $root.gossip.ConnEstablish.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.state_info = $root.gossip.StateInfo.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.state_snapshot = $root.gossip.StateInfoSnapshot.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.state_info_pull_req = $root.gossip.StateInfoPullRequest.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.state_request = $root.gossip.RemoteStateRequest.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.state_response = $root.gossip.RemoteStateResponse.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.leadership_msg = $root.gossip.LeadershipMessage.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.peer_identity = $root.gossip.PeerIdentity.decode(reader, reader.uint32());
                        break;
                    case 22:
                        message.ack = $root.gossip.Acknowledgement.decode(reader, reader.uint32());
                        break;
                    case 23:
                        message.privateReq = $root.gossip.RemotePvtDataRequest.decode(reader, reader.uint32());
                        break;
                    case 24:
                        message.privateRes = $root.gossip.RemotePvtDataResponse.decode(reader, reader.uint32());
                        break;
                    case 25:
                        message.private_data = $root.gossip.PrivateDataMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GossipMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.GossipMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.GossipMessage} GossipMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GossipMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GossipMessage message.
             * @function verify
             * @memberof gossip.GossipMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GossipMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!(message.channel && typeof message.channel.length === "number" || $util.isString(message.channel)))
                        return "channel: buffer expected";
                if (message.tag != null && message.hasOwnProperty("tag"))
                    switch (message.tag) {
                    default:
                        return "tag: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.alive_msg != null && message.hasOwnProperty("alive_msg")) {
                    properties.content = 1;
                    {
                        var error = $root.gossip.AliveMessage.verify(message.alive_msg);
                        if (error)
                            return "alive_msg." + error;
                    }
                }
                if (message.mem_req != null && message.hasOwnProperty("mem_req")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.MembershipRequest.verify(message.mem_req);
                        if (error)
                            return "mem_req." + error;
                    }
                }
                if (message.mem_res != null && message.hasOwnProperty("mem_res")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.MembershipResponse.verify(message.mem_res);
                        if (error)
                            return "mem_res." + error;
                    }
                }
                if (message.data_msg != null && message.hasOwnProperty("data_msg")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.DataMessage.verify(message.data_msg);
                        if (error)
                            return "data_msg." + error;
                    }
                }
                if (message.hello != null && message.hasOwnProperty("hello")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.GossipHello.verify(message.hello);
                        if (error)
                            return "hello." + error;
                    }
                }
                if (message.data_dig != null && message.hasOwnProperty("data_dig")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.DataDigest.verify(message.data_dig);
                        if (error)
                            return "data_dig." + error;
                    }
                }
                if (message.data_req != null && message.hasOwnProperty("data_req")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.DataRequest.verify(message.data_req);
                        if (error)
                            return "data_req." + error;
                    }
                }
                if (message.data_update != null && message.hasOwnProperty("data_update")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.DataUpdate.verify(message.data_update);
                        if (error)
                            return "data_update." + error;
                    }
                }
                if (message.empty != null && message.hasOwnProperty("empty")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.Empty.verify(message.empty);
                        if (error)
                            return "empty." + error;
                    }
                }
                if (message.conn != null && message.hasOwnProperty("conn")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.ConnEstablish.verify(message.conn);
                        if (error)
                            return "conn." + error;
                    }
                }
                if (message.state_info != null && message.hasOwnProperty("state_info")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.StateInfo.verify(message.state_info);
                        if (error)
                            return "state_info." + error;
                    }
                }
                if (message.state_snapshot != null && message.hasOwnProperty("state_snapshot")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.StateInfoSnapshot.verify(message.state_snapshot);
                        if (error)
                            return "state_snapshot." + error;
                    }
                }
                if (message.state_info_pull_req != null && message.hasOwnProperty("state_info_pull_req")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.StateInfoPullRequest.verify(message.state_info_pull_req);
                        if (error)
                            return "state_info_pull_req." + error;
                    }
                }
                if (message.state_request != null && message.hasOwnProperty("state_request")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.RemoteStateRequest.verify(message.state_request);
                        if (error)
                            return "state_request." + error;
                    }
                }
                if (message.state_response != null && message.hasOwnProperty("state_response")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.RemoteStateResponse.verify(message.state_response);
                        if (error)
                            return "state_response." + error;
                    }
                }
                if (message.leadership_msg != null && message.hasOwnProperty("leadership_msg")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.LeadershipMessage.verify(message.leadership_msg);
                        if (error)
                            return "leadership_msg." + error;
                    }
                }
                if (message.peer_identity != null && message.hasOwnProperty("peer_identity")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.PeerIdentity.verify(message.peer_identity);
                        if (error)
                            return "peer_identity." + error;
                    }
                }
                if (message.ack != null && message.hasOwnProperty("ack")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.Acknowledgement.verify(message.ack);
                        if (error)
                            return "ack." + error;
                    }
                }
                if (message.privateReq != null && message.hasOwnProperty("privateReq")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.RemotePvtDataRequest.verify(message.privateReq);
                        if (error)
                            return "privateReq." + error;
                    }
                }
                if (message.privateRes != null && message.hasOwnProperty("privateRes")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.RemotePvtDataResponse.verify(message.privateRes);
                        if (error)
                            return "privateRes." + error;
                    }
                }
                if (message.private_data != null && message.hasOwnProperty("private_data")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.PrivateDataMessage.verify(message.private_data);
                        if (error)
                            return "private_data." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a GossipMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.GossipMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.GossipMessage} GossipMessage
             */
            GossipMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.GossipMessage)
                    return object;
                var message = new $root.gossip.GossipMessage();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.channel != null)
                    if (typeof object.channel === "string")
                        $util.base64.decode(object.channel, message.channel = $util.newBuffer($util.base64.length(object.channel)), 0);
                    else if (object.channel.length)
                        message.channel = object.channel;
                switch (object.tag) {
                case "UNDEFINED":
                case 0:
                    message.tag = 0;
                    break;
                case "EMPTY":
                case 1:
                    message.tag = 1;
                    break;
                case "ORG_ONLY":
                case 2:
                    message.tag = 2;
                    break;
                case "CHAN_ONLY":
                case 3:
                    message.tag = 3;
                    break;
                case "CHAN_AND_ORG":
                case 4:
                    message.tag = 4;
                    break;
                case "CHAN_OR_ORG":
                case 5:
                    message.tag = 5;
                    break;
                }
                if (object.alive_msg != null) {
                    if (typeof object.alive_msg !== "object")
                        throw TypeError(".gossip.GossipMessage.alive_msg: object expected");
                    message.alive_msg = $root.gossip.AliveMessage.fromObject(object.alive_msg);
                }
                if (object.mem_req != null) {
                    if (typeof object.mem_req !== "object")
                        throw TypeError(".gossip.GossipMessage.mem_req: object expected");
                    message.mem_req = $root.gossip.MembershipRequest.fromObject(object.mem_req);
                }
                if (object.mem_res != null) {
                    if (typeof object.mem_res !== "object")
                        throw TypeError(".gossip.GossipMessage.mem_res: object expected");
                    message.mem_res = $root.gossip.MembershipResponse.fromObject(object.mem_res);
                }
                if (object.data_msg != null) {
                    if (typeof object.data_msg !== "object")
                        throw TypeError(".gossip.GossipMessage.data_msg: object expected");
                    message.data_msg = $root.gossip.DataMessage.fromObject(object.data_msg);
                }
                if (object.hello != null) {
                    if (typeof object.hello !== "object")
                        throw TypeError(".gossip.GossipMessage.hello: object expected");
                    message.hello = $root.gossip.GossipHello.fromObject(object.hello);
                }
                if (object.data_dig != null) {
                    if (typeof object.data_dig !== "object")
                        throw TypeError(".gossip.GossipMessage.data_dig: object expected");
                    message.data_dig = $root.gossip.DataDigest.fromObject(object.data_dig);
                }
                if (object.data_req != null) {
                    if (typeof object.data_req !== "object")
                        throw TypeError(".gossip.GossipMessage.data_req: object expected");
                    message.data_req = $root.gossip.DataRequest.fromObject(object.data_req);
                }
                if (object.data_update != null) {
                    if (typeof object.data_update !== "object")
                        throw TypeError(".gossip.GossipMessage.data_update: object expected");
                    message.data_update = $root.gossip.DataUpdate.fromObject(object.data_update);
                }
                if (object.empty != null) {
                    if (typeof object.empty !== "object")
                        throw TypeError(".gossip.GossipMessage.empty: object expected");
                    message.empty = $root.gossip.Empty.fromObject(object.empty);
                }
                if (object.conn != null) {
                    if (typeof object.conn !== "object")
                        throw TypeError(".gossip.GossipMessage.conn: object expected");
                    message.conn = $root.gossip.ConnEstablish.fromObject(object.conn);
                }
                if (object.state_info != null) {
                    if (typeof object.state_info !== "object")
                        throw TypeError(".gossip.GossipMessage.state_info: object expected");
                    message.state_info = $root.gossip.StateInfo.fromObject(object.state_info);
                }
                if (object.state_snapshot != null) {
                    if (typeof object.state_snapshot !== "object")
                        throw TypeError(".gossip.GossipMessage.state_snapshot: object expected");
                    message.state_snapshot = $root.gossip.StateInfoSnapshot.fromObject(object.state_snapshot);
                }
                if (object.state_info_pull_req != null) {
                    if (typeof object.state_info_pull_req !== "object")
                        throw TypeError(".gossip.GossipMessage.state_info_pull_req: object expected");
                    message.state_info_pull_req = $root.gossip.StateInfoPullRequest.fromObject(object.state_info_pull_req);
                }
                if (object.state_request != null) {
                    if (typeof object.state_request !== "object")
                        throw TypeError(".gossip.GossipMessage.state_request: object expected");
                    message.state_request = $root.gossip.RemoteStateRequest.fromObject(object.state_request);
                }
                if (object.state_response != null) {
                    if (typeof object.state_response !== "object")
                        throw TypeError(".gossip.GossipMessage.state_response: object expected");
                    message.state_response = $root.gossip.RemoteStateResponse.fromObject(object.state_response);
                }
                if (object.leadership_msg != null) {
                    if (typeof object.leadership_msg !== "object")
                        throw TypeError(".gossip.GossipMessage.leadership_msg: object expected");
                    message.leadership_msg = $root.gossip.LeadershipMessage.fromObject(object.leadership_msg);
                }
                if (object.peer_identity != null) {
                    if (typeof object.peer_identity !== "object")
                        throw TypeError(".gossip.GossipMessage.peer_identity: object expected");
                    message.peer_identity = $root.gossip.PeerIdentity.fromObject(object.peer_identity);
                }
                if (object.ack != null) {
                    if (typeof object.ack !== "object")
                        throw TypeError(".gossip.GossipMessage.ack: object expected");
                    message.ack = $root.gossip.Acknowledgement.fromObject(object.ack);
                }
                if (object.privateReq != null) {
                    if (typeof object.privateReq !== "object")
                        throw TypeError(".gossip.GossipMessage.privateReq: object expected");
                    message.privateReq = $root.gossip.RemotePvtDataRequest.fromObject(object.privateReq);
                }
                if (object.privateRes != null) {
                    if (typeof object.privateRes !== "object")
                        throw TypeError(".gossip.GossipMessage.privateRes: object expected");
                    message.privateRes = $root.gossip.RemotePvtDataResponse.fromObject(object.privateRes);
                }
                if (object.private_data != null) {
                    if (typeof object.private_data !== "object")
                        throw TypeError(".gossip.GossipMessage.private_data: object expected");
                    message.private_data = $root.gossip.PrivateDataMessage.fromObject(object.private_data);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a GossipMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.GossipMessage
             * @static
             * @param {gossip.GossipMessage} message GossipMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GossipMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.channel = "";
                    else {
                        object.channel = [];
                        if (options.bytes !== Array)
                            object.channel = $util.newBuffer(object.channel);
                    }
                    object.tag = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = options.bytes === String ? $util.base64.encode(message.channel, 0, message.channel.length) : options.bytes === Array ? Array.prototype.slice.call(message.channel) : message.channel;
                if (message.tag != null && message.hasOwnProperty("tag"))
                    object.tag = options.enums === String ? $root.gossip.GossipMessage.Tag[message.tag] : message.tag;
                if (message.alive_msg != null && message.hasOwnProperty("alive_msg")) {
                    object.alive_msg = $root.gossip.AliveMessage.toObject(message.alive_msg, options);
                    if (options.oneofs)
                        object.content = "alive_msg";
                }
                if (message.mem_req != null && message.hasOwnProperty("mem_req")) {
                    object.mem_req = $root.gossip.MembershipRequest.toObject(message.mem_req, options);
                    if (options.oneofs)
                        object.content = "mem_req";
                }
                if (message.mem_res != null && message.hasOwnProperty("mem_res")) {
                    object.mem_res = $root.gossip.MembershipResponse.toObject(message.mem_res, options);
                    if (options.oneofs)
                        object.content = "mem_res";
                }
                if (message.data_msg != null && message.hasOwnProperty("data_msg")) {
                    object.data_msg = $root.gossip.DataMessage.toObject(message.data_msg, options);
                    if (options.oneofs)
                        object.content = "data_msg";
                }
                if (message.hello != null && message.hasOwnProperty("hello")) {
                    object.hello = $root.gossip.GossipHello.toObject(message.hello, options);
                    if (options.oneofs)
                        object.content = "hello";
                }
                if (message.data_dig != null && message.hasOwnProperty("data_dig")) {
                    object.data_dig = $root.gossip.DataDigest.toObject(message.data_dig, options);
                    if (options.oneofs)
                        object.content = "data_dig";
                }
                if (message.data_req != null && message.hasOwnProperty("data_req")) {
                    object.data_req = $root.gossip.DataRequest.toObject(message.data_req, options);
                    if (options.oneofs)
                        object.content = "data_req";
                }
                if (message.data_update != null && message.hasOwnProperty("data_update")) {
                    object.data_update = $root.gossip.DataUpdate.toObject(message.data_update, options);
                    if (options.oneofs)
                        object.content = "data_update";
                }
                if (message.empty != null && message.hasOwnProperty("empty")) {
                    object.empty = $root.gossip.Empty.toObject(message.empty, options);
                    if (options.oneofs)
                        object.content = "empty";
                }
                if (message.conn != null && message.hasOwnProperty("conn")) {
                    object.conn = $root.gossip.ConnEstablish.toObject(message.conn, options);
                    if (options.oneofs)
                        object.content = "conn";
                }
                if (message.state_info != null && message.hasOwnProperty("state_info")) {
                    object.state_info = $root.gossip.StateInfo.toObject(message.state_info, options);
                    if (options.oneofs)
                        object.content = "state_info";
                }
                if (message.state_snapshot != null && message.hasOwnProperty("state_snapshot")) {
                    object.state_snapshot = $root.gossip.StateInfoSnapshot.toObject(message.state_snapshot, options);
                    if (options.oneofs)
                        object.content = "state_snapshot";
                }
                if (message.state_info_pull_req != null && message.hasOwnProperty("state_info_pull_req")) {
                    object.state_info_pull_req = $root.gossip.StateInfoPullRequest.toObject(message.state_info_pull_req, options);
                    if (options.oneofs)
                        object.content = "state_info_pull_req";
                }
                if (message.state_request != null && message.hasOwnProperty("state_request")) {
                    object.state_request = $root.gossip.RemoteStateRequest.toObject(message.state_request, options);
                    if (options.oneofs)
                        object.content = "state_request";
                }
                if (message.state_response != null && message.hasOwnProperty("state_response")) {
                    object.state_response = $root.gossip.RemoteStateResponse.toObject(message.state_response, options);
                    if (options.oneofs)
                        object.content = "state_response";
                }
                if (message.leadership_msg != null && message.hasOwnProperty("leadership_msg")) {
                    object.leadership_msg = $root.gossip.LeadershipMessage.toObject(message.leadership_msg, options);
                    if (options.oneofs)
                        object.content = "leadership_msg";
                }
                if (message.peer_identity != null && message.hasOwnProperty("peer_identity")) {
                    object.peer_identity = $root.gossip.PeerIdentity.toObject(message.peer_identity, options);
                    if (options.oneofs)
                        object.content = "peer_identity";
                }
                if (message.ack != null && message.hasOwnProperty("ack")) {
                    object.ack = $root.gossip.Acknowledgement.toObject(message.ack, options);
                    if (options.oneofs)
                        object.content = "ack";
                }
                if (message.privateReq != null && message.hasOwnProperty("privateReq")) {
                    object.privateReq = $root.gossip.RemotePvtDataRequest.toObject(message.privateReq, options);
                    if (options.oneofs)
                        object.content = "privateReq";
                }
                if (message.privateRes != null && message.hasOwnProperty("privateRes")) {
                    object.privateRes = $root.gossip.RemotePvtDataResponse.toObject(message.privateRes, options);
                    if (options.oneofs)
                        object.content = "privateRes";
                }
                if (message.private_data != null && message.hasOwnProperty("private_data")) {
                    object.private_data = $root.gossip.PrivateDataMessage.toObject(message.private_data, options);
                    if (options.oneofs)
                        object.content = "private_data";
                }
                return object;
            };
    
            /**
             * Converts this GossipMessage to JSON.
             * @function toJSON
             * @memberof gossip.GossipMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GossipMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Tag enum.
             * @name gossip.GossipMessage.Tag
             * @enum {number}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} EMPTY=1 EMPTY value
             * @property {number} ORG_ONLY=2 ORG_ONLY value
             * @property {number} CHAN_ONLY=3 CHAN_ONLY value
             * @property {number} CHAN_AND_ORG=4 CHAN_AND_ORG value
             * @property {number} CHAN_OR_ORG=5 CHAN_OR_ORG value
             */
            GossipMessage.Tag = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "EMPTY"] = 1;
                values[valuesById[2] = "ORG_ONLY"] = 2;
                values[valuesById[3] = "CHAN_ONLY"] = 3;
                values[valuesById[4] = "CHAN_AND_ORG"] = 4;
                values[valuesById[5] = "CHAN_OR_ORG"] = 5;
                return values;
            })();
    
            return GossipMessage;
        })();
    
        gossip.StateInfo = (function() {
    
            /**
             * Properties of a StateInfo.
             * @memberof gossip
             * @interface IStateInfo
             * @property {gossip.IPeerTime|null} [timestamp] StateInfo timestamp
             * @property {Uint8Array|null} [pki_id] StateInfo pki_id
             * @property {Uint8Array|null} [channel_MAC] StateInfo channel_MAC
             * @property {gossip.IProperties|null} [properties] StateInfo properties
             */
    
            /**
             * Constructs a new StateInfo.
             * @memberof gossip
             * @classdesc Represents a StateInfo.
             * @implements IStateInfo
             * @constructor
             * @param {gossip.IStateInfo=} [properties] Properties to set
             */
            function StateInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateInfo timestamp.
             * @member {gossip.IPeerTime|null|undefined} timestamp
             * @memberof gossip.StateInfo
             * @instance
             */
            StateInfo.prototype.timestamp = null;
    
            /**
             * StateInfo pki_id.
             * @member {Uint8Array} pki_id
             * @memberof gossip.StateInfo
             * @instance
             */
            StateInfo.prototype.pki_id = $util.newBuffer([]);
    
            /**
             * StateInfo channel_MAC.
             * @member {Uint8Array} channel_MAC
             * @memberof gossip.StateInfo
             * @instance
             */
            StateInfo.prototype.channel_MAC = $util.newBuffer([]);
    
            /**
             * StateInfo properties.
             * @member {gossip.IProperties|null|undefined} properties
             * @memberof gossip.StateInfo
             * @instance
             */
            StateInfo.prototype.properties = null;
    
            /**
             * Creates a new StateInfo instance using the specified properties.
             * @function create
             * @memberof gossip.StateInfo
             * @static
             * @param {gossip.IStateInfo=} [properties] Properties to set
             * @returns {gossip.StateInfo} StateInfo instance
             */
            StateInfo.create = function create(properties) {
                return new StateInfo(properties);
            };
    
            /**
             * Encodes the specified StateInfo message. Does not implicitly {@link gossip.StateInfo.verify|verify} messages.
             * @function encode
             * @memberof gossip.StateInfo
             * @static
             * @param {gossip.IStateInfo} message StateInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.gossip.PeerTime.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.pki_id != null && Object.hasOwnProperty.call(message, "pki_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pki_id);
                if (message.channel_MAC != null && Object.hasOwnProperty.call(message, "channel_MAC"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.channel_MAC);
                if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                    $root.gossip.Properties.encode(message.properties, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StateInfo message, length delimited. Does not implicitly {@link gossip.StateInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.StateInfo
             * @static
             * @param {gossip.IStateInfo} message StateInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.StateInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.StateInfo} StateInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.StateInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.timestamp = $root.gossip.PeerTime.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.pki_id = reader.bytes();
                        break;
                    case 4:
                        message.channel_MAC = reader.bytes();
                        break;
                    case 5:
                        message.properties = $root.gossip.Properties.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.StateInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.StateInfo} StateInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateInfo message.
             * @function verify
             * @memberof gossip.StateInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.gossip.PeerTime.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    if (!(message.pki_id && typeof message.pki_id.length === "number" || $util.isString(message.pki_id)))
                        return "pki_id: buffer expected";
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    if (!(message.channel_MAC && typeof message.channel_MAC.length === "number" || $util.isString(message.channel_MAC)))
                        return "channel_MAC: buffer expected";
                if (message.properties != null && message.hasOwnProperty("properties")) {
                    var error = $root.gossip.Properties.verify(message.properties);
                    if (error)
                        return "properties." + error;
                }
                return null;
            };
    
            /**
             * Creates a StateInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.StateInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.StateInfo} StateInfo
             */
            StateInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.StateInfo)
                    return object;
                var message = new $root.gossip.StateInfo();
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".gossip.StateInfo.timestamp: object expected");
                    message.timestamp = $root.gossip.PeerTime.fromObject(object.timestamp);
                }
                if (object.pki_id != null)
                    if (typeof object.pki_id === "string")
                        $util.base64.decode(object.pki_id, message.pki_id = $util.newBuffer($util.base64.length(object.pki_id)), 0);
                    else if (object.pki_id.length)
                        message.pki_id = object.pki_id;
                if (object.channel_MAC != null)
                    if (typeof object.channel_MAC === "string")
                        $util.base64.decode(object.channel_MAC, message.channel_MAC = $util.newBuffer($util.base64.length(object.channel_MAC)), 0);
                    else if (object.channel_MAC.length)
                        message.channel_MAC = object.channel_MAC;
                if (object.properties != null) {
                    if (typeof object.properties !== "object")
                        throw TypeError(".gossip.StateInfo.properties: object expected");
                    message.properties = $root.gossip.Properties.fromObject(object.properties);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StateInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.StateInfo
             * @static
             * @param {gossip.StateInfo} message StateInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.timestamp = null;
                    if (options.bytes === String)
                        object.pki_id = "";
                    else {
                        object.pki_id = [];
                        if (options.bytes !== Array)
                            object.pki_id = $util.newBuffer(object.pki_id);
                    }
                    if (options.bytes === String)
                        object.channel_MAC = "";
                    else {
                        object.channel_MAC = [];
                        if (options.bytes !== Array)
                            object.channel_MAC = $util.newBuffer(object.channel_MAC);
                    }
                    object.properties = null;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.gossip.PeerTime.toObject(message.timestamp, options);
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    object.pki_id = options.bytes === String ? $util.base64.encode(message.pki_id, 0, message.pki_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.pki_id) : message.pki_id;
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    object.channel_MAC = options.bytes === String ? $util.base64.encode(message.channel_MAC, 0, message.channel_MAC.length) : options.bytes === Array ? Array.prototype.slice.call(message.channel_MAC) : message.channel_MAC;
                if (message.properties != null && message.hasOwnProperty("properties"))
                    object.properties = $root.gossip.Properties.toObject(message.properties, options);
                return object;
            };
    
            /**
             * Converts this StateInfo to JSON.
             * @function toJSON
             * @memberof gossip.StateInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateInfo;
        })();
    
        gossip.Properties = (function() {
    
            /**
             * Properties of a Properties.
             * @memberof gossip
             * @interface IProperties
             * @property {number|Long|null} [ledger_height] Properties ledger_height
             * @property {boolean|null} [left_channel] Properties left_channel
             * @property {Array.<gossip.IChaincode>|null} [chaincodes] Properties chaincodes
             */
    
            /**
             * Constructs a new Properties.
             * @memberof gossip
             * @classdesc Represents a Properties.
             * @implements IProperties
             * @constructor
             * @param {gossip.IProperties=} [properties] Properties to set
             */
            function Properties(properties) {
                this.chaincodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Properties ledger_height.
             * @member {number|Long} ledger_height
             * @memberof gossip.Properties
             * @instance
             */
            Properties.prototype.ledger_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Properties left_channel.
             * @member {boolean} left_channel
             * @memberof gossip.Properties
             * @instance
             */
            Properties.prototype.left_channel = false;
    
            /**
             * Properties chaincodes.
             * @member {Array.<gossip.IChaincode>} chaincodes
             * @memberof gossip.Properties
             * @instance
             */
            Properties.prototype.chaincodes = $util.emptyArray;
    
            /**
             * Creates a new Properties instance using the specified properties.
             * @function create
             * @memberof gossip.Properties
             * @static
             * @param {gossip.IProperties=} [properties] Properties to set
             * @returns {gossip.Properties} Properties instance
             */
            Properties.create = function create(properties) {
                return new Properties(properties);
            };
    
            /**
             * Encodes the specified Properties message. Does not implicitly {@link gossip.Properties.verify|verify} messages.
             * @function encode
             * @memberof gossip.Properties
             * @static
             * @param {gossip.IProperties} message Properties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Properties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ledger_height != null && Object.hasOwnProperty.call(message, "ledger_height"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ledger_height);
                if (message.left_channel != null && Object.hasOwnProperty.call(message, "left_channel"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.left_channel);
                if (message.chaincodes != null && message.chaincodes.length)
                    for (var i = 0; i < message.chaincodes.length; ++i)
                        $root.gossip.Chaincode.encode(message.chaincodes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Properties message, length delimited. Does not implicitly {@link gossip.Properties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Properties
             * @static
             * @param {gossip.IProperties} message Properties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Properties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Properties message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Properties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Properties} Properties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Properties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Properties();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ledger_height = reader.uint64();
                        break;
                    case 2:
                        message.left_channel = reader.bool();
                        break;
                    case 3:
                        if (!(message.chaincodes && message.chaincodes.length))
                            message.chaincodes = [];
                        message.chaincodes.push($root.gossip.Chaincode.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Properties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Properties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Properties} Properties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Properties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Properties message.
             * @function verify
             * @memberof gossip.Properties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Properties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ledger_height != null && message.hasOwnProperty("ledger_height"))
                    if (!$util.isInteger(message.ledger_height) && !(message.ledger_height && $util.isInteger(message.ledger_height.low) && $util.isInteger(message.ledger_height.high)))
                        return "ledger_height: integer|Long expected";
                if (message.left_channel != null && message.hasOwnProperty("left_channel"))
                    if (typeof message.left_channel !== "boolean")
                        return "left_channel: boolean expected";
                if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                    if (!Array.isArray(message.chaincodes))
                        return "chaincodes: array expected";
                    for (var i = 0; i < message.chaincodes.length; ++i) {
                        var error = $root.gossip.Chaincode.verify(message.chaincodes[i]);
                        if (error)
                            return "chaincodes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Properties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Properties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Properties} Properties
             */
            Properties.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Properties)
                    return object;
                var message = new $root.gossip.Properties();
                if (object.ledger_height != null)
                    if ($util.Long)
                        (message.ledger_height = $util.Long.fromValue(object.ledger_height)).unsigned = true;
                    else if (typeof object.ledger_height === "string")
                        message.ledger_height = parseInt(object.ledger_height, 10);
                    else if (typeof object.ledger_height === "number")
                        message.ledger_height = object.ledger_height;
                    else if (typeof object.ledger_height === "object")
                        message.ledger_height = new $util.LongBits(object.ledger_height.low >>> 0, object.ledger_height.high >>> 0).toNumber(true);
                if (object.left_channel != null)
                    message.left_channel = Boolean(object.left_channel);
                if (object.chaincodes) {
                    if (!Array.isArray(object.chaincodes))
                        throw TypeError(".gossip.Properties.chaincodes: array expected");
                    message.chaincodes = [];
                    for (var i = 0; i < object.chaincodes.length; ++i) {
                        if (typeof object.chaincodes[i] !== "object")
                            throw TypeError(".gossip.Properties.chaincodes: object expected");
                        message.chaincodes[i] = $root.gossip.Chaincode.fromObject(object.chaincodes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Properties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Properties
             * @static
             * @param {gossip.Properties} message Properties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Properties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincodes = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.ledger_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ledger_height = options.longs === String ? "0" : 0;
                    object.left_channel = false;
                }
                if (message.ledger_height != null && message.hasOwnProperty("ledger_height"))
                    if (typeof message.ledger_height === "number")
                        object.ledger_height = options.longs === String ? String(message.ledger_height) : message.ledger_height;
                    else
                        object.ledger_height = options.longs === String ? $util.Long.prototype.toString.call(message.ledger_height) : options.longs === Number ? new $util.LongBits(message.ledger_height.low >>> 0, message.ledger_height.high >>> 0).toNumber(true) : message.ledger_height;
                if (message.left_channel != null && message.hasOwnProperty("left_channel"))
                    object.left_channel = message.left_channel;
                if (message.chaincodes && message.chaincodes.length) {
                    object.chaincodes = [];
                    for (var j = 0; j < message.chaincodes.length; ++j)
                        object.chaincodes[j] = $root.gossip.Chaincode.toObject(message.chaincodes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Properties to JSON.
             * @function toJSON
             * @memberof gossip.Properties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Properties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Properties;
        })();
    
        gossip.StateInfoSnapshot = (function() {
    
            /**
             * Properties of a StateInfoSnapshot.
             * @memberof gossip
             * @interface IStateInfoSnapshot
             * @property {Array.<gossip.IEnvelope>|null} [elements] StateInfoSnapshot elements
             */
    
            /**
             * Constructs a new StateInfoSnapshot.
             * @memberof gossip
             * @classdesc Represents a StateInfoSnapshot.
             * @implements IStateInfoSnapshot
             * @constructor
             * @param {gossip.IStateInfoSnapshot=} [properties] Properties to set
             */
            function StateInfoSnapshot(properties) {
                this.elements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateInfoSnapshot elements.
             * @member {Array.<gossip.IEnvelope>} elements
             * @memberof gossip.StateInfoSnapshot
             * @instance
             */
            StateInfoSnapshot.prototype.elements = $util.emptyArray;
    
            /**
             * Creates a new StateInfoSnapshot instance using the specified properties.
             * @function create
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {gossip.IStateInfoSnapshot=} [properties] Properties to set
             * @returns {gossip.StateInfoSnapshot} StateInfoSnapshot instance
             */
            StateInfoSnapshot.create = function create(properties) {
                return new StateInfoSnapshot(properties);
            };
    
            /**
             * Encodes the specified StateInfoSnapshot message. Does not implicitly {@link gossip.StateInfoSnapshot.verify|verify} messages.
             * @function encode
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {gossip.IStateInfoSnapshot} message StateInfoSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfoSnapshot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elements != null && message.elements.length)
                    for (var i = 0; i < message.elements.length; ++i)
                        $root.gossip.Envelope.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StateInfoSnapshot message, length delimited. Does not implicitly {@link gossip.StateInfoSnapshot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {gossip.IStateInfoSnapshot} message StateInfoSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfoSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateInfoSnapshot message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.StateInfoSnapshot} StateInfoSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfoSnapshot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.StateInfoSnapshot();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.elements && message.elements.length))
                            message.elements = [];
                        message.elements.push($root.gossip.Envelope.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateInfoSnapshot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.StateInfoSnapshot} StateInfoSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfoSnapshot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateInfoSnapshot message.
             * @function verify
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateInfoSnapshot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (var i = 0; i < message.elements.length; ++i) {
                        var error = $root.gossip.Envelope.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StateInfoSnapshot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.StateInfoSnapshot} StateInfoSnapshot
             */
            StateInfoSnapshot.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.StateInfoSnapshot)
                    return object;
                var message = new $root.gossip.StateInfoSnapshot();
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".gossip.StateInfoSnapshot.elements: array expected");
                    message.elements = [];
                    for (var i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".gossip.StateInfoSnapshot.elements: object expected");
                        message.elements[i] = $root.gossip.Envelope.fromObject(object.elements[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StateInfoSnapshot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {gossip.StateInfoSnapshot} message StateInfoSnapshot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateInfoSnapshot.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (var j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.gossip.Envelope.toObject(message.elements[j], options);
                }
                return object;
            };
    
            /**
             * Converts this StateInfoSnapshot to JSON.
             * @function toJSON
             * @memberof gossip.StateInfoSnapshot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateInfoSnapshot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateInfoSnapshot;
        })();
    
        gossip.StateInfoPullRequest = (function() {
    
            /**
             * Properties of a StateInfoPullRequest.
             * @memberof gossip
             * @interface IStateInfoPullRequest
             * @property {Uint8Array|null} [channel_MAC] StateInfoPullRequest channel_MAC
             */
    
            /**
             * Constructs a new StateInfoPullRequest.
             * @memberof gossip
             * @classdesc Represents a StateInfoPullRequest.
             * @implements IStateInfoPullRequest
             * @constructor
             * @param {gossip.IStateInfoPullRequest=} [properties] Properties to set
             */
            function StateInfoPullRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateInfoPullRequest channel_MAC.
             * @member {Uint8Array} channel_MAC
             * @memberof gossip.StateInfoPullRequest
             * @instance
             */
            StateInfoPullRequest.prototype.channel_MAC = $util.newBuffer([]);
    
            /**
             * Creates a new StateInfoPullRequest instance using the specified properties.
             * @function create
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {gossip.IStateInfoPullRequest=} [properties] Properties to set
             * @returns {gossip.StateInfoPullRequest} StateInfoPullRequest instance
             */
            StateInfoPullRequest.create = function create(properties) {
                return new StateInfoPullRequest(properties);
            };
    
            /**
             * Encodes the specified StateInfoPullRequest message. Does not implicitly {@link gossip.StateInfoPullRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {gossip.IStateInfoPullRequest} message StateInfoPullRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfoPullRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel_MAC != null && Object.hasOwnProperty.call(message, "channel_MAC"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channel_MAC);
                return writer;
            };
    
            /**
             * Encodes the specified StateInfoPullRequest message, length delimited. Does not implicitly {@link gossip.StateInfoPullRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {gossip.IStateInfoPullRequest} message StateInfoPullRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfoPullRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateInfoPullRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.StateInfoPullRequest} StateInfoPullRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfoPullRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.StateInfoPullRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel_MAC = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateInfoPullRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.StateInfoPullRequest} StateInfoPullRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfoPullRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateInfoPullRequest message.
             * @function verify
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateInfoPullRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    if (!(message.channel_MAC && typeof message.channel_MAC.length === "number" || $util.isString(message.channel_MAC)))
                        return "channel_MAC: buffer expected";
                return null;
            };
    
            /**
             * Creates a StateInfoPullRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.StateInfoPullRequest} StateInfoPullRequest
             */
            StateInfoPullRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.StateInfoPullRequest)
                    return object;
                var message = new $root.gossip.StateInfoPullRequest();
                if (object.channel_MAC != null)
                    if (typeof object.channel_MAC === "string")
                        $util.base64.decode(object.channel_MAC, message.channel_MAC = $util.newBuffer($util.base64.length(object.channel_MAC)), 0);
                    else if (object.channel_MAC.length)
                        message.channel_MAC = object.channel_MAC;
                return message;
            };
    
            /**
             * Creates a plain object from a StateInfoPullRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {gossip.StateInfoPullRequest} message StateInfoPullRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateInfoPullRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.channel_MAC = "";
                    else {
                        object.channel_MAC = [];
                        if (options.bytes !== Array)
                            object.channel_MAC = $util.newBuffer(object.channel_MAC);
                    }
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    object.channel_MAC = options.bytes === String ? $util.base64.encode(message.channel_MAC, 0, message.channel_MAC.length) : options.bytes === Array ? Array.prototype.slice.call(message.channel_MAC) : message.channel_MAC;
                return object;
            };
    
            /**
             * Converts this StateInfoPullRequest to JSON.
             * @function toJSON
             * @memberof gossip.StateInfoPullRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateInfoPullRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateInfoPullRequest;
        })();
    
        gossip.ConnEstablish = (function() {
    
            /**
             * Properties of a ConnEstablish.
             * @memberof gossip
             * @interface IConnEstablish
             * @property {Uint8Array|null} [pki_id] ConnEstablish pki_id
             * @property {Uint8Array|null} [identity] ConnEstablish identity
             * @property {Uint8Array|null} [tls_cert_hash] ConnEstablish tls_cert_hash
             */
    
            /**
             * Constructs a new ConnEstablish.
             * @memberof gossip
             * @classdesc Represents a ConnEstablish.
             * @implements IConnEstablish
             * @constructor
             * @param {gossip.IConnEstablish=} [properties] Properties to set
             */
            function ConnEstablish(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConnEstablish pki_id.
             * @member {Uint8Array} pki_id
             * @memberof gossip.ConnEstablish
             * @instance
             */
            ConnEstablish.prototype.pki_id = $util.newBuffer([]);
    
            /**
             * ConnEstablish identity.
             * @member {Uint8Array} identity
             * @memberof gossip.ConnEstablish
             * @instance
             */
            ConnEstablish.prototype.identity = $util.newBuffer([]);
    
            /**
             * ConnEstablish tls_cert_hash.
             * @member {Uint8Array} tls_cert_hash
             * @memberof gossip.ConnEstablish
             * @instance
             */
            ConnEstablish.prototype.tls_cert_hash = $util.newBuffer([]);
    
            /**
             * Creates a new ConnEstablish instance using the specified properties.
             * @function create
             * @memberof gossip.ConnEstablish
             * @static
             * @param {gossip.IConnEstablish=} [properties] Properties to set
             * @returns {gossip.ConnEstablish} ConnEstablish instance
             */
            ConnEstablish.create = function create(properties) {
                return new ConnEstablish(properties);
            };
    
            /**
             * Encodes the specified ConnEstablish message. Does not implicitly {@link gossip.ConnEstablish.verify|verify} messages.
             * @function encode
             * @memberof gossip.ConnEstablish
             * @static
             * @param {gossip.IConnEstablish} message ConnEstablish message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnEstablish.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pki_id != null && Object.hasOwnProperty.call(message, "pki_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pki_id);
                if (message.identity != null && Object.hasOwnProperty.call(message, "identity"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.identity);
                if (message.tls_cert_hash != null && Object.hasOwnProperty.call(message, "tls_cert_hash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tls_cert_hash);
                return writer;
            };
    
            /**
             * Encodes the specified ConnEstablish message, length delimited. Does not implicitly {@link gossip.ConnEstablish.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.ConnEstablish
             * @static
             * @param {gossip.IConnEstablish} message ConnEstablish message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnEstablish.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnEstablish message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.ConnEstablish
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.ConnEstablish} ConnEstablish
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnEstablish.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.ConnEstablish();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pki_id = reader.bytes();
                        break;
                    case 2:
                        message.identity = reader.bytes();
                        break;
                    case 3:
                        message.tls_cert_hash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnEstablish message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.ConnEstablish
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.ConnEstablish} ConnEstablish
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnEstablish.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnEstablish message.
             * @function verify
             * @memberof gossip.ConnEstablish
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnEstablish.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    if (!(message.pki_id && typeof message.pki_id.length === "number" || $util.isString(message.pki_id)))
                        return "pki_id: buffer expected";
                if (message.identity != null && message.hasOwnProperty("identity"))
                    if (!(message.identity && typeof message.identity.length === "number" || $util.isString(message.identity)))
                        return "identity: buffer expected";
                if (message.tls_cert_hash != null && message.hasOwnProperty("tls_cert_hash"))
                    if (!(message.tls_cert_hash && typeof message.tls_cert_hash.length === "number" || $util.isString(message.tls_cert_hash)))
                        return "tls_cert_hash: buffer expected";
                return null;
            };
    
            /**
             * Creates a ConnEstablish message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.ConnEstablish
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.ConnEstablish} ConnEstablish
             */
            ConnEstablish.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.ConnEstablish)
                    return object;
                var message = new $root.gossip.ConnEstablish();
                if (object.pki_id != null)
                    if (typeof object.pki_id === "string")
                        $util.base64.decode(object.pki_id, message.pki_id = $util.newBuffer($util.base64.length(object.pki_id)), 0);
                    else if (object.pki_id.length)
                        message.pki_id = object.pki_id;
                if (object.identity != null)
                    if (typeof object.identity === "string")
                        $util.base64.decode(object.identity, message.identity = $util.newBuffer($util.base64.length(object.identity)), 0);
                    else if (object.identity.length)
                        message.identity = object.identity;
                if (object.tls_cert_hash != null)
                    if (typeof object.tls_cert_hash === "string")
                        $util.base64.decode(object.tls_cert_hash, message.tls_cert_hash = $util.newBuffer($util.base64.length(object.tls_cert_hash)), 0);
                    else if (object.tls_cert_hash.length)
                        message.tls_cert_hash = object.tls_cert_hash;
                return message;
            };
    
            /**
             * Creates a plain object from a ConnEstablish message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.ConnEstablish
             * @static
             * @param {gossip.ConnEstablish} message ConnEstablish
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnEstablish.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.pki_id = "";
                    else {
                        object.pki_id = [];
                        if (options.bytes !== Array)
                            object.pki_id = $util.newBuffer(object.pki_id);
                    }
                    if (options.bytes === String)
                        object.identity = "";
                    else {
                        object.identity = [];
                        if (options.bytes !== Array)
                            object.identity = $util.newBuffer(object.identity);
                    }
                    if (options.bytes === String)
                        object.tls_cert_hash = "";
                    else {
                        object.tls_cert_hash = [];
                        if (options.bytes !== Array)
                            object.tls_cert_hash = $util.newBuffer(object.tls_cert_hash);
                    }
                }
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    object.pki_id = options.bytes === String ? $util.base64.encode(message.pki_id, 0, message.pki_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.pki_id) : message.pki_id;
                if (message.identity != null && message.hasOwnProperty("identity"))
                    object.identity = options.bytes === String ? $util.base64.encode(message.identity, 0, message.identity.length) : options.bytes === Array ? Array.prototype.slice.call(message.identity) : message.identity;
                if (message.tls_cert_hash != null && message.hasOwnProperty("tls_cert_hash"))
                    object.tls_cert_hash = options.bytes === String ? $util.base64.encode(message.tls_cert_hash, 0, message.tls_cert_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.tls_cert_hash) : message.tls_cert_hash;
                return object;
            };
    
            /**
             * Converts this ConnEstablish to JSON.
             * @function toJSON
             * @memberof gossip.ConnEstablish
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnEstablish.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConnEstablish;
        })();
    
        gossip.PeerIdentity = (function() {
    
            /**
             * Properties of a PeerIdentity.
             * @memberof gossip
             * @interface IPeerIdentity
             * @property {Uint8Array|null} [pki_id] PeerIdentity pki_id
             * @property {Uint8Array|null} [cert] PeerIdentity cert
             * @property {Uint8Array|null} [metadata] PeerIdentity metadata
             */
    
            /**
             * Constructs a new PeerIdentity.
             * @memberof gossip
             * @classdesc Represents a PeerIdentity.
             * @implements IPeerIdentity
             * @constructor
             * @param {gossip.IPeerIdentity=} [properties] Properties to set
             */
            function PeerIdentity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerIdentity pki_id.
             * @member {Uint8Array} pki_id
             * @memberof gossip.PeerIdentity
             * @instance
             */
            PeerIdentity.prototype.pki_id = $util.newBuffer([]);
    
            /**
             * PeerIdentity cert.
             * @member {Uint8Array} cert
             * @memberof gossip.PeerIdentity
             * @instance
             */
            PeerIdentity.prototype.cert = $util.newBuffer([]);
    
            /**
             * PeerIdentity metadata.
             * @member {Uint8Array} metadata
             * @memberof gossip.PeerIdentity
             * @instance
             */
            PeerIdentity.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new PeerIdentity instance using the specified properties.
             * @function create
             * @memberof gossip.PeerIdentity
             * @static
             * @param {gossip.IPeerIdentity=} [properties] Properties to set
             * @returns {gossip.PeerIdentity} PeerIdentity instance
             */
            PeerIdentity.create = function create(properties) {
                return new PeerIdentity(properties);
            };
    
            /**
             * Encodes the specified PeerIdentity message. Does not implicitly {@link gossip.PeerIdentity.verify|verify} messages.
             * @function encode
             * @memberof gossip.PeerIdentity
             * @static
             * @param {gossip.IPeerIdentity} message PeerIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerIdentity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pki_id != null && Object.hasOwnProperty.call(message, "pki_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pki_id);
                if (message.cert != null && Object.hasOwnProperty.call(message, "cert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.cert);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified PeerIdentity message, length delimited. Does not implicitly {@link gossip.PeerIdentity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PeerIdentity
             * @static
             * @param {gossip.IPeerIdentity} message PeerIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerIdentity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerIdentity message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PeerIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PeerIdentity} PeerIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerIdentity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PeerIdentity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pki_id = reader.bytes();
                        break;
                    case 2:
                        message.cert = reader.bytes();
                        break;
                    case 3:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerIdentity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PeerIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PeerIdentity} PeerIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerIdentity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerIdentity message.
             * @function verify
             * @memberof gossip.PeerIdentity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerIdentity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    if (!(message.pki_id && typeof message.pki_id.length === "number" || $util.isString(message.pki_id)))
                        return "pki_id: buffer expected";
                if (message.cert != null && message.hasOwnProperty("cert"))
                    if (!(message.cert && typeof message.cert.length === "number" || $util.isString(message.cert)))
                        return "cert: buffer expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a PeerIdentity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PeerIdentity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PeerIdentity} PeerIdentity
             */
            PeerIdentity.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PeerIdentity)
                    return object;
                var message = new $root.gossip.PeerIdentity();
                if (object.pki_id != null)
                    if (typeof object.pki_id === "string")
                        $util.base64.decode(object.pki_id, message.pki_id = $util.newBuffer($util.base64.length(object.pki_id)), 0);
                    else if (object.pki_id.length)
                        message.pki_id = object.pki_id;
                if (object.cert != null)
                    if (typeof object.cert === "string")
                        $util.base64.decode(object.cert, message.cert = $util.newBuffer($util.base64.length(object.cert)), 0);
                    else if (object.cert.length)
                        message.cert = object.cert;
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a PeerIdentity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PeerIdentity
             * @static
             * @param {gossip.PeerIdentity} message PeerIdentity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerIdentity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.pki_id = "";
                    else {
                        object.pki_id = [];
                        if (options.bytes !== Array)
                            object.pki_id = $util.newBuffer(object.pki_id);
                    }
                    if (options.bytes === String)
                        object.cert = "";
                    else {
                        object.cert = [];
                        if (options.bytes !== Array)
                            object.cert = $util.newBuffer(object.cert);
                    }
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    object.pki_id = options.bytes === String ? $util.base64.encode(message.pki_id, 0, message.pki_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.pki_id) : message.pki_id;
                if (message.cert != null && message.hasOwnProperty("cert"))
                    object.cert = options.bytes === String ? $util.base64.encode(message.cert, 0, message.cert.length) : options.bytes === Array ? Array.prototype.slice.call(message.cert) : message.cert;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this PeerIdentity to JSON.
             * @function toJSON
             * @memberof gossip.PeerIdentity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerIdentity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PeerIdentity;
        })();
    
        /**
         * PullMsgType enum.
         * @name gossip.PullMsgType
         * @enum {number}
         * @property {number} UNDEFINED=0 UNDEFINED value
         * @property {number} BLOCK_MSG=1 BLOCK_MSG value
         * @property {number} IDENTITY_MSG=2 IDENTITY_MSG value
         */
        gossip.PullMsgType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "BLOCK_MSG"] = 1;
            values[valuesById[2] = "IDENTITY_MSG"] = 2;
            return values;
        })();
    
        gossip.DataRequest = (function() {
    
            /**
             * Properties of a DataRequest.
             * @memberof gossip
             * @interface IDataRequest
             * @property {number|Long|null} [nonce] DataRequest nonce
             * @property {Array.<Uint8Array>|null} [digests] DataRequest digests
             * @property {gossip.PullMsgType|null} [msg_type] DataRequest msg_type
             */
    
            /**
             * Constructs a new DataRequest.
             * @memberof gossip
             * @classdesc Represents a DataRequest.
             * @implements IDataRequest
             * @constructor
             * @param {gossip.IDataRequest=} [properties] Properties to set
             */
            function DataRequest(properties) {
                this.digests = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataRequest nonce.
             * @member {number|Long} nonce
             * @memberof gossip.DataRequest
             * @instance
             */
            DataRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * DataRequest digests.
             * @member {Array.<Uint8Array>} digests
             * @memberof gossip.DataRequest
             * @instance
             */
            DataRequest.prototype.digests = $util.emptyArray;
    
            /**
             * DataRequest msg_type.
             * @member {gossip.PullMsgType} msg_type
             * @memberof gossip.DataRequest
             * @instance
             */
            DataRequest.prototype.msg_type = 0;
    
            /**
             * Creates a new DataRequest instance using the specified properties.
             * @function create
             * @memberof gossip.DataRequest
             * @static
             * @param {gossip.IDataRequest=} [properties] Properties to set
             * @returns {gossip.DataRequest} DataRequest instance
             */
            DataRequest.create = function create(properties) {
                return new DataRequest(properties);
            };
    
            /**
             * Encodes the specified DataRequest message. Does not implicitly {@link gossip.DataRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.DataRequest
             * @static
             * @param {gossip.IDataRequest} message DataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.digests != null && message.digests.length)
                    for (var i = 0; i < message.digests.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.digests[i]);
                if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msg_type);
                return writer;
            };
    
            /**
             * Encodes the specified DataRequest message, length delimited. Does not implicitly {@link gossip.DataRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.DataRequest
             * @static
             * @param {gossip.IDataRequest} message DataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.DataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.DataRequest} DataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.DataRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        if (!(message.digests && message.digests.length))
                            message.digests = [];
                        message.digests.push(reader.bytes());
                        break;
                    case 3:
                        message.msg_type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.DataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.DataRequest} DataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataRequest message.
             * @function verify
             * @memberof gossip.DataRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.digests != null && message.hasOwnProperty("digests")) {
                    if (!Array.isArray(message.digests))
                        return "digests: array expected";
                    for (var i = 0; i < message.digests.length; ++i)
                        if (!(message.digests[i] && typeof message.digests[i].length === "number" || $util.isString(message.digests[i])))
                            return "digests: buffer[] expected";
                }
                if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                    switch (message.msg_type) {
                    default:
                        return "msg_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a DataRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.DataRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.DataRequest} DataRequest
             */
            DataRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.DataRequest)
                    return object;
                var message = new $root.gossip.DataRequest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.digests) {
                    if (!Array.isArray(object.digests))
                        throw TypeError(".gossip.DataRequest.digests: array expected");
                    message.digests = [];
                    for (var i = 0; i < object.digests.length; ++i)
                        if (typeof object.digests[i] === "string")
                            $util.base64.decode(object.digests[i], message.digests[i] = $util.newBuffer($util.base64.length(object.digests[i])), 0);
                        else if (object.digests[i].length)
                            message.digests[i] = object.digests[i];
                }
                switch (object.msg_type) {
                case "UNDEFINED":
                case 0:
                    message.msg_type = 0;
                    break;
                case "BLOCK_MSG":
                case 1:
                    message.msg_type = 1;
                    break;
                case "IDENTITY_MSG":
                case 2:
                    message.msg_type = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.DataRequest
             * @static
             * @param {gossip.DataRequest} message DataRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.digests = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.msg_type = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.digests && message.digests.length) {
                    object.digests = [];
                    for (var j = 0; j < message.digests.length; ++j)
                        object.digests[j] = options.bytes === String ? $util.base64.encode(message.digests[j], 0, message.digests[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.digests[j]) : message.digests[j];
                }
                if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                    object.msg_type = options.enums === String ? $root.gossip.PullMsgType[message.msg_type] : message.msg_type;
                return object;
            };
    
            /**
             * Converts this DataRequest to JSON.
             * @function toJSON
             * @memberof gossip.DataRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataRequest;
        })();
    
        gossip.GossipHello = (function() {
    
            /**
             * Properties of a GossipHello.
             * @memberof gossip
             * @interface IGossipHello
             * @property {number|Long|null} [nonce] GossipHello nonce
             * @property {Uint8Array|null} [metadata] GossipHello metadata
             * @property {gossip.PullMsgType|null} [msg_type] GossipHello msg_type
             */
    
            /**
             * Constructs a new GossipHello.
             * @memberof gossip
             * @classdesc Represents a GossipHello.
             * @implements IGossipHello
             * @constructor
             * @param {gossip.IGossipHello=} [properties] Properties to set
             */
            function GossipHello(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GossipHello nonce.
             * @member {number|Long} nonce
             * @memberof gossip.GossipHello
             * @instance
             */
            GossipHello.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * GossipHello metadata.
             * @member {Uint8Array} metadata
             * @memberof gossip.GossipHello
             * @instance
             */
            GossipHello.prototype.metadata = $util.newBuffer([]);
    
            /**
             * GossipHello msg_type.
             * @member {gossip.PullMsgType} msg_type
             * @memberof gossip.GossipHello
             * @instance
             */
            GossipHello.prototype.msg_type = 0;
    
            /**
             * Creates a new GossipHello instance using the specified properties.
             * @function create
             * @memberof gossip.GossipHello
             * @static
             * @param {gossip.IGossipHello=} [properties] Properties to set
             * @returns {gossip.GossipHello} GossipHello instance
             */
            GossipHello.create = function create(properties) {
                return new GossipHello(properties);
            };
    
            /**
             * Encodes the specified GossipHello message. Does not implicitly {@link gossip.GossipHello.verify|verify} messages.
             * @function encode
             * @memberof gossip.GossipHello
             * @static
             * @param {gossip.IGossipHello} message GossipHello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GossipHello.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata);
                if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msg_type);
                return writer;
            };
    
            /**
             * Encodes the specified GossipHello message, length delimited. Does not implicitly {@link gossip.GossipHello.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.GossipHello
             * @static
             * @param {gossip.IGossipHello} message GossipHello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GossipHello.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GossipHello message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.GossipHello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.GossipHello} GossipHello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GossipHello.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.GossipHello();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.metadata = reader.bytes();
                        break;
                    case 3:
                        message.msg_type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GossipHello message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.GossipHello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.GossipHello} GossipHello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GossipHello.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GossipHello message.
             * @function verify
             * @memberof gossip.GossipHello
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GossipHello.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                    switch (message.msg_type) {
                    default:
                        return "msg_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a GossipHello message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.GossipHello
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.GossipHello} GossipHello
             */
            GossipHello.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.GossipHello)
                    return object;
                var message = new $root.gossip.GossipHello();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                switch (object.msg_type) {
                case "UNDEFINED":
                case 0:
                    message.msg_type = 0;
                    break;
                case "BLOCK_MSG":
                case 1:
                    message.msg_type = 1;
                    break;
                case "IDENTITY_MSG":
                case 2:
                    message.msg_type = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a GossipHello message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.GossipHello
             * @static
             * @param {gossip.GossipHello} message GossipHello
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GossipHello.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                    object.msg_type = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                    object.msg_type = options.enums === String ? $root.gossip.PullMsgType[message.msg_type] : message.msg_type;
                return object;
            };
    
            /**
             * Converts this GossipHello to JSON.
             * @function toJSON
             * @memberof gossip.GossipHello
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GossipHello.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GossipHello;
        })();
    
        gossip.DataUpdate = (function() {
    
            /**
             * Properties of a DataUpdate.
             * @memberof gossip
             * @interface IDataUpdate
             * @property {number|Long|null} [nonce] DataUpdate nonce
             * @property {Array.<gossip.IEnvelope>|null} [data] DataUpdate data
             * @property {gossip.PullMsgType|null} [msg_type] DataUpdate msg_type
             */
    
            /**
             * Constructs a new DataUpdate.
             * @memberof gossip
             * @classdesc Represents a DataUpdate.
             * @implements IDataUpdate
             * @constructor
             * @param {gossip.IDataUpdate=} [properties] Properties to set
             */
            function DataUpdate(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataUpdate nonce.
             * @member {number|Long} nonce
             * @memberof gossip.DataUpdate
             * @instance
             */
            DataUpdate.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * DataUpdate data.
             * @member {Array.<gossip.IEnvelope>} data
             * @memberof gossip.DataUpdate
             * @instance
             */
            DataUpdate.prototype.data = $util.emptyArray;
    
            /**
             * DataUpdate msg_type.
             * @member {gossip.PullMsgType} msg_type
             * @memberof gossip.DataUpdate
             * @instance
             */
            DataUpdate.prototype.msg_type = 0;
    
            /**
             * Creates a new DataUpdate instance using the specified properties.
             * @function create
             * @memberof gossip.DataUpdate
             * @static
             * @param {gossip.IDataUpdate=} [properties] Properties to set
             * @returns {gossip.DataUpdate} DataUpdate instance
             */
            DataUpdate.create = function create(properties) {
                return new DataUpdate(properties);
            };
    
            /**
             * Encodes the specified DataUpdate message. Does not implicitly {@link gossip.DataUpdate.verify|verify} messages.
             * @function encode
             * @memberof gossip.DataUpdate
             * @static
             * @param {gossip.IDataUpdate} message DataUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        $root.gossip.Envelope.encode(message.data[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msg_type);
                return writer;
            };
    
            /**
             * Encodes the specified DataUpdate message, length delimited. Does not implicitly {@link gossip.DataUpdate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.DataUpdate
             * @static
             * @param {gossip.IDataUpdate} message DataUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataUpdate message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.DataUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.DataUpdate} DataUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.DataUpdate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        message.data.push($root.gossip.Envelope.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.msg_type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataUpdate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.DataUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.DataUpdate} DataUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataUpdate message.
             * @function verify
             * @memberof gossip.DataUpdate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i) {
                        var error = $root.gossip.Envelope.verify(message.data[i]);
                        if (error)
                            return "data." + error;
                    }
                }
                if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                    switch (message.msg_type) {
                    default:
                        return "msg_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a DataUpdate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.DataUpdate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.DataUpdate} DataUpdate
             */
            DataUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.DataUpdate)
                    return object;
                var message = new $root.gossip.DataUpdate();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".gossip.DataUpdate.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i) {
                        if (typeof object.data[i] !== "object")
                            throw TypeError(".gossip.DataUpdate.data: object expected");
                        message.data[i] = $root.gossip.Envelope.fromObject(object.data[i]);
                    }
                }
                switch (object.msg_type) {
                case "UNDEFINED":
                case 0:
                    message.msg_type = 0;
                    break;
                case "BLOCK_MSG":
                case 1:
                    message.msg_type = 1;
                    break;
                case "IDENTITY_MSG":
                case 2:
                    message.msg_type = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataUpdate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.DataUpdate
             * @static
             * @param {gossip.DataUpdate} message DataUpdate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.msg_type = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = $root.gossip.Envelope.toObject(message.data[j], options);
                }
                if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                    object.msg_type = options.enums === String ? $root.gossip.PullMsgType[message.msg_type] : message.msg_type;
                return object;
            };
    
            /**
             * Converts this DataUpdate to JSON.
             * @function toJSON
             * @memberof gossip.DataUpdate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataUpdate;
        })();
    
        gossip.DataDigest = (function() {
    
            /**
             * Properties of a DataDigest.
             * @memberof gossip
             * @interface IDataDigest
             * @property {number|Long|null} [nonce] DataDigest nonce
             * @property {Array.<Uint8Array>|null} [digests] DataDigest digests
             * @property {gossip.PullMsgType|null} [msg_type] DataDigest msg_type
             */
    
            /**
             * Constructs a new DataDigest.
             * @memberof gossip
             * @classdesc Represents a DataDigest.
             * @implements IDataDigest
             * @constructor
             * @param {gossip.IDataDigest=} [properties] Properties to set
             */
            function DataDigest(properties) {
                this.digests = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataDigest nonce.
             * @member {number|Long} nonce
             * @memberof gossip.DataDigest
             * @instance
             */
            DataDigest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * DataDigest digests.
             * @member {Array.<Uint8Array>} digests
             * @memberof gossip.DataDigest
             * @instance
             */
            DataDigest.prototype.digests = $util.emptyArray;
    
            /**
             * DataDigest msg_type.
             * @member {gossip.PullMsgType} msg_type
             * @memberof gossip.DataDigest
             * @instance
             */
            DataDigest.prototype.msg_type = 0;
    
            /**
             * Creates a new DataDigest instance using the specified properties.
             * @function create
             * @memberof gossip.DataDigest
             * @static
             * @param {gossip.IDataDigest=} [properties] Properties to set
             * @returns {gossip.DataDigest} DataDigest instance
             */
            DataDigest.create = function create(properties) {
                return new DataDigest(properties);
            };
    
            /**
             * Encodes the specified DataDigest message. Does not implicitly {@link gossip.DataDigest.verify|verify} messages.
             * @function encode
             * @memberof gossip.DataDigest
             * @static
             * @param {gossip.IDataDigest} message DataDigest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataDigest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.digests != null && message.digests.length)
                    for (var i = 0; i < message.digests.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.digests[i]);
                if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msg_type);
                return writer;
            };
    
            /**
             * Encodes the specified DataDigest message, length delimited. Does not implicitly {@link gossip.DataDigest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.DataDigest
             * @static
             * @param {gossip.IDataDigest} message DataDigest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataDigest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataDigest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.DataDigest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.DataDigest} DataDigest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataDigest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.DataDigest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        if (!(message.digests && message.digests.length))
                            message.digests = [];
                        message.digests.push(reader.bytes());
                        break;
                    case 3:
                        message.msg_type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataDigest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.DataDigest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.DataDigest} DataDigest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataDigest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataDigest message.
             * @function verify
             * @memberof gossip.DataDigest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataDigest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.digests != null && message.hasOwnProperty("digests")) {
                    if (!Array.isArray(message.digests))
                        return "digests: array expected";
                    for (var i = 0; i < message.digests.length; ++i)
                        if (!(message.digests[i] && typeof message.digests[i].length === "number" || $util.isString(message.digests[i])))
                            return "digests: buffer[] expected";
                }
                if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                    switch (message.msg_type) {
                    default:
                        return "msg_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a DataDigest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.DataDigest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.DataDigest} DataDigest
             */
            DataDigest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.DataDigest)
                    return object;
                var message = new $root.gossip.DataDigest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.digests) {
                    if (!Array.isArray(object.digests))
                        throw TypeError(".gossip.DataDigest.digests: array expected");
                    message.digests = [];
                    for (var i = 0; i < object.digests.length; ++i)
                        if (typeof object.digests[i] === "string")
                            $util.base64.decode(object.digests[i], message.digests[i] = $util.newBuffer($util.base64.length(object.digests[i])), 0);
                        else if (object.digests[i].length)
                            message.digests[i] = object.digests[i];
                }
                switch (object.msg_type) {
                case "UNDEFINED":
                case 0:
                    message.msg_type = 0;
                    break;
                case "BLOCK_MSG":
                case 1:
                    message.msg_type = 1;
                    break;
                case "IDENTITY_MSG":
                case 2:
                    message.msg_type = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataDigest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.DataDigest
             * @static
             * @param {gossip.DataDigest} message DataDigest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataDigest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.digests = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.msg_type = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.digests && message.digests.length) {
                    object.digests = [];
                    for (var j = 0; j < message.digests.length; ++j)
                        object.digests[j] = options.bytes === String ? $util.base64.encode(message.digests[j], 0, message.digests[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.digests[j]) : message.digests[j];
                }
                if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                    object.msg_type = options.enums === String ? $root.gossip.PullMsgType[message.msg_type] : message.msg_type;
                return object;
            };
    
            /**
             * Converts this DataDigest to JSON.
             * @function toJSON
             * @memberof gossip.DataDigest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataDigest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataDigest;
        })();
    
        gossip.DataMessage = (function() {
    
            /**
             * Properties of a DataMessage.
             * @memberof gossip
             * @interface IDataMessage
             * @property {gossip.IPayload|null} [payload] DataMessage payload
             */
    
            /**
             * Constructs a new DataMessage.
             * @memberof gossip
             * @classdesc Represents a DataMessage.
             * @implements IDataMessage
             * @constructor
             * @param {gossip.IDataMessage=} [properties] Properties to set
             */
            function DataMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataMessage payload.
             * @member {gossip.IPayload|null|undefined} payload
             * @memberof gossip.DataMessage
             * @instance
             */
            DataMessage.prototype.payload = null;
    
            /**
             * Creates a new DataMessage instance using the specified properties.
             * @function create
             * @memberof gossip.DataMessage
             * @static
             * @param {gossip.IDataMessage=} [properties] Properties to set
             * @returns {gossip.DataMessage} DataMessage instance
             */
            DataMessage.create = function create(properties) {
                return new DataMessage(properties);
            };
    
            /**
             * Encodes the specified DataMessage message. Does not implicitly {@link gossip.DataMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.DataMessage
             * @static
             * @param {gossip.IDataMessage} message DataMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    $root.gossip.Payload.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DataMessage message, length delimited. Does not implicitly {@link gossip.DataMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.DataMessage
             * @static
             * @param {gossip.IDataMessage} message DataMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.DataMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.DataMessage} DataMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.DataMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = $root.gossip.Payload.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.DataMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.DataMessage} DataMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataMessage message.
             * @function verify
             * @memberof gossip.DataMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    var error = $root.gossip.Payload.verify(message.payload);
                    if (error)
                        return "payload." + error;
                }
                return null;
            };
    
            /**
             * Creates a DataMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.DataMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.DataMessage} DataMessage
             */
            DataMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.DataMessage)
                    return object;
                var message = new $root.gossip.DataMessage();
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".gossip.DataMessage.payload: object expected");
                    message.payload = $root.gossip.Payload.fromObject(object.payload);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.DataMessage
             * @static
             * @param {gossip.DataMessage} message DataMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.payload = null;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = $root.gossip.Payload.toObject(message.payload, options);
                return object;
            };
    
            /**
             * Converts this DataMessage to JSON.
             * @function toJSON
             * @memberof gossip.DataMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataMessage;
        })();
    
        gossip.PrivateDataMessage = (function() {
    
            /**
             * Properties of a PrivateDataMessage.
             * @memberof gossip
             * @interface IPrivateDataMessage
             * @property {gossip.IPrivatePayload|null} [payload] PrivateDataMessage payload
             */
    
            /**
             * Constructs a new PrivateDataMessage.
             * @memberof gossip
             * @classdesc Represents a PrivateDataMessage.
             * @implements IPrivateDataMessage
             * @constructor
             * @param {gossip.IPrivateDataMessage=} [properties] Properties to set
             */
            function PrivateDataMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PrivateDataMessage payload.
             * @member {gossip.IPrivatePayload|null|undefined} payload
             * @memberof gossip.PrivateDataMessage
             * @instance
             */
            PrivateDataMessage.prototype.payload = null;
    
            /**
             * Creates a new PrivateDataMessage instance using the specified properties.
             * @function create
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {gossip.IPrivateDataMessage=} [properties] Properties to set
             * @returns {gossip.PrivateDataMessage} PrivateDataMessage instance
             */
            PrivateDataMessage.create = function create(properties) {
                return new PrivateDataMessage(properties);
            };
    
            /**
             * Encodes the specified PrivateDataMessage message. Does not implicitly {@link gossip.PrivateDataMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {gossip.IPrivateDataMessage} message PrivateDataMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivateDataMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    $root.gossip.PrivatePayload.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PrivateDataMessage message, length delimited. Does not implicitly {@link gossip.PrivateDataMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {gossip.IPrivateDataMessage} message PrivateDataMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivateDataMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PrivateDataMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PrivateDataMessage} PrivateDataMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivateDataMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PrivateDataMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = $root.gossip.PrivatePayload.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PrivateDataMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PrivateDataMessage} PrivateDataMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivateDataMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PrivateDataMessage message.
             * @function verify
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrivateDataMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    var error = $root.gossip.PrivatePayload.verify(message.payload);
                    if (error)
                        return "payload." + error;
                }
                return null;
            };
    
            /**
             * Creates a PrivateDataMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PrivateDataMessage} PrivateDataMessage
             */
            PrivateDataMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PrivateDataMessage)
                    return object;
                var message = new $root.gossip.PrivateDataMessage();
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".gossip.PrivateDataMessage.payload: object expected");
                    message.payload = $root.gossip.PrivatePayload.fromObject(object.payload);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PrivateDataMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {gossip.PrivateDataMessage} message PrivateDataMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrivateDataMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.payload = null;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = $root.gossip.PrivatePayload.toObject(message.payload, options);
                return object;
            };
    
            /**
             * Converts this PrivateDataMessage to JSON.
             * @function toJSON
             * @memberof gossip.PrivateDataMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrivateDataMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PrivateDataMessage;
        })();
    
        gossip.Payload = (function() {
    
            /**
             * Properties of a Payload.
             * @memberof gossip
             * @interface IPayload
             * @property {number|Long|null} [seq_num] Payload seq_num
             * @property {Uint8Array|null} [data] Payload data
             * @property {Array.<Uint8Array>|null} [private_data] Payload private_data
             */
    
            /**
             * Constructs a new Payload.
             * @memberof gossip
             * @classdesc Represents a Payload.
             * @implements IPayload
             * @constructor
             * @param {gossip.IPayload=} [properties] Properties to set
             */
            function Payload(properties) {
                this.private_data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Payload seq_num.
             * @member {number|Long} seq_num
             * @memberof gossip.Payload
             * @instance
             */
            Payload.prototype.seq_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Payload data.
             * @member {Uint8Array} data
             * @memberof gossip.Payload
             * @instance
             */
            Payload.prototype.data = $util.newBuffer([]);
    
            /**
             * Payload private_data.
             * @member {Array.<Uint8Array>} private_data
             * @memberof gossip.Payload
             * @instance
             */
            Payload.prototype.private_data = $util.emptyArray;
    
            /**
             * Creates a new Payload instance using the specified properties.
             * @function create
             * @memberof gossip.Payload
             * @static
             * @param {gossip.IPayload=} [properties] Properties to set
             * @returns {gossip.Payload} Payload instance
             */
            Payload.create = function create(properties) {
                return new Payload(properties);
            };
    
            /**
             * Encodes the specified Payload message. Does not implicitly {@link gossip.Payload.verify|verify} messages.
             * @function encode
             * @memberof gossip.Payload
             * @static
             * @param {gossip.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seq_num != null && Object.hasOwnProperty.call(message, "seq_num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.seq_num);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                if (message.private_data != null && message.private_data.length)
                    for (var i = 0; i < message.private_data.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.private_data[i]);
                return writer;
            };
    
            /**
             * Encodes the specified Payload message, length delimited. Does not implicitly {@link gossip.Payload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Payload
             * @static
             * @param {gossip.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Payload message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Payload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seq_num = reader.uint64();
                        break;
                    case 2:
                        message.data = reader.bytes();
                        break;
                    case 3:
                        if (!(message.private_data && message.private_data.length))
                            message.private_data = [];
                        message.private_data.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Payload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Payload message.
             * @function verify
             * @memberof gossip.Payload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Payload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seq_num != null && message.hasOwnProperty("seq_num"))
                    if (!$util.isInteger(message.seq_num) && !(message.seq_num && $util.isInteger(message.seq_num.low) && $util.isInteger(message.seq_num.high)))
                        return "seq_num: integer|Long expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.private_data != null && message.hasOwnProperty("private_data")) {
                    if (!Array.isArray(message.private_data))
                        return "private_data: array expected";
                    for (var i = 0; i < message.private_data.length; ++i)
                        if (!(message.private_data[i] && typeof message.private_data[i].length === "number" || $util.isString(message.private_data[i])))
                            return "private_data: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a Payload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Payload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Payload} Payload
             */
            Payload.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Payload)
                    return object;
                var message = new $root.gossip.Payload();
                if (object.seq_num != null)
                    if ($util.Long)
                        (message.seq_num = $util.Long.fromValue(object.seq_num)).unsigned = true;
                    else if (typeof object.seq_num === "string")
                        message.seq_num = parseInt(object.seq_num, 10);
                    else if (typeof object.seq_num === "number")
                        message.seq_num = object.seq_num;
                    else if (typeof object.seq_num === "object")
                        message.seq_num = new $util.LongBits(object.seq_num.low >>> 0, object.seq_num.high >>> 0).toNumber(true);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.private_data) {
                    if (!Array.isArray(object.private_data))
                        throw TypeError(".gossip.Payload.private_data: array expected");
                    message.private_data = [];
                    for (var i = 0; i < object.private_data.length; ++i)
                        if (typeof object.private_data[i] === "string")
                            $util.base64.decode(object.private_data[i], message.private_data[i] = $util.newBuffer($util.base64.length(object.private_data[i])), 0);
                        else if (object.private_data[i].length)
                            message.private_data[i] = object.private_data[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Payload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Payload
             * @static
             * @param {gossip.Payload} message Payload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Payload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.private_data = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.seq_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seq_num = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.seq_num != null && message.hasOwnProperty("seq_num"))
                    if (typeof message.seq_num === "number")
                        object.seq_num = options.longs === String ? String(message.seq_num) : message.seq_num;
                    else
                        object.seq_num = options.longs === String ? $util.Long.prototype.toString.call(message.seq_num) : options.longs === Number ? new $util.LongBits(message.seq_num.low >>> 0, message.seq_num.high >>> 0).toNumber(true) : message.seq_num;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.private_data && message.private_data.length) {
                    object.private_data = [];
                    for (var j = 0; j < message.private_data.length; ++j)
                        object.private_data[j] = options.bytes === String ? $util.base64.encode(message.private_data[j], 0, message.private_data[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.private_data[j]) : message.private_data[j];
                }
                return object;
            };
    
            /**
             * Converts this Payload to JSON.
             * @function toJSON
             * @memberof gossip.Payload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Payload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Payload;
        })();
    
        gossip.PrivatePayload = (function() {
    
            /**
             * Properties of a PrivatePayload.
             * @memberof gossip
             * @interface IPrivatePayload
             * @property {string|null} [collection_name] PrivatePayload collection_name
             * @property {string|null} [namespace] PrivatePayload namespace
             * @property {string|null} [tx_id] PrivatePayload tx_id
             * @property {Uint8Array|null} [private_rwset] PrivatePayload private_rwset
             * @property {number|Long|null} [private_sim_height] PrivatePayload private_sim_height
             * @property {protos.ICollectionConfigPackage|null} [collection_configs] PrivatePayload collection_configs
             */
    
            /**
             * Constructs a new PrivatePayload.
             * @memberof gossip
             * @classdesc Represents a PrivatePayload.
             * @implements IPrivatePayload
             * @constructor
             * @param {gossip.IPrivatePayload=} [properties] Properties to set
             */
            function PrivatePayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PrivatePayload collection_name.
             * @member {string} collection_name
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.collection_name = "";
    
            /**
             * PrivatePayload namespace.
             * @member {string} namespace
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.namespace = "";
    
            /**
             * PrivatePayload tx_id.
             * @member {string} tx_id
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.tx_id = "";
    
            /**
             * PrivatePayload private_rwset.
             * @member {Uint8Array} private_rwset
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.private_rwset = $util.newBuffer([]);
    
            /**
             * PrivatePayload private_sim_height.
             * @member {number|Long} private_sim_height
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.private_sim_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PrivatePayload collection_configs.
             * @member {protos.ICollectionConfigPackage|null|undefined} collection_configs
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.collection_configs = null;
    
            /**
             * Creates a new PrivatePayload instance using the specified properties.
             * @function create
             * @memberof gossip.PrivatePayload
             * @static
             * @param {gossip.IPrivatePayload=} [properties] Properties to set
             * @returns {gossip.PrivatePayload} PrivatePayload instance
             */
            PrivatePayload.create = function create(properties) {
                return new PrivatePayload(properties);
            };
    
            /**
             * Encodes the specified PrivatePayload message. Does not implicitly {@link gossip.PrivatePayload.verify|verify} messages.
             * @function encode
             * @memberof gossip.PrivatePayload
             * @static
             * @param {gossip.IPrivatePayload} message PrivatePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivatePayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection_name != null && Object.hasOwnProperty.call(message, "collection_name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection_name);
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.namespace);
                if (message.tx_id != null && Object.hasOwnProperty.call(message, "tx_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tx_id);
                if (message.private_rwset != null && Object.hasOwnProperty.call(message, "private_rwset"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.private_rwset);
                if (message.private_sim_height != null && Object.hasOwnProperty.call(message, "private_sim_height"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.private_sim_height);
                if (message.collection_configs != null && Object.hasOwnProperty.call(message, "collection_configs"))
                    $root.protos.CollectionConfigPackage.encode(message.collection_configs, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PrivatePayload message, length delimited. Does not implicitly {@link gossip.PrivatePayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PrivatePayload
             * @static
             * @param {gossip.IPrivatePayload} message PrivatePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivatePayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PrivatePayload message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PrivatePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PrivatePayload} PrivatePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivatePayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PrivatePayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection_name = reader.string();
                        break;
                    case 2:
                        message.namespace = reader.string();
                        break;
                    case 3:
                        message.tx_id = reader.string();
                        break;
                    case 4:
                        message.private_rwset = reader.bytes();
                        break;
                    case 5:
                        message.private_sim_height = reader.uint64();
                        break;
                    case 6:
                        message.collection_configs = $root.protos.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PrivatePayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PrivatePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PrivatePayload} PrivatePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivatePayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PrivatePayload message.
             * @function verify
             * @memberof gossip.PrivatePayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrivatePayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    if (!$util.isString(message.collection_name))
                        return "collection_name: string expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    if (!$util.isString(message.tx_id))
                        return "tx_id: string expected";
                if (message.private_rwset != null && message.hasOwnProperty("private_rwset"))
                    if (!(message.private_rwset && typeof message.private_rwset.length === "number" || $util.isString(message.private_rwset)))
                        return "private_rwset: buffer expected";
                if (message.private_sim_height != null && message.hasOwnProperty("private_sim_height"))
                    if (!$util.isInteger(message.private_sim_height) && !(message.private_sim_height && $util.isInteger(message.private_sim_height.low) && $util.isInteger(message.private_sim_height.high)))
                        return "private_sim_height: integer|Long expected";
                if (message.collection_configs != null && message.hasOwnProperty("collection_configs")) {
                    var error = $root.protos.CollectionConfigPackage.verify(message.collection_configs);
                    if (error)
                        return "collection_configs." + error;
                }
                return null;
            };
    
            /**
             * Creates a PrivatePayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PrivatePayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PrivatePayload} PrivatePayload
             */
            PrivatePayload.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PrivatePayload)
                    return object;
                var message = new $root.gossip.PrivatePayload();
                if (object.collection_name != null)
                    message.collection_name = String(object.collection_name);
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.tx_id != null)
                    message.tx_id = String(object.tx_id);
                if (object.private_rwset != null)
                    if (typeof object.private_rwset === "string")
                        $util.base64.decode(object.private_rwset, message.private_rwset = $util.newBuffer($util.base64.length(object.private_rwset)), 0);
                    else if (object.private_rwset.length)
                        message.private_rwset = object.private_rwset;
                if (object.private_sim_height != null)
                    if ($util.Long)
                        (message.private_sim_height = $util.Long.fromValue(object.private_sim_height)).unsigned = true;
                    else if (typeof object.private_sim_height === "string")
                        message.private_sim_height = parseInt(object.private_sim_height, 10);
                    else if (typeof object.private_sim_height === "number")
                        message.private_sim_height = object.private_sim_height;
                    else if (typeof object.private_sim_height === "object")
                        message.private_sim_height = new $util.LongBits(object.private_sim_height.low >>> 0, object.private_sim_height.high >>> 0).toNumber(true);
                if (object.collection_configs != null) {
                    if (typeof object.collection_configs !== "object")
                        throw TypeError(".gossip.PrivatePayload.collection_configs: object expected");
                    message.collection_configs = $root.protos.CollectionConfigPackage.fromObject(object.collection_configs);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PrivatePayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PrivatePayload
             * @static
             * @param {gossip.PrivatePayload} message PrivatePayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrivatePayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection_name = "";
                    object.namespace = "";
                    object.tx_id = "";
                    if (options.bytes === String)
                        object.private_rwset = "";
                    else {
                        object.private_rwset = [];
                        if (options.bytes !== Array)
                            object.private_rwset = $util.newBuffer(object.private_rwset);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.private_sim_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.private_sim_height = options.longs === String ? "0" : 0;
                    object.collection_configs = null;
                }
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    object.collection_name = message.collection_name;
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    object.tx_id = message.tx_id;
                if (message.private_rwset != null && message.hasOwnProperty("private_rwset"))
                    object.private_rwset = options.bytes === String ? $util.base64.encode(message.private_rwset, 0, message.private_rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.private_rwset) : message.private_rwset;
                if (message.private_sim_height != null && message.hasOwnProperty("private_sim_height"))
                    if (typeof message.private_sim_height === "number")
                        object.private_sim_height = options.longs === String ? String(message.private_sim_height) : message.private_sim_height;
                    else
                        object.private_sim_height = options.longs === String ? $util.Long.prototype.toString.call(message.private_sim_height) : options.longs === Number ? new $util.LongBits(message.private_sim_height.low >>> 0, message.private_sim_height.high >>> 0).toNumber(true) : message.private_sim_height;
                if (message.collection_configs != null && message.hasOwnProperty("collection_configs"))
                    object.collection_configs = $root.protos.CollectionConfigPackage.toObject(message.collection_configs, options);
                return object;
            };
    
            /**
             * Converts this PrivatePayload to JSON.
             * @function toJSON
             * @memberof gossip.PrivatePayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrivatePayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PrivatePayload;
        })();
    
        gossip.AliveMessage = (function() {
    
            /**
             * Properties of an AliveMessage.
             * @memberof gossip
             * @interface IAliveMessage
             * @property {gossip.IMember|null} [membership] AliveMessage membership
             * @property {gossip.IPeerTime|null} [timestamp] AliveMessage timestamp
             * @property {Uint8Array|null} [identity] AliveMessage identity
             */
    
            /**
             * Constructs a new AliveMessage.
             * @memberof gossip
             * @classdesc Represents an AliveMessage.
             * @implements IAliveMessage
             * @constructor
             * @param {gossip.IAliveMessage=} [properties] Properties to set
             */
            function AliveMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AliveMessage membership.
             * @member {gossip.IMember|null|undefined} membership
             * @memberof gossip.AliveMessage
             * @instance
             */
            AliveMessage.prototype.membership = null;
    
            /**
             * AliveMessage timestamp.
             * @member {gossip.IPeerTime|null|undefined} timestamp
             * @memberof gossip.AliveMessage
             * @instance
             */
            AliveMessage.prototype.timestamp = null;
    
            /**
             * AliveMessage identity.
             * @member {Uint8Array} identity
             * @memberof gossip.AliveMessage
             * @instance
             */
            AliveMessage.prototype.identity = $util.newBuffer([]);
    
            /**
             * Creates a new AliveMessage instance using the specified properties.
             * @function create
             * @memberof gossip.AliveMessage
             * @static
             * @param {gossip.IAliveMessage=} [properties] Properties to set
             * @returns {gossip.AliveMessage} AliveMessage instance
             */
            AliveMessage.create = function create(properties) {
                return new AliveMessage(properties);
            };
    
            /**
             * Encodes the specified AliveMessage message. Does not implicitly {@link gossip.AliveMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.AliveMessage
             * @static
             * @param {gossip.IAliveMessage} message AliveMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AliveMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.membership != null && Object.hasOwnProperty.call(message, "membership"))
                    $root.gossip.Member.encode(message.membership, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.gossip.PeerTime.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identity != null && Object.hasOwnProperty.call(message, "identity"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.identity);
                return writer;
            };
    
            /**
             * Encodes the specified AliveMessage message, length delimited. Does not implicitly {@link gossip.AliveMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.AliveMessage
             * @static
             * @param {gossip.IAliveMessage} message AliveMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AliveMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AliveMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.AliveMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.AliveMessage} AliveMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AliveMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.AliveMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.membership = $root.gossip.Member.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.timestamp = $root.gossip.PeerTime.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.identity = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AliveMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.AliveMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.AliveMessage} AliveMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AliveMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AliveMessage message.
             * @function verify
             * @memberof gossip.AliveMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AliveMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.membership != null && message.hasOwnProperty("membership")) {
                    var error = $root.gossip.Member.verify(message.membership);
                    if (error)
                        return "membership." + error;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.gossip.PeerTime.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.identity != null && message.hasOwnProperty("identity"))
                    if (!(message.identity && typeof message.identity.length === "number" || $util.isString(message.identity)))
                        return "identity: buffer expected";
                return null;
            };
    
            /**
             * Creates an AliveMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.AliveMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.AliveMessage} AliveMessage
             */
            AliveMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.AliveMessage)
                    return object;
                var message = new $root.gossip.AliveMessage();
                if (object.membership != null) {
                    if (typeof object.membership !== "object")
                        throw TypeError(".gossip.AliveMessage.membership: object expected");
                    message.membership = $root.gossip.Member.fromObject(object.membership);
                }
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".gossip.AliveMessage.timestamp: object expected");
                    message.timestamp = $root.gossip.PeerTime.fromObject(object.timestamp);
                }
                if (object.identity != null)
                    if (typeof object.identity === "string")
                        $util.base64.decode(object.identity, message.identity = $util.newBuffer($util.base64.length(object.identity)), 0);
                    else if (object.identity.length)
                        message.identity = object.identity;
                return message;
            };
    
            /**
             * Creates a plain object from an AliveMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.AliveMessage
             * @static
             * @param {gossip.AliveMessage} message AliveMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AliveMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.membership = null;
                    object.timestamp = null;
                    if (options.bytes === String)
                        object.identity = "";
                    else {
                        object.identity = [];
                        if (options.bytes !== Array)
                            object.identity = $util.newBuffer(object.identity);
                    }
                }
                if (message.membership != null && message.hasOwnProperty("membership"))
                    object.membership = $root.gossip.Member.toObject(message.membership, options);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.gossip.PeerTime.toObject(message.timestamp, options);
                if (message.identity != null && message.hasOwnProperty("identity"))
                    object.identity = options.bytes === String ? $util.base64.encode(message.identity, 0, message.identity.length) : options.bytes === Array ? Array.prototype.slice.call(message.identity) : message.identity;
                return object;
            };
    
            /**
             * Converts this AliveMessage to JSON.
             * @function toJSON
             * @memberof gossip.AliveMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AliveMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AliveMessage;
        })();
    
        gossip.LeadershipMessage = (function() {
    
            /**
             * Properties of a LeadershipMessage.
             * @memberof gossip
             * @interface ILeadershipMessage
             * @property {Uint8Array|null} [pki_id] LeadershipMessage pki_id
             * @property {gossip.IPeerTime|null} [timestamp] LeadershipMessage timestamp
             * @property {boolean|null} [is_declaration] LeadershipMessage is_declaration
             */
    
            /**
             * Constructs a new LeadershipMessage.
             * @memberof gossip
             * @classdesc Represents a LeadershipMessage.
             * @implements ILeadershipMessage
             * @constructor
             * @param {gossip.ILeadershipMessage=} [properties] Properties to set
             */
            function LeadershipMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LeadershipMessage pki_id.
             * @member {Uint8Array} pki_id
             * @memberof gossip.LeadershipMessage
             * @instance
             */
            LeadershipMessage.prototype.pki_id = $util.newBuffer([]);
    
            /**
             * LeadershipMessage timestamp.
             * @member {gossip.IPeerTime|null|undefined} timestamp
             * @memberof gossip.LeadershipMessage
             * @instance
             */
            LeadershipMessage.prototype.timestamp = null;
    
            /**
             * LeadershipMessage is_declaration.
             * @member {boolean} is_declaration
             * @memberof gossip.LeadershipMessage
             * @instance
             */
            LeadershipMessage.prototype.is_declaration = false;
    
            /**
             * Creates a new LeadershipMessage instance using the specified properties.
             * @function create
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {gossip.ILeadershipMessage=} [properties] Properties to set
             * @returns {gossip.LeadershipMessage} LeadershipMessage instance
             */
            LeadershipMessage.create = function create(properties) {
                return new LeadershipMessage(properties);
            };
    
            /**
             * Encodes the specified LeadershipMessage message. Does not implicitly {@link gossip.LeadershipMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {gossip.ILeadershipMessage} message LeadershipMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeadershipMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pki_id != null && Object.hasOwnProperty.call(message, "pki_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pki_id);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.gossip.PeerTime.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.is_declaration != null && Object.hasOwnProperty.call(message, "is_declaration"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_declaration);
                return writer;
            };
    
            /**
             * Encodes the specified LeadershipMessage message, length delimited. Does not implicitly {@link gossip.LeadershipMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {gossip.ILeadershipMessage} message LeadershipMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeadershipMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LeadershipMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.LeadershipMessage} LeadershipMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeadershipMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.LeadershipMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pki_id = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = $root.gossip.PeerTime.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.is_declaration = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LeadershipMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.LeadershipMessage} LeadershipMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeadershipMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LeadershipMessage message.
             * @function verify
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeadershipMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    if (!(message.pki_id && typeof message.pki_id.length === "number" || $util.isString(message.pki_id)))
                        return "pki_id: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.gossip.PeerTime.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.is_declaration != null && message.hasOwnProperty("is_declaration"))
                    if (typeof message.is_declaration !== "boolean")
                        return "is_declaration: boolean expected";
                return null;
            };
    
            /**
             * Creates a LeadershipMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.LeadershipMessage} LeadershipMessage
             */
            LeadershipMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.LeadershipMessage)
                    return object;
                var message = new $root.gossip.LeadershipMessage();
                if (object.pki_id != null)
                    if (typeof object.pki_id === "string")
                        $util.base64.decode(object.pki_id, message.pki_id = $util.newBuffer($util.base64.length(object.pki_id)), 0);
                    else if (object.pki_id.length)
                        message.pki_id = object.pki_id;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".gossip.LeadershipMessage.timestamp: object expected");
                    message.timestamp = $root.gossip.PeerTime.fromObject(object.timestamp);
                }
                if (object.is_declaration != null)
                    message.is_declaration = Boolean(object.is_declaration);
                return message;
            };
    
            /**
             * Creates a plain object from a LeadershipMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {gossip.LeadershipMessage} message LeadershipMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeadershipMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.pki_id = "";
                    else {
                        object.pki_id = [];
                        if (options.bytes !== Array)
                            object.pki_id = $util.newBuffer(object.pki_id);
                    }
                    object.timestamp = null;
                    object.is_declaration = false;
                }
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    object.pki_id = options.bytes === String ? $util.base64.encode(message.pki_id, 0, message.pki_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.pki_id) : message.pki_id;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.gossip.PeerTime.toObject(message.timestamp, options);
                if (message.is_declaration != null && message.hasOwnProperty("is_declaration"))
                    object.is_declaration = message.is_declaration;
                return object;
            };
    
            /**
             * Converts this LeadershipMessage to JSON.
             * @function toJSON
             * @memberof gossip.LeadershipMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeadershipMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LeadershipMessage;
        })();
    
        gossip.PeerTime = (function() {
    
            /**
             * Properties of a PeerTime.
             * @memberof gossip
             * @interface IPeerTime
             * @property {number|Long|null} [inc_num] PeerTime inc_num
             * @property {number|Long|null} [seq_num] PeerTime seq_num
             */
    
            /**
             * Constructs a new PeerTime.
             * @memberof gossip
             * @classdesc Represents a PeerTime.
             * @implements IPeerTime
             * @constructor
             * @param {gossip.IPeerTime=} [properties] Properties to set
             */
            function PeerTime(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerTime inc_num.
             * @member {number|Long} inc_num
             * @memberof gossip.PeerTime
             * @instance
             */
            PeerTime.prototype.inc_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PeerTime seq_num.
             * @member {number|Long} seq_num
             * @memberof gossip.PeerTime
             * @instance
             */
            PeerTime.prototype.seq_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new PeerTime instance using the specified properties.
             * @function create
             * @memberof gossip.PeerTime
             * @static
             * @param {gossip.IPeerTime=} [properties] Properties to set
             * @returns {gossip.PeerTime} PeerTime instance
             */
            PeerTime.create = function create(properties) {
                return new PeerTime(properties);
            };
    
            /**
             * Encodes the specified PeerTime message. Does not implicitly {@link gossip.PeerTime.verify|verify} messages.
             * @function encode
             * @memberof gossip.PeerTime
             * @static
             * @param {gossip.IPeerTime} message PeerTime message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerTime.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inc_num != null && Object.hasOwnProperty.call(message, "inc_num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inc_num);
                if (message.seq_num != null && Object.hasOwnProperty.call(message, "seq_num"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.seq_num);
                return writer;
            };
    
            /**
             * Encodes the specified PeerTime message, length delimited. Does not implicitly {@link gossip.PeerTime.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PeerTime
             * @static
             * @param {gossip.IPeerTime} message PeerTime message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerTime.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerTime message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PeerTime
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PeerTime} PeerTime
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerTime.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PeerTime();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inc_num = reader.uint64();
                        break;
                    case 2:
                        message.seq_num = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerTime message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PeerTime
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PeerTime} PeerTime
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerTime.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerTime message.
             * @function verify
             * @memberof gossip.PeerTime
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerTime.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inc_num != null && message.hasOwnProperty("inc_num"))
                    if (!$util.isInteger(message.inc_num) && !(message.inc_num && $util.isInteger(message.inc_num.low) && $util.isInteger(message.inc_num.high)))
                        return "inc_num: integer|Long expected";
                if (message.seq_num != null && message.hasOwnProperty("seq_num"))
                    if (!$util.isInteger(message.seq_num) && !(message.seq_num && $util.isInteger(message.seq_num.low) && $util.isInteger(message.seq_num.high)))
                        return "seq_num: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a PeerTime message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PeerTime
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PeerTime} PeerTime
             */
            PeerTime.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PeerTime)
                    return object;
                var message = new $root.gossip.PeerTime();
                if (object.inc_num != null)
                    if ($util.Long)
                        (message.inc_num = $util.Long.fromValue(object.inc_num)).unsigned = true;
                    else if (typeof object.inc_num === "string")
                        message.inc_num = parseInt(object.inc_num, 10);
                    else if (typeof object.inc_num === "number")
                        message.inc_num = object.inc_num;
                    else if (typeof object.inc_num === "object")
                        message.inc_num = new $util.LongBits(object.inc_num.low >>> 0, object.inc_num.high >>> 0).toNumber(true);
                if (object.seq_num != null)
                    if ($util.Long)
                        (message.seq_num = $util.Long.fromValue(object.seq_num)).unsigned = true;
                    else if (typeof object.seq_num === "string")
                        message.seq_num = parseInt(object.seq_num, 10);
                    else if (typeof object.seq_num === "number")
                        message.seq_num = object.seq_num;
                    else if (typeof object.seq_num === "object")
                        message.seq_num = new $util.LongBits(object.seq_num.low >>> 0, object.seq_num.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a PeerTime message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PeerTime
             * @static
             * @param {gossip.PeerTime} message PeerTime
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerTime.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.inc_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inc_num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.seq_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seq_num = options.longs === String ? "0" : 0;
                }
                if (message.inc_num != null && message.hasOwnProperty("inc_num"))
                    if (typeof message.inc_num === "number")
                        object.inc_num = options.longs === String ? String(message.inc_num) : message.inc_num;
                    else
                        object.inc_num = options.longs === String ? $util.Long.prototype.toString.call(message.inc_num) : options.longs === Number ? new $util.LongBits(message.inc_num.low >>> 0, message.inc_num.high >>> 0).toNumber(true) : message.inc_num;
                if (message.seq_num != null && message.hasOwnProperty("seq_num"))
                    if (typeof message.seq_num === "number")
                        object.seq_num = options.longs === String ? String(message.seq_num) : message.seq_num;
                    else
                        object.seq_num = options.longs === String ? $util.Long.prototype.toString.call(message.seq_num) : options.longs === Number ? new $util.LongBits(message.seq_num.low >>> 0, message.seq_num.high >>> 0).toNumber(true) : message.seq_num;
                return object;
            };
    
            /**
             * Converts this PeerTime to JSON.
             * @function toJSON
             * @memberof gossip.PeerTime
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerTime.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PeerTime;
        })();
    
        gossip.MembershipRequest = (function() {
    
            /**
             * Properties of a MembershipRequest.
             * @memberof gossip
             * @interface IMembershipRequest
             * @property {gossip.IEnvelope|null} [self_information] MembershipRequest self_information
             * @property {Array.<Uint8Array>|null} [known] MembershipRequest known
             */
    
            /**
             * Constructs a new MembershipRequest.
             * @memberof gossip
             * @classdesc Represents a MembershipRequest.
             * @implements IMembershipRequest
             * @constructor
             * @param {gossip.IMembershipRequest=} [properties] Properties to set
             */
            function MembershipRequest(properties) {
                this.known = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MembershipRequest self_information.
             * @member {gossip.IEnvelope|null|undefined} self_information
             * @memberof gossip.MembershipRequest
             * @instance
             */
            MembershipRequest.prototype.self_information = null;
    
            /**
             * MembershipRequest known.
             * @member {Array.<Uint8Array>} known
             * @memberof gossip.MembershipRequest
             * @instance
             */
            MembershipRequest.prototype.known = $util.emptyArray;
    
            /**
             * Creates a new MembershipRequest instance using the specified properties.
             * @function create
             * @memberof gossip.MembershipRequest
             * @static
             * @param {gossip.IMembershipRequest=} [properties] Properties to set
             * @returns {gossip.MembershipRequest} MembershipRequest instance
             */
            MembershipRequest.create = function create(properties) {
                return new MembershipRequest(properties);
            };
    
            /**
             * Encodes the specified MembershipRequest message. Does not implicitly {@link gossip.MembershipRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.MembershipRequest
             * @static
             * @param {gossip.IMembershipRequest} message MembershipRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MembershipRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.self_information != null && Object.hasOwnProperty.call(message, "self_information"))
                    $root.gossip.Envelope.encode(message.self_information, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.known != null && message.known.length)
                    for (var i = 0; i < message.known.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.known[i]);
                return writer;
            };
    
            /**
             * Encodes the specified MembershipRequest message, length delimited. Does not implicitly {@link gossip.MembershipRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.MembershipRequest
             * @static
             * @param {gossip.IMembershipRequest} message MembershipRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MembershipRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MembershipRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.MembershipRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.MembershipRequest} MembershipRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MembershipRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.MembershipRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.self_information = $root.gossip.Envelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.known && message.known.length))
                            message.known = [];
                        message.known.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MembershipRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.MembershipRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.MembershipRequest} MembershipRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MembershipRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MembershipRequest message.
             * @function verify
             * @memberof gossip.MembershipRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MembershipRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.self_information != null && message.hasOwnProperty("self_information")) {
                    var error = $root.gossip.Envelope.verify(message.self_information);
                    if (error)
                        return "self_information." + error;
                }
                if (message.known != null && message.hasOwnProperty("known")) {
                    if (!Array.isArray(message.known))
                        return "known: array expected";
                    for (var i = 0; i < message.known.length; ++i)
                        if (!(message.known[i] && typeof message.known[i].length === "number" || $util.isString(message.known[i])))
                            return "known: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a MembershipRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.MembershipRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.MembershipRequest} MembershipRequest
             */
            MembershipRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.MembershipRequest)
                    return object;
                var message = new $root.gossip.MembershipRequest();
                if (object.self_information != null) {
                    if (typeof object.self_information !== "object")
                        throw TypeError(".gossip.MembershipRequest.self_information: object expected");
                    message.self_information = $root.gossip.Envelope.fromObject(object.self_information);
                }
                if (object.known) {
                    if (!Array.isArray(object.known))
                        throw TypeError(".gossip.MembershipRequest.known: array expected");
                    message.known = [];
                    for (var i = 0; i < object.known.length; ++i)
                        if (typeof object.known[i] === "string")
                            $util.base64.decode(object.known[i], message.known[i] = $util.newBuffer($util.base64.length(object.known[i])), 0);
                        else if (object.known[i].length)
                            message.known[i] = object.known[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MembershipRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.MembershipRequest
             * @static
             * @param {gossip.MembershipRequest} message MembershipRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MembershipRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.known = [];
                if (options.defaults)
                    object.self_information = null;
                if (message.self_information != null && message.hasOwnProperty("self_information"))
                    object.self_information = $root.gossip.Envelope.toObject(message.self_information, options);
                if (message.known && message.known.length) {
                    object.known = [];
                    for (var j = 0; j < message.known.length; ++j)
                        object.known[j] = options.bytes === String ? $util.base64.encode(message.known[j], 0, message.known[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.known[j]) : message.known[j];
                }
                return object;
            };
    
            /**
             * Converts this MembershipRequest to JSON.
             * @function toJSON
             * @memberof gossip.MembershipRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MembershipRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MembershipRequest;
        })();
    
        gossip.MembershipResponse = (function() {
    
            /**
             * Properties of a MembershipResponse.
             * @memberof gossip
             * @interface IMembershipResponse
             * @property {Array.<gossip.IEnvelope>|null} [alive] MembershipResponse alive
             * @property {Array.<gossip.IEnvelope>|null} [dead] MembershipResponse dead
             */
    
            /**
             * Constructs a new MembershipResponse.
             * @memberof gossip
             * @classdesc Represents a MembershipResponse.
             * @implements IMembershipResponse
             * @constructor
             * @param {gossip.IMembershipResponse=} [properties] Properties to set
             */
            function MembershipResponse(properties) {
                this.alive = [];
                this.dead = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MembershipResponse alive.
             * @member {Array.<gossip.IEnvelope>} alive
             * @memberof gossip.MembershipResponse
             * @instance
             */
            MembershipResponse.prototype.alive = $util.emptyArray;
    
            /**
             * MembershipResponse dead.
             * @member {Array.<gossip.IEnvelope>} dead
             * @memberof gossip.MembershipResponse
             * @instance
             */
            MembershipResponse.prototype.dead = $util.emptyArray;
    
            /**
             * Creates a new MembershipResponse instance using the specified properties.
             * @function create
             * @memberof gossip.MembershipResponse
             * @static
             * @param {gossip.IMembershipResponse=} [properties] Properties to set
             * @returns {gossip.MembershipResponse} MembershipResponse instance
             */
            MembershipResponse.create = function create(properties) {
                return new MembershipResponse(properties);
            };
    
            /**
             * Encodes the specified MembershipResponse message. Does not implicitly {@link gossip.MembershipResponse.verify|verify} messages.
             * @function encode
             * @memberof gossip.MembershipResponse
             * @static
             * @param {gossip.IMembershipResponse} message MembershipResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MembershipResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.alive != null && message.alive.length)
                    for (var i = 0; i < message.alive.length; ++i)
                        $root.gossip.Envelope.encode(message.alive[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.dead != null && message.dead.length)
                    for (var i = 0; i < message.dead.length; ++i)
                        $root.gossip.Envelope.encode(message.dead[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified MembershipResponse message, length delimited. Does not implicitly {@link gossip.MembershipResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.MembershipResponse
             * @static
             * @param {gossip.IMembershipResponse} message MembershipResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MembershipResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MembershipResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.MembershipResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.MembershipResponse} MembershipResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MembershipResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.MembershipResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.alive && message.alive.length))
                            message.alive = [];
                        message.alive.push($root.gossip.Envelope.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.dead && message.dead.length))
                            message.dead = [];
                        message.dead.push($root.gossip.Envelope.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MembershipResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.MembershipResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.MembershipResponse} MembershipResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MembershipResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MembershipResponse message.
             * @function verify
             * @memberof gossip.MembershipResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MembershipResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.alive != null && message.hasOwnProperty("alive")) {
                    if (!Array.isArray(message.alive))
                        return "alive: array expected";
                    for (var i = 0; i < message.alive.length; ++i) {
                        var error = $root.gossip.Envelope.verify(message.alive[i]);
                        if (error)
                            return "alive." + error;
                    }
                }
                if (message.dead != null && message.hasOwnProperty("dead")) {
                    if (!Array.isArray(message.dead))
                        return "dead: array expected";
                    for (var i = 0; i < message.dead.length; ++i) {
                        var error = $root.gossip.Envelope.verify(message.dead[i]);
                        if (error)
                            return "dead." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a MembershipResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.MembershipResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.MembershipResponse} MembershipResponse
             */
            MembershipResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.MembershipResponse)
                    return object;
                var message = new $root.gossip.MembershipResponse();
                if (object.alive) {
                    if (!Array.isArray(object.alive))
                        throw TypeError(".gossip.MembershipResponse.alive: array expected");
                    message.alive = [];
                    for (var i = 0; i < object.alive.length; ++i) {
                        if (typeof object.alive[i] !== "object")
                            throw TypeError(".gossip.MembershipResponse.alive: object expected");
                        message.alive[i] = $root.gossip.Envelope.fromObject(object.alive[i]);
                    }
                }
                if (object.dead) {
                    if (!Array.isArray(object.dead))
                        throw TypeError(".gossip.MembershipResponse.dead: array expected");
                    message.dead = [];
                    for (var i = 0; i < object.dead.length; ++i) {
                        if (typeof object.dead[i] !== "object")
                            throw TypeError(".gossip.MembershipResponse.dead: object expected");
                        message.dead[i] = $root.gossip.Envelope.fromObject(object.dead[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MembershipResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.MembershipResponse
             * @static
             * @param {gossip.MembershipResponse} message MembershipResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MembershipResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.alive = [];
                    object.dead = [];
                }
                if (message.alive && message.alive.length) {
                    object.alive = [];
                    for (var j = 0; j < message.alive.length; ++j)
                        object.alive[j] = $root.gossip.Envelope.toObject(message.alive[j], options);
                }
                if (message.dead && message.dead.length) {
                    object.dead = [];
                    for (var j = 0; j < message.dead.length; ++j)
                        object.dead[j] = $root.gossip.Envelope.toObject(message.dead[j], options);
                }
                return object;
            };
    
            /**
             * Converts this MembershipResponse to JSON.
             * @function toJSON
             * @memberof gossip.MembershipResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MembershipResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MembershipResponse;
        })();
    
        gossip.Member = (function() {
    
            /**
             * Properties of a Member.
             * @memberof gossip
             * @interface IMember
             * @property {string|null} [endpoint] Member endpoint
             * @property {Uint8Array|null} [metadata] Member metadata
             * @property {Uint8Array|null} [pki_id] Member pki_id
             */
    
            /**
             * Constructs a new Member.
             * @memberof gossip
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {gossip.IMember=} [properties] Properties to set
             */
            function Member(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Member endpoint.
             * @member {string} endpoint
             * @memberof gossip.Member
             * @instance
             */
            Member.prototype.endpoint = "";
    
            /**
             * Member metadata.
             * @member {Uint8Array} metadata
             * @memberof gossip.Member
             * @instance
             */
            Member.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Member pki_id.
             * @member {Uint8Array} pki_id
             * @memberof gossip.Member
             * @instance
             */
            Member.prototype.pki_id = $util.newBuffer([]);
    
            /**
             * Creates a new Member instance using the specified properties.
             * @function create
             * @memberof gossip.Member
             * @static
             * @param {gossip.IMember=} [properties] Properties to set
             * @returns {gossip.Member} Member instance
             */
            Member.create = function create(properties) {
                return new Member(properties);
            };
    
            /**
             * Encodes the specified Member message. Does not implicitly {@link gossip.Member.verify|verify} messages.
             * @function encode
             * @memberof gossip.Member
             * @static
             * @param {gossip.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endpoint != null && Object.hasOwnProperty.call(message, "endpoint"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.endpoint);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata);
                if (message.pki_id != null && Object.hasOwnProperty.call(message, "pki_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pki_id);
                return writer;
            };
    
            /**
             * Encodes the specified Member message, length delimited. Does not implicitly {@link gossip.Member.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Member
             * @static
             * @param {gossip.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Member();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endpoint = reader.string();
                        break;
                    case 2:
                        message.metadata = reader.bytes();
                        break;
                    case 3:
                        message.pki_id = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Member message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Member message.
             * @function verify
             * @memberof gossip.Member
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Member.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endpoint != null && message.hasOwnProperty("endpoint"))
                    if (!$util.isString(message.endpoint))
                        return "endpoint: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    if (!(message.pki_id && typeof message.pki_id.length === "number" || $util.isString(message.pki_id)))
                        return "pki_id: buffer expected";
                return null;
            };
    
            /**
             * Creates a Member message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Member
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Member} Member
             */
            Member.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Member)
                    return object;
                var message = new $root.gossip.Member();
                if (object.endpoint != null)
                    message.endpoint = String(object.endpoint);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                if (object.pki_id != null)
                    if (typeof object.pki_id === "string")
                        $util.base64.decode(object.pki_id, message.pki_id = $util.newBuffer($util.base64.length(object.pki_id)), 0);
                    else if (object.pki_id.length)
                        message.pki_id = object.pki_id;
                return message;
            };
    
            /**
             * Creates a plain object from a Member message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Member
             * @static
             * @param {gossip.Member} message Member
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Member.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.endpoint = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                    if (options.bytes === String)
                        object.pki_id = "";
                    else {
                        object.pki_id = [];
                        if (options.bytes !== Array)
                            object.pki_id = $util.newBuffer(object.pki_id);
                    }
                }
                if (message.endpoint != null && message.hasOwnProperty("endpoint"))
                    object.endpoint = message.endpoint;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                if (message.pki_id != null && message.hasOwnProperty("pki_id"))
                    object.pki_id = options.bytes === String ? $util.base64.encode(message.pki_id, 0, message.pki_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.pki_id) : message.pki_id;
                return object;
            };
    
            /**
             * Converts this Member to JSON.
             * @function toJSON
             * @memberof gossip.Member
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Member.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Member;
        })();
    
        gossip.Empty = (function() {
    
            /**
             * Properties of an Empty.
             * @memberof gossip
             * @interface IEmpty
             */
    
            /**
             * Constructs a new Empty.
             * @memberof gossip
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {gossip.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof gossip.Empty
             * @static
             * @param {gossip.IEmpty=} [properties] Properties to set
             * @returns {gossip.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };
    
            /**
             * Encodes the specified Empty message. Does not implicitly {@link gossip.Empty.verify|verify} messages.
             * @function encode
             * @memberof gossip.Empty
             * @static
             * @param {gossip.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link gossip.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Empty
             * @static
             * @param {gossip.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof gossip.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Empty)
                    return object;
                return new $root.gossip.Empty();
            };
    
            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Empty
             * @static
             * @param {gossip.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof gossip.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Empty;
        })();
    
        gossip.RemoteStateRequest = (function() {
    
            /**
             * Properties of a RemoteStateRequest.
             * @memberof gossip
             * @interface IRemoteStateRequest
             * @property {number|Long|null} [start_seq_num] RemoteStateRequest start_seq_num
             * @property {number|Long|null} [end_seq_num] RemoteStateRequest end_seq_num
             */
    
            /**
             * Constructs a new RemoteStateRequest.
             * @memberof gossip
             * @classdesc Represents a RemoteStateRequest.
             * @implements IRemoteStateRequest
             * @constructor
             * @param {gossip.IRemoteStateRequest=} [properties] Properties to set
             */
            function RemoteStateRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemoteStateRequest start_seq_num.
             * @member {number|Long} start_seq_num
             * @memberof gossip.RemoteStateRequest
             * @instance
             */
            RemoteStateRequest.prototype.start_seq_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * RemoteStateRequest end_seq_num.
             * @member {number|Long} end_seq_num
             * @memberof gossip.RemoteStateRequest
             * @instance
             */
            RemoteStateRequest.prototype.end_seq_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new RemoteStateRequest instance using the specified properties.
             * @function create
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {gossip.IRemoteStateRequest=} [properties] Properties to set
             * @returns {gossip.RemoteStateRequest} RemoteStateRequest instance
             */
            RemoteStateRequest.create = function create(properties) {
                return new RemoteStateRequest(properties);
            };
    
            /**
             * Encodes the specified RemoteStateRequest message. Does not implicitly {@link gossip.RemoteStateRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {gossip.IRemoteStateRequest} message RemoteStateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteStateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start_seq_num != null && Object.hasOwnProperty.call(message, "start_seq_num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.start_seq_num);
                if (message.end_seq_num != null && Object.hasOwnProperty.call(message, "end_seq_num"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.end_seq_num);
                return writer;
            };
    
            /**
             * Encodes the specified RemoteStateRequest message, length delimited. Does not implicitly {@link gossip.RemoteStateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {gossip.IRemoteStateRequest} message RemoteStateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteStateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemoteStateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.RemoteStateRequest} RemoteStateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteStateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.RemoteStateRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start_seq_num = reader.uint64();
                        break;
                    case 2:
                        message.end_seq_num = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemoteStateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.RemoteStateRequest} RemoteStateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteStateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemoteStateRequest message.
             * @function verify
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoteStateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start_seq_num != null && message.hasOwnProperty("start_seq_num"))
                    if (!$util.isInteger(message.start_seq_num) && !(message.start_seq_num && $util.isInteger(message.start_seq_num.low) && $util.isInteger(message.start_seq_num.high)))
                        return "start_seq_num: integer|Long expected";
                if (message.end_seq_num != null && message.hasOwnProperty("end_seq_num"))
                    if (!$util.isInteger(message.end_seq_num) && !(message.end_seq_num && $util.isInteger(message.end_seq_num.low) && $util.isInteger(message.end_seq_num.high)))
                        return "end_seq_num: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a RemoteStateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.RemoteStateRequest} RemoteStateRequest
             */
            RemoteStateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.RemoteStateRequest)
                    return object;
                var message = new $root.gossip.RemoteStateRequest();
                if (object.start_seq_num != null)
                    if ($util.Long)
                        (message.start_seq_num = $util.Long.fromValue(object.start_seq_num)).unsigned = true;
                    else if (typeof object.start_seq_num === "string")
                        message.start_seq_num = parseInt(object.start_seq_num, 10);
                    else if (typeof object.start_seq_num === "number")
                        message.start_seq_num = object.start_seq_num;
                    else if (typeof object.start_seq_num === "object")
                        message.start_seq_num = new $util.LongBits(object.start_seq_num.low >>> 0, object.start_seq_num.high >>> 0).toNumber(true);
                if (object.end_seq_num != null)
                    if ($util.Long)
                        (message.end_seq_num = $util.Long.fromValue(object.end_seq_num)).unsigned = true;
                    else if (typeof object.end_seq_num === "string")
                        message.end_seq_num = parseInt(object.end_seq_num, 10);
                    else if (typeof object.end_seq_num === "number")
                        message.end_seq_num = object.end_seq_num;
                    else if (typeof object.end_seq_num === "object")
                        message.end_seq_num = new $util.LongBits(object.end_seq_num.low >>> 0, object.end_seq_num.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a RemoteStateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {gossip.RemoteStateRequest} message RemoteStateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoteStateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.start_seq_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.start_seq_num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.end_seq_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.end_seq_num = options.longs === String ? "0" : 0;
                }
                if (message.start_seq_num != null && message.hasOwnProperty("start_seq_num"))
                    if (typeof message.start_seq_num === "number")
                        object.start_seq_num = options.longs === String ? String(message.start_seq_num) : message.start_seq_num;
                    else
                        object.start_seq_num = options.longs === String ? $util.Long.prototype.toString.call(message.start_seq_num) : options.longs === Number ? new $util.LongBits(message.start_seq_num.low >>> 0, message.start_seq_num.high >>> 0).toNumber(true) : message.start_seq_num;
                if (message.end_seq_num != null && message.hasOwnProperty("end_seq_num"))
                    if (typeof message.end_seq_num === "number")
                        object.end_seq_num = options.longs === String ? String(message.end_seq_num) : message.end_seq_num;
                    else
                        object.end_seq_num = options.longs === String ? $util.Long.prototype.toString.call(message.end_seq_num) : options.longs === Number ? new $util.LongBits(message.end_seq_num.low >>> 0, message.end_seq_num.high >>> 0).toNumber(true) : message.end_seq_num;
                return object;
            };
    
            /**
             * Converts this RemoteStateRequest to JSON.
             * @function toJSON
             * @memberof gossip.RemoteStateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoteStateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemoteStateRequest;
        })();
    
        gossip.RemoteStateResponse = (function() {
    
            /**
             * Properties of a RemoteStateResponse.
             * @memberof gossip
             * @interface IRemoteStateResponse
             * @property {Array.<gossip.IPayload>|null} [payloads] RemoteStateResponse payloads
             */
    
            /**
             * Constructs a new RemoteStateResponse.
             * @memberof gossip
             * @classdesc Represents a RemoteStateResponse.
             * @implements IRemoteStateResponse
             * @constructor
             * @param {gossip.IRemoteStateResponse=} [properties] Properties to set
             */
            function RemoteStateResponse(properties) {
                this.payloads = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemoteStateResponse payloads.
             * @member {Array.<gossip.IPayload>} payloads
             * @memberof gossip.RemoteStateResponse
             * @instance
             */
            RemoteStateResponse.prototype.payloads = $util.emptyArray;
    
            /**
             * Creates a new RemoteStateResponse instance using the specified properties.
             * @function create
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {gossip.IRemoteStateResponse=} [properties] Properties to set
             * @returns {gossip.RemoteStateResponse} RemoteStateResponse instance
             */
            RemoteStateResponse.create = function create(properties) {
                return new RemoteStateResponse(properties);
            };
    
            /**
             * Encodes the specified RemoteStateResponse message. Does not implicitly {@link gossip.RemoteStateResponse.verify|verify} messages.
             * @function encode
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {gossip.IRemoteStateResponse} message RemoteStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteStateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payloads != null && message.payloads.length)
                    for (var i = 0; i < message.payloads.length; ++i)
                        $root.gossip.Payload.encode(message.payloads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RemoteStateResponse message, length delimited. Does not implicitly {@link gossip.RemoteStateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {gossip.IRemoteStateResponse} message RemoteStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemoteStateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.RemoteStateResponse} RemoteStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteStateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.RemoteStateResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.payloads && message.payloads.length))
                            message.payloads = [];
                        message.payloads.push($root.gossip.Payload.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemoteStateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.RemoteStateResponse} RemoteStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteStateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemoteStateResponse message.
             * @function verify
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoteStateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payloads != null && message.hasOwnProperty("payloads")) {
                    if (!Array.isArray(message.payloads))
                        return "payloads: array expected";
                    for (var i = 0; i < message.payloads.length; ++i) {
                        var error = $root.gossip.Payload.verify(message.payloads[i]);
                        if (error)
                            return "payloads." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RemoteStateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.RemoteStateResponse} RemoteStateResponse
             */
            RemoteStateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.RemoteStateResponse)
                    return object;
                var message = new $root.gossip.RemoteStateResponse();
                if (object.payloads) {
                    if (!Array.isArray(object.payloads))
                        throw TypeError(".gossip.RemoteStateResponse.payloads: array expected");
                    message.payloads = [];
                    for (var i = 0; i < object.payloads.length; ++i) {
                        if (typeof object.payloads[i] !== "object")
                            throw TypeError(".gossip.RemoteStateResponse.payloads: object expected");
                        message.payloads[i] = $root.gossip.Payload.fromObject(object.payloads[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RemoteStateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {gossip.RemoteStateResponse} message RemoteStateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoteStateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.payloads = [];
                if (message.payloads && message.payloads.length) {
                    object.payloads = [];
                    for (var j = 0; j < message.payloads.length; ++j)
                        object.payloads[j] = $root.gossip.Payload.toObject(message.payloads[j], options);
                }
                return object;
            };
    
            /**
             * Converts this RemoteStateResponse to JSON.
             * @function toJSON
             * @memberof gossip.RemoteStateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoteStateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemoteStateResponse;
        })();
    
        gossip.RemotePvtDataRequest = (function() {
    
            /**
             * Properties of a RemotePvtDataRequest.
             * @memberof gossip
             * @interface IRemotePvtDataRequest
             * @property {Array.<gossip.IPvtDataDigest>|null} [digests] RemotePvtDataRequest digests
             */
    
            /**
             * Constructs a new RemotePvtDataRequest.
             * @memberof gossip
             * @classdesc Represents a RemotePvtDataRequest.
             * @implements IRemotePvtDataRequest
             * @constructor
             * @param {gossip.IRemotePvtDataRequest=} [properties] Properties to set
             */
            function RemotePvtDataRequest(properties) {
                this.digests = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemotePvtDataRequest digests.
             * @member {Array.<gossip.IPvtDataDigest>} digests
             * @memberof gossip.RemotePvtDataRequest
             * @instance
             */
            RemotePvtDataRequest.prototype.digests = $util.emptyArray;
    
            /**
             * Creates a new RemotePvtDataRequest instance using the specified properties.
             * @function create
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {gossip.IRemotePvtDataRequest=} [properties] Properties to set
             * @returns {gossip.RemotePvtDataRequest} RemotePvtDataRequest instance
             */
            RemotePvtDataRequest.create = function create(properties) {
                return new RemotePvtDataRequest(properties);
            };
    
            /**
             * Encodes the specified RemotePvtDataRequest message. Does not implicitly {@link gossip.RemotePvtDataRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {gossip.IRemotePvtDataRequest} message RemotePvtDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemotePvtDataRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.digests != null && message.digests.length)
                    for (var i = 0; i < message.digests.length; ++i)
                        $root.gossip.PvtDataDigest.encode(message.digests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RemotePvtDataRequest message, length delimited. Does not implicitly {@link gossip.RemotePvtDataRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {gossip.IRemotePvtDataRequest} message RemotePvtDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemotePvtDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemotePvtDataRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.RemotePvtDataRequest} RemotePvtDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemotePvtDataRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.RemotePvtDataRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.digests && message.digests.length))
                            message.digests = [];
                        message.digests.push($root.gossip.PvtDataDigest.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemotePvtDataRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.RemotePvtDataRequest} RemotePvtDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemotePvtDataRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemotePvtDataRequest message.
             * @function verify
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemotePvtDataRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.digests != null && message.hasOwnProperty("digests")) {
                    if (!Array.isArray(message.digests))
                        return "digests: array expected";
                    for (var i = 0; i < message.digests.length; ++i) {
                        var error = $root.gossip.PvtDataDigest.verify(message.digests[i]);
                        if (error)
                            return "digests." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RemotePvtDataRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.RemotePvtDataRequest} RemotePvtDataRequest
             */
            RemotePvtDataRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.RemotePvtDataRequest)
                    return object;
                var message = new $root.gossip.RemotePvtDataRequest();
                if (object.digests) {
                    if (!Array.isArray(object.digests))
                        throw TypeError(".gossip.RemotePvtDataRequest.digests: array expected");
                    message.digests = [];
                    for (var i = 0; i < object.digests.length; ++i) {
                        if (typeof object.digests[i] !== "object")
                            throw TypeError(".gossip.RemotePvtDataRequest.digests: object expected");
                        message.digests[i] = $root.gossip.PvtDataDigest.fromObject(object.digests[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RemotePvtDataRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {gossip.RemotePvtDataRequest} message RemotePvtDataRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemotePvtDataRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.digests = [];
                if (message.digests && message.digests.length) {
                    object.digests = [];
                    for (var j = 0; j < message.digests.length; ++j)
                        object.digests[j] = $root.gossip.PvtDataDigest.toObject(message.digests[j], options);
                }
                return object;
            };
    
            /**
             * Converts this RemotePvtDataRequest to JSON.
             * @function toJSON
             * @memberof gossip.RemotePvtDataRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemotePvtDataRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemotePvtDataRequest;
        })();
    
        gossip.PvtDataDigest = (function() {
    
            /**
             * Properties of a PvtDataDigest.
             * @memberof gossip
             * @interface IPvtDataDigest
             * @property {string|null} [tx_id] PvtDataDigest tx_id
             * @property {string|null} [namespace] PvtDataDigest namespace
             * @property {string|null} [collection] PvtDataDigest collection
             * @property {number|Long|null} [block_seq] PvtDataDigest block_seq
             * @property {number|Long|null} [seq_in_block] PvtDataDigest seq_in_block
             */
    
            /**
             * Constructs a new PvtDataDigest.
             * @memberof gossip
             * @classdesc Represents a PvtDataDigest.
             * @implements IPvtDataDigest
             * @constructor
             * @param {gossip.IPvtDataDigest=} [properties] Properties to set
             */
            function PvtDataDigest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PvtDataDigest tx_id.
             * @member {string} tx_id
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.tx_id = "";
    
            /**
             * PvtDataDigest namespace.
             * @member {string} namespace
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.namespace = "";
    
            /**
             * PvtDataDigest collection.
             * @member {string} collection
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.collection = "";
    
            /**
             * PvtDataDigest block_seq.
             * @member {number|Long} block_seq
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.block_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PvtDataDigest seq_in_block.
             * @member {number|Long} seq_in_block
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.seq_in_block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new PvtDataDigest instance using the specified properties.
             * @function create
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {gossip.IPvtDataDigest=} [properties] Properties to set
             * @returns {gossip.PvtDataDigest} PvtDataDigest instance
             */
            PvtDataDigest.create = function create(properties) {
                return new PvtDataDigest(properties);
            };
    
            /**
             * Encodes the specified PvtDataDigest message. Does not implicitly {@link gossip.PvtDataDigest.verify|verify} messages.
             * @function encode
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {gossip.IPvtDataDigest} message PvtDataDigest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataDigest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx_id != null && Object.hasOwnProperty.call(message, "tx_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tx_id);
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.namespace);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                if (message.block_seq != null && Object.hasOwnProperty.call(message, "block_seq"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.block_seq);
                if (message.seq_in_block != null && Object.hasOwnProperty.call(message, "seq_in_block"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.seq_in_block);
                return writer;
            };
    
            /**
             * Encodes the specified PvtDataDigest message, length delimited. Does not implicitly {@link gossip.PvtDataDigest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {gossip.IPvtDataDigest} message PvtDataDigest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataDigest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PvtDataDigest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PvtDataDigest} PvtDataDigest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataDigest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PvtDataDigest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tx_id = reader.string();
                        break;
                    case 2:
                        message.namespace = reader.string();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    case 4:
                        message.block_seq = reader.uint64();
                        break;
                    case 5:
                        message.seq_in_block = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PvtDataDigest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PvtDataDigest} PvtDataDigest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataDigest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PvtDataDigest message.
             * @function verify
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PvtDataDigest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    if (!$util.isString(message.tx_id))
                        return "tx_id: string expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.block_seq != null && message.hasOwnProperty("block_seq"))
                    if (!$util.isInteger(message.block_seq) && !(message.block_seq && $util.isInteger(message.block_seq.low) && $util.isInteger(message.block_seq.high)))
                        return "block_seq: integer|Long expected";
                if (message.seq_in_block != null && message.hasOwnProperty("seq_in_block"))
                    if (!$util.isInteger(message.seq_in_block) && !(message.seq_in_block && $util.isInteger(message.seq_in_block.low) && $util.isInteger(message.seq_in_block.high)))
                        return "seq_in_block: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a PvtDataDigest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PvtDataDigest} PvtDataDigest
             */
            PvtDataDigest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PvtDataDigest)
                    return object;
                var message = new $root.gossip.PvtDataDigest();
                if (object.tx_id != null)
                    message.tx_id = String(object.tx_id);
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.block_seq != null)
                    if ($util.Long)
                        (message.block_seq = $util.Long.fromValue(object.block_seq)).unsigned = true;
                    else if (typeof object.block_seq === "string")
                        message.block_seq = parseInt(object.block_seq, 10);
                    else if (typeof object.block_seq === "number")
                        message.block_seq = object.block_seq;
                    else if (typeof object.block_seq === "object")
                        message.block_seq = new $util.LongBits(object.block_seq.low >>> 0, object.block_seq.high >>> 0).toNumber(true);
                if (object.seq_in_block != null)
                    if ($util.Long)
                        (message.seq_in_block = $util.Long.fromValue(object.seq_in_block)).unsigned = true;
                    else if (typeof object.seq_in_block === "string")
                        message.seq_in_block = parseInt(object.seq_in_block, 10);
                    else if (typeof object.seq_in_block === "number")
                        message.seq_in_block = object.seq_in_block;
                    else if (typeof object.seq_in_block === "object")
                        message.seq_in_block = new $util.LongBits(object.seq_in_block.low >>> 0, object.seq_in_block.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a PvtDataDigest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {gossip.PvtDataDigest} message PvtDataDigest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PvtDataDigest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tx_id = "";
                    object.namespace = "";
                    object.collection = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.block_seq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_seq = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.seq_in_block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seq_in_block = options.longs === String ? "0" : 0;
                }
                if (message.tx_id != null && message.hasOwnProperty("tx_id"))
                    object.tx_id = message.tx_id;
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.block_seq != null && message.hasOwnProperty("block_seq"))
                    if (typeof message.block_seq === "number")
                        object.block_seq = options.longs === String ? String(message.block_seq) : message.block_seq;
                    else
                        object.block_seq = options.longs === String ? $util.Long.prototype.toString.call(message.block_seq) : options.longs === Number ? new $util.LongBits(message.block_seq.low >>> 0, message.block_seq.high >>> 0).toNumber(true) : message.block_seq;
                if (message.seq_in_block != null && message.hasOwnProperty("seq_in_block"))
                    if (typeof message.seq_in_block === "number")
                        object.seq_in_block = options.longs === String ? String(message.seq_in_block) : message.seq_in_block;
                    else
                        object.seq_in_block = options.longs === String ? $util.Long.prototype.toString.call(message.seq_in_block) : options.longs === Number ? new $util.LongBits(message.seq_in_block.low >>> 0, message.seq_in_block.high >>> 0).toNumber(true) : message.seq_in_block;
                return object;
            };
    
            /**
             * Converts this PvtDataDigest to JSON.
             * @function toJSON
             * @memberof gossip.PvtDataDigest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PvtDataDigest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PvtDataDigest;
        })();
    
        gossip.RemotePvtDataResponse = (function() {
    
            /**
             * Properties of a RemotePvtDataResponse.
             * @memberof gossip
             * @interface IRemotePvtDataResponse
             * @property {Array.<gossip.IPvtDataElement>|null} [elements] RemotePvtDataResponse elements
             */
    
            /**
             * Constructs a new RemotePvtDataResponse.
             * @memberof gossip
             * @classdesc Represents a RemotePvtDataResponse.
             * @implements IRemotePvtDataResponse
             * @constructor
             * @param {gossip.IRemotePvtDataResponse=} [properties] Properties to set
             */
            function RemotePvtDataResponse(properties) {
                this.elements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemotePvtDataResponse elements.
             * @member {Array.<gossip.IPvtDataElement>} elements
             * @memberof gossip.RemotePvtDataResponse
             * @instance
             */
            RemotePvtDataResponse.prototype.elements = $util.emptyArray;
    
            /**
             * Creates a new RemotePvtDataResponse instance using the specified properties.
             * @function create
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {gossip.IRemotePvtDataResponse=} [properties] Properties to set
             * @returns {gossip.RemotePvtDataResponse} RemotePvtDataResponse instance
             */
            RemotePvtDataResponse.create = function create(properties) {
                return new RemotePvtDataResponse(properties);
            };
    
            /**
             * Encodes the specified RemotePvtDataResponse message. Does not implicitly {@link gossip.RemotePvtDataResponse.verify|verify} messages.
             * @function encode
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {gossip.IRemotePvtDataResponse} message RemotePvtDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemotePvtDataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elements != null && message.elements.length)
                    for (var i = 0; i < message.elements.length; ++i)
                        $root.gossip.PvtDataElement.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RemotePvtDataResponse message, length delimited. Does not implicitly {@link gossip.RemotePvtDataResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {gossip.IRemotePvtDataResponse} message RemotePvtDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemotePvtDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemotePvtDataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.RemotePvtDataResponse} RemotePvtDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemotePvtDataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.RemotePvtDataResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.elements && message.elements.length))
                            message.elements = [];
                        message.elements.push($root.gossip.PvtDataElement.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemotePvtDataResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.RemotePvtDataResponse} RemotePvtDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemotePvtDataResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemotePvtDataResponse message.
             * @function verify
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemotePvtDataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (var i = 0; i < message.elements.length; ++i) {
                        var error = $root.gossip.PvtDataElement.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RemotePvtDataResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.RemotePvtDataResponse} RemotePvtDataResponse
             */
            RemotePvtDataResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.RemotePvtDataResponse)
                    return object;
                var message = new $root.gossip.RemotePvtDataResponse();
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".gossip.RemotePvtDataResponse.elements: array expected");
                    message.elements = [];
                    for (var i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".gossip.RemotePvtDataResponse.elements: object expected");
                        message.elements[i] = $root.gossip.PvtDataElement.fromObject(object.elements[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RemotePvtDataResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {gossip.RemotePvtDataResponse} message RemotePvtDataResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemotePvtDataResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (var j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.gossip.PvtDataElement.toObject(message.elements[j], options);
                }
                return object;
            };
    
            /**
             * Converts this RemotePvtDataResponse to JSON.
             * @function toJSON
             * @memberof gossip.RemotePvtDataResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemotePvtDataResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemotePvtDataResponse;
        })();
    
        gossip.PvtDataElement = (function() {
    
            /**
             * Properties of a PvtDataElement.
             * @memberof gossip
             * @interface IPvtDataElement
             * @property {gossip.IPvtDataDigest|null} [digest] PvtDataElement digest
             * @property {Array.<Uint8Array>|null} [payload] PvtDataElement payload
             */
    
            /**
             * Constructs a new PvtDataElement.
             * @memberof gossip
             * @classdesc Represents a PvtDataElement.
             * @implements IPvtDataElement
             * @constructor
             * @param {gossip.IPvtDataElement=} [properties] Properties to set
             */
            function PvtDataElement(properties) {
                this.payload = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PvtDataElement digest.
             * @member {gossip.IPvtDataDigest|null|undefined} digest
             * @memberof gossip.PvtDataElement
             * @instance
             */
            PvtDataElement.prototype.digest = null;
    
            /**
             * PvtDataElement payload.
             * @member {Array.<Uint8Array>} payload
             * @memberof gossip.PvtDataElement
             * @instance
             */
            PvtDataElement.prototype.payload = $util.emptyArray;
    
            /**
             * Creates a new PvtDataElement instance using the specified properties.
             * @function create
             * @memberof gossip.PvtDataElement
             * @static
             * @param {gossip.IPvtDataElement=} [properties] Properties to set
             * @returns {gossip.PvtDataElement} PvtDataElement instance
             */
            PvtDataElement.create = function create(properties) {
                return new PvtDataElement(properties);
            };
    
            /**
             * Encodes the specified PvtDataElement message. Does not implicitly {@link gossip.PvtDataElement.verify|verify} messages.
             * @function encode
             * @memberof gossip.PvtDataElement
             * @static
             * @param {gossip.IPvtDataElement} message PvtDataElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                    $root.gossip.PvtDataDigest.encode(message.digest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.payload != null && message.payload.length)
                    for (var i = 0; i < message.payload.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload[i]);
                return writer;
            };
    
            /**
             * Encodes the specified PvtDataElement message, length delimited. Does not implicitly {@link gossip.PvtDataElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PvtDataElement
             * @static
             * @param {gossip.IPvtDataElement} message PvtDataElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PvtDataElement message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PvtDataElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PvtDataElement} PvtDataElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PvtDataElement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.digest = $root.gossip.PvtDataDigest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.payload && message.payload.length))
                            message.payload = [];
                        message.payload.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PvtDataElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PvtDataElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PvtDataElement} PvtDataElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PvtDataElement message.
             * @function verify
             * @memberof gossip.PvtDataElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PvtDataElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.digest != null && message.hasOwnProperty("digest")) {
                    var error = $root.gossip.PvtDataDigest.verify(message.digest);
                    if (error)
                        return "digest." + error;
                }
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    if (!Array.isArray(message.payload))
                        return "payload: array expected";
                    for (var i = 0; i < message.payload.length; ++i)
                        if (!(message.payload[i] && typeof message.payload[i].length === "number" || $util.isString(message.payload[i])))
                            return "payload: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a PvtDataElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PvtDataElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PvtDataElement} PvtDataElement
             */
            PvtDataElement.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PvtDataElement)
                    return object;
                var message = new $root.gossip.PvtDataElement();
                if (object.digest != null) {
                    if (typeof object.digest !== "object")
                        throw TypeError(".gossip.PvtDataElement.digest: object expected");
                    message.digest = $root.gossip.PvtDataDigest.fromObject(object.digest);
                }
                if (object.payload) {
                    if (!Array.isArray(object.payload))
                        throw TypeError(".gossip.PvtDataElement.payload: array expected");
                    message.payload = [];
                    for (var i = 0; i < object.payload.length; ++i)
                        if (typeof object.payload[i] === "string")
                            $util.base64.decode(object.payload[i], message.payload[i] = $util.newBuffer($util.base64.length(object.payload[i])), 0);
                        else if (object.payload[i].length)
                            message.payload[i] = object.payload[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PvtDataElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PvtDataElement
             * @static
             * @param {gossip.PvtDataElement} message PvtDataElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PvtDataElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.payload = [];
                if (options.defaults)
                    object.digest = null;
                if (message.digest != null && message.hasOwnProperty("digest"))
                    object.digest = $root.gossip.PvtDataDigest.toObject(message.digest, options);
                if (message.payload && message.payload.length) {
                    object.payload = [];
                    for (var j = 0; j < message.payload.length; ++j)
                        object.payload[j] = options.bytes === String ? $util.base64.encode(message.payload[j], 0, message.payload[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.payload[j]) : message.payload[j];
                }
                return object;
            };
    
            /**
             * Converts this PvtDataElement to JSON.
             * @function toJSON
             * @memberof gossip.PvtDataElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PvtDataElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PvtDataElement;
        })();
    
        gossip.PvtDataPayload = (function() {
    
            /**
             * Properties of a PvtDataPayload.
             * @memberof gossip
             * @interface IPvtDataPayload
             * @property {number|Long|null} [tx_seq_in_block] PvtDataPayload tx_seq_in_block
             * @property {Uint8Array|null} [payload] PvtDataPayload payload
             */
    
            /**
             * Constructs a new PvtDataPayload.
             * @memberof gossip
             * @classdesc Represents a PvtDataPayload.
             * @implements IPvtDataPayload
             * @constructor
             * @param {gossip.IPvtDataPayload=} [properties] Properties to set
             */
            function PvtDataPayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PvtDataPayload tx_seq_in_block.
             * @member {number|Long} tx_seq_in_block
             * @memberof gossip.PvtDataPayload
             * @instance
             */
            PvtDataPayload.prototype.tx_seq_in_block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PvtDataPayload payload.
             * @member {Uint8Array} payload
             * @memberof gossip.PvtDataPayload
             * @instance
             */
            PvtDataPayload.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new PvtDataPayload instance using the specified properties.
             * @function create
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {gossip.IPvtDataPayload=} [properties] Properties to set
             * @returns {gossip.PvtDataPayload} PvtDataPayload instance
             */
            PvtDataPayload.create = function create(properties) {
                return new PvtDataPayload(properties);
            };
    
            /**
             * Encodes the specified PvtDataPayload message. Does not implicitly {@link gossip.PvtDataPayload.verify|verify} messages.
             * @function encode
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {gossip.IPvtDataPayload} message PvtDataPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataPayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx_seq_in_block != null && Object.hasOwnProperty.call(message, "tx_seq_in_block"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tx_seq_in_block);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified PvtDataPayload message, length delimited. Does not implicitly {@link gossip.PvtDataPayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {gossip.IPvtDataPayload} message PvtDataPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataPayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PvtDataPayload message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PvtDataPayload} PvtDataPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataPayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PvtDataPayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tx_seq_in_block = reader.uint64();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PvtDataPayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PvtDataPayload} PvtDataPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataPayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PvtDataPayload message.
             * @function verify
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PvtDataPayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx_seq_in_block != null && message.hasOwnProperty("tx_seq_in_block"))
                    if (!$util.isInteger(message.tx_seq_in_block) && !(message.tx_seq_in_block && $util.isInteger(message.tx_seq_in_block.low) && $util.isInteger(message.tx_seq_in_block.high)))
                        return "tx_seq_in_block: integer|Long expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a PvtDataPayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PvtDataPayload} PvtDataPayload
             */
            PvtDataPayload.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PvtDataPayload)
                    return object;
                var message = new $root.gossip.PvtDataPayload();
                if (object.tx_seq_in_block != null)
                    if ($util.Long)
                        (message.tx_seq_in_block = $util.Long.fromValue(object.tx_seq_in_block)).unsigned = true;
                    else if (typeof object.tx_seq_in_block === "string")
                        message.tx_seq_in_block = parseInt(object.tx_seq_in_block, 10);
                    else if (typeof object.tx_seq_in_block === "number")
                        message.tx_seq_in_block = object.tx_seq_in_block;
                    else if (typeof object.tx_seq_in_block === "object")
                        message.tx_seq_in_block = new $util.LongBits(object.tx_seq_in_block.low >>> 0, object.tx_seq_in_block.high >>> 0).toNumber(true);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a PvtDataPayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {gossip.PvtDataPayload} message PvtDataPayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PvtDataPayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.tx_seq_in_block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx_seq_in_block = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.tx_seq_in_block != null && message.hasOwnProperty("tx_seq_in_block"))
                    if (typeof message.tx_seq_in_block === "number")
                        object.tx_seq_in_block = options.longs === String ? String(message.tx_seq_in_block) : message.tx_seq_in_block;
                    else
                        object.tx_seq_in_block = options.longs === String ? $util.Long.prototype.toString.call(message.tx_seq_in_block) : options.longs === Number ? new $util.LongBits(message.tx_seq_in_block.low >>> 0, message.tx_seq_in_block.high >>> 0).toNumber(true) : message.tx_seq_in_block;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this PvtDataPayload to JSON.
             * @function toJSON
             * @memberof gossip.PvtDataPayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PvtDataPayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PvtDataPayload;
        })();
    
        gossip.Acknowledgement = (function() {
    
            /**
             * Properties of an Acknowledgement.
             * @memberof gossip
             * @interface IAcknowledgement
             * @property {string|null} [error] Acknowledgement error
             */
    
            /**
             * Constructs a new Acknowledgement.
             * @memberof gossip
             * @classdesc Represents an Acknowledgement.
             * @implements IAcknowledgement
             * @constructor
             * @param {gossip.IAcknowledgement=} [properties] Properties to set
             */
            function Acknowledgement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Acknowledgement error.
             * @member {string} error
             * @memberof gossip.Acknowledgement
             * @instance
             */
            Acknowledgement.prototype.error = "";
    
            /**
             * Creates a new Acknowledgement instance using the specified properties.
             * @function create
             * @memberof gossip.Acknowledgement
             * @static
             * @param {gossip.IAcknowledgement=} [properties] Properties to set
             * @returns {gossip.Acknowledgement} Acknowledgement instance
             */
            Acknowledgement.create = function create(properties) {
                return new Acknowledgement(properties);
            };
    
            /**
             * Encodes the specified Acknowledgement message. Does not implicitly {@link gossip.Acknowledgement.verify|verify} messages.
             * @function encode
             * @memberof gossip.Acknowledgement
             * @static
             * @param {gossip.IAcknowledgement} message Acknowledgement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Acknowledgement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
                return writer;
            };
    
            /**
             * Encodes the specified Acknowledgement message, length delimited. Does not implicitly {@link gossip.Acknowledgement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Acknowledgement
             * @static
             * @param {gossip.IAcknowledgement} message Acknowledgement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Acknowledgement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Acknowledgement message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Acknowledgement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Acknowledgement} Acknowledgement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Acknowledgement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Acknowledgement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Acknowledgement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Acknowledgement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Acknowledgement} Acknowledgement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Acknowledgement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Acknowledgement message.
             * @function verify
             * @memberof gossip.Acknowledgement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Acknowledgement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                return null;
            };
    
            /**
             * Creates an Acknowledgement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Acknowledgement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Acknowledgement} Acknowledgement
             */
            Acknowledgement.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Acknowledgement)
                    return object;
                var message = new $root.gossip.Acknowledgement();
                if (object.error != null)
                    message.error = String(object.error);
                return message;
            };
    
            /**
             * Creates a plain object from an Acknowledgement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Acknowledgement
             * @static
             * @param {gossip.Acknowledgement} message Acknowledgement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Acknowledgement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.error = "";
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                return object;
            };
    
            /**
             * Converts this Acknowledgement to JSON.
             * @function toJSON
             * @memberof gossip.Acknowledgement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Acknowledgement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Acknowledgement;
        })();
    
        gossip.Chaincode = (function() {
    
            /**
             * Properties of a Chaincode.
             * @memberof gossip
             * @interface IChaincode
             * @property {string|null} [name] Chaincode name
             * @property {string|null} [version] Chaincode version
             * @property {Uint8Array|null} [metadata] Chaincode metadata
             */
    
            /**
             * Constructs a new Chaincode.
             * @memberof gossip
             * @classdesc Represents a Chaincode.
             * @implements IChaincode
             * @constructor
             * @param {gossip.IChaincode=} [properties] Properties to set
             */
            function Chaincode(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Chaincode name.
             * @member {string} name
             * @memberof gossip.Chaincode
             * @instance
             */
            Chaincode.prototype.name = "";
    
            /**
             * Chaincode version.
             * @member {string} version
             * @memberof gossip.Chaincode
             * @instance
             */
            Chaincode.prototype.version = "";
    
            /**
             * Chaincode metadata.
             * @member {Uint8Array} metadata
             * @memberof gossip.Chaincode
             * @instance
             */
            Chaincode.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new Chaincode instance using the specified properties.
             * @function create
             * @memberof gossip.Chaincode
             * @static
             * @param {gossip.IChaincode=} [properties] Properties to set
             * @returns {gossip.Chaincode} Chaincode instance
             */
            Chaincode.create = function create(properties) {
                return new Chaincode(properties);
            };
    
            /**
             * Encodes the specified Chaincode message. Does not implicitly {@link gossip.Chaincode.verify|verify} messages.
             * @function encode
             * @memberof gossip.Chaincode
             * @static
             * @param {gossip.IChaincode} message Chaincode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chaincode.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified Chaincode message, length delimited. Does not implicitly {@link gossip.Chaincode.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Chaincode
             * @static
             * @param {gossip.IChaincode} message Chaincode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chaincode.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Chaincode message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Chaincode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Chaincode} Chaincode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chaincode.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Chaincode();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Chaincode message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Chaincode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Chaincode} Chaincode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chaincode.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Chaincode message.
             * @function verify
             * @memberof gossip.Chaincode
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Chaincode.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a Chaincode message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Chaincode
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Chaincode} Chaincode
             */
            Chaincode.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Chaincode)
                    return object;
                var message = new $root.gossip.Chaincode();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a Chaincode message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Chaincode
             * @static
             * @param {gossip.Chaincode} message Chaincode
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Chaincode.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.version = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this Chaincode to JSON.
             * @function toJSON
             * @memberof gossip.Chaincode
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Chaincode.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Chaincode;
        })();
    
        return gossip;
    })();
    
    $root.msp = (function() {
    
        /**
         * Namespace msp.
         * @exports msp
         * @namespace
         */
        var msp = {};
    
        msp.MSPConfig = (function() {
    
            /**
             * Properties of a MSPConfig.
             * @memberof msp
             * @interface IMSPConfig
             * @property {number|null} [type] MSPConfig type
             * @property {Uint8Array|null} [config] MSPConfig config
             */
    
            /**
             * Constructs a new MSPConfig.
             * @memberof msp
             * @classdesc Represents a MSPConfig.
             * @implements IMSPConfig
             * @constructor
             * @param {msp.IMSPConfig=} [properties] Properties to set
             */
            function MSPConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MSPConfig type.
             * @member {number} type
             * @memberof msp.MSPConfig
             * @instance
             */
            MSPConfig.prototype.type = 0;
    
            /**
             * MSPConfig config.
             * @member {Uint8Array} config
             * @memberof msp.MSPConfig
             * @instance
             */
            MSPConfig.prototype.config = $util.newBuffer([]);
    
            /**
             * Creates a new MSPConfig instance using the specified properties.
             * @function create
             * @memberof msp.MSPConfig
             * @static
             * @param {msp.IMSPConfig=} [properties] Properties to set
             * @returns {msp.MSPConfig} MSPConfig instance
             */
            MSPConfig.create = function create(properties) {
                return new MSPConfig(properties);
            };
    
            /**
             * Encodes the specified MSPConfig message. Does not implicitly {@link msp.MSPConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.MSPConfig
             * @static
             * @param {msp.IMSPConfig} message MSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.config);
                return writer;
            };
    
            /**
             * Encodes the specified MSPConfig message, length delimited. Does not implicitly {@link msp.MSPConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.MSPConfig
             * @static
             * @param {msp.IMSPConfig} message MSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MSPConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.MSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.MSPConfig} MSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.MSPConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.config = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MSPConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.MSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.MSPConfig} MSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MSPConfig message.
             * @function verify
             * @memberof msp.MSPConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MSPConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.config != null && message.hasOwnProperty("config"))
                    if (!(message.config && typeof message.config.length === "number" || $util.isString(message.config)))
                        return "config: buffer expected";
                return null;
            };
    
            /**
             * Creates a MSPConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.MSPConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.MSPConfig} MSPConfig
             */
            MSPConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.MSPConfig)
                    return object;
                var message = new $root.msp.MSPConfig();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.config != null)
                    if (typeof object.config === "string")
                        $util.base64.decode(object.config, message.config = $util.newBuffer($util.base64.length(object.config)), 0);
                    else if (object.config.length)
                        message.config = object.config;
                return message;
            };
    
            /**
             * Creates a plain object from a MSPConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.MSPConfig
             * @static
             * @param {msp.MSPConfig} message MSPConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MSPConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    if (options.bytes === String)
                        object.config = "";
                    else {
                        object.config = [];
                        if (options.bytes !== Array)
                            object.config = $util.newBuffer(object.config);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = options.bytes === String ? $util.base64.encode(message.config, 0, message.config.length) : options.bytes === Array ? Array.prototype.slice.call(message.config) : message.config;
                return object;
            };
    
            /**
             * Converts this MSPConfig to JSON.
             * @function toJSON
             * @memberof msp.MSPConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MSPConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MSPConfig;
        })();
    
        msp.FabricMSPConfig = (function() {
    
            /**
             * Properties of a FabricMSPConfig.
             * @memberof msp
             * @interface IFabricMSPConfig
             * @property {string|null} [name] FabricMSPConfig name
             * @property {Array.<Uint8Array>|null} [root_certs] FabricMSPConfig root_certs
             * @property {Array.<Uint8Array>|null} [intermediate_certs] FabricMSPConfig intermediate_certs
             * @property {Array.<Uint8Array>|null} [admins] FabricMSPConfig admins
             * @property {Array.<Uint8Array>|null} [revocation_list] FabricMSPConfig revocation_list
             * @property {msp.ISigningIdentityInfo|null} [signing_identity] FabricMSPConfig signing_identity
             * @property {Array.<msp.IFabricOUIdentifier>|null} [organizational_unit_identifiers] FabricMSPConfig organizational_unit_identifiers
             * @property {msp.IFabricCryptoConfig|null} [crypto_config] FabricMSPConfig crypto_config
             * @property {Array.<Uint8Array>|null} [tls_root_certs] FabricMSPConfig tls_root_certs
             * @property {Array.<Uint8Array>|null} [tls_intermediate_certs] FabricMSPConfig tls_intermediate_certs
             * @property {msp.IFabricNodeOUs|null} [fabric_node_ous] FabricMSPConfig fabric_node_ous
             */
    
            /**
             * Constructs a new FabricMSPConfig.
             * @memberof msp
             * @classdesc Represents a FabricMSPConfig.
             * @implements IFabricMSPConfig
             * @constructor
             * @param {msp.IFabricMSPConfig=} [properties] Properties to set
             */
            function FabricMSPConfig(properties) {
                this.root_certs = [];
                this.intermediate_certs = [];
                this.admins = [];
                this.revocation_list = [];
                this.organizational_unit_identifiers = [];
                this.tls_root_certs = [];
                this.tls_intermediate_certs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FabricMSPConfig name.
             * @member {string} name
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.name = "";
    
            /**
             * FabricMSPConfig root_certs.
             * @member {Array.<Uint8Array>} root_certs
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.root_certs = $util.emptyArray;
    
            /**
             * FabricMSPConfig intermediate_certs.
             * @member {Array.<Uint8Array>} intermediate_certs
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.intermediate_certs = $util.emptyArray;
    
            /**
             * FabricMSPConfig admins.
             * @member {Array.<Uint8Array>} admins
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.admins = $util.emptyArray;
    
            /**
             * FabricMSPConfig revocation_list.
             * @member {Array.<Uint8Array>} revocation_list
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.revocation_list = $util.emptyArray;
    
            /**
             * FabricMSPConfig signing_identity.
             * @member {msp.ISigningIdentityInfo|null|undefined} signing_identity
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.signing_identity = null;
    
            /**
             * FabricMSPConfig organizational_unit_identifiers.
             * @member {Array.<msp.IFabricOUIdentifier>} organizational_unit_identifiers
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.organizational_unit_identifiers = $util.emptyArray;
    
            /**
             * FabricMSPConfig crypto_config.
             * @member {msp.IFabricCryptoConfig|null|undefined} crypto_config
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.crypto_config = null;
    
            /**
             * FabricMSPConfig tls_root_certs.
             * @member {Array.<Uint8Array>} tls_root_certs
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.tls_root_certs = $util.emptyArray;
    
            /**
             * FabricMSPConfig tls_intermediate_certs.
             * @member {Array.<Uint8Array>} tls_intermediate_certs
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.tls_intermediate_certs = $util.emptyArray;
    
            /**
             * FabricMSPConfig fabric_node_ous.
             * @member {msp.IFabricNodeOUs|null|undefined} fabric_node_ous
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.fabric_node_ous = null;
    
            /**
             * Creates a new FabricMSPConfig instance using the specified properties.
             * @function create
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {msp.IFabricMSPConfig=} [properties] Properties to set
             * @returns {msp.FabricMSPConfig} FabricMSPConfig instance
             */
            FabricMSPConfig.create = function create(properties) {
                return new FabricMSPConfig(properties);
            };
    
            /**
             * Encodes the specified FabricMSPConfig message. Does not implicitly {@link msp.FabricMSPConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {msp.IFabricMSPConfig} message FabricMSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricMSPConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.root_certs != null && message.root_certs.length)
                    for (var i = 0; i < message.root_certs.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.root_certs[i]);
                if (message.intermediate_certs != null && message.intermediate_certs.length)
                    for (var i = 0; i < message.intermediate_certs.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.intermediate_certs[i]);
                if (message.admins != null && message.admins.length)
                    for (var i = 0; i < message.admins.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.admins[i]);
                if (message.revocation_list != null && message.revocation_list.length)
                    for (var i = 0; i < message.revocation_list.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.revocation_list[i]);
                if (message.signing_identity != null && Object.hasOwnProperty.call(message, "signing_identity"))
                    $root.msp.SigningIdentityInfo.encode(message.signing_identity, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.organizational_unit_identifiers != null && message.organizational_unit_identifiers.length)
                    for (var i = 0; i < message.organizational_unit_identifiers.length; ++i)
                        $root.msp.FabricOUIdentifier.encode(message.organizational_unit_identifiers[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.crypto_config != null && Object.hasOwnProperty.call(message, "crypto_config"))
                    $root.msp.FabricCryptoConfig.encode(message.crypto_config, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.tls_root_certs != null && message.tls_root_certs.length)
                    for (var i = 0; i < message.tls_root_certs.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.tls_root_certs[i]);
                if (message.tls_intermediate_certs != null && message.tls_intermediate_certs.length)
                    for (var i = 0; i < message.tls_intermediate_certs.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.tls_intermediate_certs[i]);
                if (message.fabric_node_ous != null && Object.hasOwnProperty.call(message, "fabric_node_ous"))
                    $root.msp.FabricNodeOUs.encode(message.fabric_node_ous, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FabricMSPConfig message, length delimited. Does not implicitly {@link msp.FabricMSPConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {msp.IFabricMSPConfig} message FabricMSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricMSPConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FabricMSPConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.FabricMSPConfig} FabricMSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricMSPConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.FabricMSPConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.root_certs && message.root_certs.length))
                            message.root_certs = [];
                        message.root_certs.push(reader.bytes());
                        break;
                    case 3:
                        if (!(message.intermediate_certs && message.intermediate_certs.length))
                            message.intermediate_certs = [];
                        message.intermediate_certs.push(reader.bytes());
                        break;
                    case 4:
                        if (!(message.admins && message.admins.length))
                            message.admins = [];
                        message.admins.push(reader.bytes());
                        break;
                    case 5:
                        if (!(message.revocation_list && message.revocation_list.length))
                            message.revocation_list = [];
                        message.revocation_list.push(reader.bytes());
                        break;
                    case 6:
                        message.signing_identity = $root.msp.SigningIdentityInfo.decode(reader, reader.uint32());
                        break;
                    case 7:
                        if (!(message.organizational_unit_identifiers && message.organizational_unit_identifiers.length))
                            message.organizational_unit_identifiers = [];
                        message.organizational_unit_identifiers.push($root.msp.FabricOUIdentifier.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.crypto_config = $root.msp.FabricCryptoConfig.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.tls_root_certs && message.tls_root_certs.length))
                            message.tls_root_certs = [];
                        message.tls_root_certs.push(reader.bytes());
                        break;
                    case 10:
                        if (!(message.tls_intermediate_certs && message.tls_intermediate_certs.length))
                            message.tls_intermediate_certs = [];
                        message.tls_intermediate_certs.push(reader.bytes());
                        break;
                    case 11:
                        message.fabric_node_ous = $root.msp.FabricNodeOUs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FabricMSPConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.FabricMSPConfig} FabricMSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricMSPConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FabricMSPConfig message.
             * @function verify
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FabricMSPConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.root_certs != null && message.hasOwnProperty("root_certs")) {
                    if (!Array.isArray(message.root_certs))
                        return "root_certs: array expected";
                    for (var i = 0; i < message.root_certs.length; ++i)
                        if (!(message.root_certs[i] && typeof message.root_certs[i].length === "number" || $util.isString(message.root_certs[i])))
                            return "root_certs: buffer[] expected";
                }
                if (message.intermediate_certs != null && message.hasOwnProperty("intermediate_certs")) {
                    if (!Array.isArray(message.intermediate_certs))
                        return "intermediate_certs: array expected";
                    for (var i = 0; i < message.intermediate_certs.length; ++i)
                        if (!(message.intermediate_certs[i] && typeof message.intermediate_certs[i].length === "number" || $util.isString(message.intermediate_certs[i])))
                            return "intermediate_certs: buffer[] expected";
                }
                if (message.admins != null && message.hasOwnProperty("admins")) {
                    if (!Array.isArray(message.admins))
                        return "admins: array expected";
                    for (var i = 0; i < message.admins.length; ++i)
                        if (!(message.admins[i] && typeof message.admins[i].length === "number" || $util.isString(message.admins[i])))
                            return "admins: buffer[] expected";
                }
                if (message.revocation_list != null && message.hasOwnProperty("revocation_list")) {
                    if (!Array.isArray(message.revocation_list))
                        return "revocation_list: array expected";
                    for (var i = 0; i < message.revocation_list.length; ++i)
                        if (!(message.revocation_list[i] && typeof message.revocation_list[i].length === "number" || $util.isString(message.revocation_list[i])))
                            return "revocation_list: buffer[] expected";
                }
                if (message.signing_identity != null && message.hasOwnProperty("signing_identity")) {
                    var error = $root.msp.SigningIdentityInfo.verify(message.signing_identity);
                    if (error)
                        return "signing_identity." + error;
                }
                if (message.organizational_unit_identifiers != null && message.hasOwnProperty("organizational_unit_identifiers")) {
                    if (!Array.isArray(message.organizational_unit_identifiers))
                        return "organizational_unit_identifiers: array expected";
                    for (var i = 0; i < message.organizational_unit_identifiers.length; ++i) {
                        var error = $root.msp.FabricOUIdentifier.verify(message.organizational_unit_identifiers[i]);
                        if (error)
                            return "organizational_unit_identifiers." + error;
                    }
                }
                if (message.crypto_config != null && message.hasOwnProperty("crypto_config")) {
                    var error = $root.msp.FabricCryptoConfig.verify(message.crypto_config);
                    if (error)
                        return "crypto_config." + error;
                }
                if (message.tls_root_certs != null && message.hasOwnProperty("tls_root_certs")) {
                    if (!Array.isArray(message.tls_root_certs))
                        return "tls_root_certs: array expected";
                    for (var i = 0; i < message.tls_root_certs.length; ++i)
                        if (!(message.tls_root_certs[i] && typeof message.tls_root_certs[i].length === "number" || $util.isString(message.tls_root_certs[i])))
                            return "tls_root_certs: buffer[] expected";
                }
                if (message.tls_intermediate_certs != null && message.hasOwnProperty("tls_intermediate_certs")) {
                    if (!Array.isArray(message.tls_intermediate_certs))
                        return "tls_intermediate_certs: array expected";
                    for (var i = 0; i < message.tls_intermediate_certs.length; ++i)
                        if (!(message.tls_intermediate_certs[i] && typeof message.tls_intermediate_certs[i].length === "number" || $util.isString(message.tls_intermediate_certs[i])))
                            return "tls_intermediate_certs: buffer[] expected";
                }
                if (message.fabric_node_ous != null && message.hasOwnProperty("fabric_node_ous")) {
                    var error = $root.msp.FabricNodeOUs.verify(message.fabric_node_ous);
                    if (error)
                        return "fabric_node_ous." + error;
                }
                return null;
            };
    
            /**
             * Creates a FabricMSPConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.FabricMSPConfig} FabricMSPConfig
             */
            FabricMSPConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.FabricMSPConfig)
                    return object;
                var message = new $root.msp.FabricMSPConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.root_certs) {
                    if (!Array.isArray(object.root_certs))
                        throw TypeError(".msp.FabricMSPConfig.root_certs: array expected");
                    message.root_certs = [];
                    for (var i = 0; i < object.root_certs.length; ++i)
                        if (typeof object.root_certs[i] === "string")
                            $util.base64.decode(object.root_certs[i], message.root_certs[i] = $util.newBuffer($util.base64.length(object.root_certs[i])), 0);
                        else if (object.root_certs[i].length)
                            message.root_certs[i] = object.root_certs[i];
                }
                if (object.intermediate_certs) {
                    if (!Array.isArray(object.intermediate_certs))
                        throw TypeError(".msp.FabricMSPConfig.intermediate_certs: array expected");
                    message.intermediate_certs = [];
                    for (var i = 0; i < object.intermediate_certs.length; ++i)
                        if (typeof object.intermediate_certs[i] === "string")
                            $util.base64.decode(object.intermediate_certs[i], message.intermediate_certs[i] = $util.newBuffer($util.base64.length(object.intermediate_certs[i])), 0);
                        else if (object.intermediate_certs[i].length)
                            message.intermediate_certs[i] = object.intermediate_certs[i];
                }
                if (object.admins) {
                    if (!Array.isArray(object.admins))
                        throw TypeError(".msp.FabricMSPConfig.admins: array expected");
                    message.admins = [];
                    for (var i = 0; i < object.admins.length; ++i)
                        if (typeof object.admins[i] === "string")
                            $util.base64.decode(object.admins[i], message.admins[i] = $util.newBuffer($util.base64.length(object.admins[i])), 0);
                        else if (object.admins[i].length)
                            message.admins[i] = object.admins[i];
                }
                if (object.revocation_list) {
                    if (!Array.isArray(object.revocation_list))
                        throw TypeError(".msp.FabricMSPConfig.revocation_list: array expected");
                    message.revocation_list = [];
                    for (var i = 0; i < object.revocation_list.length; ++i)
                        if (typeof object.revocation_list[i] === "string")
                            $util.base64.decode(object.revocation_list[i], message.revocation_list[i] = $util.newBuffer($util.base64.length(object.revocation_list[i])), 0);
                        else if (object.revocation_list[i].length)
                            message.revocation_list[i] = object.revocation_list[i];
                }
                if (object.signing_identity != null) {
                    if (typeof object.signing_identity !== "object")
                        throw TypeError(".msp.FabricMSPConfig.signing_identity: object expected");
                    message.signing_identity = $root.msp.SigningIdentityInfo.fromObject(object.signing_identity);
                }
                if (object.organizational_unit_identifiers) {
                    if (!Array.isArray(object.organizational_unit_identifiers))
                        throw TypeError(".msp.FabricMSPConfig.organizational_unit_identifiers: array expected");
                    message.organizational_unit_identifiers = [];
                    for (var i = 0; i < object.organizational_unit_identifiers.length; ++i) {
                        if (typeof object.organizational_unit_identifiers[i] !== "object")
                            throw TypeError(".msp.FabricMSPConfig.organizational_unit_identifiers: object expected");
                        message.organizational_unit_identifiers[i] = $root.msp.FabricOUIdentifier.fromObject(object.organizational_unit_identifiers[i]);
                    }
                }
                if (object.crypto_config != null) {
                    if (typeof object.crypto_config !== "object")
                        throw TypeError(".msp.FabricMSPConfig.crypto_config: object expected");
                    message.crypto_config = $root.msp.FabricCryptoConfig.fromObject(object.crypto_config);
                }
                if (object.tls_root_certs) {
                    if (!Array.isArray(object.tls_root_certs))
                        throw TypeError(".msp.FabricMSPConfig.tls_root_certs: array expected");
                    message.tls_root_certs = [];
                    for (var i = 0; i < object.tls_root_certs.length; ++i)
                        if (typeof object.tls_root_certs[i] === "string")
                            $util.base64.decode(object.tls_root_certs[i], message.tls_root_certs[i] = $util.newBuffer($util.base64.length(object.tls_root_certs[i])), 0);
                        else if (object.tls_root_certs[i].length)
                            message.tls_root_certs[i] = object.tls_root_certs[i];
                }
                if (object.tls_intermediate_certs) {
                    if (!Array.isArray(object.tls_intermediate_certs))
                        throw TypeError(".msp.FabricMSPConfig.tls_intermediate_certs: array expected");
                    message.tls_intermediate_certs = [];
                    for (var i = 0; i < object.tls_intermediate_certs.length; ++i)
                        if (typeof object.tls_intermediate_certs[i] === "string")
                            $util.base64.decode(object.tls_intermediate_certs[i], message.tls_intermediate_certs[i] = $util.newBuffer($util.base64.length(object.tls_intermediate_certs[i])), 0);
                        else if (object.tls_intermediate_certs[i].length)
                            message.tls_intermediate_certs[i] = object.tls_intermediate_certs[i];
                }
                if (object.fabric_node_ous != null) {
                    if (typeof object.fabric_node_ous !== "object")
                        throw TypeError(".msp.FabricMSPConfig.fabric_node_ous: object expected");
                    message.fabric_node_ous = $root.msp.FabricNodeOUs.fromObject(object.fabric_node_ous);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FabricMSPConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {msp.FabricMSPConfig} message FabricMSPConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FabricMSPConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.root_certs = [];
                    object.intermediate_certs = [];
                    object.admins = [];
                    object.revocation_list = [];
                    object.organizational_unit_identifiers = [];
                    object.tls_root_certs = [];
                    object.tls_intermediate_certs = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.signing_identity = null;
                    object.crypto_config = null;
                    object.fabric_node_ous = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.root_certs && message.root_certs.length) {
                    object.root_certs = [];
                    for (var j = 0; j < message.root_certs.length; ++j)
                        object.root_certs[j] = options.bytes === String ? $util.base64.encode(message.root_certs[j], 0, message.root_certs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.root_certs[j]) : message.root_certs[j];
                }
                if (message.intermediate_certs && message.intermediate_certs.length) {
                    object.intermediate_certs = [];
                    for (var j = 0; j < message.intermediate_certs.length; ++j)
                        object.intermediate_certs[j] = options.bytes === String ? $util.base64.encode(message.intermediate_certs[j], 0, message.intermediate_certs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.intermediate_certs[j]) : message.intermediate_certs[j];
                }
                if (message.admins && message.admins.length) {
                    object.admins = [];
                    for (var j = 0; j < message.admins.length; ++j)
                        object.admins[j] = options.bytes === String ? $util.base64.encode(message.admins[j], 0, message.admins[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.admins[j]) : message.admins[j];
                }
                if (message.revocation_list && message.revocation_list.length) {
                    object.revocation_list = [];
                    for (var j = 0; j < message.revocation_list.length; ++j)
                        object.revocation_list[j] = options.bytes === String ? $util.base64.encode(message.revocation_list[j], 0, message.revocation_list[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.revocation_list[j]) : message.revocation_list[j];
                }
                if (message.signing_identity != null && message.hasOwnProperty("signing_identity"))
                    object.signing_identity = $root.msp.SigningIdentityInfo.toObject(message.signing_identity, options);
                if (message.organizational_unit_identifiers && message.organizational_unit_identifiers.length) {
                    object.organizational_unit_identifiers = [];
                    for (var j = 0; j < message.organizational_unit_identifiers.length; ++j)
                        object.organizational_unit_identifiers[j] = $root.msp.FabricOUIdentifier.toObject(message.organizational_unit_identifiers[j], options);
                }
                if (message.crypto_config != null && message.hasOwnProperty("crypto_config"))
                    object.crypto_config = $root.msp.FabricCryptoConfig.toObject(message.crypto_config, options);
                if (message.tls_root_certs && message.tls_root_certs.length) {
                    object.tls_root_certs = [];
                    for (var j = 0; j < message.tls_root_certs.length; ++j)
                        object.tls_root_certs[j] = options.bytes === String ? $util.base64.encode(message.tls_root_certs[j], 0, message.tls_root_certs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.tls_root_certs[j]) : message.tls_root_certs[j];
                }
                if (message.tls_intermediate_certs && message.tls_intermediate_certs.length) {
                    object.tls_intermediate_certs = [];
                    for (var j = 0; j < message.tls_intermediate_certs.length; ++j)
                        object.tls_intermediate_certs[j] = options.bytes === String ? $util.base64.encode(message.tls_intermediate_certs[j], 0, message.tls_intermediate_certs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.tls_intermediate_certs[j]) : message.tls_intermediate_certs[j];
                }
                if (message.fabric_node_ous != null && message.hasOwnProperty("fabric_node_ous"))
                    object.fabric_node_ous = $root.msp.FabricNodeOUs.toObject(message.fabric_node_ous, options);
                return object;
            };
    
            /**
             * Converts this FabricMSPConfig to JSON.
             * @function toJSON
             * @memberof msp.FabricMSPConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FabricMSPConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FabricMSPConfig;
        })();
    
        msp.FabricCryptoConfig = (function() {
    
            /**
             * Properties of a FabricCryptoConfig.
             * @memberof msp
             * @interface IFabricCryptoConfig
             * @property {string|null} [signature_hash_family] FabricCryptoConfig signature_hash_family
             * @property {string|null} [identity_identifier_hash_function] FabricCryptoConfig identity_identifier_hash_function
             */
    
            /**
             * Constructs a new FabricCryptoConfig.
             * @memberof msp
             * @classdesc Represents a FabricCryptoConfig.
             * @implements IFabricCryptoConfig
             * @constructor
             * @param {msp.IFabricCryptoConfig=} [properties] Properties to set
             */
            function FabricCryptoConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FabricCryptoConfig signature_hash_family.
             * @member {string} signature_hash_family
             * @memberof msp.FabricCryptoConfig
             * @instance
             */
            FabricCryptoConfig.prototype.signature_hash_family = "";
    
            /**
             * FabricCryptoConfig identity_identifier_hash_function.
             * @member {string} identity_identifier_hash_function
             * @memberof msp.FabricCryptoConfig
             * @instance
             */
            FabricCryptoConfig.prototype.identity_identifier_hash_function = "";
    
            /**
             * Creates a new FabricCryptoConfig instance using the specified properties.
             * @function create
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {msp.IFabricCryptoConfig=} [properties] Properties to set
             * @returns {msp.FabricCryptoConfig} FabricCryptoConfig instance
             */
            FabricCryptoConfig.create = function create(properties) {
                return new FabricCryptoConfig(properties);
            };
    
            /**
             * Encodes the specified FabricCryptoConfig message. Does not implicitly {@link msp.FabricCryptoConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {msp.IFabricCryptoConfig} message FabricCryptoConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricCryptoConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signature_hash_family != null && Object.hasOwnProperty.call(message, "signature_hash_family"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.signature_hash_family);
                if (message.identity_identifier_hash_function != null && Object.hasOwnProperty.call(message, "identity_identifier_hash_function"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.identity_identifier_hash_function);
                return writer;
            };
    
            /**
             * Encodes the specified FabricCryptoConfig message, length delimited. Does not implicitly {@link msp.FabricCryptoConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {msp.IFabricCryptoConfig} message FabricCryptoConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricCryptoConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FabricCryptoConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.FabricCryptoConfig} FabricCryptoConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricCryptoConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.FabricCryptoConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signature_hash_family = reader.string();
                        break;
                    case 2:
                        message.identity_identifier_hash_function = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FabricCryptoConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.FabricCryptoConfig} FabricCryptoConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricCryptoConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FabricCryptoConfig message.
             * @function verify
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FabricCryptoConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.signature_hash_family != null && message.hasOwnProperty("signature_hash_family"))
                    if (!$util.isString(message.signature_hash_family))
                        return "signature_hash_family: string expected";
                if (message.identity_identifier_hash_function != null && message.hasOwnProperty("identity_identifier_hash_function"))
                    if (!$util.isString(message.identity_identifier_hash_function))
                        return "identity_identifier_hash_function: string expected";
                return null;
            };
    
            /**
             * Creates a FabricCryptoConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.FabricCryptoConfig} FabricCryptoConfig
             */
            FabricCryptoConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.FabricCryptoConfig)
                    return object;
                var message = new $root.msp.FabricCryptoConfig();
                if (object.signature_hash_family != null)
                    message.signature_hash_family = String(object.signature_hash_family);
                if (object.identity_identifier_hash_function != null)
                    message.identity_identifier_hash_function = String(object.identity_identifier_hash_function);
                return message;
            };
    
            /**
             * Creates a plain object from a FabricCryptoConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {msp.FabricCryptoConfig} message FabricCryptoConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FabricCryptoConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.signature_hash_family = "";
                    object.identity_identifier_hash_function = "";
                }
                if (message.signature_hash_family != null && message.hasOwnProperty("signature_hash_family"))
                    object.signature_hash_family = message.signature_hash_family;
                if (message.identity_identifier_hash_function != null && message.hasOwnProperty("identity_identifier_hash_function"))
                    object.identity_identifier_hash_function = message.identity_identifier_hash_function;
                return object;
            };
    
            /**
             * Converts this FabricCryptoConfig to JSON.
             * @function toJSON
             * @memberof msp.FabricCryptoConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FabricCryptoConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FabricCryptoConfig;
        })();
    
        msp.IdemixMSPConfig = (function() {
    
            /**
             * Properties of an IdemixMSPConfig.
             * @memberof msp
             * @interface IIdemixMSPConfig
             * @property {string|null} [name] IdemixMSPConfig name
             * @property {Uint8Array|null} [ipk] IdemixMSPConfig ipk
             * @property {msp.IIdemixMSPSignerConfig|null} [signer] IdemixMSPConfig signer
             * @property {Uint8Array|null} [revocation_pk] IdemixMSPConfig revocation_pk
             * @property {number|Long|null} [epoch] IdemixMSPConfig epoch
             */
    
            /**
             * Constructs a new IdemixMSPConfig.
             * @memberof msp
             * @classdesc Represents an IdemixMSPConfig.
             * @implements IIdemixMSPConfig
             * @constructor
             * @param {msp.IIdemixMSPConfig=} [properties] Properties to set
             */
            function IdemixMSPConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * IdemixMSPConfig name.
             * @member {string} name
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.name = "";
    
            /**
             * IdemixMSPConfig ipk.
             * @member {Uint8Array} ipk
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.ipk = $util.newBuffer([]);
    
            /**
             * IdemixMSPConfig signer.
             * @member {msp.IIdemixMSPSignerConfig|null|undefined} signer
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.signer = null;
    
            /**
             * IdemixMSPConfig revocation_pk.
             * @member {Uint8Array} revocation_pk
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.revocation_pk = $util.newBuffer([]);
    
            /**
             * IdemixMSPConfig epoch.
             * @member {number|Long} epoch
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.epoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new IdemixMSPConfig instance using the specified properties.
             * @function create
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {msp.IIdemixMSPConfig=} [properties] Properties to set
             * @returns {msp.IdemixMSPConfig} IdemixMSPConfig instance
             */
            IdemixMSPConfig.create = function create(properties) {
                return new IdemixMSPConfig(properties);
            };
    
            /**
             * Encodes the specified IdemixMSPConfig message. Does not implicitly {@link msp.IdemixMSPConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {msp.IIdemixMSPConfig} message IdemixMSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdemixMSPConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.ipk != null && Object.hasOwnProperty.call(message, "ipk"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ipk);
                if (message.signer != null && Object.hasOwnProperty.call(message, "signer"))
                    $root.msp.IdemixMSPSignerConfig.encode(message.signer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.revocation_pk != null && Object.hasOwnProperty.call(message, "revocation_pk"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.revocation_pk);
                if (message.epoch != null && Object.hasOwnProperty.call(message, "epoch"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.epoch);
                return writer;
            };
    
            /**
             * Encodes the specified IdemixMSPConfig message, length delimited. Does not implicitly {@link msp.IdemixMSPConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {msp.IIdemixMSPConfig} message IdemixMSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdemixMSPConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an IdemixMSPConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.IdemixMSPConfig} IdemixMSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdemixMSPConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.IdemixMSPConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.ipk = reader.bytes();
                        break;
                    case 3:
                        message.signer = $root.msp.IdemixMSPSignerConfig.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.revocation_pk = reader.bytes();
                        break;
                    case 5:
                        message.epoch = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an IdemixMSPConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.IdemixMSPConfig} IdemixMSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdemixMSPConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an IdemixMSPConfig message.
             * @function verify
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IdemixMSPConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.ipk != null && message.hasOwnProperty("ipk"))
                    if (!(message.ipk && typeof message.ipk.length === "number" || $util.isString(message.ipk)))
                        return "ipk: buffer expected";
                if (message.signer != null && message.hasOwnProperty("signer")) {
                    var error = $root.msp.IdemixMSPSignerConfig.verify(message.signer);
                    if (error)
                        return "signer." + error;
                }
                if (message.revocation_pk != null && message.hasOwnProperty("revocation_pk"))
                    if (!(message.revocation_pk && typeof message.revocation_pk.length === "number" || $util.isString(message.revocation_pk)))
                        return "revocation_pk: buffer expected";
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (!$util.isInteger(message.epoch) && !(message.epoch && $util.isInteger(message.epoch.low) && $util.isInteger(message.epoch.high)))
                        return "epoch: integer|Long expected";
                return null;
            };
    
            /**
             * Creates an IdemixMSPConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.IdemixMSPConfig} IdemixMSPConfig
             */
            IdemixMSPConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.IdemixMSPConfig)
                    return object;
                var message = new $root.msp.IdemixMSPConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.ipk != null)
                    if (typeof object.ipk === "string")
                        $util.base64.decode(object.ipk, message.ipk = $util.newBuffer($util.base64.length(object.ipk)), 0);
                    else if (object.ipk.length)
                        message.ipk = object.ipk;
                if (object.signer != null) {
                    if (typeof object.signer !== "object")
                        throw TypeError(".msp.IdemixMSPConfig.signer: object expected");
                    message.signer = $root.msp.IdemixMSPSignerConfig.fromObject(object.signer);
                }
                if (object.revocation_pk != null)
                    if (typeof object.revocation_pk === "string")
                        $util.base64.decode(object.revocation_pk, message.revocation_pk = $util.newBuffer($util.base64.length(object.revocation_pk)), 0);
                    else if (object.revocation_pk.length)
                        message.revocation_pk = object.revocation_pk;
                if (object.epoch != null)
                    if ($util.Long)
                        (message.epoch = $util.Long.fromValue(object.epoch)).unsigned = false;
                    else if (typeof object.epoch === "string")
                        message.epoch = parseInt(object.epoch, 10);
                    else if (typeof object.epoch === "number")
                        message.epoch = object.epoch;
                    else if (typeof object.epoch === "object")
                        message.epoch = new $util.LongBits(object.epoch.low >>> 0, object.epoch.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from an IdemixMSPConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {msp.IdemixMSPConfig} message IdemixMSPConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IdemixMSPConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if (options.bytes === String)
                        object.ipk = "";
                    else {
                        object.ipk = [];
                        if (options.bytes !== Array)
                            object.ipk = $util.newBuffer(object.ipk);
                    }
                    object.signer = null;
                    if (options.bytes === String)
                        object.revocation_pk = "";
                    else {
                        object.revocation_pk = [];
                        if (options.bytes !== Array)
                            object.revocation_pk = $util.newBuffer(object.revocation_pk);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.epoch = options.longs === String ? "0" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.ipk != null && message.hasOwnProperty("ipk"))
                    object.ipk = options.bytes === String ? $util.base64.encode(message.ipk, 0, message.ipk.length) : options.bytes === Array ? Array.prototype.slice.call(message.ipk) : message.ipk;
                if (message.signer != null && message.hasOwnProperty("signer"))
                    object.signer = $root.msp.IdemixMSPSignerConfig.toObject(message.signer, options);
                if (message.revocation_pk != null && message.hasOwnProperty("revocation_pk"))
                    object.revocation_pk = options.bytes === String ? $util.base64.encode(message.revocation_pk, 0, message.revocation_pk.length) : options.bytes === Array ? Array.prototype.slice.call(message.revocation_pk) : message.revocation_pk;
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (typeof message.epoch === "number")
                        object.epoch = options.longs === String ? String(message.epoch) : message.epoch;
                    else
                        object.epoch = options.longs === String ? $util.Long.prototype.toString.call(message.epoch) : options.longs === Number ? new $util.LongBits(message.epoch.low >>> 0, message.epoch.high >>> 0).toNumber() : message.epoch;
                return object;
            };
    
            /**
             * Converts this IdemixMSPConfig to JSON.
             * @function toJSON
             * @memberof msp.IdemixMSPConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IdemixMSPConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return IdemixMSPConfig;
        })();
    
        msp.IdemixMSPSignerConfig = (function() {
    
            /**
             * Properties of an IdemixMSPSignerConfig.
             * @memberof msp
             * @interface IIdemixMSPSignerConfig
             * @property {Uint8Array|null} [cred] IdemixMSPSignerConfig cred
             * @property {Uint8Array|null} [sk] IdemixMSPSignerConfig sk
             * @property {string|null} [organizational_unit_identifier] IdemixMSPSignerConfig organizational_unit_identifier
             * @property {number|null} [role] IdemixMSPSignerConfig role
             * @property {string|null} [enrollment_id] IdemixMSPSignerConfig enrollment_id
             * @property {Uint8Array|null} [credential_revocation_information] IdemixMSPSignerConfig credential_revocation_information
             */
    
            /**
             * Constructs a new IdemixMSPSignerConfig.
             * @memberof msp
             * @classdesc Represents an IdemixMSPSignerConfig.
             * @implements IIdemixMSPSignerConfig
             * @constructor
             * @param {msp.IIdemixMSPSignerConfig=} [properties] Properties to set
             */
            function IdemixMSPSignerConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * IdemixMSPSignerConfig cred.
             * @member {Uint8Array} cred
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.cred = $util.newBuffer([]);
    
            /**
             * IdemixMSPSignerConfig sk.
             * @member {Uint8Array} sk
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.sk = $util.newBuffer([]);
    
            /**
             * IdemixMSPSignerConfig organizational_unit_identifier.
             * @member {string} organizational_unit_identifier
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.organizational_unit_identifier = "";
    
            /**
             * IdemixMSPSignerConfig role.
             * @member {number} role
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.role = 0;
    
            /**
             * IdemixMSPSignerConfig enrollment_id.
             * @member {string} enrollment_id
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.enrollment_id = "";
    
            /**
             * IdemixMSPSignerConfig credential_revocation_information.
             * @member {Uint8Array} credential_revocation_information
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.credential_revocation_information = $util.newBuffer([]);
    
            /**
             * Creates a new IdemixMSPSignerConfig instance using the specified properties.
             * @function create
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {msp.IIdemixMSPSignerConfig=} [properties] Properties to set
             * @returns {msp.IdemixMSPSignerConfig} IdemixMSPSignerConfig instance
             */
            IdemixMSPSignerConfig.create = function create(properties) {
                return new IdemixMSPSignerConfig(properties);
            };
    
            /**
             * Encodes the specified IdemixMSPSignerConfig message. Does not implicitly {@link msp.IdemixMSPSignerConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {msp.IIdemixMSPSignerConfig} message IdemixMSPSignerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdemixMSPSignerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cred != null && Object.hasOwnProperty.call(message, "cred"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cred);
                if (message.sk != null && Object.hasOwnProperty.call(message, "sk"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sk);
                if (message.organizational_unit_identifier != null && Object.hasOwnProperty.call(message, "organizational_unit_identifier"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.organizational_unit_identifier);
                if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.role);
                if (message.enrollment_id != null && Object.hasOwnProperty.call(message, "enrollment_id"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.enrollment_id);
                if (message.credential_revocation_information != null && Object.hasOwnProperty.call(message, "credential_revocation_information"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.credential_revocation_information);
                return writer;
            };
    
            /**
             * Encodes the specified IdemixMSPSignerConfig message, length delimited. Does not implicitly {@link msp.IdemixMSPSignerConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {msp.IIdemixMSPSignerConfig} message IdemixMSPSignerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdemixMSPSignerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an IdemixMSPSignerConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.IdemixMSPSignerConfig} IdemixMSPSignerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdemixMSPSignerConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.IdemixMSPSignerConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cred = reader.bytes();
                        break;
                    case 2:
                        message.sk = reader.bytes();
                        break;
                    case 3:
                        message.organizational_unit_identifier = reader.string();
                        break;
                    case 4:
                        message.role = reader.int32();
                        break;
                    case 5:
                        message.enrollment_id = reader.string();
                        break;
                    case 6:
                        message.credential_revocation_information = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an IdemixMSPSignerConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.IdemixMSPSignerConfig} IdemixMSPSignerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdemixMSPSignerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an IdemixMSPSignerConfig message.
             * @function verify
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IdemixMSPSignerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cred != null && message.hasOwnProperty("cred"))
                    if (!(message.cred && typeof message.cred.length === "number" || $util.isString(message.cred)))
                        return "cred: buffer expected";
                if (message.sk != null && message.hasOwnProperty("sk"))
                    if (!(message.sk && typeof message.sk.length === "number" || $util.isString(message.sk)))
                        return "sk: buffer expected";
                if (message.organizational_unit_identifier != null && message.hasOwnProperty("organizational_unit_identifier"))
                    if (!$util.isString(message.organizational_unit_identifier))
                        return "organizational_unit_identifier: string expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    if (!$util.isInteger(message.role))
                        return "role: integer expected";
                if (message.enrollment_id != null && message.hasOwnProperty("enrollment_id"))
                    if (!$util.isString(message.enrollment_id))
                        return "enrollment_id: string expected";
                if (message.credential_revocation_information != null && message.hasOwnProperty("credential_revocation_information"))
                    if (!(message.credential_revocation_information && typeof message.credential_revocation_information.length === "number" || $util.isString(message.credential_revocation_information)))
                        return "credential_revocation_information: buffer expected";
                return null;
            };
    
            /**
             * Creates an IdemixMSPSignerConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.IdemixMSPSignerConfig} IdemixMSPSignerConfig
             */
            IdemixMSPSignerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.IdemixMSPSignerConfig)
                    return object;
                var message = new $root.msp.IdemixMSPSignerConfig();
                if (object.cred != null)
                    if (typeof object.cred === "string")
                        $util.base64.decode(object.cred, message.cred = $util.newBuffer($util.base64.length(object.cred)), 0);
                    else if (object.cred.length)
                        message.cred = object.cred;
                if (object.sk != null)
                    if (typeof object.sk === "string")
                        $util.base64.decode(object.sk, message.sk = $util.newBuffer($util.base64.length(object.sk)), 0);
                    else if (object.sk.length)
                        message.sk = object.sk;
                if (object.organizational_unit_identifier != null)
                    message.organizational_unit_identifier = String(object.organizational_unit_identifier);
                if (object.role != null)
                    message.role = object.role | 0;
                if (object.enrollment_id != null)
                    message.enrollment_id = String(object.enrollment_id);
                if (object.credential_revocation_information != null)
                    if (typeof object.credential_revocation_information === "string")
                        $util.base64.decode(object.credential_revocation_information, message.credential_revocation_information = $util.newBuffer($util.base64.length(object.credential_revocation_information)), 0);
                    else if (object.credential_revocation_information.length)
                        message.credential_revocation_information = object.credential_revocation_information;
                return message;
            };
    
            /**
             * Creates a plain object from an IdemixMSPSignerConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {msp.IdemixMSPSignerConfig} message IdemixMSPSignerConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IdemixMSPSignerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.cred = "";
                    else {
                        object.cred = [];
                        if (options.bytes !== Array)
                            object.cred = $util.newBuffer(object.cred);
                    }
                    if (options.bytes === String)
                        object.sk = "";
                    else {
                        object.sk = [];
                        if (options.bytes !== Array)
                            object.sk = $util.newBuffer(object.sk);
                    }
                    object.organizational_unit_identifier = "";
                    object.role = 0;
                    object.enrollment_id = "";
                    if (options.bytes === String)
                        object.credential_revocation_information = "";
                    else {
                        object.credential_revocation_information = [];
                        if (options.bytes !== Array)
                            object.credential_revocation_information = $util.newBuffer(object.credential_revocation_information);
                    }
                }
                if (message.cred != null && message.hasOwnProperty("cred"))
                    object.cred = options.bytes === String ? $util.base64.encode(message.cred, 0, message.cred.length) : options.bytes === Array ? Array.prototype.slice.call(message.cred) : message.cred;
                if (message.sk != null && message.hasOwnProperty("sk"))
                    object.sk = options.bytes === String ? $util.base64.encode(message.sk, 0, message.sk.length) : options.bytes === Array ? Array.prototype.slice.call(message.sk) : message.sk;
                if (message.organizational_unit_identifier != null && message.hasOwnProperty("organizational_unit_identifier"))
                    object.organizational_unit_identifier = message.organizational_unit_identifier;
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = message.role;
                if (message.enrollment_id != null && message.hasOwnProperty("enrollment_id"))
                    object.enrollment_id = message.enrollment_id;
                if (message.credential_revocation_information != null && message.hasOwnProperty("credential_revocation_information"))
                    object.credential_revocation_information = options.bytes === String ? $util.base64.encode(message.credential_revocation_information, 0, message.credential_revocation_information.length) : options.bytes === Array ? Array.prototype.slice.call(message.credential_revocation_information) : message.credential_revocation_information;
                return object;
            };
    
            /**
             * Converts this IdemixMSPSignerConfig to JSON.
             * @function toJSON
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IdemixMSPSignerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return IdemixMSPSignerConfig;
        })();
    
        msp.SigningIdentityInfo = (function() {
    
            /**
             * Properties of a SigningIdentityInfo.
             * @memberof msp
             * @interface ISigningIdentityInfo
             * @property {Uint8Array|null} [public_signer] SigningIdentityInfo public_signer
             * @property {msp.IKeyInfo|null} [private_signer] SigningIdentityInfo private_signer
             */
    
            /**
             * Constructs a new SigningIdentityInfo.
             * @memberof msp
             * @classdesc Represents a SigningIdentityInfo.
             * @implements ISigningIdentityInfo
             * @constructor
             * @param {msp.ISigningIdentityInfo=} [properties] Properties to set
             */
            function SigningIdentityInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SigningIdentityInfo public_signer.
             * @member {Uint8Array} public_signer
             * @memberof msp.SigningIdentityInfo
             * @instance
             */
            SigningIdentityInfo.prototype.public_signer = $util.newBuffer([]);
    
            /**
             * SigningIdentityInfo private_signer.
             * @member {msp.IKeyInfo|null|undefined} private_signer
             * @memberof msp.SigningIdentityInfo
             * @instance
             */
            SigningIdentityInfo.prototype.private_signer = null;
    
            /**
             * Creates a new SigningIdentityInfo instance using the specified properties.
             * @function create
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {msp.ISigningIdentityInfo=} [properties] Properties to set
             * @returns {msp.SigningIdentityInfo} SigningIdentityInfo instance
             */
            SigningIdentityInfo.create = function create(properties) {
                return new SigningIdentityInfo(properties);
            };
    
            /**
             * Encodes the specified SigningIdentityInfo message. Does not implicitly {@link msp.SigningIdentityInfo.verify|verify} messages.
             * @function encode
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {msp.ISigningIdentityInfo} message SigningIdentityInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SigningIdentityInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.public_signer != null && Object.hasOwnProperty.call(message, "public_signer"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.public_signer);
                if (message.private_signer != null && Object.hasOwnProperty.call(message, "private_signer"))
                    $root.msp.KeyInfo.encode(message.private_signer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SigningIdentityInfo message, length delimited. Does not implicitly {@link msp.SigningIdentityInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {msp.ISigningIdentityInfo} message SigningIdentityInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SigningIdentityInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SigningIdentityInfo message from the specified reader or buffer.
             * @function decode
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.SigningIdentityInfo} SigningIdentityInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SigningIdentityInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.SigningIdentityInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.public_signer = reader.bytes();
                        break;
                    case 2:
                        message.private_signer = $root.msp.KeyInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SigningIdentityInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.SigningIdentityInfo} SigningIdentityInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SigningIdentityInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SigningIdentityInfo message.
             * @function verify
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SigningIdentityInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.public_signer != null && message.hasOwnProperty("public_signer"))
                    if (!(message.public_signer && typeof message.public_signer.length === "number" || $util.isString(message.public_signer)))
                        return "public_signer: buffer expected";
                if (message.private_signer != null && message.hasOwnProperty("private_signer")) {
                    var error = $root.msp.KeyInfo.verify(message.private_signer);
                    if (error)
                        return "private_signer." + error;
                }
                return null;
            };
    
            /**
             * Creates a SigningIdentityInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.SigningIdentityInfo} SigningIdentityInfo
             */
            SigningIdentityInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.SigningIdentityInfo)
                    return object;
                var message = new $root.msp.SigningIdentityInfo();
                if (object.public_signer != null)
                    if (typeof object.public_signer === "string")
                        $util.base64.decode(object.public_signer, message.public_signer = $util.newBuffer($util.base64.length(object.public_signer)), 0);
                    else if (object.public_signer.length)
                        message.public_signer = object.public_signer;
                if (object.private_signer != null) {
                    if (typeof object.private_signer !== "object")
                        throw TypeError(".msp.SigningIdentityInfo.private_signer: object expected");
                    message.private_signer = $root.msp.KeyInfo.fromObject(object.private_signer);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SigningIdentityInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {msp.SigningIdentityInfo} message SigningIdentityInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SigningIdentityInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.public_signer = "";
                    else {
                        object.public_signer = [];
                        if (options.bytes !== Array)
                            object.public_signer = $util.newBuffer(object.public_signer);
                    }
                    object.private_signer = null;
                }
                if (message.public_signer != null && message.hasOwnProperty("public_signer"))
                    object.public_signer = options.bytes === String ? $util.base64.encode(message.public_signer, 0, message.public_signer.length) : options.bytes === Array ? Array.prototype.slice.call(message.public_signer) : message.public_signer;
                if (message.private_signer != null && message.hasOwnProperty("private_signer"))
                    object.private_signer = $root.msp.KeyInfo.toObject(message.private_signer, options);
                return object;
            };
    
            /**
             * Converts this SigningIdentityInfo to JSON.
             * @function toJSON
             * @memberof msp.SigningIdentityInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SigningIdentityInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SigningIdentityInfo;
        })();
    
        msp.KeyInfo = (function() {
    
            /**
             * Properties of a KeyInfo.
             * @memberof msp
             * @interface IKeyInfo
             * @property {string|null} [key_identifier] KeyInfo key_identifier
             * @property {Uint8Array|null} [key_material] KeyInfo key_material
             */
    
            /**
             * Constructs a new KeyInfo.
             * @memberof msp
             * @classdesc Represents a KeyInfo.
             * @implements IKeyInfo
             * @constructor
             * @param {msp.IKeyInfo=} [properties] Properties to set
             */
            function KeyInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KeyInfo key_identifier.
             * @member {string} key_identifier
             * @memberof msp.KeyInfo
             * @instance
             */
            KeyInfo.prototype.key_identifier = "";
    
            /**
             * KeyInfo key_material.
             * @member {Uint8Array} key_material
             * @memberof msp.KeyInfo
             * @instance
             */
            KeyInfo.prototype.key_material = $util.newBuffer([]);
    
            /**
             * Creates a new KeyInfo instance using the specified properties.
             * @function create
             * @memberof msp.KeyInfo
             * @static
             * @param {msp.IKeyInfo=} [properties] Properties to set
             * @returns {msp.KeyInfo} KeyInfo instance
             */
            KeyInfo.create = function create(properties) {
                return new KeyInfo(properties);
            };
    
            /**
             * Encodes the specified KeyInfo message. Does not implicitly {@link msp.KeyInfo.verify|verify} messages.
             * @function encode
             * @memberof msp.KeyInfo
             * @static
             * @param {msp.IKeyInfo} message KeyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key_identifier != null && Object.hasOwnProperty.call(message, "key_identifier"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key_identifier);
                if (message.key_material != null && Object.hasOwnProperty.call(message, "key_material"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key_material);
                return writer;
            };
    
            /**
             * Encodes the specified KeyInfo message, length delimited. Does not implicitly {@link msp.KeyInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.KeyInfo
             * @static
             * @param {msp.IKeyInfo} message KeyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KeyInfo message from the specified reader or buffer.
             * @function decode
             * @memberof msp.KeyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.KeyInfo} KeyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.KeyInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key_identifier = reader.string();
                        break;
                    case 2:
                        message.key_material = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KeyInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.KeyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.KeyInfo} KeyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KeyInfo message.
             * @function verify
             * @memberof msp.KeyInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key_identifier != null && message.hasOwnProperty("key_identifier"))
                    if (!$util.isString(message.key_identifier))
                        return "key_identifier: string expected";
                if (message.key_material != null && message.hasOwnProperty("key_material"))
                    if (!(message.key_material && typeof message.key_material.length === "number" || $util.isString(message.key_material)))
                        return "key_material: buffer expected";
                return null;
            };
    
            /**
             * Creates a KeyInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.KeyInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.KeyInfo} KeyInfo
             */
            KeyInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.KeyInfo)
                    return object;
                var message = new $root.msp.KeyInfo();
                if (object.key_identifier != null)
                    message.key_identifier = String(object.key_identifier);
                if (object.key_material != null)
                    if (typeof object.key_material === "string")
                        $util.base64.decode(object.key_material, message.key_material = $util.newBuffer($util.base64.length(object.key_material)), 0);
                    else if (object.key_material.length)
                        message.key_material = object.key_material;
                return message;
            };
    
            /**
             * Creates a plain object from a KeyInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.KeyInfo
             * @static
             * @param {msp.KeyInfo} message KeyInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key_identifier = "";
                    if (options.bytes === String)
                        object.key_material = "";
                    else {
                        object.key_material = [];
                        if (options.bytes !== Array)
                            object.key_material = $util.newBuffer(object.key_material);
                    }
                }
                if (message.key_identifier != null && message.hasOwnProperty("key_identifier"))
                    object.key_identifier = message.key_identifier;
                if (message.key_material != null && message.hasOwnProperty("key_material"))
                    object.key_material = options.bytes === String ? $util.base64.encode(message.key_material, 0, message.key_material.length) : options.bytes === Array ? Array.prototype.slice.call(message.key_material) : message.key_material;
                return object;
            };
    
            /**
             * Converts this KeyInfo to JSON.
             * @function toJSON
             * @memberof msp.KeyInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KeyInfo;
        })();
    
        msp.FabricOUIdentifier = (function() {
    
            /**
             * Properties of a FabricOUIdentifier.
             * @memberof msp
             * @interface IFabricOUIdentifier
             * @property {Uint8Array|null} [certificate] FabricOUIdentifier certificate
             * @property {string|null} [organizational_unit_identifier] FabricOUIdentifier organizational_unit_identifier
             */
    
            /**
             * Constructs a new FabricOUIdentifier.
             * @memberof msp
             * @classdesc Represents a FabricOUIdentifier.
             * @implements IFabricOUIdentifier
             * @constructor
             * @param {msp.IFabricOUIdentifier=} [properties] Properties to set
             */
            function FabricOUIdentifier(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FabricOUIdentifier certificate.
             * @member {Uint8Array} certificate
             * @memberof msp.FabricOUIdentifier
             * @instance
             */
            FabricOUIdentifier.prototype.certificate = $util.newBuffer([]);
    
            /**
             * FabricOUIdentifier organizational_unit_identifier.
             * @member {string} organizational_unit_identifier
             * @memberof msp.FabricOUIdentifier
             * @instance
             */
            FabricOUIdentifier.prototype.organizational_unit_identifier = "";
    
            /**
             * Creates a new FabricOUIdentifier instance using the specified properties.
             * @function create
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {msp.IFabricOUIdentifier=} [properties] Properties to set
             * @returns {msp.FabricOUIdentifier} FabricOUIdentifier instance
             */
            FabricOUIdentifier.create = function create(properties) {
                return new FabricOUIdentifier(properties);
            };
    
            /**
             * Encodes the specified FabricOUIdentifier message. Does not implicitly {@link msp.FabricOUIdentifier.verify|verify} messages.
             * @function encode
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {msp.IFabricOUIdentifier} message FabricOUIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricOUIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.certificate);
                if (message.organizational_unit_identifier != null && Object.hasOwnProperty.call(message, "organizational_unit_identifier"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.organizational_unit_identifier);
                return writer;
            };
    
            /**
             * Encodes the specified FabricOUIdentifier message, length delimited. Does not implicitly {@link msp.FabricOUIdentifier.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {msp.IFabricOUIdentifier} message FabricOUIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricOUIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FabricOUIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.FabricOUIdentifier} FabricOUIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricOUIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.FabricOUIdentifier();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.certificate = reader.bytes();
                        break;
                    case 2:
                        message.organizational_unit_identifier = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FabricOUIdentifier message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.FabricOUIdentifier} FabricOUIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricOUIdentifier.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FabricOUIdentifier message.
             * @function verify
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FabricOUIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.certificate != null && message.hasOwnProperty("certificate"))
                    if (!(message.certificate && typeof message.certificate.length === "number" || $util.isString(message.certificate)))
                        return "certificate: buffer expected";
                if (message.organizational_unit_identifier != null && message.hasOwnProperty("organizational_unit_identifier"))
                    if (!$util.isString(message.organizational_unit_identifier))
                        return "organizational_unit_identifier: string expected";
                return null;
            };
    
            /**
             * Creates a FabricOUIdentifier message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.FabricOUIdentifier} FabricOUIdentifier
             */
            FabricOUIdentifier.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.FabricOUIdentifier)
                    return object;
                var message = new $root.msp.FabricOUIdentifier();
                if (object.certificate != null)
                    if (typeof object.certificate === "string")
                        $util.base64.decode(object.certificate, message.certificate = $util.newBuffer($util.base64.length(object.certificate)), 0);
                    else if (object.certificate.length)
                        message.certificate = object.certificate;
                if (object.organizational_unit_identifier != null)
                    message.organizational_unit_identifier = String(object.organizational_unit_identifier);
                return message;
            };
    
            /**
             * Creates a plain object from a FabricOUIdentifier message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {msp.FabricOUIdentifier} message FabricOUIdentifier
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FabricOUIdentifier.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.certificate = "";
                    else {
                        object.certificate = [];
                        if (options.bytes !== Array)
                            object.certificate = $util.newBuffer(object.certificate);
                    }
                    object.organizational_unit_identifier = "";
                }
                if (message.certificate != null && message.hasOwnProperty("certificate"))
                    object.certificate = options.bytes === String ? $util.base64.encode(message.certificate, 0, message.certificate.length) : options.bytes === Array ? Array.prototype.slice.call(message.certificate) : message.certificate;
                if (message.organizational_unit_identifier != null && message.hasOwnProperty("organizational_unit_identifier"))
                    object.organizational_unit_identifier = message.organizational_unit_identifier;
                return object;
            };
    
            /**
             * Converts this FabricOUIdentifier to JSON.
             * @function toJSON
             * @memberof msp.FabricOUIdentifier
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FabricOUIdentifier.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FabricOUIdentifier;
        })();
    
        msp.FabricNodeOUs = (function() {
    
            /**
             * Properties of a FabricNodeOUs.
             * @memberof msp
             * @interface IFabricNodeOUs
             * @property {boolean|null} [enable] FabricNodeOUs enable
             * @property {msp.IFabricOUIdentifier|null} [client_ou_identifier] FabricNodeOUs client_ou_identifier
             * @property {msp.IFabricOUIdentifier|null} [peer_ou_identifier] FabricNodeOUs peer_ou_identifier
             * @property {msp.IFabricOUIdentifier|null} [admin_ou_identifier] FabricNodeOUs admin_ou_identifier
             * @property {msp.IFabricOUIdentifier|null} [orderer_ou_identifier] FabricNodeOUs orderer_ou_identifier
             */
    
            /**
             * Constructs a new FabricNodeOUs.
             * @memberof msp
             * @classdesc Represents a FabricNodeOUs.
             * @implements IFabricNodeOUs
             * @constructor
             * @param {msp.IFabricNodeOUs=} [properties] Properties to set
             */
            function FabricNodeOUs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FabricNodeOUs enable.
             * @member {boolean} enable
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.enable = false;
    
            /**
             * FabricNodeOUs client_ou_identifier.
             * @member {msp.IFabricOUIdentifier|null|undefined} client_ou_identifier
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.client_ou_identifier = null;
    
            /**
             * FabricNodeOUs peer_ou_identifier.
             * @member {msp.IFabricOUIdentifier|null|undefined} peer_ou_identifier
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.peer_ou_identifier = null;
    
            /**
             * FabricNodeOUs admin_ou_identifier.
             * @member {msp.IFabricOUIdentifier|null|undefined} admin_ou_identifier
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.admin_ou_identifier = null;
    
            /**
             * FabricNodeOUs orderer_ou_identifier.
             * @member {msp.IFabricOUIdentifier|null|undefined} orderer_ou_identifier
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.orderer_ou_identifier = null;
    
            /**
             * Creates a new FabricNodeOUs instance using the specified properties.
             * @function create
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {msp.IFabricNodeOUs=} [properties] Properties to set
             * @returns {msp.FabricNodeOUs} FabricNodeOUs instance
             */
            FabricNodeOUs.create = function create(properties) {
                return new FabricNodeOUs(properties);
            };
    
            /**
             * Encodes the specified FabricNodeOUs message. Does not implicitly {@link msp.FabricNodeOUs.verify|verify} messages.
             * @function encode
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {msp.IFabricNodeOUs} message FabricNodeOUs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricNodeOUs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enable);
                if (message.client_ou_identifier != null && Object.hasOwnProperty.call(message, "client_ou_identifier"))
                    $root.msp.FabricOUIdentifier.encode(message.client_ou_identifier, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.peer_ou_identifier != null && Object.hasOwnProperty.call(message, "peer_ou_identifier"))
                    $root.msp.FabricOUIdentifier.encode(message.peer_ou_identifier, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.admin_ou_identifier != null && Object.hasOwnProperty.call(message, "admin_ou_identifier"))
                    $root.msp.FabricOUIdentifier.encode(message.admin_ou_identifier, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.orderer_ou_identifier != null && Object.hasOwnProperty.call(message, "orderer_ou_identifier"))
                    $root.msp.FabricOUIdentifier.encode(message.orderer_ou_identifier, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FabricNodeOUs message, length delimited. Does not implicitly {@link msp.FabricNodeOUs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {msp.IFabricNodeOUs} message FabricNodeOUs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricNodeOUs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FabricNodeOUs message from the specified reader or buffer.
             * @function decode
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.FabricNodeOUs} FabricNodeOUs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricNodeOUs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.FabricNodeOUs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.enable = reader.bool();
                        break;
                    case 2:
                        message.client_ou_identifier = $root.msp.FabricOUIdentifier.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.peer_ou_identifier = $root.msp.FabricOUIdentifier.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.admin_ou_identifier = $root.msp.FabricOUIdentifier.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.orderer_ou_identifier = $root.msp.FabricOUIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FabricNodeOUs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.FabricNodeOUs} FabricNodeOUs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricNodeOUs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FabricNodeOUs message.
             * @function verify
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FabricNodeOUs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enable != null && message.hasOwnProperty("enable"))
                    if (typeof message.enable !== "boolean")
                        return "enable: boolean expected";
                if (message.client_ou_identifier != null && message.hasOwnProperty("client_ou_identifier")) {
                    var error = $root.msp.FabricOUIdentifier.verify(message.client_ou_identifier);
                    if (error)
                        return "client_ou_identifier." + error;
                }
                if (message.peer_ou_identifier != null && message.hasOwnProperty("peer_ou_identifier")) {
                    var error = $root.msp.FabricOUIdentifier.verify(message.peer_ou_identifier);
                    if (error)
                        return "peer_ou_identifier." + error;
                }
                if (message.admin_ou_identifier != null && message.hasOwnProperty("admin_ou_identifier")) {
                    var error = $root.msp.FabricOUIdentifier.verify(message.admin_ou_identifier);
                    if (error)
                        return "admin_ou_identifier." + error;
                }
                if (message.orderer_ou_identifier != null && message.hasOwnProperty("orderer_ou_identifier")) {
                    var error = $root.msp.FabricOUIdentifier.verify(message.orderer_ou_identifier);
                    if (error)
                        return "orderer_ou_identifier." + error;
                }
                return null;
            };
    
            /**
             * Creates a FabricNodeOUs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.FabricNodeOUs} FabricNodeOUs
             */
            FabricNodeOUs.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.FabricNodeOUs)
                    return object;
                var message = new $root.msp.FabricNodeOUs();
                if (object.enable != null)
                    message.enable = Boolean(object.enable);
                if (object.client_ou_identifier != null) {
                    if (typeof object.client_ou_identifier !== "object")
                        throw TypeError(".msp.FabricNodeOUs.client_ou_identifier: object expected");
                    message.client_ou_identifier = $root.msp.FabricOUIdentifier.fromObject(object.client_ou_identifier);
                }
                if (object.peer_ou_identifier != null) {
                    if (typeof object.peer_ou_identifier !== "object")
                        throw TypeError(".msp.FabricNodeOUs.peer_ou_identifier: object expected");
                    message.peer_ou_identifier = $root.msp.FabricOUIdentifier.fromObject(object.peer_ou_identifier);
                }
                if (object.admin_ou_identifier != null) {
                    if (typeof object.admin_ou_identifier !== "object")
                        throw TypeError(".msp.FabricNodeOUs.admin_ou_identifier: object expected");
                    message.admin_ou_identifier = $root.msp.FabricOUIdentifier.fromObject(object.admin_ou_identifier);
                }
                if (object.orderer_ou_identifier != null) {
                    if (typeof object.orderer_ou_identifier !== "object")
                        throw TypeError(".msp.FabricNodeOUs.orderer_ou_identifier: object expected");
                    message.orderer_ou_identifier = $root.msp.FabricOUIdentifier.fromObject(object.orderer_ou_identifier);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FabricNodeOUs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {msp.FabricNodeOUs} message FabricNodeOUs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FabricNodeOUs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enable = false;
                    object.client_ou_identifier = null;
                    object.peer_ou_identifier = null;
                    object.admin_ou_identifier = null;
                    object.orderer_ou_identifier = null;
                }
                if (message.enable != null && message.hasOwnProperty("enable"))
                    object.enable = message.enable;
                if (message.client_ou_identifier != null && message.hasOwnProperty("client_ou_identifier"))
                    object.client_ou_identifier = $root.msp.FabricOUIdentifier.toObject(message.client_ou_identifier, options);
                if (message.peer_ou_identifier != null && message.hasOwnProperty("peer_ou_identifier"))
                    object.peer_ou_identifier = $root.msp.FabricOUIdentifier.toObject(message.peer_ou_identifier, options);
                if (message.admin_ou_identifier != null && message.hasOwnProperty("admin_ou_identifier"))
                    object.admin_ou_identifier = $root.msp.FabricOUIdentifier.toObject(message.admin_ou_identifier, options);
                if (message.orderer_ou_identifier != null && message.hasOwnProperty("orderer_ou_identifier"))
                    object.orderer_ou_identifier = $root.msp.FabricOUIdentifier.toObject(message.orderer_ou_identifier, options);
                return object;
            };
    
            /**
             * Converts this FabricNodeOUs to JSON.
             * @function toJSON
             * @memberof msp.FabricNodeOUs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FabricNodeOUs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FabricNodeOUs;
        })();
    
        msp.SerializedIdentity = (function() {
    
            /**
             * Properties of a SerializedIdentity.
             * @memberof msp
             * @interface ISerializedIdentity
             * @property {string|null} [mspid] SerializedIdentity mspid
             * @property {Uint8Array|null} [id_bytes] SerializedIdentity id_bytes
             */
    
            /**
             * Constructs a new SerializedIdentity.
             * @memberof msp
             * @classdesc Represents a SerializedIdentity.
             * @implements ISerializedIdentity
             * @constructor
             * @param {msp.ISerializedIdentity=} [properties] Properties to set
             */
            function SerializedIdentity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SerializedIdentity mspid.
             * @member {string} mspid
             * @memberof msp.SerializedIdentity
             * @instance
             */
            SerializedIdentity.prototype.mspid = "";
    
            /**
             * SerializedIdentity id_bytes.
             * @member {Uint8Array} id_bytes
             * @memberof msp.SerializedIdentity
             * @instance
             */
            SerializedIdentity.prototype.id_bytes = $util.newBuffer([]);
    
            /**
             * Creates a new SerializedIdentity instance using the specified properties.
             * @function create
             * @memberof msp.SerializedIdentity
             * @static
             * @param {msp.ISerializedIdentity=} [properties] Properties to set
             * @returns {msp.SerializedIdentity} SerializedIdentity instance
             */
            SerializedIdentity.create = function create(properties) {
                return new SerializedIdentity(properties);
            };
    
            /**
             * Encodes the specified SerializedIdentity message. Does not implicitly {@link msp.SerializedIdentity.verify|verify} messages.
             * @function encode
             * @memberof msp.SerializedIdentity
             * @static
             * @param {msp.ISerializedIdentity} message SerializedIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializedIdentity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mspid != null && Object.hasOwnProperty.call(message, "mspid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mspid);
                if (message.id_bytes != null && Object.hasOwnProperty.call(message, "id_bytes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id_bytes);
                return writer;
            };
    
            /**
             * Encodes the specified SerializedIdentity message, length delimited. Does not implicitly {@link msp.SerializedIdentity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.SerializedIdentity
             * @static
             * @param {msp.ISerializedIdentity} message SerializedIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializedIdentity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SerializedIdentity message from the specified reader or buffer.
             * @function decode
             * @memberof msp.SerializedIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.SerializedIdentity} SerializedIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializedIdentity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.SerializedIdentity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mspid = reader.string();
                        break;
                    case 2:
                        message.id_bytes = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SerializedIdentity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.SerializedIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.SerializedIdentity} SerializedIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializedIdentity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SerializedIdentity message.
             * @function verify
             * @memberof msp.SerializedIdentity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SerializedIdentity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mspid != null && message.hasOwnProperty("mspid"))
                    if (!$util.isString(message.mspid))
                        return "mspid: string expected";
                if (message.id_bytes != null && message.hasOwnProperty("id_bytes"))
                    if (!(message.id_bytes && typeof message.id_bytes.length === "number" || $util.isString(message.id_bytes)))
                        return "id_bytes: buffer expected";
                return null;
            };
    
            /**
             * Creates a SerializedIdentity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.SerializedIdentity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.SerializedIdentity} SerializedIdentity
             */
            SerializedIdentity.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.SerializedIdentity)
                    return object;
                var message = new $root.msp.SerializedIdentity();
                if (object.mspid != null)
                    message.mspid = String(object.mspid);
                if (object.id_bytes != null)
                    if (typeof object.id_bytes === "string")
                        $util.base64.decode(object.id_bytes, message.id_bytes = $util.newBuffer($util.base64.length(object.id_bytes)), 0);
                    else if (object.id_bytes.length)
                        message.id_bytes = object.id_bytes;
                return message;
            };
    
            /**
             * Creates a plain object from a SerializedIdentity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.SerializedIdentity
             * @static
             * @param {msp.SerializedIdentity} message SerializedIdentity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SerializedIdentity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.mspid = "";
                    if (options.bytes === String)
                        object.id_bytes = "";
                    else {
                        object.id_bytes = [];
                        if (options.bytes !== Array)
                            object.id_bytes = $util.newBuffer(object.id_bytes);
                    }
                }
                if (message.mspid != null && message.hasOwnProperty("mspid"))
                    object.mspid = message.mspid;
                if (message.id_bytes != null && message.hasOwnProperty("id_bytes"))
                    object.id_bytes = options.bytes === String ? $util.base64.encode(message.id_bytes, 0, message.id_bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.id_bytes) : message.id_bytes;
                return object;
            };
    
            /**
             * Converts this SerializedIdentity to JSON.
             * @function toJSON
             * @memberof msp.SerializedIdentity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SerializedIdentity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SerializedIdentity;
        })();
    
        msp.SerializedIdemixIdentity = (function() {
    
            /**
             * Properties of a SerializedIdemixIdentity.
             * @memberof msp
             * @interface ISerializedIdemixIdentity
             * @property {Uint8Array|null} [nym_x] SerializedIdemixIdentity nym_x
             * @property {Uint8Array|null} [nym_y] SerializedIdemixIdentity nym_y
             * @property {Uint8Array|null} [ou] SerializedIdemixIdentity ou
             * @property {Uint8Array|null} [role] SerializedIdemixIdentity role
             * @property {Uint8Array|null} [proof] SerializedIdemixIdentity proof
             */
    
            /**
             * Constructs a new SerializedIdemixIdentity.
             * @memberof msp
             * @classdesc Represents a SerializedIdemixIdentity.
             * @implements ISerializedIdemixIdentity
             * @constructor
             * @param {msp.ISerializedIdemixIdentity=} [properties] Properties to set
             */
            function SerializedIdemixIdentity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SerializedIdemixIdentity nym_x.
             * @member {Uint8Array} nym_x
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.nym_x = $util.newBuffer([]);
    
            /**
             * SerializedIdemixIdentity nym_y.
             * @member {Uint8Array} nym_y
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.nym_y = $util.newBuffer([]);
    
            /**
             * SerializedIdemixIdentity ou.
             * @member {Uint8Array} ou
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.ou = $util.newBuffer([]);
    
            /**
             * SerializedIdemixIdentity role.
             * @member {Uint8Array} role
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.role = $util.newBuffer([]);
    
            /**
             * SerializedIdemixIdentity proof.
             * @member {Uint8Array} proof
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.proof = $util.newBuffer([]);
    
            /**
             * Creates a new SerializedIdemixIdentity instance using the specified properties.
             * @function create
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {msp.ISerializedIdemixIdentity=} [properties] Properties to set
             * @returns {msp.SerializedIdemixIdentity} SerializedIdemixIdentity instance
             */
            SerializedIdemixIdentity.create = function create(properties) {
                return new SerializedIdemixIdentity(properties);
            };
    
            /**
             * Encodes the specified SerializedIdemixIdentity message. Does not implicitly {@link msp.SerializedIdemixIdentity.verify|verify} messages.
             * @function encode
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {msp.ISerializedIdemixIdentity} message SerializedIdemixIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializedIdemixIdentity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nym_x != null && Object.hasOwnProperty.call(message, "nym_x"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nym_x);
                if (message.nym_y != null && Object.hasOwnProperty.call(message, "nym_y"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nym_y);
                if (message.ou != null && Object.hasOwnProperty.call(message, "ou"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ou);
                if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.role);
                if (message.proof != null && Object.hasOwnProperty.call(message, "proof"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.proof);
                return writer;
            };
    
            /**
             * Encodes the specified SerializedIdemixIdentity message, length delimited. Does not implicitly {@link msp.SerializedIdemixIdentity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {msp.ISerializedIdemixIdentity} message SerializedIdemixIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializedIdemixIdentity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SerializedIdemixIdentity message from the specified reader or buffer.
             * @function decode
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.SerializedIdemixIdentity} SerializedIdemixIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializedIdemixIdentity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.SerializedIdemixIdentity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nym_x = reader.bytes();
                        break;
                    case 2:
                        message.nym_y = reader.bytes();
                        break;
                    case 3:
                        message.ou = reader.bytes();
                        break;
                    case 4:
                        message.role = reader.bytes();
                        break;
                    case 5:
                        message.proof = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SerializedIdemixIdentity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.SerializedIdemixIdentity} SerializedIdemixIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializedIdemixIdentity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SerializedIdemixIdentity message.
             * @function verify
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SerializedIdemixIdentity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nym_x != null && message.hasOwnProperty("nym_x"))
                    if (!(message.nym_x && typeof message.nym_x.length === "number" || $util.isString(message.nym_x)))
                        return "nym_x: buffer expected";
                if (message.nym_y != null && message.hasOwnProperty("nym_y"))
                    if (!(message.nym_y && typeof message.nym_y.length === "number" || $util.isString(message.nym_y)))
                        return "nym_y: buffer expected";
                if (message.ou != null && message.hasOwnProperty("ou"))
                    if (!(message.ou && typeof message.ou.length === "number" || $util.isString(message.ou)))
                        return "ou: buffer expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    if (!(message.role && typeof message.role.length === "number" || $util.isString(message.role)))
                        return "role: buffer expected";
                if (message.proof != null && message.hasOwnProperty("proof"))
                    if (!(message.proof && typeof message.proof.length === "number" || $util.isString(message.proof)))
                        return "proof: buffer expected";
                return null;
            };
    
            /**
             * Creates a SerializedIdemixIdentity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.SerializedIdemixIdentity} SerializedIdemixIdentity
             */
            SerializedIdemixIdentity.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.SerializedIdemixIdentity)
                    return object;
                var message = new $root.msp.SerializedIdemixIdentity();
                if (object.nym_x != null)
                    if (typeof object.nym_x === "string")
                        $util.base64.decode(object.nym_x, message.nym_x = $util.newBuffer($util.base64.length(object.nym_x)), 0);
                    else if (object.nym_x.length)
                        message.nym_x = object.nym_x;
                if (object.nym_y != null)
                    if (typeof object.nym_y === "string")
                        $util.base64.decode(object.nym_y, message.nym_y = $util.newBuffer($util.base64.length(object.nym_y)), 0);
                    else if (object.nym_y.length)
                        message.nym_y = object.nym_y;
                if (object.ou != null)
                    if (typeof object.ou === "string")
                        $util.base64.decode(object.ou, message.ou = $util.newBuffer($util.base64.length(object.ou)), 0);
                    else if (object.ou.length)
                        message.ou = object.ou;
                if (object.role != null)
                    if (typeof object.role === "string")
                        $util.base64.decode(object.role, message.role = $util.newBuffer($util.base64.length(object.role)), 0);
                    else if (object.role.length)
                        message.role = object.role;
                if (object.proof != null)
                    if (typeof object.proof === "string")
                        $util.base64.decode(object.proof, message.proof = $util.newBuffer($util.base64.length(object.proof)), 0);
                    else if (object.proof.length)
                        message.proof = object.proof;
                return message;
            };
    
            /**
             * Creates a plain object from a SerializedIdemixIdentity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {msp.SerializedIdemixIdentity} message SerializedIdemixIdentity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SerializedIdemixIdentity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.nym_x = "";
                    else {
                        object.nym_x = [];
                        if (options.bytes !== Array)
                            object.nym_x = $util.newBuffer(object.nym_x);
                    }
                    if (options.bytes === String)
                        object.nym_y = "";
                    else {
                        object.nym_y = [];
                        if (options.bytes !== Array)
                            object.nym_y = $util.newBuffer(object.nym_y);
                    }
                    if (options.bytes === String)
                        object.ou = "";
                    else {
                        object.ou = [];
                        if (options.bytes !== Array)
                            object.ou = $util.newBuffer(object.ou);
                    }
                    if (options.bytes === String)
                        object.role = "";
                    else {
                        object.role = [];
                        if (options.bytes !== Array)
                            object.role = $util.newBuffer(object.role);
                    }
                    if (options.bytes === String)
                        object.proof = "";
                    else {
                        object.proof = [];
                        if (options.bytes !== Array)
                            object.proof = $util.newBuffer(object.proof);
                    }
                }
                if (message.nym_x != null && message.hasOwnProperty("nym_x"))
                    object.nym_x = options.bytes === String ? $util.base64.encode(message.nym_x, 0, message.nym_x.length) : options.bytes === Array ? Array.prototype.slice.call(message.nym_x) : message.nym_x;
                if (message.nym_y != null && message.hasOwnProperty("nym_y"))
                    object.nym_y = options.bytes === String ? $util.base64.encode(message.nym_y, 0, message.nym_y.length) : options.bytes === Array ? Array.prototype.slice.call(message.nym_y) : message.nym_y;
                if (message.ou != null && message.hasOwnProperty("ou"))
                    object.ou = options.bytes === String ? $util.base64.encode(message.ou, 0, message.ou.length) : options.bytes === Array ? Array.prototype.slice.call(message.ou) : message.ou;
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = options.bytes === String ? $util.base64.encode(message.role, 0, message.role.length) : options.bytes === Array ? Array.prototype.slice.call(message.role) : message.role;
                if (message.proof != null && message.hasOwnProperty("proof"))
                    object.proof = options.bytes === String ? $util.base64.encode(message.proof, 0, message.proof.length) : options.bytes === Array ? Array.prototype.slice.call(message.proof) : message.proof;
                return object;
            };
    
            /**
             * Converts this SerializedIdemixIdentity to JSON.
             * @function toJSON
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SerializedIdemixIdentity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SerializedIdemixIdentity;
        })();
    
        return msp;
    })();
    
    $root.orderer = (function() {
    
        /**
         * Namespace orderer.
         * @exports orderer
         * @namespace
         */
        var orderer = {};
    
        orderer.Cluster = (function() {
    
            /**
             * Constructs a new Cluster service.
             * @memberof orderer
             * @classdesc Represents a Cluster
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Cluster(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Cluster.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Cluster;
    
            /**
             * Creates new Cluster service using the specified rpc implementation.
             * @function create
             * @memberof orderer.Cluster
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Cluster} RPC service. Useful where requests and/or responses are streamed.
             */
            Cluster.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link orderer.Cluster#step}.
             * @memberof orderer.Cluster
             * @typedef StepCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {orderer.StepResponse} [response] StepResponse
             */
    
            /**
             * Calls Step.
             * @function step
             * @memberof orderer.Cluster
             * @instance
             * @param {orderer.IStepRequest} request StepRequest message or plain object
             * @param {orderer.Cluster.StepCallback} callback Node-style callback called with the error, if any, and StepResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Cluster.prototype.step = function step(request, callback) {
                return this.rpcCall(step, $root.orderer.StepRequest, $root.orderer.StepResponse, request, callback);
            }, "name", { value: "Step" });
    
            /**
             * Calls Step.
             * @function step
             * @memberof orderer.Cluster
             * @instance
             * @param {orderer.IStepRequest} request StepRequest message or plain object
             * @returns {Promise<orderer.StepResponse>} Promise
             * @variation 2
             */
    
            return Cluster;
        })();
    
        orderer.StepRequest = (function() {
    
            /**
             * Properties of a StepRequest.
             * @memberof orderer
             * @interface IStepRequest
             * @property {orderer.IConsensusRequest|null} [consensus_request] StepRequest consensus_request
             * @property {orderer.ISubmitRequest|null} [submit_request] StepRequest submit_request
             */
    
            /**
             * Constructs a new StepRequest.
             * @memberof orderer
             * @classdesc Represents a StepRequest.
             * @implements IStepRequest
             * @constructor
             * @param {orderer.IStepRequest=} [properties] Properties to set
             */
            function StepRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StepRequest consensus_request.
             * @member {orderer.IConsensusRequest|null|undefined} consensus_request
             * @memberof orderer.StepRequest
             * @instance
             */
            StepRequest.prototype.consensus_request = null;
    
            /**
             * StepRequest submit_request.
             * @member {orderer.ISubmitRequest|null|undefined} submit_request
             * @memberof orderer.StepRequest
             * @instance
             */
            StepRequest.prototype.submit_request = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * StepRequest payload.
             * @member {"consensus_request"|"submit_request"|undefined} payload
             * @memberof orderer.StepRequest
             * @instance
             */
            Object.defineProperty(StepRequest.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["consensus_request", "submit_request"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new StepRequest instance using the specified properties.
             * @function create
             * @memberof orderer.StepRequest
             * @static
             * @param {orderer.IStepRequest=} [properties] Properties to set
             * @returns {orderer.StepRequest} StepRequest instance
             */
            StepRequest.create = function create(properties) {
                return new StepRequest(properties);
            };
    
            /**
             * Encodes the specified StepRequest message. Does not implicitly {@link orderer.StepRequest.verify|verify} messages.
             * @function encode
             * @memberof orderer.StepRequest
             * @static
             * @param {orderer.IStepRequest} message StepRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.consensus_request != null && Object.hasOwnProperty.call(message, "consensus_request"))
                    $root.orderer.ConsensusRequest.encode(message.consensus_request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.submit_request != null && Object.hasOwnProperty.call(message, "submit_request"))
                    $root.orderer.SubmitRequest.encode(message.submit_request, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StepRequest message, length delimited. Does not implicitly {@link orderer.StepRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.StepRequest
             * @static
             * @param {orderer.IStepRequest} message StepRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StepRequest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.StepRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.StepRequest} StepRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.StepRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consensus_request = $root.orderer.ConsensusRequest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.submit_request = $root.orderer.SubmitRequest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StepRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.StepRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.StepRequest} StepRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StepRequest message.
             * @function verify
             * @memberof orderer.StepRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.consensus_request != null && message.hasOwnProperty("consensus_request")) {
                    properties.payload = 1;
                    {
                        var error = $root.orderer.ConsensusRequest.verify(message.consensus_request);
                        if (error)
                            return "consensus_request." + error;
                    }
                }
                if (message.submit_request != null && message.hasOwnProperty("submit_request")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.orderer.SubmitRequest.verify(message.submit_request);
                        if (error)
                            return "submit_request." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StepRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.StepRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.StepRequest} StepRequest
             */
            StepRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.StepRequest)
                    return object;
                var message = new $root.orderer.StepRequest();
                if (object.consensus_request != null) {
                    if (typeof object.consensus_request !== "object")
                        throw TypeError(".orderer.StepRequest.consensus_request: object expected");
                    message.consensus_request = $root.orderer.ConsensusRequest.fromObject(object.consensus_request);
                }
                if (object.submit_request != null) {
                    if (typeof object.submit_request !== "object")
                        throw TypeError(".orderer.StepRequest.submit_request: object expected");
                    message.submit_request = $root.orderer.SubmitRequest.fromObject(object.submit_request);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StepRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.StepRequest
             * @static
             * @param {orderer.StepRequest} message StepRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.consensus_request != null && message.hasOwnProperty("consensus_request")) {
                    object.consensus_request = $root.orderer.ConsensusRequest.toObject(message.consensus_request, options);
                    if (options.oneofs)
                        object.payload = "consensus_request";
                }
                if (message.submit_request != null && message.hasOwnProperty("submit_request")) {
                    object.submit_request = $root.orderer.SubmitRequest.toObject(message.submit_request, options);
                    if (options.oneofs)
                        object.payload = "submit_request";
                }
                return object;
            };
    
            /**
             * Converts this StepRequest to JSON.
             * @function toJSON
             * @memberof orderer.StepRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StepRequest;
        })();
    
        orderer.StepResponse = (function() {
    
            /**
             * Properties of a StepResponse.
             * @memberof orderer
             * @interface IStepResponse
             * @property {orderer.ISubmitResponse|null} [submit_res] StepResponse submit_res
             */
    
            /**
             * Constructs a new StepResponse.
             * @memberof orderer
             * @classdesc Represents a StepResponse.
             * @implements IStepResponse
             * @constructor
             * @param {orderer.IStepResponse=} [properties] Properties to set
             */
            function StepResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StepResponse submit_res.
             * @member {orderer.ISubmitResponse|null|undefined} submit_res
             * @memberof orderer.StepResponse
             * @instance
             */
            StepResponse.prototype.submit_res = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * StepResponse payload.
             * @member {"submit_res"|undefined} payload
             * @memberof orderer.StepResponse
             * @instance
             */
            Object.defineProperty(StepResponse.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["submit_res"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new StepResponse instance using the specified properties.
             * @function create
             * @memberof orderer.StepResponse
             * @static
             * @param {orderer.IStepResponse=} [properties] Properties to set
             * @returns {orderer.StepResponse} StepResponse instance
             */
            StepResponse.create = function create(properties) {
                return new StepResponse(properties);
            };
    
            /**
             * Encodes the specified StepResponse message. Does not implicitly {@link orderer.StepResponse.verify|verify} messages.
             * @function encode
             * @memberof orderer.StepResponse
             * @static
             * @param {orderer.IStepResponse} message StepResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.submit_res != null && Object.hasOwnProperty.call(message, "submit_res"))
                    $root.orderer.SubmitResponse.encode(message.submit_res, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StepResponse message, length delimited. Does not implicitly {@link orderer.StepResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.StepResponse
             * @static
             * @param {orderer.IStepResponse} message StepResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StepResponse message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.StepResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.StepResponse} StepResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.StepResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.submit_res = $root.orderer.SubmitResponse.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StepResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.StepResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.StepResponse} StepResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StepResponse message.
             * @function verify
             * @memberof orderer.StepResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.submit_res != null && message.hasOwnProperty("submit_res")) {
                    properties.payload = 1;
                    {
                        var error = $root.orderer.SubmitResponse.verify(message.submit_res);
                        if (error)
                            return "submit_res." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StepResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.StepResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.StepResponse} StepResponse
             */
            StepResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.StepResponse)
                    return object;
                var message = new $root.orderer.StepResponse();
                if (object.submit_res != null) {
                    if (typeof object.submit_res !== "object")
                        throw TypeError(".orderer.StepResponse.submit_res: object expected");
                    message.submit_res = $root.orderer.SubmitResponse.fromObject(object.submit_res);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StepResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.StepResponse
             * @static
             * @param {orderer.StepResponse} message StepResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.submit_res != null && message.hasOwnProperty("submit_res")) {
                    object.submit_res = $root.orderer.SubmitResponse.toObject(message.submit_res, options);
                    if (options.oneofs)
                        object.payload = "submit_res";
                }
                return object;
            };
    
            /**
             * Converts this StepResponse to JSON.
             * @function toJSON
             * @memberof orderer.StepResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StepResponse;
        })();
    
        orderer.ConsensusRequest = (function() {
    
            /**
             * Properties of a ConsensusRequest.
             * @memberof orderer
             * @interface IConsensusRequest
             * @property {string|null} [channel] ConsensusRequest channel
             * @property {Uint8Array|null} [payload] ConsensusRequest payload
             * @property {Uint8Array|null} [metadata] ConsensusRequest metadata
             */
    
            /**
             * Constructs a new ConsensusRequest.
             * @memberof orderer
             * @classdesc Represents a ConsensusRequest.
             * @implements IConsensusRequest
             * @constructor
             * @param {orderer.IConsensusRequest=} [properties] Properties to set
             */
            function ConsensusRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConsensusRequest channel.
             * @member {string} channel
             * @memberof orderer.ConsensusRequest
             * @instance
             */
            ConsensusRequest.prototype.channel = "";
    
            /**
             * ConsensusRequest payload.
             * @member {Uint8Array} payload
             * @memberof orderer.ConsensusRequest
             * @instance
             */
            ConsensusRequest.prototype.payload = $util.newBuffer([]);
    
            /**
             * ConsensusRequest metadata.
             * @member {Uint8Array} metadata
             * @memberof orderer.ConsensusRequest
             * @instance
             */
            ConsensusRequest.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new ConsensusRequest instance using the specified properties.
             * @function create
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {orderer.IConsensusRequest=} [properties] Properties to set
             * @returns {orderer.ConsensusRequest} ConsensusRequest instance
             */
            ConsensusRequest.create = function create(properties) {
                return new ConsensusRequest(properties);
            };
    
            /**
             * Encodes the specified ConsensusRequest message. Does not implicitly {@link orderer.ConsensusRequest.verify|verify} messages.
             * @function encode
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {orderer.IConsensusRequest} message ConsensusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsensusRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified ConsensusRequest message, length delimited. Does not implicitly {@link orderer.ConsensusRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {orderer.IConsensusRequest} message ConsensusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsensusRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConsensusRequest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.ConsensusRequest} ConsensusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsensusRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.ConsensusRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    case 3:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConsensusRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.ConsensusRequest} ConsensusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsensusRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConsensusRequest message.
             * @function verify
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConsensusRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a ConsensusRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.ConsensusRequest} ConsensusRequest
             */
            ConsensusRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.ConsensusRequest)
                    return object;
                var message = new $root.orderer.ConsensusRequest();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a ConsensusRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {orderer.ConsensusRequest} message ConsensusRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConsensusRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this ConsensusRequest to JSON.
             * @function toJSON
             * @memberof orderer.ConsensusRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConsensusRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConsensusRequest;
        })();
    
        orderer.SubmitRequest = (function() {
    
            /**
             * Properties of a SubmitRequest.
             * @memberof orderer
             * @interface ISubmitRequest
             * @property {string|null} [channel] SubmitRequest channel
             * @property {number|Long|null} [last_validation_seq] SubmitRequest last_validation_seq
             * @property {common.IEnvelope|null} [payload] SubmitRequest payload
             */
    
            /**
             * Constructs a new SubmitRequest.
             * @memberof orderer
             * @classdesc Represents a SubmitRequest.
             * @implements ISubmitRequest
             * @constructor
             * @param {orderer.ISubmitRequest=} [properties] Properties to set
             */
            function SubmitRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SubmitRequest channel.
             * @member {string} channel
             * @memberof orderer.SubmitRequest
             * @instance
             */
            SubmitRequest.prototype.channel = "";
    
            /**
             * SubmitRequest last_validation_seq.
             * @member {number|Long} last_validation_seq
             * @memberof orderer.SubmitRequest
             * @instance
             */
            SubmitRequest.prototype.last_validation_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * SubmitRequest payload.
             * @member {common.IEnvelope|null|undefined} payload
             * @memberof orderer.SubmitRequest
             * @instance
             */
            SubmitRequest.prototype.payload = null;
    
            /**
             * Creates a new SubmitRequest instance using the specified properties.
             * @function create
             * @memberof orderer.SubmitRequest
             * @static
             * @param {orderer.ISubmitRequest=} [properties] Properties to set
             * @returns {orderer.SubmitRequest} SubmitRequest instance
             */
            SubmitRequest.create = function create(properties) {
                return new SubmitRequest(properties);
            };
    
            /**
             * Encodes the specified SubmitRequest message. Does not implicitly {@link orderer.SubmitRequest.verify|verify} messages.
             * @function encode
             * @memberof orderer.SubmitRequest
             * @static
             * @param {orderer.ISubmitRequest} message SubmitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubmitRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.last_validation_seq != null && Object.hasOwnProperty.call(message, "last_validation_seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.last_validation_seq);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    $root.common.Envelope.encode(message.payload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SubmitRequest message, length delimited. Does not implicitly {@link orderer.SubmitRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SubmitRequest
             * @static
             * @param {orderer.ISubmitRequest} message SubmitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubmitRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SubmitRequest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SubmitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SubmitRequest} SubmitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubmitRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SubmitRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.last_validation_seq = reader.uint64();
                        break;
                    case 3:
                        message.payload = $root.common.Envelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SubmitRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SubmitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SubmitRequest} SubmitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubmitRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SubmitRequest message.
             * @function verify
             * @memberof orderer.SubmitRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubmitRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.last_validation_seq != null && message.hasOwnProperty("last_validation_seq"))
                    if (!$util.isInteger(message.last_validation_seq) && !(message.last_validation_seq && $util.isInteger(message.last_validation_seq.low) && $util.isInteger(message.last_validation_seq.high)))
                        return "last_validation_seq: integer|Long expected";
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    var error = $root.common.Envelope.verify(message.payload);
                    if (error)
                        return "payload." + error;
                }
                return null;
            };
    
            /**
             * Creates a SubmitRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SubmitRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SubmitRequest} SubmitRequest
             */
            SubmitRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SubmitRequest)
                    return object;
                var message = new $root.orderer.SubmitRequest();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.last_validation_seq != null)
                    if ($util.Long)
                        (message.last_validation_seq = $util.Long.fromValue(object.last_validation_seq)).unsigned = true;
                    else if (typeof object.last_validation_seq === "string")
                        message.last_validation_seq = parseInt(object.last_validation_seq, 10);
                    else if (typeof object.last_validation_seq === "number")
                        message.last_validation_seq = object.last_validation_seq;
                    else if (typeof object.last_validation_seq === "object")
                        message.last_validation_seq = new $util.LongBits(object.last_validation_seq.low >>> 0, object.last_validation_seq.high >>> 0).toNumber(true);
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".orderer.SubmitRequest.payload: object expected");
                    message.payload = $root.common.Envelope.fromObject(object.payload);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SubmitRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SubmitRequest
             * @static
             * @param {orderer.SubmitRequest} message SubmitRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubmitRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.last_validation_seq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_validation_seq = options.longs === String ? "0" : 0;
                    object.payload = null;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.last_validation_seq != null && message.hasOwnProperty("last_validation_seq"))
                    if (typeof message.last_validation_seq === "number")
                        object.last_validation_seq = options.longs === String ? String(message.last_validation_seq) : message.last_validation_seq;
                    else
                        object.last_validation_seq = options.longs === String ? $util.Long.prototype.toString.call(message.last_validation_seq) : options.longs === Number ? new $util.LongBits(message.last_validation_seq.low >>> 0, message.last_validation_seq.high >>> 0).toNumber(true) : message.last_validation_seq;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = $root.common.Envelope.toObject(message.payload, options);
                return object;
            };
    
            /**
             * Converts this SubmitRequest to JSON.
             * @function toJSON
             * @memberof orderer.SubmitRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubmitRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SubmitRequest;
        })();
    
        orderer.SubmitResponse = (function() {
    
            /**
             * Properties of a SubmitResponse.
             * @memberof orderer
             * @interface ISubmitResponse
             * @property {string|null} [channel] SubmitResponse channel
             * @property {common.Status|null} [status] SubmitResponse status
             * @property {string|null} [info] SubmitResponse info
             */
    
            /**
             * Constructs a new SubmitResponse.
             * @memberof orderer
             * @classdesc Represents a SubmitResponse.
             * @implements ISubmitResponse
             * @constructor
             * @param {orderer.ISubmitResponse=} [properties] Properties to set
             */
            function SubmitResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SubmitResponse channel.
             * @member {string} channel
             * @memberof orderer.SubmitResponse
             * @instance
             */
            SubmitResponse.prototype.channel = "";
    
            /**
             * SubmitResponse status.
             * @member {common.Status} status
             * @memberof orderer.SubmitResponse
             * @instance
             */
            SubmitResponse.prototype.status = 0;
    
            /**
             * SubmitResponse info.
             * @member {string} info
             * @memberof orderer.SubmitResponse
             * @instance
             */
            SubmitResponse.prototype.info = "";
    
            /**
             * Creates a new SubmitResponse instance using the specified properties.
             * @function create
             * @memberof orderer.SubmitResponse
             * @static
             * @param {orderer.ISubmitResponse=} [properties] Properties to set
             * @returns {orderer.SubmitResponse} SubmitResponse instance
             */
            SubmitResponse.create = function create(properties) {
                return new SubmitResponse(properties);
            };
    
            /**
             * Encodes the specified SubmitResponse message. Does not implicitly {@link orderer.SubmitResponse.verify|verify} messages.
             * @function encode
             * @memberof orderer.SubmitResponse
             * @static
             * @param {orderer.ISubmitResponse} message SubmitResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubmitResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.info);
                return writer;
            };
    
            /**
             * Encodes the specified SubmitResponse message, length delimited. Does not implicitly {@link orderer.SubmitResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SubmitResponse
             * @static
             * @param {orderer.ISubmitResponse} message SubmitResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubmitResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SubmitResponse message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SubmitResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SubmitResponse} SubmitResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubmitResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SubmitResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.status = reader.int32();
                        break;
                    case 3:
                        message.info = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SubmitResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SubmitResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SubmitResponse} SubmitResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubmitResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SubmitResponse message.
             * @function verify
             * @memberof orderer.SubmitResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubmitResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 200:
                    case 400:
                    case 403:
                    case 404:
                    case 413:
                    case 500:
                    case 501:
                    case 503:
                        break;
                    }
                if (message.info != null && message.hasOwnProperty("info"))
                    if (!$util.isString(message.info))
                        return "info: string expected";
                return null;
            };
    
            /**
             * Creates a SubmitResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SubmitResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SubmitResponse} SubmitResponse
             */
            SubmitResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SubmitResponse)
                    return object;
                var message = new $root.orderer.SubmitResponse();
                if (object.channel != null)
                    message.channel = String(object.channel);
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 200:
                    message.status = 200;
                    break;
                case "BAD_REQUEST":
                case 400:
                    message.status = 400;
                    break;
                case "FORBIDDEN":
                case 403:
                    message.status = 403;
                    break;
                case "NOT_FOUND":
                case 404:
                    message.status = 404;
                    break;
                case "REQUEST_ENTITY_TOO_LARGE":
                case 413:
                    message.status = 413;
                    break;
                case "INTERNAL_SERVER_ERROR":
                case 500:
                    message.status = 500;
                    break;
                case "NOT_IMPLEMENTED":
                case 501:
                    message.status = 501;
                    break;
                case "SERVICE_UNAVAILABLE":
                case 503:
                    message.status = 503;
                    break;
                }
                if (object.info != null)
                    message.info = String(object.info);
                return message;
            };
    
            /**
             * Creates a plain object from a SubmitResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SubmitResponse
             * @static
             * @param {orderer.SubmitResponse} message SubmitResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubmitResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    object.status = options.enums === String ? "UNKNOWN" : 0;
                    object.info = "";
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.common.Status[message.status] : message.status;
                if (message.info != null && message.hasOwnProperty("info"))
                    object.info = message.info;
                return object;
            };
    
            /**
             * Converts this SubmitResponse to JSON.
             * @function toJSON
             * @memberof orderer.SubmitResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubmitResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SubmitResponse;
        })();
    
        orderer.ConsensusType = (function() {
    
            /**
             * Properties of a ConsensusType.
             * @memberof orderer
             * @interface IConsensusType
             * @property {string|null} [type] ConsensusType type
             * @property {Uint8Array|null} [metadata] ConsensusType metadata
             * @property {orderer.ConsensusType.State|null} [state] ConsensusType state
             */
    
            /**
             * Constructs a new ConsensusType.
             * @memberof orderer
             * @classdesc Represents a ConsensusType.
             * @implements IConsensusType
             * @constructor
             * @param {orderer.IConsensusType=} [properties] Properties to set
             */
            function ConsensusType(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConsensusType type.
             * @member {string} type
             * @memberof orderer.ConsensusType
             * @instance
             */
            ConsensusType.prototype.type = "";
    
            /**
             * ConsensusType metadata.
             * @member {Uint8Array} metadata
             * @memberof orderer.ConsensusType
             * @instance
             */
            ConsensusType.prototype.metadata = $util.newBuffer([]);
    
            /**
             * ConsensusType state.
             * @member {orderer.ConsensusType.State} state
             * @memberof orderer.ConsensusType
             * @instance
             */
            ConsensusType.prototype.state = 0;
    
            /**
             * Creates a new ConsensusType instance using the specified properties.
             * @function create
             * @memberof orderer.ConsensusType
             * @static
             * @param {orderer.IConsensusType=} [properties] Properties to set
             * @returns {orderer.ConsensusType} ConsensusType instance
             */
            ConsensusType.create = function create(properties) {
                return new ConsensusType(properties);
            };
    
            /**
             * Encodes the specified ConsensusType message. Does not implicitly {@link orderer.ConsensusType.verify|verify} messages.
             * @function encode
             * @memberof orderer.ConsensusType
             * @static
             * @param {orderer.IConsensusType} message ConsensusType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsensusType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
                return writer;
            };
    
            /**
             * Encodes the specified ConsensusType message, length delimited. Does not implicitly {@link orderer.ConsensusType.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.ConsensusType
             * @static
             * @param {orderer.IConsensusType} message ConsensusType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsensusType.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConsensusType message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.ConsensusType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.ConsensusType} ConsensusType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsensusType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.ConsensusType();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.string();
                        break;
                    case 2:
                        message.metadata = reader.bytes();
                        break;
                    case 3:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConsensusType message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.ConsensusType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.ConsensusType} ConsensusType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsensusType.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConsensusType message.
             * @function verify
             * @memberof orderer.ConsensusType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConsensusType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a ConsensusType message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.ConsensusType
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.ConsensusType} ConsensusType
             */
            ConsensusType.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.ConsensusType)
                    return object;
                var message = new $root.orderer.ConsensusType();
                if (object.type != null)
                    message.type = String(object.type);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                switch (object.state) {
                case "STATE_NORMAL":
                case 0:
                    message.state = 0;
                    break;
                case "STATE_MAINTENANCE":
                case 1:
                    message.state = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConsensusType message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.ConsensusType
             * @static
             * @param {orderer.ConsensusType} message ConsensusType
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConsensusType.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                    object.state = options.enums === String ? "STATE_NORMAL" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.orderer.ConsensusType.State[message.state] : message.state;
                return object;
            };
    
            /**
             * Converts this ConsensusType to JSON.
             * @function toJSON
             * @memberof orderer.ConsensusType
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConsensusType.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * State enum.
             * @name orderer.ConsensusType.State
             * @enum {number}
             * @property {number} STATE_NORMAL=0 STATE_NORMAL value
             * @property {number} STATE_MAINTENANCE=1 STATE_MAINTENANCE value
             */
            ConsensusType.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATE_NORMAL"] = 0;
                values[valuesById[1] = "STATE_MAINTENANCE"] = 1;
                return values;
            })();
    
            return ConsensusType;
        })();
    
        orderer.BatchSize = (function() {
    
            /**
             * Properties of a BatchSize.
             * @memberof orderer
             * @interface IBatchSize
             * @property {number|null} [max_message_count] BatchSize max_message_count
             * @property {number|null} [absolute_max_bytes] BatchSize absolute_max_bytes
             * @property {number|null} [preferred_max_bytes] BatchSize preferred_max_bytes
             */
    
            /**
             * Constructs a new BatchSize.
             * @memberof orderer
             * @classdesc Represents a BatchSize.
             * @implements IBatchSize
             * @constructor
             * @param {orderer.IBatchSize=} [properties] Properties to set
             */
            function BatchSize(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BatchSize max_message_count.
             * @member {number} max_message_count
             * @memberof orderer.BatchSize
             * @instance
             */
            BatchSize.prototype.max_message_count = 0;
    
            /**
             * BatchSize absolute_max_bytes.
             * @member {number} absolute_max_bytes
             * @memberof orderer.BatchSize
             * @instance
             */
            BatchSize.prototype.absolute_max_bytes = 0;
    
            /**
             * BatchSize preferred_max_bytes.
             * @member {number} preferred_max_bytes
             * @memberof orderer.BatchSize
             * @instance
             */
            BatchSize.prototype.preferred_max_bytes = 0;
    
            /**
             * Creates a new BatchSize instance using the specified properties.
             * @function create
             * @memberof orderer.BatchSize
             * @static
             * @param {orderer.IBatchSize=} [properties] Properties to set
             * @returns {orderer.BatchSize} BatchSize instance
             */
            BatchSize.create = function create(properties) {
                return new BatchSize(properties);
            };
    
            /**
             * Encodes the specified BatchSize message. Does not implicitly {@link orderer.BatchSize.verify|verify} messages.
             * @function encode
             * @memberof orderer.BatchSize
             * @static
             * @param {orderer.IBatchSize} message BatchSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSize.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.max_message_count != null && Object.hasOwnProperty.call(message, "max_message_count"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.max_message_count);
                if (message.absolute_max_bytes != null && Object.hasOwnProperty.call(message, "absolute_max_bytes"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.absolute_max_bytes);
                if (message.preferred_max_bytes != null && Object.hasOwnProperty.call(message, "preferred_max_bytes"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.preferred_max_bytes);
                return writer;
            };
    
            /**
             * Encodes the specified BatchSize message, length delimited. Does not implicitly {@link orderer.BatchSize.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.BatchSize
             * @static
             * @param {orderer.IBatchSize} message BatchSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSize.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BatchSize message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.BatchSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.BatchSize} BatchSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSize.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.BatchSize();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.max_message_count = reader.uint32();
                        break;
                    case 2:
                        message.absolute_max_bytes = reader.uint32();
                        break;
                    case 3:
                        message.preferred_max_bytes = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BatchSize message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.BatchSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.BatchSize} BatchSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSize.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BatchSize message.
             * @function verify
             * @memberof orderer.BatchSize
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchSize.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.max_message_count != null && message.hasOwnProperty("max_message_count"))
                    if (!$util.isInteger(message.max_message_count))
                        return "max_message_count: integer expected";
                if (message.absolute_max_bytes != null && message.hasOwnProperty("absolute_max_bytes"))
                    if (!$util.isInteger(message.absolute_max_bytes))
                        return "absolute_max_bytes: integer expected";
                if (message.preferred_max_bytes != null && message.hasOwnProperty("preferred_max_bytes"))
                    if (!$util.isInteger(message.preferred_max_bytes))
                        return "preferred_max_bytes: integer expected";
                return null;
            };
    
            /**
             * Creates a BatchSize message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.BatchSize
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.BatchSize} BatchSize
             */
            BatchSize.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.BatchSize)
                    return object;
                var message = new $root.orderer.BatchSize();
                if (object.max_message_count != null)
                    message.max_message_count = object.max_message_count >>> 0;
                if (object.absolute_max_bytes != null)
                    message.absolute_max_bytes = object.absolute_max_bytes >>> 0;
                if (object.preferred_max_bytes != null)
                    message.preferred_max_bytes = object.preferred_max_bytes >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a BatchSize message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.BatchSize
             * @static
             * @param {orderer.BatchSize} message BatchSize
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchSize.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.max_message_count = 0;
                    object.absolute_max_bytes = 0;
                    object.preferred_max_bytes = 0;
                }
                if (message.max_message_count != null && message.hasOwnProperty("max_message_count"))
                    object.max_message_count = message.max_message_count;
                if (message.absolute_max_bytes != null && message.hasOwnProperty("absolute_max_bytes"))
                    object.absolute_max_bytes = message.absolute_max_bytes;
                if (message.preferred_max_bytes != null && message.hasOwnProperty("preferred_max_bytes"))
                    object.preferred_max_bytes = message.preferred_max_bytes;
                return object;
            };
    
            /**
             * Converts this BatchSize to JSON.
             * @function toJSON
             * @memberof orderer.BatchSize
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchSize.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BatchSize;
        })();
    
        orderer.BatchTimeout = (function() {
    
            /**
             * Properties of a BatchTimeout.
             * @memberof orderer
             * @interface IBatchTimeout
             * @property {string|null} [timeout] BatchTimeout timeout
             */
    
            /**
             * Constructs a new BatchTimeout.
             * @memberof orderer
             * @classdesc Represents a BatchTimeout.
             * @implements IBatchTimeout
             * @constructor
             * @param {orderer.IBatchTimeout=} [properties] Properties to set
             */
            function BatchTimeout(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BatchTimeout timeout.
             * @member {string} timeout
             * @memberof orderer.BatchTimeout
             * @instance
             */
            BatchTimeout.prototype.timeout = "";
    
            /**
             * Creates a new BatchTimeout instance using the specified properties.
             * @function create
             * @memberof orderer.BatchTimeout
             * @static
             * @param {orderer.IBatchTimeout=} [properties] Properties to set
             * @returns {orderer.BatchTimeout} BatchTimeout instance
             */
            BatchTimeout.create = function create(properties) {
                return new BatchTimeout(properties);
            };
    
            /**
             * Encodes the specified BatchTimeout message. Does not implicitly {@link orderer.BatchTimeout.verify|verify} messages.
             * @function encode
             * @memberof orderer.BatchTimeout
             * @static
             * @param {orderer.IBatchTimeout} message BatchTimeout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchTimeout.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.timeout);
                return writer;
            };
    
            /**
             * Encodes the specified BatchTimeout message, length delimited. Does not implicitly {@link orderer.BatchTimeout.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.BatchTimeout
             * @static
             * @param {orderer.IBatchTimeout} message BatchTimeout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchTimeout.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BatchTimeout message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.BatchTimeout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.BatchTimeout} BatchTimeout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchTimeout.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.BatchTimeout();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timeout = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BatchTimeout message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.BatchTimeout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.BatchTimeout} BatchTimeout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchTimeout.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BatchTimeout message.
             * @function verify
             * @memberof orderer.BatchTimeout
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchTimeout.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (!$util.isString(message.timeout))
                        return "timeout: string expected";
                return null;
            };
    
            /**
             * Creates a BatchTimeout message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.BatchTimeout
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.BatchTimeout} BatchTimeout
             */
            BatchTimeout.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.BatchTimeout)
                    return object;
                var message = new $root.orderer.BatchTimeout();
                if (object.timeout != null)
                    message.timeout = String(object.timeout);
                return message;
            };
    
            /**
             * Creates a plain object from a BatchTimeout message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.BatchTimeout
             * @static
             * @param {orderer.BatchTimeout} message BatchTimeout
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchTimeout.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.timeout = "";
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    object.timeout = message.timeout;
                return object;
            };
    
            /**
             * Converts this BatchTimeout to JSON.
             * @function toJSON
             * @memberof orderer.BatchTimeout
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchTimeout.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BatchTimeout;
        })();
    
        orderer.KafkaBrokers = (function() {
    
            /**
             * Properties of a KafkaBrokers.
             * @memberof orderer
             * @interface IKafkaBrokers
             * @property {Array.<string>|null} [brokers] KafkaBrokers brokers
             */
    
            /**
             * Constructs a new KafkaBrokers.
             * @memberof orderer
             * @classdesc Represents a KafkaBrokers.
             * @implements IKafkaBrokers
             * @constructor
             * @param {orderer.IKafkaBrokers=} [properties] Properties to set
             */
            function KafkaBrokers(properties) {
                this.brokers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaBrokers brokers.
             * @member {Array.<string>} brokers
             * @memberof orderer.KafkaBrokers
             * @instance
             */
            KafkaBrokers.prototype.brokers = $util.emptyArray;
    
            /**
             * Creates a new KafkaBrokers instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {orderer.IKafkaBrokers=} [properties] Properties to set
             * @returns {orderer.KafkaBrokers} KafkaBrokers instance
             */
            KafkaBrokers.create = function create(properties) {
                return new KafkaBrokers(properties);
            };
    
            /**
             * Encodes the specified KafkaBrokers message. Does not implicitly {@link orderer.KafkaBrokers.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {orderer.IKafkaBrokers} message KafkaBrokers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaBrokers.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.brokers != null && message.brokers.length)
                    for (var i = 0; i < message.brokers.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.brokers[i]);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaBrokers message, length delimited. Does not implicitly {@link orderer.KafkaBrokers.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {orderer.IKafkaBrokers} message KafkaBrokers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaBrokers.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaBrokers message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaBrokers} KafkaBrokers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaBrokers.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaBrokers();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.brokers && message.brokers.length))
                            message.brokers = [];
                        message.brokers.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaBrokers message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaBrokers} KafkaBrokers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaBrokers.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaBrokers message.
             * @function verify
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaBrokers.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.brokers != null && message.hasOwnProperty("brokers")) {
                    if (!Array.isArray(message.brokers))
                        return "brokers: array expected";
                    for (var i = 0; i < message.brokers.length; ++i)
                        if (!$util.isString(message.brokers[i]))
                            return "brokers: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a KafkaBrokers message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaBrokers} KafkaBrokers
             */
            KafkaBrokers.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaBrokers)
                    return object;
                var message = new $root.orderer.KafkaBrokers();
                if (object.brokers) {
                    if (!Array.isArray(object.brokers))
                        throw TypeError(".orderer.KafkaBrokers.brokers: array expected");
                    message.brokers = [];
                    for (var i = 0; i < object.brokers.length; ++i)
                        message.brokers[i] = String(object.brokers[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaBrokers message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {orderer.KafkaBrokers} message KafkaBrokers
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaBrokers.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.brokers = [];
                if (message.brokers && message.brokers.length) {
                    object.brokers = [];
                    for (var j = 0; j < message.brokers.length; ++j)
                        object.brokers[j] = message.brokers[j];
                }
                return object;
            };
    
            /**
             * Converts this KafkaBrokers to JSON.
             * @function toJSON
             * @memberof orderer.KafkaBrokers
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaBrokers.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaBrokers;
        })();
    
        orderer.ChannelRestrictions = (function() {
    
            /**
             * Properties of a ChannelRestrictions.
             * @memberof orderer
             * @interface IChannelRestrictions
             * @property {number|Long|null} [max_count] ChannelRestrictions max_count
             */
    
            /**
             * Constructs a new ChannelRestrictions.
             * @memberof orderer
             * @classdesc Represents a ChannelRestrictions.
             * @implements IChannelRestrictions
             * @constructor
             * @param {orderer.IChannelRestrictions=} [properties] Properties to set
             */
            function ChannelRestrictions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChannelRestrictions max_count.
             * @member {number|Long} max_count
             * @memberof orderer.ChannelRestrictions
             * @instance
             */
            ChannelRestrictions.prototype.max_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new ChannelRestrictions instance using the specified properties.
             * @function create
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {orderer.IChannelRestrictions=} [properties] Properties to set
             * @returns {orderer.ChannelRestrictions} ChannelRestrictions instance
             */
            ChannelRestrictions.create = function create(properties) {
                return new ChannelRestrictions(properties);
            };
    
            /**
             * Encodes the specified ChannelRestrictions message. Does not implicitly {@link orderer.ChannelRestrictions.verify|verify} messages.
             * @function encode
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {orderer.IChannelRestrictions} message ChannelRestrictions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelRestrictions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.max_count != null && Object.hasOwnProperty.call(message, "max_count"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.max_count);
                return writer;
            };
    
            /**
             * Encodes the specified ChannelRestrictions message, length delimited. Does not implicitly {@link orderer.ChannelRestrictions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {orderer.IChannelRestrictions} message ChannelRestrictions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelRestrictions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChannelRestrictions message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.ChannelRestrictions} ChannelRestrictions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelRestrictions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.ChannelRestrictions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.max_count = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChannelRestrictions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.ChannelRestrictions} ChannelRestrictions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelRestrictions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChannelRestrictions message.
             * @function verify
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelRestrictions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.max_count != null && message.hasOwnProperty("max_count"))
                    if (!$util.isInteger(message.max_count) && !(message.max_count && $util.isInteger(message.max_count.low) && $util.isInteger(message.max_count.high)))
                        return "max_count: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a ChannelRestrictions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.ChannelRestrictions} ChannelRestrictions
             */
            ChannelRestrictions.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.ChannelRestrictions)
                    return object;
                var message = new $root.orderer.ChannelRestrictions();
                if (object.max_count != null)
                    if ($util.Long)
                        (message.max_count = $util.Long.fromValue(object.max_count)).unsigned = true;
                    else if (typeof object.max_count === "string")
                        message.max_count = parseInt(object.max_count, 10);
                    else if (typeof object.max_count === "number")
                        message.max_count = object.max_count;
                    else if (typeof object.max_count === "object")
                        message.max_count = new $util.LongBits(object.max_count.low >>> 0, object.max_count.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a ChannelRestrictions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {orderer.ChannelRestrictions} message ChannelRestrictions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelRestrictions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.max_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.max_count = options.longs === String ? "0" : 0;
                if (message.max_count != null && message.hasOwnProperty("max_count"))
                    if (typeof message.max_count === "number")
                        object.max_count = options.longs === String ? String(message.max_count) : message.max_count;
                    else
                        object.max_count = options.longs === String ? $util.Long.prototype.toString.call(message.max_count) : options.longs === Number ? new $util.LongBits(message.max_count.low >>> 0, message.max_count.high >>> 0).toNumber(true) : message.max_count;
                return object;
            };
    
            /**
             * Converts this ChannelRestrictions to JSON.
             * @function toJSON
             * @memberof orderer.ChannelRestrictions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelRestrictions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChannelRestrictions;
        })();
    
        orderer.KafkaMessage = (function() {
    
            /**
             * Properties of a KafkaMessage.
             * @memberof orderer
             * @interface IKafkaMessage
             * @property {orderer.IKafkaMessageRegular|null} [regular] KafkaMessage regular
             * @property {orderer.IKafkaMessageTimeToCut|null} [time_to_cut] KafkaMessage time_to_cut
             * @property {orderer.IKafkaMessageConnect|null} [connect] KafkaMessage connect
             */
    
            /**
             * Constructs a new KafkaMessage.
             * @memberof orderer
             * @classdesc Represents a KafkaMessage.
             * @implements IKafkaMessage
             * @constructor
             * @param {orderer.IKafkaMessage=} [properties] Properties to set
             */
            function KafkaMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMessage regular.
             * @member {orderer.IKafkaMessageRegular|null|undefined} regular
             * @memberof orderer.KafkaMessage
             * @instance
             */
            KafkaMessage.prototype.regular = null;
    
            /**
             * KafkaMessage time_to_cut.
             * @member {orderer.IKafkaMessageTimeToCut|null|undefined} time_to_cut
             * @memberof orderer.KafkaMessage
             * @instance
             */
            KafkaMessage.prototype.time_to_cut = null;
    
            /**
             * KafkaMessage connect.
             * @member {orderer.IKafkaMessageConnect|null|undefined} connect
             * @memberof orderer.KafkaMessage
             * @instance
             */
            KafkaMessage.prototype.connect = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * KafkaMessage Type.
             * @member {"regular"|"time_to_cut"|"connect"|undefined} Type
             * @memberof orderer.KafkaMessage
             * @instance
             */
            Object.defineProperty(KafkaMessage.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["regular", "time_to_cut", "connect"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new KafkaMessage instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMessage
             * @static
             * @param {orderer.IKafkaMessage=} [properties] Properties to set
             * @returns {orderer.KafkaMessage} KafkaMessage instance
             */
            KafkaMessage.create = function create(properties) {
                return new KafkaMessage(properties);
            };
    
            /**
             * Encodes the specified KafkaMessage message. Does not implicitly {@link orderer.KafkaMessage.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMessage
             * @static
             * @param {orderer.IKafkaMessage} message KafkaMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.regular != null && Object.hasOwnProperty.call(message, "regular"))
                    $root.orderer.KafkaMessageRegular.encode(message.regular, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.time_to_cut != null && Object.hasOwnProperty.call(message, "time_to_cut"))
                    $root.orderer.KafkaMessageTimeToCut.encode(message.time_to_cut, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.connect != null && Object.hasOwnProperty.call(message, "connect"))
                    $root.orderer.KafkaMessageConnect.encode(message.connect, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMessage message, length delimited. Does not implicitly {@link orderer.KafkaMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMessage
             * @static
             * @param {orderer.IKafkaMessage} message KafkaMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMessage message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMessage} KafkaMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.regular = $root.orderer.KafkaMessageRegular.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.time_to_cut = $root.orderer.KafkaMessageTimeToCut.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.connect = $root.orderer.KafkaMessageConnect.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMessage} KafkaMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMessage message.
             * @function verify
             * @memberof orderer.KafkaMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.regular != null && message.hasOwnProperty("regular")) {
                    properties.Type = 1;
                    {
                        var error = $root.orderer.KafkaMessageRegular.verify(message.regular);
                        if (error)
                            return "regular." + error;
                    }
                }
                if (message.time_to_cut != null && message.hasOwnProperty("time_to_cut")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.orderer.KafkaMessageTimeToCut.verify(message.time_to_cut);
                        if (error)
                            return "time_to_cut." + error;
                    }
                }
                if (message.connect != null && message.hasOwnProperty("connect")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.orderer.KafkaMessageConnect.verify(message.connect);
                        if (error)
                            return "connect." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KafkaMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMessage} KafkaMessage
             */
            KafkaMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMessage)
                    return object;
                var message = new $root.orderer.KafkaMessage();
                if (object.regular != null) {
                    if (typeof object.regular !== "object")
                        throw TypeError(".orderer.KafkaMessage.regular: object expected");
                    message.regular = $root.orderer.KafkaMessageRegular.fromObject(object.regular);
                }
                if (object.time_to_cut != null) {
                    if (typeof object.time_to_cut !== "object")
                        throw TypeError(".orderer.KafkaMessage.time_to_cut: object expected");
                    message.time_to_cut = $root.orderer.KafkaMessageTimeToCut.fromObject(object.time_to_cut);
                }
                if (object.connect != null) {
                    if (typeof object.connect !== "object")
                        throw TypeError(".orderer.KafkaMessage.connect: object expected");
                    message.connect = $root.orderer.KafkaMessageConnect.fromObject(object.connect);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMessage
             * @static
             * @param {orderer.KafkaMessage} message KafkaMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.regular != null && message.hasOwnProperty("regular")) {
                    object.regular = $root.orderer.KafkaMessageRegular.toObject(message.regular, options);
                    if (options.oneofs)
                        object.Type = "regular";
                }
                if (message.time_to_cut != null && message.hasOwnProperty("time_to_cut")) {
                    object.time_to_cut = $root.orderer.KafkaMessageTimeToCut.toObject(message.time_to_cut, options);
                    if (options.oneofs)
                        object.Type = "time_to_cut";
                }
                if (message.connect != null && message.hasOwnProperty("connect")) {
                    object.connect = $root.orderer.KafkaMessageConnect.toObject(message.connect, options);
                    if (options.oneofs)
                        object.Type = "connect";
                }
                return object;
            };
    
            /**
             * Converts this KafkaMessage to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaMessage;
        })();
    
        orderer.KafkaMessageRegular = (function() {
    
            /**
             * Properties of a KafkaMessageRegular.
             * @memberof orderer
             * @interface IKafkaMessageRegular
             * @property {Uint8Array|null} [payload] KafkaMessageRegular payload
             * @property {number|Long|null} [config_seq] KafkaMessageRegular config_seq
             * @property {orderer.KafkaMessageRegular.Class|null} ["class"] KafkaMessageRegular class
             * @property {number|Long|null} [original_offset] KafkaMessageRegular original_offset
             */
    
            /**
             * Constructs a new KafkaMessageRegular.
             * @memberof orderer
             * @classdesc Represents a KafkaMessageRegular.
             * @implements IKafkaMessageRegular
             * @constructor
             * @param {orderer.IKafkaMessageRegular=} [properties] Properties to set
             */
            function KafkaMessageRegular(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMessageRegular payload.
             * @member {Uint8Array} payload
             * @memberof orderer.KafkaMessageRegular
             * @instance
             */
            KafkaMessageRegular.prototype.payload = $util.newBuffer([]);
    
            /**
             * KafkaMessageRegular config_seq.
             * @member {number|Long} config_seq
             * @memberof orderer.KafkaMessageRegular
             * @instance
             */
            KafkaMessageRegular.prototype.config_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * KafkaMessageRegular class.
             * @member {orderer.KafkaMessageRegular.Class} class
             * @memberof orderer.KafkaMessageRegular
             * @instance
             */
            KafkaMessageRegular.prototype["class"] = 0;
    
            /**
             * KafkaMessageRegular original_offset.
             * @member {number|Long} original_offset
             * @memberof orderer.KafkaMessageRegular
             * @instance
             */
            KafkaMessageRegular.prototype.original_offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new KafkaMessageRegular instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {orderer.IKafkaMessageRegular=} [properties] Properties to set
             * @returns {orderer.KafkaMessageRegular} KafkaMessageRegular instance
             */
            KafkaMessageRegular.create = function create(properties) {
                return new KafkaMessageRegular(properties);
            };
    
            /**
             * Encodes the specified KafkaMessageRegular message. Does not implicitly {@link orderer.KafkaMessageRegular.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {orderer.IKafkaMessageRegular} message KafkaMessageRegular message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageRegular.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.config_seq != null && Object.hasOwnProperty.call(message, "config_seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.config_seq);
                if (message["class"] != null && Object.hasOwnProperty.call(message, "class"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message["class"]);
                if (message.original_offset != null && Object.hasOwnProperty.call(message, "original_offset"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.original_offset);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMessageRegular message, length delimited. Does not implicitly {@link orderer.KafkaMessageRegular.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {orderer.IKafkaMessageRegular} message KafkaMessageRegular message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageRegular.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMessageRegular message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMessageRegular} KafkaMessageRegular
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageRegular.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMessageRegular();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.config_seq = reader.uint64();
                        break;
                    case 3:
                        message["class"] = reader.int32();
                        break;
                    case 4:
                        message.original_offset = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMessageRegular message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMessageRegular} KafkaMessageRegular
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageRegular.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMessageRegular message.
             * @function verify
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMessageRegular.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.config_seq != null && message.hasOwnProperty("config_seq"))
                    if (!$util.isInteger(message.config_seq) && !(message.config_seq && $util.isInteger(message.config_seq.low) && $util.isInteger(message.config_seq.high)))
                        return "config_seq: integer|Long expected";
                if (message["class"] != null && message.hasOwnProperty("class"))
                    switch (message["class"]) {
                    default:
                        return "class: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.original_offset != null && message.hasOwnProperty("original_offset"))
                    if (!$util.isInteger(message.original_offset) && !(message.original_offset && $util.isInteger(message.original_offset.low) && $util.isInteger(message.original_offset.high)))
                        return "original_offset: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a KafkaMessageRegular message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMessageRegular} KafkaMessageRegular
             */
            KafkaMessageRegular.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMessageRegular)
                    return object;
                var message = new $root.orderer.KafkaMessageRegular();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.config_seq != null)
                    if ($util.Long)
                        (message.config_seq = $util.Long.fromValue(object.config_seq)).unsigned = true;
                    else if (typeof object.config_seq === "string")
                        message.config_seq = parseInt(object.config_seq, 10);
                    else if (typeof object.config_seq === "number")
                        message.config_seq = object.config_seq;
                    else if (typeof object.config_seq === "object")
                        message.config_seq = new $util.LongBits(object.config_seq.low >>> 0, object.config_seq.high >>> 0).toNumber(true);
                switch (object["class"]) {
                case "UNKNOWN":
                case 0:
                    message["class"] = 0;
                    break;
                case "NORMAL":
                case 1:
                    message["class"] = 1;
                    break;
                case "CONFIG":
                case 2:
                    message["class"] = 2;
                    break;
                }
                if (object.original_offset != null)
                    if ($util.Long)
                        (message.original_offset = $util.Long.fromValue(object.original_offset)).unsigned = false;
                    else if (typeof object.original_offset === "string")
                        message.original_offset = parseInt(object.original_offset, 10);
                    else if (typeof object.original_offset === "number")
                        message.original_offset = object.original_offset;
                    else if (typeof object.original_offset === "object")
                        message.original_offset = new $util.LongBits(object.original_offset.low >>> 0, object.original_offset.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMessageRegular message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {orderer.KafkaMessageRegular} message KafkaMessageRegular
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMessageRegular.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.config_seq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.config_seq = options.longs === String ? "0" : 0;
                    object["class"] = options.enums === String ? "UNKNOWN" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.original_offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.original_offset = options.longs === String ? "0" : 0;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.config_seq != null && message.hasOwnProperty("config_seq"))
                    if (typeof message.config_seq === "number")
                        object.config_seq = options.longs === String ? String(message.config_seq) : message.config_seq;
                    else
                        object.config_seq = options.longs === String ? $util.Long.prototype.toString.call(message.config_seq) : options.longs === Number ? new $util.LongBits(message.config_seq.low >>> 0, message.config_seq.high >>> 0).toNumber(true) : message.config_seq;
                if (message["class"] != null && message.hasOwnProperty("class"))
                    object["class"] = options.enums === String ? $root.orderer.KafkaMessageRegular.Class[message["class"]] : message["class"];
                if (message.original_offset != null && message.hasOwnProperty("original_offset"))
                    if (typeof message.original_offset === "number")
                        object.original_offset = options.longs === String ? String(message.original_offset) : message.original_offset;
                    else
                        object.original_offset = options.longs === String ? $util.Long.prototype.toString.call(message.original_offset) : options.longs === Number ? new $util.LongBits(message.original_offset.low >>> 0, message.original_offset.high >>> 0).toNumber() : message.original_offset;
                return object;
            };
    
            /**
             * Converts this KafkaMessageRegular to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMessageRegular
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMessageRegular.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Class enum.
             * @name orderer.KafkaMessageRegular.Class
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} NORMAL=1 NORMAL value
             * @property {number} CONFIG=2 CONFIG value
             */
            KafkaMessageRegular.Class = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "NORMAL"] = 1;
                values[valuesById[2] = "CONFIG"] = 2;
                return values;
            })();
    
            return KafkaMessageRegular;
        })();
    
        orderer.KafkaMessageTimeToCut = (function() {
    
            /**
             * Properties of a KafkaMessageTimeToCut.
             * @memberof orderer
             * @interface IKafkaMessageTimeToCut
             * @property {number|Long|null} [block_number] KafkaMessageTimeToCut block_number
             */
    
            /**
             * Constructs a new KafkaMessageTimeToCut.
             * @memberof orderer
             * @classdesc Represents a KafkaMessageTimeToCut.
             * @implements IKafkaMessageTimeToCut
             * @constructor
             * @param {orderer.IKafkaMessageTimeToCut=} [properties] Properties to set
             */
            function KafkaMessageTimeToCut(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMessageTimeToCut block_number.
             * @member {number|Long} block_number
             * @memberof orderer.KafkaMessageTimeToCut
             * @instance
             */
            KafkaMessageTimeToCut.prototype.block_number = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new KafkaMessageTimeToCut instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {orderer.IKafkaMessageTimeToCut=} [properties] Properties to set
             * @returns {orderer.KafkaMessageTimeToCut} KafkaMessageTimeToCut instance
             */
            KafkaMessageTimeToCut.create = function create(properties) {
                return new KafkaMessageTimeToCut(properties);
            };
    
            /**
             * Encodes the specified KafkaMessageTimeToCut message. Does not implicitly {@link orderer.KafkaMessageTimeToCut.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {orderer.IKafkaMessageTimeToCut} message KafkaMessageTimeToCut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageTimeToCut.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.block_number != null && Object.hasOwnProperty.call(message, "block_number"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.block_number);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMessageTimeToCut message, length delimited. Does not implicitly {@link orderer.KafkaMessageTimeToCut.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {orderer.IKafkaMessageTimeToCut} message KafkaMessageTimeToCut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageTimeToCut.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMessageTimeToCut message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMessageTimeToCut} KafkaMessageTimeToCut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageTimeToCut.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMessageTimeToCut();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.block_number = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMessageTimeToCut message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMessageTimeToCut} KafkaMessageTimeToCut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageTimeToCut.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMessageTimeToCut message.
             * @function verify
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMessageTimeToCut.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.block_number != null && message.hasOwnProperty("block_number"))
                    if (!$util.isInteger(message.block_number) && !(message.block_number && $util.isInteger(message.block_number.low) && $util.isInteger(message.block_number.high)))
                        return "block_number: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a KafkaMessageTimeToCut message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMessageTimeToCut} KafkaMessageTimeToCut
             */
            KafkaMessageTimeToCut.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMessageTimeToCut)
                    return object;
                var message = new $root.orderer.KafkaMessageTimeToCut();
                if (object.block_number != null)
                    if ($util.Long)
                        (message.block_number = $util.Long.fromValue(object.block_number)).unsigned = true;
                    else if (typeof object.block_number === "string")
                        message.block_number = parseInt(object.block_number, 10);
                    else if (typeof object.block_number === "number")
                        message.block_number = object.block_number;
                    else if (typeof object.block_number === "object")
                        message.block_number = new $util.LongBits(object.block_number.low >>> 0, object.block_number.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMessageTimeToCut message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {orderer.KafkaMessageTimeToCut} message KafkaMessageTimeToCut
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMessageTimeToCut.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.block_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_number = options.longs === String ? "0" : 0;
                if (message.block_number != null && message.hasOwnProperty("block_number"))
                    if (typeof message.block_number === "number")
                        object.block_number = options.longs === String ? String(message.block_number) : message.block_number;
                    else
                        object.block_number = options.longs === String ? $util.Long.prototype.toString.call(message.block_number) : options.longs === Number ? new $util.LongBits(message.block_number.low >>> 0, message.block_number.high >>> 0).toNumber(true) : message.block_number;
                return object;
            };
    
            /**
             * Converts this KafkaMessageTimeToCut to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMessageTimeToCut
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMessageTimeToCut.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaMessageTimeToCut;
        })();
    
        orderer.KafkaMessageConnect = (function() {
    
            /**
             * Properties of a KafkaMessageConnect.
             * @memberof orderer
             * @interface IKafkaMessageConnect
             * @property {Uint8Array|null} [payload] KafkaMessageConnect payload
             */
    
            /**
             * Constructs a new KafkaMessageConnect.
             * @memberof orderer
             * @classdesc Represents a KafkaMessageConnect.
             * @implements IKafkaMessageConnect
             * @constructor
             * @param {orderer.IKafkaMessageConnect=} [properties] Properties to set
             */
            function KafkaMessageConnect(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMessageConnect payload.
             * @member {Uint8Array} payload
             * @memberof orderer.KafkaMessageConnect
             * @instance
             */
            KafkaMessageConnect.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new KafkaMessageConnect instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {orderer.IKafkaMessageConnect=} [properties] Properties to set
             * @returns {orderer.KafkaMessageConnect} KafkaMessageConnect instance
             */
            KafkaMessageConnect.create = function create(properties) {
                return new KafkaMessageConnect(properties);
            };
    
            /**
             * Encodes the specified KafkaMessageConnect message. Does not implicitly {@link orderer.KafkaMessageConnect.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {orderer.IKafkaMessageConnect} message KafkaMessageConnect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageConnect.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMessageConnect message, length delimited. Does not implicitly {@link orderer.KafkaMessageConnect.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {orderer.IKafkaMessageConnect} message KafkaMessageConnect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageConnect.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMessageConnect message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMessageConnect} KafkaMessageConnect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageConnect.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMessageConnect();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMessageConnect message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMessageConnect} KafkaMessageConnect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageConnect.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMessageConnect message.
             * @function verify
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMessageConnect.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a KafkaMessageConnect message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMessageConnect} KafkaMessageConnect
             */
            KafkaMessageConnect.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMessageConnect)
                    return object;
                var message = new $root.orderer.KafkaMessageConnect();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMessageConnect message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {orderer.KafkaMessageConnect} message KafkaMessageConnect
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMessageConnect.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this KafkaMessageConnect to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMessageConnect
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMessageConnect.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaMessageConnect;
        })();
    
        orderer.KafkaMetadata = (function() {
    
            /**
             * Properties of a KafkaMetadata.
             * @memberof orderer
             * @interface IKafkaMetadata
             * @property {number|Long|null} [last_offset_persisted] KafkaMetadata last_offset_persisted
             * @property {number|Long|null} [last_original_offset_processed] KafkaMetadata last_original_offset_processed
             * @property {number|Long|null} [last_resubmitted_config_offset] KafkaMetadata last_resubmitted_config_offset
             */
    
            /**
             * Constructs a new KafkaMetadata.
             * @memberof orderer
             * @classdesc Represents a KafkaMetadata.
             * @implements IKafkaMetadata
             * @constructor
             * @param {orderer.IKafkaMetadata=} [properties] Properties to set
             */
            function KafkaMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMetadata last_offset_persisted.
             * @member {number|Long} last_offset_persisted
             * @memberof orderer.KafkaMetadata
             * @instance
             */
            KafkaMetadata.prototype.last_offset_persisted = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * KafkaMetadata last_original_offset_processed.
             * @member {number|Long} last_original_offset_processed
             * @memberof orderer.KafkaMetadata
             * @instance
             */
            KafkaMetadata.prototype.last_original_offset_processed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * KafkaMetadata last_resubmitted_config_offset.
             * @member {number|Long} last_resubmitted_config_offset
             * @memberof orderer.KafkaMetadata
             * @instance
             */
            KafkaMetadata.prototype.last_resubmitted_config_offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new KafkaMetadata instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {orderer.IKafkaMetadata=} [properties] Properties to set
             * @returns {orderer.KafkaMetadata} KafkaMetadata instance
             */
            KafkaMetadata.create = function create(properties) {
                return new KafkaMetadata(properties);
            };
    
            /**
             * Encodes the specified KafkaMetadata message. Does not implicitly {@link orderer.KafkaMetadata.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {orderer.IKafkaMetadata} message KafkaMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.last_offset_persisted != null && Object.hasOwnProperty.call(message, "last_offset_persisted"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.last_offset_persisted);
                if (message.last_original_offset_processed != null && Object.hasOwnProperty.call(message, "last_original_offset_processed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.last_original_offset_processed);
                if (message.last_resubmitted_config_offset != null && Object.hasOwnProperty.call(message, "last_resubmitted_config_offset"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.last_resubmitted_config_offset);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMetadata message, length delimited. Does not implicitly {@link orderer.KafkaMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {orderer.IKafkaMetadata} message KafkaMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMetadata} KafkaMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.last_offset_persisted = reader.int64();
                        break;
                    case 2:
                        message.last_original_offset_processed = reader.int64();
                        break;
                    case 3:
                        message.last_resubmitted_config_offset = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMetadata} KafkaMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMetadata message.
             * @function verify
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.last_offset_persisted != null && message.hasOwnProperty("last_offset_persisted"))
                    if (!$util.isInteger(message.last_offset_persisted) && !(message.last_offset_persisted && $util.isInteger(message.last_offset_persisted.low) && $util.isInteger(message.last_offset_persisted.high)))
                        return "last_offset_persisted: integer|Long expected";
                if (message.last_original_offset_processed != null && message.hasOwnProperty("last_original_offset_processed"))
                    if (!$util.isInteger(message.last_original_offset_processed) && !(message.last_original_offset_processed && $util.isInteger(message.last_original_offset_processed.low) && $util.isInteger(message.last_original_offset_processed.high)))
                        return "last_original_offset_processed: integer|Long expected";
                if (message.last_resubmitted_config_offset != null && message.hasOwnProperty("last_resubmitted_config_offset"))
                    if (!$util.isInteger(message.last_resubmitted_config_offset) && !(message.last_resubmitted_config_offset && $util.isInteger(message.last_resubmitted_config_offset.low) && $util.isInteger(message.last_resubmitted_config_offset.high)))
                        return "last_resubmitted_config_offset: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a KafkaMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMetadata} KafkaMetadata
             */
            KafkaMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMetadata)
                    return object;
                var message = new $root.orderer.KafkaMetadata();
                if (object.last_offset_persisted != null)
                    if ($util.Long)
                        (message.last_offset_persisted = $util.Long.fromValue(object.last_offset_persisted)).unsigned = false;
                    else if (typeof object.last_offset_persisted === "string")
                        message.last_offset_persisted = parseInt(object.last_offset_persisted, 10);
                    else if (typeof object.last_offset_persisted === "number")
                        message.last_offset_persisted = object.last_offset_persisted;
                    else if (typeof object.last_offset_persisted === "object")
                        message.last_offset_persisted = new $util.LongBits(object.last_offset_persisted.low >>> 0, object.last_offset_persisted.high >>> 0).toNumber();
                if (object.last_original_offset_processed != null)
                    if ($util.Long)
                        (message.last_original_offset_processed = $util.Long.fromValue(object.last_original_offset_processed)).unsigned = false;
                    else if (typeof object.last_original_offset_processed === "string")
                        message.last_original_offset_processed = parseInt(object.last_original_offset_processed, 10);
                    else if (typeof object.last_original_offset_processed === "number")
                        message.last_original_offset_processed = object.last_original_offset_processed;
                    else if (typeof object.last_original_offset_processed === "object")
                        message.last_original_offset_processed = new $util.LongBits(object.last_original_offset_processed.low >>> 0, object.last_original_offset_processed.high >>> 0).toNumber();
                if (object.last_resubmitted_config_offset != null)
                    if ($util.Long)
                        (message.last_resubmitted_config_offset = $util.Long.fromValue(object.last_resubmitted_config_offset)).unsigned = false;
                    else if (typeof object.last_resubmitted_config_offset === "string")
                        message.last_resubmitted_config_offset = parseInt(object.last_resubmitted_config_offset, 10);
                    else if (typeof object.last_resubmitted_config_offset === "number")
                        message.last_resubmitted_config_offset = object.last_resubmitted_config_offset;
                    else if (typeof object.last_resubmitted_config_offset === "object")
                        message.last_resubmitted_config_offset = new $util.LongBits(object.last_resubmitted_config_offset.low >>> 0, object.last_resubmitted_config_offset.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {orderer.KafkaMetadata} message KafkaMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.last_offset_persisted = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_offset_persisted = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.last_original_offset_processed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_original_offset_processed = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.last_resubmitted_config_offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_resubmitted_config_offset = options.longs === String ? "0" : 0;
                }
                if (message.last_offset_persisted != null && message.hasOwnProperty("last_offset_persisted"))
                    if (typeof message.last_offset_persisted === "number")
                        object.last_offset_persisted = options.longs === String ? String(message.last_offset_persisted) : message.last_offset_persisted;
                    else
                        object.last_offset_persisted = options.longs === String ? $util.Long.prototype.toString.call(message.last_offset_persisted) : options.longs === Number ? new $util.LongBits(message.last_offset_persisted.low >>> 0, message.last_offset_persisted.high >>> 0).toNumber() : message.last_offset_persisted;
                if (message.last_original_offset_processed != null && message.hasOwnProperty("last_original_offset_processed"))
                    if (typeof message.last_original_offset_processed === "number")
                        object.last_original_offset_processed = options.longs === String ? String(message.last_original_offset_processed) : message.last_original_offset_processed;
                    else
                        object.last_original_offset_processed = options.longs === String ? $util.Long.prototype.toString.call(message.last_original_offset_processed) : options.longs === Number ? new $util.LongBits(message.last_original_offset_processed.low >>> 0, message.last_original_offset_processed.high >>> 0).toNumber() : message.last_original_offset_processed;
                if (message.last_resubmitted_config_offset != null && message.hasOwnProperty("last_resubmitted_config_offset"))
                    if (typeof message.last_resubmitted_config_offset === "number")
                        object.last_resubmitted_config_offset = options.longs === String ? String(message.last_resubmitted_config_offset) : message.last_resubmitted_config_offset;
                    else
                        object.last_resubmitted_config_offset = options.longs === String ? $util.Long.prototype.toString.call(message.last_resubmitted_config_offset) : options.longs === Number ? new $util.LongBits(message.last_resubmitted_config_offset.low >>> 0, message.last_resubmitted_config_offset.high >>> 0).toNumber() : message.last_resubmitted_config_offset;
                return object;
            };
    
            /**
             * Converts this KafkaMetadata to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaMetadata;
        })();
    
        orderer.BroadcastResponse = (function() {
    
            /**
             * Properties of a BroadcastResponse.
             * @memberof orderer
             * @interface IBroadcastResponse
             * @property {common.Status|null} [status] BroadcastResponse status
             * @property {string|null} [info] BroadcastResponse info
             */
    
            /**
             * Constructs a new BroadcastResponse.
             * @memberof orderer
             * @classdesc Represents a BroadcastResponse.
             * @implements IBroadcastResponse
             * @constructor
             * @param {orderer.IBroadcastResponse=} [properties] Properties to set
             */
            function BroadcastResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BroadcastResponse status.
             * @member {common.Status} status
             * @memberof orderer.BroadcastResponse
             * @instance
             */
            BroadcastResponse.prototype.status = 0;
    
            /**
             * BroadcastResponse info.
             * @member {string} info
             * @memberof orderer.BroadcastResponse
             * @instance
             */
            BroadcastResponse.prototype.info = "";
    
            /**
             * Creates a new BroadcastResponse instance using the specified properties.
             * @function create
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {orderer.IBroadcastResponse=} [properties] Properties to set
             * @returns {orderer.BroadcastResponse} BroadcastResponse instance
             */
            BroadcastResponse.create = function create(properties) {
                return new BroadcastResponse(properties);
            };
    
            /**
             * Encodes the specified BroadcastResponse message. Does not implicitly {@link orderer.BroadcastResponse.verify|verify} messages.
             * @function encode
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {orderer.IBroadcastResponse} message BroadcastResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BroadcastResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.info);
                return writer;
            };
    
            /**
             * Encodes the specified BroadcastResponse message, length delimited. Does not implicitly {@link orderer.BroadcastResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {orderer.IBroadcastResponse} message BroadcastResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BroadcastResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BroadcastResponse message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.BroadcastResponse} BroadcastResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BroadcastResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.BroadcastResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.info = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BroadcastResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.BroadcastResponse} BroadcastResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BroadcastResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BroadcastResponse message.
             * @function verify
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BroadcastResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 200:
                    case 400:
                    case 403:
                    case 404:
                    case 413:
                    case 500:
                    case 501:
                    case 503:
                        break;
                    }
                if (message.info != null && message.hasOwnProperty("info"))
                    if (!$util.isString(message.info))
                        return "info: string expected";
                return null;
            };
    
            /**
             * Creates a BroadcastResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.BroadcastResponse} BroadcastResponse
             */
            BroadcastResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.BroadcastResponse)
                    return object;
                var message = new $root.orderer.BroadcastResponse();
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 200:
                    message.status = 200;
                    break;
                case "BAD_REQUEST":
                case 400:
                    message.status = 400;
                    break;
                case "FORBIDDEN":
                case 403:
                    message.status = 403;
                    break;
                case "NOT_FOUND":
                case 404:
                    message.status = 404;
                    break;
                case "REQUEST_ENTITY_TOO_LARGE":
                case 413:
                    message.status = 413;
                    break;
                case "INTERNAL_SERVER_ERROR":
                case 500:
                    message.status = 500;
                    break;
                case "NOT_IMPLEMENTED":
                case 501:
                    message.status = 501;
                    break;
                case "SERVICE_UNAVAILABLE":
                case 503:
                    message.status = 503;
                    break;
                }
                if (object.info != null)
                    message.info = String(object.info);
                return message;
            };
    
            /**
             * Creates a plain object from a BroadcastResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {orderer.BroadcastResponse} message BroadcastResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BroadcastResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.status = options.enums === String ? "UNKNOWN" : 0;
                    object.info = "";
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.common.Status[message.status] : message.status;
                if (message.info != null && message.hasOwnProperty("info"))
                    object.info = message.info;
                return object;
            };
    
            /**
             * Converts this BroadcastResponse to JSON.
             * @function toJSON
             * @memberof orderer.BroadcastResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BroadcastResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BroadcastResponse;
        })();
    
        orderer.SeekNewest = (function() {
    
            /**
             * Properties of a SeekNewest.
             * @memberof orderer
             * @interface ISeekNewest
             */
    
            /**
             * Constructs a new SeekNewest.
             * @memberof orderer
             * @classdesc Represents a SeekNewest.
             * @implements ISeekNewest
             * @constructor
             * @param {orderer.ISeekNewest=} [properties] Properties to set
             */
            function SeekNewest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SeekNewest instance using the specified properties.
             * @function create
             * @memberof orderer.SeekNewest
             * @static
             * @param {orderer.ISeekNewest=} [properties] Properties to set
             * @returns {orderer.SeekNewest} SeekNewest instance
             */
            SeekNewest.create = function create(properties) {
                return new SeekNewest(properties);
            };
    
            /**
             * Encodes the specified SeekNewest message. Does not implicitly {@link orderer.SeekNewest.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekNewest
             * @static
             * @param {orderer.ISeekNewest} message SeekNewest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekNewest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified SeekNewest message, length delimited. Does not implicitly {@link orderer.SeekNewest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekNewest
             * @static
             * @param {orderer.ISeekNewest} message SeekNewest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekNewest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekNewest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekNewest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekNewest} SeekNewest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekNewest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekNewest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekNewest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekNewest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekNewest} SeekNewest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekNewest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekNewest message.
             * @function verify
             * @memberof orderer.SeekNewest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekNewest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a SeekNewest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekNewest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekNewest} SeekNewest
             */
            SeekNewest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekNewest)
                    return object;
                return new $root.orderer.SeekNewest();
            };
    
            /**
             * Creates a plain object from a SeekNewest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekNewest
             * @static
             * @param {orderer.SeekNewest} message SeekNewest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekNewest.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this SeekNewest to JSON.
             * @function toJSON
             * @memberof orderer.SeekNewest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekNewest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeekNewest;
        })();
    
        orderer.SeekOldest = (function() {
    
            /**
             * Properties of a SeekOldest.
             * @memberof orderer
             * @interface ISeekOldest
             */
    
            /**
             * Constructs a new SeekOldest.
             * @memberof orderer
             * @classdesc Represents a SeekOldest.
             * @implements ISeekOldest
             * @constructor
             * @param {orderer.ISeekOldest=} [properties] Properties to set
             */
            function SeekOldest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SeekOldest instance using the specified properties.
             * @function create
             * @memberof orderer.SeekOldest
             * @static
             * @param {orderer.ISeekOldest=} [properties] Properties to set
             * @returns {orderer.SeekOldest} SeekOldest instance
             */
            SeekOldest.create = function create(properties) {
                return new SeekOldest(properties);
            };
    
            /**
             * Encodes the specified SeekOldest message. Does not implicitly {@link orderer.SeekOldest.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekOldest
             * @static
             * @param {orderer.ISeekOldest} message SeekOldest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekOldest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified SeekOldest message, length delimited. Does not implicitly {@link orderer.SeekOldest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekOldest
             * @static
             * @param {orderer.ISeekOldest} message SeekOldest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekOldest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekOldest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekOldest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekOldest} SeekOldest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekOldest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekOldest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekOldest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekOldest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekOldest} SeekOldest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekOldest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekOldest message.
             * @function verify
             * @memberof orderer.SeekOldest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekOldest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a SeekOldest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekOldest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekOldest} SeekOldest
             */
            SeekOldest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekOldest)
                    return object;
                return new $root.orderer.SeekOldest();
            };
    
            /**
             * Creates a plain object from a SeekOldest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekOldest
             * @static
             * @param {orderer.SeekOldest} message SeekOldest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekOldest.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this SeekOldest to JSON.
             * @function toJSON
             * @memberof orderer.SeekOldest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekOldest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeekOldest;
        })();
    
        orderer.SeekSpecified = (function() {
    
            /**
             * Properties of a SeekSpecified.
             * @memberof orderer
             * @interface ISeekSpecified
             * @property {number|Long|null} [number] SeekSpecified number
             */
    
            /**
             * Constructs a new SeekSpecified.
             * @memberof orderer
             * @classdesc Represents a SeekSpecified.
             * @implements ISeekSpecified
             * @constructor
             * @param {orderer.ISeekSpecified=} [properties] Properties to set
             */
            function SeekSpecified(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeekSpecified number.
             * @member {number|Long} number
             * @memberof orderer.SeekSpecified
             * @instance
             */
            SeekSpecified.prototype.number = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new SeekSpecified instance using the specified properties.
             * @function create
             * @memberof orderer.SeekSpecified
             * @static
             * @param {orderer.ISeekSpecified=} [properties] Properties to set
             * @returns {orderer.SeekSpecified} SeekSpecified instance
             */
            SeekSpecified.create = function create(properties) {
                return new SeekSpecified(properties);
            };
    
            /**
             * Encodes the specified SeekSpecified message. Does not implicitly {@link orderer.SeekSpecified.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekSpecified
             * @static
             * @param {orderer.ISeekSpecified} message SeekSpecified message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekSpecified.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.number);
                return writer;
            };
    
            /**
             * Encodes the specified SeekSpecified message, length delimited. Does not implicitly {@link orderer.SeekSpecified.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekSpecified
             * @static
             * @param {orderer.ISeekSpecified} message SeekSpecified message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekSpecified.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekSpecified message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekSpecified
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekSpecified} SeekSpecified
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekSpecified.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekSpecified();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.number = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekSpecified message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekSpecified
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekSpecified} SeekSpecified
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekSpecified.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekSpecified message.
             * @function verify
             * @memberof orderer.SeekSpecified
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekSpecified.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a SeekSpecified message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekSpecified
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekSpecified} SeekSpecified
             */
            SeekSpecified.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekSpecified)
                    return object;
                var message = new $root.orderer.SeekSpecified();
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = true;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a SeekSpecified message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekSpecified
             * @static
             * @param {orderer.SeekSpecified} message SeekSpecified
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekSpecified.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber(true) : message.number;
                return object;
            };
    
            /**
             * Converts this SeekSpecified to JSON.
             * @function toJSON
             * @memberof orderer.SeekSpecified
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekSpecified.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeekSpecified;
        })();
    
        orderer.SeekPosition = (function() {
    
            /**
             * Properties of a SeekPosition.
             * @memberof orderer
             * @interface ISeekPosition
             * @property {orderer.ISeekNewest|null} [newest] SeekPosition newest
             * @property {orderer.ISeekOldest|null} [oldest] SeekPosition oldest
             * @property {orderer.ISeekSpecified|null} [specified] SeekPosition specified
             */
    
            /**
             * Constructs a new SeekPosition.
             * @memberof orderer
             * @classdesc Represents a SeekPosition.
             * @implements ISeekPosition
             * @constructor
             * @param {orderer.ISeekPosition=} [properties] Properties to set
             */
            function SeekPosition(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeekPosition newest.
             * @member {orderer.ISeekNewest|null|undefined} newest
             * @memberof orderer.SeekPosition
             * @instance
             */
            SeekPosition.prototype.newest = null;
    
            /**
             * SeekPosition oldest.
             * @member {orderer.ISeekOldest|null|undefined} oldest
             * @memberof orderer.SeekPosition
             * @instance
             */
            SeekPosition.prototype.oldest = null;
    
            /**
             * SeekPosition specified.
             * @member {orderer.ISeekSpecified|null|undefined} specified
             * @memberof orderer.SeekPosition
             * @instance
             */
            SeekPosition.prototype.specified = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * SeekPosition Type.
             * @member {"newest"|"oldest"|"specified"|undefined} Type
             * @memberof orderer.SeekPosition
             * @instance
             */
            Object.defineProperty(SeekPosition.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["newest", "oldest", "specified"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new SeekPosition instance using the specified properties.
             * @function create
             * @memberof orderer.SeekPosition
             * @static
             * @param {orderer.ISeekPosition=} [properties] Properties to set
             * @returns {orderer.SeekPosition} SeekPosition instance
             */
            SeekPosition.create = function create(properties) {
                return new SeekPosition(properties);
            };
    
            /**
             * Encodes the specified SeekPosition message. Does not implicitly {@link orderer.SeekPosition.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekPosition
             * @static
             * @param {orderer.ISeekPosition} message SeekPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekPosition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.newest != null && Object.hasOwnProperty.call(message, "newest"))
                    $root.orderer.SeekNewest.encode(message.newest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.oldest != null && Object.hasOwnProperty.call(message, "oldest"))
                    $root.orderer.SeekOldest.encode(message.oldest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.specified != null && Object.hasOwnProperty.call(message, "specified"))
                    $root.orderer.SeekSpecified.encode(message.specified, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SeekPosition message, length delimited. Does not implicitly {@link orderer.SeekPosition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekPosition
             * @static
             * @param {orderer.ISeekPosition} message SeekPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekPosition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekPosition message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekPosition} SeekPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekPosition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekPosition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.newest = $root.orderer.SeekNewest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.oldest = $root.orderer.SeekOldest.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.specified = $root.orderer.SeekSpecified.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekPosition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekPosition} SeekPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekPosition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekPosition message.
             * @function verify
             * @memberof orderer.SeekPosition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekPosition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.newest != null && message.hasOwnProperty("newest")) {
                    properties.Type = 1;
                    {
                        var error = $root.orderer.SeekNewest.verify(message.newest);
                        if (error)
                            return "newest." + error;
                    }
                }
                if (message.oldest != null && message.hasOwnProperty("oldest")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.orderer.SeekOldest.verify(message.oldest);
                        if (error)
                            return "oldest." + error;
                    }
                }
                if (message.specified != null && message.hasOwnProperty("specified")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.orderer.SeekSpecified.verify(message.specified);
                        if (error)
                            return "specified." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SeekPosition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekPosition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekPosition} SeekPosition
             */
            SeekPosition.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekPosition)
                    return object;
                var message = new $root.orderer.SeekPosition();
                if (object.newest != null) {
                    if (typeof object.newest !== "object")
                        throw TypeError(".orderer.SeekPosition.newest: object expected");
                    message.newest = $root.orderer.SeekNewest.fromObject(object.newest);
                }
                if (object.oldest != null) {
                    if (typeof object.oldest !== "object")
                        throw TypeError(".orderer.SeekPosition.oldest: object expected");
                    message.oldest = $root.orderer.SeekOldest.fromObject(object.oldest);
                }
                if (object.specified != null) {
                    if (typeof object.specified !== "object")
                        throw TypeError(".orderer.SeekPosition.specified: object expected");
                    message.specified = $root.orderer.SeekSpecified.fromObject(object.specified);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeekPosition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekPosition
             * @static
             * @param {orderer.SeekPosition} message SeekPosition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekPosition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.newest != null && message.hasOwnProperty("newest")) {
                    object.newest = $root.orderer.SeekNewest.toObject(message.newest, options);
                    if (options.oneofs)
                        object.Type = "newest";
                }
                if (message.oldest != null && message.hasOwnProperty("oldest")) {
                    object.oldest = $root.orderer.SeekOldest.toObject(message.oldest, options);
                    if (options.oneofs)
                        object.Type = "oldest";
                }
                if (message.specified != null && message.hasOwnProperty("specified")) {
                    object.specified = $root.orderer.SeekSpecified.toObject(message.specified, options);
                    if (options.oneofs)
                        object.Type = "specified";
                }
                return object;
            };
    
            /**
             * Converts this SeekPosition to JSON.
             * @function toJSON
             * @memberof orderer.SeekPosition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekPosition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeekPosition;
        })();
    
        orderer.SeekInfo = (function() {
    
            /**
             * Properties of a SeekInfo.
             * @memberof orderer
             * @interface ISeekInfo
             * @property {orderer.ISeekPosition|null} [start] SeekInfo start
             * @property {orderer.ISeekPosition|null} [stop] SeekInfo stop
             * @property {orderer.SeekInfo.SeekBehavior|null} [behavior] SeekInfo behavior
             * @property {orderer.SeekInfo.SeekErrorResponse|null} [error_response] SeekInfo error_response
             */
    
            /**
             * Constructs a new SeekInfo.
             * @memberof orderer
             * @classdesc Represents a SeekInfo.
             * @implements ISeekInfo
             * @constructor
             * @param {orderer.ISeekInfo=} [properties] Properties to set
             */
            function SeekInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeekInfo start.
             * @member {orderer.ISeekPosition|null|undefined} start
             * @memberof orderer.SeekInfo
             * @instance
             */
            SeekInfo.prototype.start = null;
    
            /**
             * SeekInfo stop.
             * @member {orderer.ISeekPosition|null|undefined} stop
             * @memberof orderer.SeekInfo
             * @instance
             */
            SeekInfo.prototype.stop = null;
    
            /**
             * SeekInfo behavior.
             * @member {orderer.SeekInfo.SeekBehavior} behavior
             * @memberof orderer.SeekInfo
             * @instance
             */
            SeekInfo.prototype.behavior = 0;
    
            /**
             * SeekInfo error_response.
             * @member {orderer.SeekInfo.SeekErrorResponse} error_response
             * @memberof orderer.SeekInfo
             * @instance
             */
            SeekInfo.prototype.error_response = 0;
    
            /**
             * Creates a new SeekInfo instance using the specified properties.
             * @function create
             * @memberof orderer.SeekInfo
             * @static
             * @param {orderer.ISeekInfo=} [properties] Properties to set
             * @returns {orderer.SeekInfo} SeekInfo instance
             */
            SeekInfo.create = function create(properties) {
                return new SeekInfo(properties);
            };
    
            /**
             * Encodes the specified SeekInfo message. Does not implicitly {@link orderer.SeekInfo.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekInfo
             * @static
             * @param {orderer.ISeekInfo} message SeekInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    $root.orderer.SeekPosition.encode(message.start, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.stop != null && Object.hasOwnProperty.call(message, "stop"))
                    $root.orderer.SeekPosition.encode(message.stop, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.behavior != null && Object.hasOwnProperty.call(message, "behavior"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.behavior);
                if (message.error_response != null && Object.hasOwnProperty.call(message, "error_response"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.error_response);
                return writer;
            };
    
            /**
             * Encodes the specified SeekInfo message, length delimited. Does not implicitly {@link orderer.SeekInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekInfo
             * @static
             * @param {orderer.ISeekInfo} message SeekInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekInfo message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekInfo} SeekInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start = $root.orderer.SeekPosition.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.stop = $root.orderer.SeekPosition.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.behavior = reader.int32();
                        break;
                    case 4:
                        message.error_response = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekInfo} SeekInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekInfo message.
             * @function verify
             * @memberof orderer.SeekInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start")) {
                    var error = $root.orderer.SeekPosition.verify(message.start);
                    if (error)
                        return "start." + error;
                }
                if (message.stop != null && message.hasOwnProperty("stop")) {
                    var error = $root.orderer.SeekPosition.verify(message.stop);
                    if (error)
                        return "stop." + error;
                }
                if (message.behavior != null && message.hasOwnProperty("behavior"))
                    switch (message.behavior) {
                    default:
                        return "behavior: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.error_response != null && message.hasOwnProperty("error_response"))
                    switch (message.error_response) {
                    default:
                        return "error_response: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a SeekInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekInfo} SeekInfo
             */
            SeekInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekInfo)
                    return object;
                var message = new $root.orderer.SeekInfo();
                if (object.start != null) {
                    if (typeof object.start !== "object")
                        throw TypeError(".orderer.SeekInfo.start: object expected");
                    message.start = $root.orderer.SeekPosition.fromObject(object.start);
                }
                if (object.stop != null) {
                    if (typeof object.stop !== "object")
                        throw TypeError(".orderer.SeekInfo.stop: object expected");
                    message.stop = $root.orderer.SeekPosition.fromObject(object.stop);
                }
                switch (object.behavior) {
                case "BLOCK_UNTIL_READY":
                case 0:
                    message.behavior = 0;
                    break;
                case "FAIL_IF_NOT_READY":
                case 1:
                    message.behavior = 1;
                    break;
                }
                switch (object.error_response) {
                case "STRICT":
                case 0:
                    message.error_response = 0;
                    break;
                case "BEST_EFFORT":
                case 1:
                    message.error_response = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeekInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekInfo
             * @static
             * @param {orderer.SeekInfo} message SeekInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.start = null;
                    object.stop = null;
                    object.behavior = options.enums === String ? "BLOCK_UNTIL_READY" : 0;
                    object.error_response = options.enums === String ? "STRICT" : 0;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = $root.orderer.SeekPosition.toObject(message.start, options);
                if (message.stop != null && message.hasOwnProperty("stop"))
                    object.stop = $root.orderer.SeekPosition.toObject(message.stop, options);
                if (message.behavior != null && message.hasOwnProperty("behavior"))
                    object.behavior = options.enums === String ? $root.orderer.SeekInfo.SeekBehavior[message.behavior] : message.behavior;
                if (message.error_response != null && message.hasOwnProperty("error_response"))
                    object.error_response = options.enums === String ? $root.orderer.SeekInfo.SeekErrorResponse[message.error_response] : message.error_response;
                return object;
            };
    
            /**
             * Converts this SeekInfo to JSON.
             * @function toJSON
             * @memberof orderer.SeekInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * SeekBehavior enum.
             * @name orderer.SeekInfo.SeekBehavior
             * @enum {number}
             * @property {number} BLOCK_UNTIL_READY=0 BLOCK_UNTIL_READY value
             * @property {number} FAIL_IF_NOT_READY=1 FAIL_IF_NOT_READY value
             */
            SeekInfo.SeekBehavior = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BLOCK_UNTIL_READY"] = 0;
                values[valuesById[1] = "FAIL_IF_NOT_READY"] = 1;
                return values;
            })();
    
            /**
             * SeekErrorResponse enum.
             * @name orderer.SeekInfo.SeekErrorResponse
             * @enum {number}
             * @property {number} STRICT=0 STRICT value
             * @property {number} BEST_EFFORT=1 BEST_EFFORT value
             */
            SeekInfo.SeekErrorResponse = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRICT"] = 0;
                values[valuesById[1] = "BEST_EFFORT"] = 1;
                return values;
            })();
    
            return SeekInfo;
        })();
    
        orderer.DeliverResponse = (function() {
    
            /**
             * Properties of a DeliverResponse.
             * @memberof orderer
             * @interface IDeliverResponse
             * @property {common.Status|null} [status] DeliverResponse status
             * @property {common.IBlock|null} [block] DeliverResponse block
             */
    
            /**
             * Constructs a new DeliverResponse.
             * @memberof orderer
             * @classdesc Represents a DeliverResponse.
             * @implements IDeliverResponse
             * @constructor
             * @param {orderer.IDeliverResponse=} [properties] Properties to set
             */
            function DeliverResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DeliverResponse status.
             * @member {common.Status|null|undefined} status
             * @memberof orderer.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.status = null;
    
            /**
             * DeliverResponse block.
             * @member {common.IBlock|null|undefined} block
             * @memberof orderer.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.block = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * DeliverResponse Type.
             * @member {"status"|"block"|undefined} Type
             * @memberof orderer.DeliverResponse
             * @instance
             */
            Object.defineProperty(DeliverResponse.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["status", "block"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new DeliverResponse instance using the specified properties.
             * @function create
             * @memberof orderer.DeliverResponse
             * @static
             * @param {orderer.IDeliverResponse=} [properties] Properties to set
             * @returns {orderer.DeliverResponse} DeliverResponse instance
             */
            DeliverResponse.create = function create(properties) {
                return new DeliverResponse(properties);
            };
    
            /**
             * Encodes the specified DeliverResponse message. Does not implicitly {@link orderer.DeliverResponse.verify|verify} messages.
             * @function encode
             * @memberof orderer.DeliverResponse
             * @static
             * @param {orderer.IDeliverResponse} message DeliverResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeliverResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                    $root.common.Block.encode(message.block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DeliverResponse message, length delimited. Does not implicitly {@link orderer.DeliverResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.DeliverResponse
             * @static
             * @param {orderer.IDeliverResponse} message DeliverResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeliverResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DeliverResponse message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.DeliverResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.DeliverResponse} DeliverResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeliverResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.DeliverResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.block = $root.common.Block.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DeliverResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.DeliverResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.DeliverResponse} DeliverResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeliverResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DeliverResponse message.
             * @function verify
             * @memberof orderer.DeliverResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeliverResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.status != null && message.hasOwnProperty("status")) {
                    properties.Type = 1;
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 200:
                    case 400:
                    case 403:
                    case 404:
                    case 413:
                    case 500:
                    case 501:
                    case 503:
                        break;
                    }
                }
                if (message.block != null && message.hasOwnProperty("block")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.common.Block.verify(message.block);
                        if (error)
                            return "block." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a DeliverResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.DeliverResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.DeliverResponse} DeliverResponse
             */
            DeliverResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.DeliverResponse)
                    return object;
                var message = new $root.orderer.DeliverResponse();
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 200:
                    message.status = 200;
                    break;
                case "BAD_REQUEST":
                case 400:
                    message.status = 400;
                    break;
                case "FORBIDDEN":
                case 403:
                    message.status = 403;
                    break;
                case "NOT_FOUND":
                case 404:
                    message.status = 404;
                    break;
                case "REQUEST_ENTITY_TOO_LARGE":
                case 413:
                    message.status = 413;
                    break;
                case "INTERNAL_SERVER_ERROR":
                case 500:
                    message.status = 500;
                    break;
                case "NOT_IMPLEMENTED":
                case 501:
                    message.status = 501;
                    break;
                case "SERVICE_UNAVAILABLE":
                case 503:
                    message.status = 503;
                    break;
                }
                if (object.block != null) {
                    if (typeof object.block !== "object")
                        throw TypeError(".orderer.DeliverResponse.block: object expected");
                    message.block = $root.common.Block.fromObject(object.block);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DeliverResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.DeliverResponse
             * @static
             * @param {orderer.DeliverResponse} message DeliverResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeliverResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.status != null && message.hasOwnProperty("status")) {
                    object.status = options.enums === String ? $root.common.Status[message.status] : message.status;
                    if (options.oneofs)
                        object.Type = "status";
                }
                if (message.block != null && message.hasOwnProperty("block")) {
                    object.block = $root.common.Block.toObject(message.block, options);
                    if (options.oneofs)
                        object.Type = "block";
                }
                return object;
            };
    
            /**
             * Converts this DeliverResponse to JSON.
             * @function toJSON
             * @memberof orderer.DeliverResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeliverResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DeliverResponse;
        })();
    
        orderer.AtomicBroadcast = (function() {
    
            /**
             * Constructs a new AtomicBroadcast service.
             * @memberof orderer
             * @classdesc Represents an AtomicBroadcast
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function AtomicBroadcast(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (AtomicBroadcast.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AtomicBroadcast;
    
            /**
             * Creates new AtomicBroadcast service using the specified rpc implementation.
             * @function create
             * @memberof orderer.AtomicBroadcast
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {AtomicBroadcast} RPC service. Useful where requests and/or responses are streamed.
             */
            AtomicBroadcast.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link orderer.AtomicBroadcast#broadcast}.
             * @memberof orderer.AtomicBroadcast
             * @typedef BroadcastCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {orderer.BroadcastResponse} [response] BroadcastResponse
             */
    
            /**
             * Calls Broadcast.
             * @function broadcast
             * @memberof orderer.AtomicBroadcast
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {orderer.AtomicBroadcast.BroadcastCallback} callback Node-style callback called with the error, if any, and BroadcastResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AtomicBroadcast.prototype.broadcast = function broadcast(request, callback) {
                return this.rpcCall(broadcast, $root.common.Envelope, $root.orderer.BroadcastResponse, request, callback);
            }, "name", { value: "Broadcast" });
    
            /**
             * Calls Broadcast.
             * @function broadcast
             * @memberof orderer.AtomicBroadcast
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<orderer.BroadcastResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link orderer.AtomicBroadcast#deliver}.
             * @memberof orderer.AtomicBroadcast
             * @typedef DeliverCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {orderer.DeliverResponse} [response] DeliverResponse
             */
    
            /**
             * Calls Deliver.
             * @function deliver
             * @memberof orderer.AtomicBroadcast
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {orderer.AtomicBroadcast.DeliverCallback} callback Node-style callback called with the error, if any, and DeliverResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AtomicBroadcast.prototype.deliver = function deliver(request, callback) {
                return this.rpcCall(deliver, $root.common.Envelope, $root.orderer.DeliverResponse, request, callback);
            }, "name", { value: "Deliver" });
    
            /**
             * Calls Deliver.
             * @function deliver
             * @memberof orderer.AtomicBroadcast
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<orderer.DeliverResponse>} Promise
             * @variation 2
             */
    
            return AtomicBroadcast;
        })();
    
        return orderer;
    })();
    
    $root.etcdraft = (function() {
    
        /**
         * Namespace etcdraft.
         * @exports etcdraft
         * @namespace
         */
        var etcdraft = {};
    
        etcdraft.ConfigMetadata = (function() {
    
            /**
             * Properties of a ConfigMetadata.
             * @memberof etcdraft
             * @interface IConfigMetadata
             * @property {Array.<etcdraft.IConsenter>|null} [consenters] ConfigMetadata consenters
             * @property {etcdraft.IOptions|null} [options] ConfigMetadata options
             */
    
            /**
             * Constructs a new ConfigMetadata.
             * @memberof etcdraft
             * @classdesc Represents a ConfigMetadata.
             * @implements IConfigMetadata
             * @constructor
             * @param {etcdraft.IConfigMetadata=} [properties] Properties to set
             */
            function ConfigMetadata(properties) {
                this.consenters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigMetadata consenters.
             * @member {Array.<etcdraft.IConsenter>} consenters
             * @memberof etcdraft.ConfigMetadata
             * @instance
             */
            ConfigMetadata.prototype.consenters = $util.emptyArray;
    
            /**
             * ConfigMetadata options.
             * @member {etcdraft.IOptions|null|undefined} options
             * @memberof etcdraft.ConfigMetadata
             * @instance
             */
            ConfigMetadata.prototype.options = null;
    
            /**
             * Creates a new ConfigMetadata instance using the specified properties.
             * @function create
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {etcdraft.IConfigMetadata=} [properties] Properties to set
             * @returns {etcdraft.ConfigMetadata} ConfigMetadata instance
             */
            ConfigMetadata.create = function create(properties) {
                return new ConfigMetadata(properties);
            };
    
            /**
             * Encodes the specified ConfigMetadata message. Does not implicitly {@link etcdraft.ConfigMetadata.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {etcdraft.IConfigMetadata} message ConfigMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.consenters != null && message.consenters.length)
                    for (var i = 0; i < message.consenters.length; ++i)
                        $root.etcdraft.Consenter.encode(message.consenters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.etcdraft.Options.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigMetadata message, length delimited. Does not implicitly {@link etcdraft.ConfigMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {etcdraft.IConfigMetadata} message ConfigMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.ConfigMetadata} ConfigMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.ConfigMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.consenters && message.consenters.length))
                            message.consenters = [];
                        message.consenters.push($root.etcdraft.Consenter.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.options = $root.etcdraft.Options.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.ConfigMetadata} ConfigMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigMetadata message.
             * @function verify
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.consenters != null && message.hasOwnProperty("consenters")) {
                    if (!Array.isArray(message.consenters))
                        return "consenters: array expected";
                    for (var i = 0; i < message.consenters.length; ++i) {
                        var error = $root.etcdraft.Consenter.verify(message.consenters[i]);
                        if (error)
                            return "consenters." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.etcdraft.Options.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };
    
            /**
             * Creates a ConfigMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.ConfigMetadata} ConfigMetadata
             */
            ConfigMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.ConfigMetadata)
                    return object;
                var message = new $root.etcdraft.ConfigMetadata();
                if (object.consenters) {
                    if (!Array.isArray(object.consenters))
                        throw TypeError(".etcdraft.ConfigMetadata.consenters: array expected");
                    message.consenters = [];
                    for (var i = 0; i < object.consenters.length; ++i) {
                        if (typeof object.consenters[i] !== "object")
                            throw TypeError(".etcdraft.ConfigMetadata.consenters: object expected");
                        message.consenters[i] = $root.etcdraft.Consenter.fromObject(object.consenters[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".etcdraft.ConfigMetadata.options: object expected");
                    message.options = $root.etcdraft.Options.fromObject(object.options);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {etcdraft.ConfigMetadata} message ConfigMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.consenters = [];
                if (options.defaults)
                    object.options = null;
                if (message.consenters && message.consenters.length) {
                    object.consenters = [];
                    for (var j = 0; j < message.consenters.length; ++j)
                        object.consenters[j] = $root.etcdraft.Consenter.toObject(message.consenters[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.etcdraft.Options.toObject(message.options, options);
                return object;
            };
    
            /**
             * Converts this ConfigMetadata to JSON.
             * @function toJSON
             * @memberof etcdraft.ConfigMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigMetadata;
        })();
    
        etcdraft.Consenter = (function() {
    
            /**
             * Properties of a Consenter.
             * @memberof etcdraft
             * @interface IConsenter
             * @property {string|null} [host] Consenter host
             * @property {number|null} [port] Consenter port
             * @property {Uint8Array|null} [client_tls_cert] Consenter client_tls_cert
             * @property {Uint8Array|null} [server_tls_cert] Consenter server_tls_cert
             */
    
            /**
             * Constructs a new Consenter.
             * @memberof etcdraft
             * @classdesc Represents a Consenter.
             * @implements IConsenter
             * @constructor
             * @param {etcdraft.IConsenter=} [properties] Properties to set
             */
            function Consenter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Consenter host.
             * @member {string} host
             * @memberof etcdraft.Consenter
             * @instance
             */
            Consenter.prototype.host = "";
    
            /**
             * Consenter port.
             * @member {number} port
             * @memberof etcdraft.Consenter
             * @instance
             */
            Consenter.prototype.port = 0;
    
            /**
             * Consenter client_tls_cert.
             * @member {Uint8Array} client_tls_cert
             * @memberof etcdraft.Consenter
             * @instance
             */
            Consenter.prototype.client_tls_cert = $util.newBuffer([]);
    
            /**
             * Consenter server_tls_cert.
             * @member {Uint8Array} server_tls_cert
             * @memberof etcdraft.Consenter
             * @instance
             */
            Consenter.prototype.server_tls_cert = $util.newBuffer([]);
    
            /**
             * Creates a new Consenter instance using the specified properties.
             * @function create
             * @memberof etcdraft.Consenter
             * @static
             * @param {etcdraft.IConsenter=} [properties] Properties to set
             * @returns {etcdraft.Consenter} Consenter instance
             */
            Consenter.create = function create(properties) {
                return new Consenter(properties);
            };
    
            /**
             * Encodes the specified Consenter message. Does not implicitly {@link etcdraft.Consenter.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.Consenter
             * @static
             * @param {etcdraft.IConsenter} message Consenter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Consenter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.client_tls_cert != null && Object.hasOwnProperty.call(message, "client_tls_cert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.client_tls_cert);
                if (message.server_tls_cert != null && Object.hasOwnProperty.call(message, "server_tls_cert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.server_tls_cert);
                return writer;
            };
    
            /**
             * Encodes the specified Consenter message, length delimited. Does not implicitly {@link etcdraft.Consenter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.Consenter
             * @static
             * @param {etcdraft.IConsenter} message Consenter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Consenter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Consenter message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.Consenter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.Consenter} Consenter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Consenter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.Consenter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.client_tls_cert = reader.bytes();
                        break;
                    case 4:
                        message.server_tls_cert = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Consenter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.Consenter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.Consenter} Consenter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Consenter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Consenter message.
             * @function verify
             * @memberof etcdraft.Consenter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Consenter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.client_tls_cert != null && message.hasOwnProperty("client_tls_cert"))
                    if (!(message.client_tls_cert && typeof message.client_tls_cert.length === "number" || $util.isString(message.client_tls_cert)))
                        return "client_tls_cert: buffer expected";
                if (message.server_tls_cert != null && message.hasOwnProperty("server_tls_cert"))
                    if (!(message.server_tls_cert && typeof message.server_tls_cert.length === "number" || $util.isString(message.server_tls_cert)))
                        return "server_tls_cert: buffer expected";
                return null;
            };
    
            /**
             * Creates a Consenter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.Consenter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.Consenter} Consenter
             */
            Consenter.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.Consenter)
                    return object;
                var message = new $root.etcdraft.Consenter();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.client_tls_cert != null)
                    if (typeof object.client_tls_cert === "string")
                        $util.base64.decode(object.client_tls_cert, message.client_tls_cert = $util.newBuffer($util.base64.length(object.client_tls_cert)), 0);
                    else if (object.client_tls_cert.length)
                        message.client_tls_cert = object.client_tls_cert;
                if (object.server_tls_cert != null)
                    if (typeof object.server_tls_cert === "string")
                        $util.base64.decode(object.server_tls_cert, message.server_tls_cert = $util.newBuffer($util.base64.length(object.server_tls_cert)), 0);
                    else if (object.server_tls_cert.length)
                        message.server_tls_cert = object.server_tls_cert;
                return message;
            };
    
            /**
             * Creates a plain object from a Consenter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.Consenter
             * @static
             * @param {etcdraft.Consenter} message Consenter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Consenter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                    if (options.bytes === String)
                        object.client_tls_cert = "";
                    else {
                        object.client_tls_cert = [];
                        if (options.bytes !== Array)
                            object.client_tls_cert = $util.newBuffer(object.client_tls_cert);
                    }
                    if (options.bytes === String)
                        object.server_tls_cert = "";
                    else {
                        object.server_tls_cert = [];
                        if (options.bytes !== Array)
                            object.server_tls_cert = $util.newBuffer(object.server_tls_cert);
                    }
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.client_tls_cert != null && message.hasOwnProperty("client_tls_cert"))
                    object.client_tls_cert = options.bytes === String ? $util.base64.encode(message.client_tls_cert, 0, message.client_tls_cert.length) : options.bytes === Array ? Array.prototype.slice.call(message.client_tls_cert) : message.client_tls_cert;
                if (message.server_tls_cert != null && message.hasOwnProperty("server_tls_cert"))
                    object.server_tls_cert = options.bytes === String ? $util.base64.encode(message.server_tls_cert, 0, message.server_tls_cert.length) : options.bytes === Array ? Array.prototype.slice.call(message.server_tls_cert) : message.server_tls_cert;
                return object;
            };
    
            /**
             * Converts this Consenter to JSON.
             * @function toJSON
             * @memberof etcdraft.Consenter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Consenter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Consenter;
        })();
    
        etcdraft.Options = (function() {
    
            /**
             * Properties of an Options.
             * @memberof etcdraft
             * @interface IOptions
             * @property {string|null} [tick_interval] Options tick_interval
             * @property {number|null} [election_tick] Options election_tick
             * @property {number|null} [heartbeat_tick] Options heartbeat_tick
             * @property {number|null} [max_inflight_blocks] Options max_inflight_blocks
             * @property {number|null} [snapshot_interval_size] Options snapshot_interval_size
             */
    
            /**
             * Constructs a new Options.
             * @memberof etcdraft
             * @classdesc Represents an Options.
             * @implements IOptions
             * @constructor
             * @param {etcdraft.IOptions=} [properties] Properties to set
             */
            function Options(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Options tick_interval.
             * @member {string} tick_interval
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.tick_interval = "";
    
            /**
             * Options election_tick.
             * @member {number} election_tick
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.election_tick = 0;
    
            /**
             * Options heartbeat_tick.
             * @member {number} heartbeat_tick
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.heartbeat_tick = 0;
    
            /**
             * Options max_inflight_blocks.
             * @member {number} max_inflight_blocks
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.max_inflight_blocks = 0;
    
            /**
             * Options snapshot_interval_size.
             * @member {number} snapshot_interval_size
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.snapshot_interval_size = 0;
    
            /**
             * Creates a new Options instance using the specified properties.
             * @function create
             * @memberof etcdraft.Options
             * @static
             * @param {etcdraft.IOptions=} [properties] Properties to set
             * @returns {etcdraft.Options} Options instance
             */
            Options.create = function create(properties) {
                return new Options(properties);
            };
    
            /**
             * Encodes the specified Options message. Does not implicitly {@link etcdraft.Options.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.Options
             * @static
             * @param {etcdraft.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick_interval != null && Object.hasOwnProperty.call(message, "tick_interval"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tick_interval);
                if (message.election_tick != null && Object.hasOwnProperty.call(message, "election_tick"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.election_tick);
                if (message.heartbeat_tick != null && Object.hasOwnProperty.call(message, "heartbeat_tick"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.heartbeat_tick);
                if (message.max_inflight_blocks != null && Object.hasOwnProperty.call(message, "max_inflight_blocks"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.max_inflight_blocks);
                if (message.snapshot_interval_size != null && Object.hasOwnProperty.call(message, "snapshot_interval_size"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.snapshot_interval_size);
                return writer;
            };
    
            /**
             * Encodes the specified Options message, length delimited. Does not implicitly {@link etcdraft.Options.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.Options
             * @static
             * @param {etcdraft.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Options message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.Options();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick_interval = reader.string();
                        break;
                    case 2:
                        message.election_tick = reader.uint32();
                        break;
                    case 3:
                        message.heartbeat_tick = reader.uint32();
                        break;
                    case 4:
                        message.max_inflight_blocks = reader.uint32();
                        break;
                    case 5:
                        message.snapshot_interval_size = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Options message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Options message.
             * @function verify
             * @memberof etcdraft.Options
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Options.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                    if (!$util.isString(message.tick_interval))
                        return "tick_interval: string expected";
                if (message.election_tick != null && message.hasOwnProperty("election_tick"))
                    if (!$util.isInteger(message.election_tick))
                        return "election_tick: integer expected";
                if (message.heartbeat_tick != null && message.hasOwnProperty("heartbeat_tick"))
                    if (!$util.isInteger(message.heartbeat_tick))
                        return "heartbeat_tick: integer expected";
                if (message.max_inflight_blocks != null && message.hasOwnProperty("max_inflight_blocks"))
                    if (!$util.isInteger(message.max_inflight_blocks))
                        return "max_inflight_blocks: integer expected";
                if (message.snapshot_interval_size != null && message.hasOwnProperty("snapshot_interval_size"))
                    if (!$util.isInteger(message.snapshot_interval_size))
                        return "snapshot_interval_size: integer expected";
                return null;
            };
    
            /**
             * Creates an Options message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.Options
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.Options} Options
             */
            Options.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.Options)
                    return object;
                var message = new $root.etcdraft.Options();
                if (object.tick_interval != null)
                    message.tick_interval = String(object.tick_interval);
                if (object.election_tick != null)
                    message.election_tick = object.election_tick >>> 0;
                if (object.heartbeat_tick != null)
                    message.heartbeat_tick = object.heartbeat_tick >>> 0;
                if (object.max_inflight_blocks != null)
                    message.max_inflight_blocks = object.max_inflight_blocks >>> 0;
                if (object.snapshot_interval_size != null)
                    message.snapshot_interval_size = object.snapshot_interval_size >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from an Options message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.Options
             * @static
             * @param {etcdraft.Options} message Options
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Options.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick_interval = "";
                    object.election_tick = 0;
                    object.heartbeat_tick = 0;
                    object.max_inflight_blocks = 0;
                    object.snapshot_interval_size = 0;
                }
                if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                    object.tick_interval = message.tick_interval;
                if (message.election_tick != null && message.hasOwnProperty("election_tick"))
                    object.election_tick = message.election_tick;
                if (message.heartbeat_tick != null && message.hasOwnProperty("heartbeat_tick"))
                    object.heartbeat_tick = message.heartbeat_tick;
                if (message.max_inflight_blocks != null && message.hasOwnProperty("max_inflight_blocks"))
                    object.max_inflight_blocks = message.max_inflight_blocks;
                if (message.snapshot_interval_size != null && message.hasOwnProperty("snapshot_interval_size"))
                    object.snapshot_interval_size = message.snapshot_interval_size;
                return object;
            };
    
            /**
             * Converts this Options to JSON.
             * @function toJSON
             * @memberof etcdraft.Options
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Options.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Options;
        })();
    
        etcdraft.BlockMetadata = (function() {
    
            /**
             * Properties of a BlockMetadata.
             * @memberof etcdraft
             * @interface IBlockMetadata
             * @property {Array.<number|Long>|null} [consenter_ids] BlockMetadata consenter_ids
             * @property {number|Long|null} [next_consenter_id] BlockMetadata next_consenter_id
             * @property {number|Long|null} [raft_index] BlockMetadata raft_index
             */
    
            /**
             * Constructs a new BlockMetadata.
             * @memberof etcdraft
             * @classdesc Represents a BlockMetadata.
             * @implements IBlockMetadata
             * @constructor
             * @param {etcdraft.IBlockMetadata=} [properties] Properties to set
             */
            function BlockMetadata(properties) {
                this.consenter_ids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockMetadata consenter_ids.
             * @member {Array.<number|Long>} consenter_ids
             * @memberof etcdraft.BlockMetadata
             * @instance
             */
            BlockMetadata.prototype.consenter_ids = $util.emptyArray;
    
            /**
             * BlockMetadata next_consenter_id.
             * @member {number|Long} next_consenter_id
             * @memberof etcdraft.BlockMetadata
             * @instance
             */
            BlockMetadata.prototype.next_consenter_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * BlockMetadata raft_index.
             * @member {number|Long} raft_index
             * @memberof etcdraft.BlockMetadata
             * @instance
             */
            BlockMetadata.prototype.raft_index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new BlockMetadata instance using the specified properties.
             * @function create
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {etcdraft.IBlockMetadata=} [properties] Properties to set
             * @returns {etcdraft.BlockMetadata} BlockMetadata instance
             */
            BlockMetadata.create = function create(properties) {
                return new BlockMetadata(properties);
            };
    
            /**
             * Encodes the specified BlockMetadata message. Does not implicitly {@link etcdraft.BlockMetadata.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {etcdraft.IBlockMetadata} message BlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.consenter_ids != null && message.consenter_ids.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.consenter_ids.length; ++i)
                        writer.uint64(message.consenter_ids[i]);
                    writer.ldelim();
                }
                if (message.next_consenter_id != null && Object.hasOwnProperty.call(message, "next_consenter_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.next_consenter_id);
                if (message.raft_index != null && Object.hasOwnProperty.call(message, "raft_index"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.raft_index);
                return writer;
            };
    
            /**
             * Encodes the specified BlockMetadata message, length delimited. Does not implicitly {@link etcdraft.BlockMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {etcdraft.IBlockMetadata} message BlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.BlockMetadata} BlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.BlockMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.consenter_ids && message.consenter_ids.length))
                            message.consenter_ids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.consenter_ids.push(reader.uint64());
                        } else
                            message.consenter_ids.push(reader.uint64());
                        break;
                    case 2:
                        message.next_consenter_id = reader.uint64();
                        break;
                    case 3:
                        message.raft_index = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.BlockMetadata} BlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockMetadata message.
             * @function verify
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.consenter_ids != null && message.hasOwnProperty("consenter_ids")) {
                    if (!Array.isArray(message.consenter_ids))
                        return "consenter_ids: array expected";
                    for (var i = 0; i < message.consenter_ids.length; ++i)
                        if (!$util.isInteger(message.consenter_ids[i]) && !(message.consenter_ids[i] && $util.isInteger(message.consenter_ids[i].low) && $util.isInteger(message.consenter_ids[i].high)))
                            return "consenter_ids: integer|Long[] expected";
                }
                if (message.next_consenter_id != null && message.hasOwnProperty("next_consenter_id"))
                    if (!$util.isInteger(message.next_consenter_id) && !(message.next_consenter_id && $util.isInteger(message.next_consenter_id.low) && $util.isInteger(message.next_consenter_id.high)))
                        return "next_consenter_id: integer|Long expected";
                if (message.raft_index != null && message.hasOwnProperty("raft_index"))
                    if (!$util.isInteger(message.raft_index) && !(message.raft_index && $util.isInteger(message.raft_index.low) && $util.isInteger(message.raft_index.high)))
                        return "raft_index: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a BlockMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.BlockMetadata} BlockMetadata
             */
            BlockMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.BlockMetadata)
                    return object;
                var message = new $root.etcdraft.BlockMetadata();
                if (object.consenter_ids) {
                    if (!Array.isArray(object.consenter_ids))
                        throw TypeError(".etcdraft.BlockMetadata.consenter_ids: array expected");
                    message.consenter_ids = [];
                    for (var i = 0; i < object.consenter_ids.length; ++i)
                        if ($util.Long)
                            (message.consenter_ids[i] = $util.Long.fromValue(object.consenter_ids[i])).unsigned = true;
                        else if (typeof object.consenter_ids[i] === "string")
                            message.consenter_ids[i] = parseInt(object.consenter_ids[i], 10);
                        else if (typeof object.consenter_ids[i] === "number")
                            message.consenter_ids[i] = object.consenter_ids[i];
                        else if (typeof object.consenter_ids[i] === "object")
                            message.consenter_ids[i] = new $util.LongBits(object.consenter_ids[i].low >>> 0, object.consenter_ids[i].high >>> 0).toNumber(true);
                }
                if (object.next_consenter_id != null)
                    if ($util.Long)
                        (message.next_consenter_id = $util.Long.fromValue(object.next_consenter_id)).unsigned = true;
                    else if (typeof object.next_consenter_id === "string")
                        message.next_consenter_id = parseInt(object.next_consenter_id, 10);
                    else if (typeof object.next_consenter_id === "number")
                        message.next_consenter_id = object.next_consenter_id;
                    else if (typeof object.next_consenter_id === "object")
                        message.next_consenter_id = new $util.LongBits(object.next_consenter_id.low >>> 0, object.next_consenter_id.high >>> 0).toNumber(true);
                if (object.raft_index != null)
                    if ($util.Long)
                        (message.raft_index = $util.Long.fromValue(object.raft_index)).unsigned = true;
                    else if (typeof object.raft_index === "string")
                        message.raft_index = parseInt(object.raft_index, 10);
                    else if (typeof object.raft_index === "number")
                        message.raft_index = object.raft_index;
                    else if (typeof object.raft_index === "object")
                        message.raft_index = new $util.LongBits(object.raft_index.low >>> 0, object.raft_index.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a BlockMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {etcdraft.BlockMetadata} message BlockMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.consenter_ids = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.next_consenter_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.next_consenter_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.raft_index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.raft_index = options.longs === String ? "0" : 0;
                }
                if (message.consenter_ids && message.consenter_ids.length) {
                    object.consenter_ids = [];
                    for (var j = 0; j < message.consenter_ids.length; ++j)
                        if (typeof message.consenter_ids[j] === "number")
                            object.consenter_ids[j] = options.longs === String ? String(message.consenter_ids[j]) : message.consenter_ids[j];
                        else
                            object.consenter_ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.consenter_ids[j]) : options.longs === Number ? new $util.LongBits(message.consenter_ids[j].low >>> 0, message.consenter_ids[j].high >>> 0).toNumber(true) : message.consenter_ids[j];
                }
                if (message.next_consenter_id != null && message.hasOwnProperty("next_consenter_id"))
                    if (typeof message.next_consenter_id === "number")
                        object.next_consenter_id = options.longs === String ? String(message.next_consenter_id) : message.next_consenter_id;
                    else
                        object.next_consenter_id = options.longs === String ? $util.Long.prototype.toString.call(message.next_consenter_id) : options.longs === Number ? new $util.LongBits(message.next_consenter_id.low >>> 0, message.next_consenter_id.high >>> 0).toNumber(true) : message.next_consenter_id;
                if (message.raft_index != null && message.hasOwnProperty("raft_index"))
                    if (typeof message.raft_index === "number")
                        object.raft_index = options.longs === String ? String(message.raft_index) : message.raft_index;
                    else
                        object.raft_index = options.longs === String ? $util.Long.prototype.toString.call(message.raft_index) : options.longs === Number ? new $util.LongBits(message.raft_index.low >>> 0, message.raft_index.high >>> 0).toNumber(true) : message.raft_index;
                return object;
            };
    
            /**
             * Converts this BlockMetadata to JSON.
             * @function toJSON
             * @memberof etcdraft.BlockMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockMetadata;
        })();
    
        etcdraft.ClusterMetadata = (function() {
    
            /**
             * Properties of a ClusterMetadata.
             * @memberof etcdraft
             * @interface IClusterMetadata
             * @property {Array.<number|Long>|null} [active_nodes] ClusterMetadata active_nodes
             */
    
            /**
             * Constructs a new ClusterMetadata.
             * @memberof etcdraft
             * @classdesc Represents a ClusterMetadata.
             * @implements IClusterMetadata
             * @constructor
             * @param {etcdraft.IClusterMetadata=} [properties] Properties to set
             */
            function ClusterMetadata(properties) {
                this.active_nodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ClusterMetadata active_nodes.
             * @member {Array.<number|Long>} active_nodes
             * @memberof etcdraft.ClusterMetadata
             * @instance
             */
            ClusterMetadata.prototype.active_nodes = $util.emptyArray;
    
            /**
             * Creates a new ClusterMetadata instance using the specified properties.
             * @function create
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {etcdraft.IClusterMetadata=} [properties] Properties to set
             * @returns {etcdraft.ClusterMetadata} ClusterMetadata instance
             */
            ClusterMetadata.create = function create(properties) {
                return new ClusterMetadata(properties);
            };
    
            /**
             * Encodes the specified ClusterMetadata message. Does not implicitly {@link etcdraft.ClusterMetadata.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {etcdraft.IClusterMetadata} message ClusterMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.active_nodes != null && message.active_nodes.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.active_nodes.length; ++i)
                        writer.uint64(message.active_nodes[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified ClusterMetadata message, length delimited. Does not implicitly {@link etcdraft.ClusterMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {etcdraft.IClusterMetadata} message ClusterMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ClusterMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.ClusterMetadata} ClusterMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.ClusterMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.active_nodes && message.active_nodes.length))
                            message.active_nodes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.active_nodes.push(reader.uint64());
                        } else
                            message.active_nodes.push(reader.uint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ClusterMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.ClusterMetadata} ClusterMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ClusterMetadata message.
             * @function verify
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClusterMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.active_nodes != null && message.hasOwnProperty("active_nodes")) {
                    if (!Array.isArray(message.active_nodes))
                        return "active_nodes: array expected";
                    for (var i = 0; i < message.active_nodes.length; ++i)
                        if (!$util.isInteger(message.active_nodes[i]) && !(message.active_nodes[i] && $util.isInteger(message.active_nodes[i].low) && $util.isInteger(message.active_nodes[i].high)))
                            return "active_nodes: integer|Long[] expected";
                }
                return null;
            };
    
            /**
             * Creates a ClusterMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.ClusterMetadata} ClusterMetadata
             */
            ClusterMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.ClusterMetadata)
                    return object;
                var message = new $root.etcdraft.ClusterMetadata();
                if (object.active_nodes) {
                    if (!Array.isArray(object.active_nodes))
                        throw TypeError(".etcdraft.ClusterMetadata.active_nodes: array expected");
                    message.active_nodes = [];
                    for (var i = 0; i < object.active_nodes.length; ++i)
                        if ($util.Long)
                            (message.active_nodes[i] = $util.Long.fromValue(object.active_nodes[i])).unsigned = true;
                        else if (typeof object.active_nodes[i] === "string")
                            message.active_nodes[i] = parseInt(object.active_nodes[i], 10);
                        else if (typeof object.active_nodes[i] === "number")
                            message.active_nodes[i] = object.active_nodes[i];
                        else if (typeof object.active_nodes[i] === "object")
                            message.active_nodes[i] = new $util.LongBits(object.active_nodes[i].low >>> 0, object.active_nodes[i].high >>> 0).toNumber(true);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ClusterMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {etcdraft.ClusterMetadata} message ClusterMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClusterMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.active_nodes = [];
                if (message.active_nodes && message.active_nodes.length) {
                    object.active_nodes = [];
                    for (var j = 0; j < message.active_nodes.length; ++j)
                        if (typeof message.active_nodes[j] === "number")
                            object.active_nodes[j] = options.longs === String ? String(message.active_nodes[j]) : message.active_nodes[j];
                        else
                            object.active_nodes[j] = options.longs === String ? $util.Long.prototype.toString.call(message.active_nodes[j]) : options.longs === Number ? new $util.LongBits(message.active_nodes[j].low >>> 0, message.active_nodes[j].high >>> 0).toNumber(true) : message.active_nodes[j];
                }
                return object;
            };
    
            /**
             * Converts this ClusterMetadata to JSON.
             * @function toJSON
             * @memberof etcdraft.ClusterMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClusterMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ClusterMetadata;
        })();
    
        return etcdraft;
    })();
    
    $root.lifecycle = (function() {
    
        /**
         * Namespace lifecycle.
         * @exports lifecycle
         * @namespace
         */
        var lifecycle = {};
    
        lifecycle.InstallChaincodeArgs = (function() {
    
            /**
             * Properties of an InstallChaincodeArgs.
             * @memberof lifecycle
             * @interface IInstallChaincodeArgs
             * @property {Uint8Array|null} [chaincode_install_package] InstallChaincodeArgs chaincode_install_package
             */
    
            /**
             * Constructs a new InstallChaincodeArgs.
             * @memberof lifecycle
             * @classdesc Represents an InstallChaincodeArgs.
             * @implements IInstallChaincodeArgs
             * @constructor
             * @param {lifecycle.IInstallChaincodeArgs=} [properties] Properties to set
             */
            function InstallChaincodeArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * InstallChaincodeArgs chaincode_install_package.
             * @member {Uint8Array} chaincode_install_package
             * @memberof lifecycle.InstallChaincodeArgs
             * @instance
             */
            InstallChaincodeArgs.prototype.chaincode_install_package = $util.newBuffer([]);
    
            /**
             * Creates a new InstallChaincodeArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {lifecycle.IInstallChaincodeArgs=} [properties] Properties to set
             * @returns {lifecycle.InstallChaincodeArgs} InstallChaincodeArgs instance
             */
            InstallChaincodeArgs.create = function create(properties) {
                return new InstallChaincodeArgs(properties);
            };
    
            /**
             * Encodes the specified InstallChaincodeArgs message. Does not implicitly {@link lifecycle.InstallChaincodeArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {lifecycle.IInstallChaincodeArgs} message InstallChaincodeArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InstallChaincodeArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_install_package != null && Object.hasOwnProperty.call(message, "chaincode_install_package"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chaincode_install_package);
                return writer;
            };
    
            /**
             * Encodes the specified InstallChaincodeArgs message, length delimited. Does not implicitly {@link lifecycle.InstallChaincodeArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {lifecycle.IInstallChaincodeArgs} message InstallChaincodeArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InstallChaincodeArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an InstallChaincodeArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.InstallChaincodeArgs} InstallChaincodeArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InstallChaincodeArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.InstallChaincodeArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_install_package = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an InstallChaincodeArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.InstallChaincodeArgs} InstallChaincodeArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InstallChaincodeArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an InstallChaincodeArgs message.
             * @function verify
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InstallChaincodeArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_install_package != null && message.hasOwnProperty("chaincode_install_package"))
                    if (!(message.chaincode_install_package && typeof message.chaincode_install_package.length === "number" || $util.isString(message.chaincode_install_package)))
                        return "chaincode_install_package: buffer expected";
                return null;
            };
    
            /**
             * Creates an InstallChaincodeArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.InstallChaincodeArgs} InstallChaincodeArgs
             */
            InstallChaincodeArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.InstallChaincodeArgs)
                    return object;
                var message = new $root.lifecycle.InstallChaincodeArgs();
                if (object.chaincode_install_package != null)
                    if (typeof object.chaincode_install_package === "string")
                        $util.base64.decode(object.chaincode_install_package, message.chaincode_install_package = $util.newBuffer($util.base64.length(object.chaincode_install_package)), 0);
                    else if (object.chaincode_install_package.length)
                        message.chaincode_install_package = object.chaincode_install_package;
                return message;
            };
    
            /**
             * Creates a plain object from an InstallChaincodeArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {lifecycle.InstallChaincodeArgs} message InstallChaincodeArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InstallChaincodeArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.chaincode_install_package = "";
                    else {
                        object.chaincode_install_package = [];
                        if (options.bytes !== Array)
                            object.chaincode_install_package = $util.newBuffer(object.chaincode_install_package);
                    }
                if (message.chaincode_install_package != null && message.hasOwnProperty("chaincode_install_package"))
                    object.chaincode_install_package = options.bytes === String ? $util.base64.encode(message.chaincode_install_package, 0, message.chaincode_install_package.length) : options.bytes === Array ? Array.prototype.slice.call(message.chaincode_install_package) : message.chaincode_install_package;
                return object;
            };
    
            /**
             * Converts this InstallChaincodeArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.InstallChaincodeArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InstallChaincodeArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return InstallChaincodeArgs;
        })();
    
        lifecycle.InstallChaincodeResult = (function() {
    
            /**
             * Properties of an InstallChaincodeResult.
             * @memberof lifecycle
             * @interface IInstallChaincodeResult
             * @property {string|null} [package_id] InstallChaincodeResult package_id
             * @property {string|null} [label] InstallChaincodeResult label
             */
    
            /**
             * Constructs a new InstallChaincodeResult.
             * @memberof lifecycle
             * @classdesc Represents an InstallChaincodeResult.
             * @implements IInstallChaincodeResult
             * @constructor
             * @param {lifecycle.IInstallChaincodeResult=} [properties] Properties to set
             */
            function InstallChaincodeResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * InstallChaincodeResult package_id.
             * @member {string} package_id
             * @memberof lifecycle.InstallChaincodeResult
             * @instance
             */
            InstallChaincodeResult.prototype.package_id = "";
    
            /**
             * InstallChaincodeResult label.
             * @member {string} label
             * @memberof lifecycle.InstallChaincodeResult
             * @instance
             */
            InstallChaincodeResult.prototype.label = "";
    
            /**
             * Creates a new InstallChaincodeResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {lifecycle.IInstallChaincodeResult=} [properties] Properties to set
             * @returns {lifecycle.InstallChaincodeResult} InstallChaincodeResult instance
             */
            InstallChaincodeResult.create = function create(properties) {
                return new InstallChaincodeResult(properties);
            };
    
            /**
             * Encodes the specified InstallChaincodeResult message. Does not implicitly {@link lifecycle.InstallChaincodeResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {lifecycle.IInstallChaincodeResult} message InstallChaincodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InstallChaincodeResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.package_id != null && Object.hasOwnProperty.call(message, "package_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.package_id);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                return writer;
            };
    
            /**
             * Encodes the specified InstallChaincodeResult message, length delimited. Does not implicitly {@link lifecycle.InstallChaincodeResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {lifecycle.IInstallChaincodeResult} message InstallChaincodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InstallChaincodeResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an InstallChaincodeResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.InstallChaincodeResult} InstallChaincodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InstallChaincodeResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.InstallChaincodeResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.package_id = reader.string();
                        break;
                    case 2:
                        message.label = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an InstallChaincodeResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.InstallChaincodeResult} InstallChaincodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InstallChaincodeResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an InstallChaincodeResult message.
             * @function verify
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InstallChaincodeResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.package_id != null && message.hasOwnProperty("package_id"))
                    if (!$util.isString(message.package_id))
                        return "package_id: string expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                return null;
            };
    
            /**
             * Creates an InstallChaincodeResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.InstallChaincodeResult} InstallChaincodeResult
             */
            InstallChaincodeResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.InstallChaincodeResult)
                    return object;
                var message = new $root.lifecycle.InstallChaincodeResult();
                if (object.package_id != null)
                    message.package_id = String(object.package_id);
                if (object.label != null)
                    message.label = String(object.label);
                return message;
            };
    
            /**
             * Creates a plain object from an InstallChaincodeResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {lifecycle.InstallChaincodeResult} message InstallChaincodeResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InstallChaincodeResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.package_id = "";
                    object.label = "";
                }
                if (message.package_id != null && message.hasOwnProperty("package_id"))
                    object.package_id = message.package_id;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                return object;
            };
    
            /**
             * Converts this InstallChaincodeResult to JSON.
             * @function toJSON
             * @memberof lifecycle.InstallChaincodeResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InstallChaincodeResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return InstallChaincodeResult;
        })();
    
        lifecycle.QueryInstalledChaincodeArgs = (function() {
    
            /**
             * Properties of a QueryInstalledChaincodeArgs.
             * @memberof lifecycle
             * @interface IQueryInstalledChaincodeArgs
             * @property {string|null} [package_id] QueryInstalledChaincodeArgs package_id
             */
    
            /**
             * Constructs a new QueryInstalledChaincodeArgs.
             * @memberof lifecycle
             * @classdesc Represents a QueryInstalledChaincodeArgs.
             * @implements IQueryInstalledChaincodeArgs
             * @constructor
             * @param {lifecycle.IQueryInstalledChaincodeArgs=} [properties] Properties to set
             */
            function QueryInstalledChaincodeArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryInstalledChaincodeArgs package_id.
             * @member {string} package_id
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @instance
             */
            QueryInstalledChaincodeArgs.prototype.package_id = "";
    
            /**
             * Creates a new QueryInstalledChaincodeArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeArgs=} [properties] Properties to set
             * @returns {lifecycle.QueryInstalledChaincodeArgs} QueryInstalledChaincodeArgs instance
             */
            QueryInstalledChaincodeArgs.create = function create(properties) {
                return new QueryInstalledChaincodeArgs(properties);
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodeArgs message. Does not implicitly {@link lifecycle.QueryInstalledChaincodeArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeArgs} message QueryInstalledChaincodeArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodeArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.package_id != null && Object.hasOwnProperty.call(message, "package_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.package_id);
                return writer;
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodeArgs message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodeArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeArgs} message QueryInstalledChaincodeArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodeArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryInstalledChaincodeArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryInstalledChaincodeArgs} QueryInstalledChaincodeArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodeArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodeArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.package_id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryInstalledChaincodeArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryInstalledChaincodeArgs} QueryInstalledChaincodeArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodeArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryInstalledChaincodeArgs message.
             * @function verify
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryInstalledChaincodeArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.package_id != null && message.hasOwnProperty("package_id"))
                    if (!$util.isString(message.package_id))
                        return "package_id: string expected";
                return null;
            };
    
            /**
             * Creates a QueryInstalledChaincodeArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryInstalledChaincodeArgs} QueryInstalledChaincodeArgs
             */
            QueryInstalledChaincodeArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryInstalledChaincodeArgs)
                    return object;
                var message = new $root.lifecycle.QueryInstalledChaincodeArgs();
                if (object.package_id != null)
                    message.package_id = String(object.package_id);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryInstalledChaincodeArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {lifecycle.QueryInstalledChaincodeArgs} message QueryInstalledChaincodeArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryInstalledChaincodeArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.package_id = "";
                if (message.package_id != null && message.hasOwnProperty("package_id"))
                    object.package_id = message.package_id;
                return object;
            };
    
            /**
             * Converts this QueryInstalledChaincodeArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryInstalledChaincodeArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryInstalledChaincodeArgs;
        })();
    
        lifecycle.QueryInstalledChaincodeResult = (function() {
    
            /**
             * Properties of a QueryInstalledChaincodeResult.
             * @memberof lifecycle
             * @interface IQueryInstalledChaincodeResult
             * @property {string|null} [package_id] QueryInstalledChaincodeResult package_id
             * @property {string|null} [label] QueryInstalledChaincodeResult label
             * @property {Object.<string,lifecycle.QueryInstalledChaincodeResult.IReferences>|null} [references] QueryInstalledChaincodeResult references
             */
    
            /**
             * Constructs a new QueryInstalledChaincodeResult.
             * @memberof lifecycle
             * @classdesc Represents a QueryInstalledChaincodeResult.
             * @implements IQueryInstalledChaincodeResult
             * @constructor
             * @param {lifecycle.IQueryInstalledChaincodeResult=} [properties] Properties to set
             */
            function QueryInstalledChaincodeResult(properties) {
                this.references = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryInstalledChaincodeResult package_id.
             * @member {string} package_id
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @instance
             */
            QueryInstalledChaincodeResult.prototype.package_id = "";
    
            /**
             * QueryInstalledChaincodeResult label.
             * @member {string} label
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @instance
             */
            QueryInstalledChaincodeResult.prototype.label = "";
    
            /**
             * QueryInstalledChaincodeResult references.
             * @member {Object.<string,lifecycle.QueryInstalledChaincodeResult.IReferences>} references
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @instance
             */
            QueryInstalledChaincodeResult.prototype.references = $util.emptyObject;
    
            /**
             * Creates a new QueryInstalledChaincodeResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeResult=} [properties] Properties to set
             * @returns {lifecycle.QueryInstalledChaincodeResult} QueryInstalledChaincodeResult instance
             */
            QueryInstalledChaincodeResult.create = function create(properties) {
                return new QueryInstalledChaincodeResult(properties);
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodeResult message. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeResult} message QueryInstalledChaincodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodeResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.package_id != null && Object.hasOwnProperty.call(message, "package_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.package_id);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                if (message.references != null && Object.hasOwnProperty.call(message, "references"))
                    for (var keys = Object.keys(message.references), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.lifecycle.QueryInstalledChaincodeResult.References.encode(message.references[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodeResult message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeResult} message QueryInstalledChaincodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodeResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryInstalledChaincodeResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryInstalledChaincodeResult} QueryInstalledChaincodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodeResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodeResult(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.package_id = reader.string();
                        break;
                    case 2:
                        message.label = reader.string();
                        break;
                    case 3:
                        if (message.references === $util.emptyObject)
                            message.references = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.lifecycle.QueryInstalledChaincodeResult.References.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.references[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryInstalledChaincodeResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryInstalledChaincodeResult} QueryInstalledChaincodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodeResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryInstalledChaincodeResult message.
             * @function verify
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryInstalledChaincodeResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.package_id != null && message.hasOwnProperty("package_id"))
                    if (!$util.isString(message.package_id))
                        return "package_id: string expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.references != null && message.hasOwnProperty("references")) {
                    if (!$util.isObject(message.references))
                        return "references: object expected";
                    var key = Object.keys(message.references);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.lifecycle.QueryInstalledChaincodeResult.References.verify(message.references[key[i]]);
                        if (error)
                            return "references." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryInstalledChaincodeResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryInstalledChaincodeResult} QueryInstalledChaincodeResult
             */
            QueryInstalledChaincodeResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryInstalledChaincodeResult)
                    return object;
                var message = new $root.lifecycle.QueryInstalledChaincodeResult();
                if (object.package_id != null)
                    message.package_id = String(object.package_id);
                if (object.label != null)
                    message.label = String(object.label);
                if (object.references) {
                    if (typeof object.references !== "object")
                        throw TypeError(".lifecycle.QueryInstalledChaincodeResult.references: object expected");
                    message.references = {};
                    for (var keys = Object.keys(object.references), i = 0; i < keys.length; ++i) {
                        if (typeof object.references[keys[i]] !== "object")
                            throw TypeError(".lifecycle.QueryInstalledChaincodeResult.references: object expected");
                        message.references[keys[i]] = $root.lifecycle.QueryInstalledChaincodeResult.References.fromObject(object.references[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryInstalledChaincodeResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {lifecycle.QueryInstalledChaincodeResult} message QueryInstalledChaincodeResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryInstalledChaincodeResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.references = {};
                if (options.defaults) {
                    object.package_id = "";
                    object.label = "";
                }
                if (message.package_id != null && message.hasOwnProperty("package_id"))
                    object.package_id = message.package_id;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                var keys2;
                if (message.references && (keys2 = Object.keys(message.references)).length) {
                    object.references = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.references[keys2[j]] = $root.lifecycle.QueryInstalledChaincodeResult.References.toObject(message.references[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryInstalledChaincodeResult to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryInstalledChaincodeResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            QueryInstalledChaincodeResult.References = (function() {
    
                /**
                 * Properties of a References.
                 * @memberof lifecycle.QueryInstalledChaincodeResult
                 * @interface IReferences
                 * @property {Array.<lifecycle.QueryInstalledChaincodeResult.IChaincode>|null} [chaincodes] References chaincodes
                 */
    
                /**
                 * Constructs a new References.
                 * @memberof lifecycle.QueryInstalledChaincodeResult
                 * @classdesc Represents a References.
                 * @implements IReferences
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodeResult.IReferences=} [properties] Properties to set
                 */
                function References(properties) {
                    this.chaincodes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * References chaincodes.
                 * @member {Array.<lifecycle.QueryInstalledChaincodeResult.IChaincode>} chaincodes
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @instance
                 */
                References.prototype.chaincodes = $util.emptyArray;
    
                /**
                 * Creates a new References instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IReferences=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodeResult.References} References instance
                 */
                References.create = function create(properties) {
                    return new References(properties);
                };
    
                /**
                 * Encodes the specified References message. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.References.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IReferences} message References message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                References.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chaincodes != null && message.chaincodes.length)
                        for (var i = 0; i < message.chaincodes.length; ++i)
                            $root.lifecycle.QueryInstalledChaincodeResult.Chaincode.encode(message.chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified References message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.References.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IReferences} message References message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                References.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a References message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodeResult.References} References
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                References.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodeResult.References();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.chaincodes && message.chaincodes.length))
                                message.chaincodes = [];
                            message.chaincodes.push($root.lifecycle.QueryInstalledChaincodeResult.Chaincode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a References message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodeResult.References} References
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                References.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a References message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                References.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                        if (!Array.isArray(message.chaincodes))
                            return "chaincodes: array expected";
                        for (var i = 0; i < message.chaincodes.length; ++i) {
                            var error = $root.lifecycle.QueryInstalledChaincodeResult.Chaincode.verify(message.chaincodes[i]);
                            if (error)
                                return "chaincodes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a References message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodeResult.References} References
                 */
                References.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodeResult.References)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodeResult.References();
                    if (object.chaincodes) {
                        if (!Array.isArray(object.chaincodes))
                            throw TypeError(".lifecycle.QueryInstalledChaincodeResult.References.chaincodes: array expected");
                        message.chaincodes = [];
                        for (var i = 0; i < object.chaincodes.length; ++i) {
                            if (typeof object.chaincodes[i] !== "object")
                                throw TypeError(".lifecycle.QueryInstalledChaincodeResult.References.chaincodes: object expected");
                            message.chaincodes[i] = $root.lifecycle.QueryInstalledChaincodeResult.Chaincode.fromObject(object.chaincodes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a References message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.References} message References
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                References.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.chaincodes = [];
                    if (message.chaincodes && message.chaincodes.length) {
                        object.chaincodes = [];
                        for (var j = 0; j < message.chaincodes.length; ++j)
                            object.chaincodes[j] = $root.lifecycle.QueryInstalledChaincodeResult.Chaincode.toObject(message.chaincodes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this References to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                References.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return References;
            })();
    
            QueryInstalledChaincodeResult.Chaincode = (function() {
    
                /**
                 * Properties of a Chaincode.
                 * @memberof lifecycle.QueryInstalledChaincodeResult
                 * @interface IChaincode
                 * @property {string|null} [name] Chaincode name
                 * @property {string|null} [version] Chaincode version
                 */
    
                /**
                 * Constructs a new Chaincode.
                 * @memberof lifecycle.QueryInstalledChaincodeResult
                 * @classdesc Represents a Chaincode.
                 * @implements IChaincode
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodeResult.IChaincode=} [properties] Properties to set
                 */
                function Chaincode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Chaincode name.
                 * @member {string} name
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @instance
                 */
                Chaincode.prototype.name = "";
    
                /**
                 * Chaincode version.
                 * @member {string} version
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @instance
                 */
                Chaincode.prototype.version = "";
    
                /**
                 * Creates a new Chaincode instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IChaincode=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodeResult.Chaincode} Chaincode instance
                 */
                Chaincode.create = function create(properties) {
                    return new Chaincode(properties);
                };
    
                /**
                 * Encodes the specified Chaincode message. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.Chaincode.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IChaincode} message Chaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Chaincode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                    return writer;
                };
    
                /**
                 * Encodes the specified Chaincode message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.Chaincode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IChaincode} message Chaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Chaincode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Chaincode message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodeResult.Chaincode} Chaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Chaincode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodeResult.Chaincode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.version = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Chaincode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodeResult.Chaincode} Chaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Chaincode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Chaincode message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Chaincode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    return null;
                };
    
                /**
                 * Creates a Chaincode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodeResult.Chaincode} Chaincode
                 */
                Chaincode.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodeResult.Chaincode)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodeResult.Chaincode();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.version != null)
                        message.version = String(object.version);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Chaincode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.Chaincode} message Chaincode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Chaincode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.version = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    return object;
                };
    
                /**
                 * Converts this Chaincode to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Chaincode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Chaincode;
            })();
    
            return QueryInstalledChaincodeResult;
        })();
    
        lifecycle.GetInstalledChaincodePackageArgs = (function() {
    
            /**
             * Properties of a GetInstalledChaincodePackageArgs.
             * @memberof lifecycle
             * @interface IGetInstalledChaincodePackageArgs
             * @property {string|null} [package_id] GetInstalledChaincodePackageArgs package_id
             */
    
            /**
             * Constructs a new GetInstalledChaincodePackageArgs.
             * @memberof lifecycle
             * @classdesc Represents a GetInstalledChaincodePackageArgs.
             * @implements IGetInstalledChaincodePackageArgs
             * @constructor
             * @param {lifecycle.IGetInstalledChaincodePackageArgs=} [properties] Properties to set
             */
            function GetInstalledChaincodePackageArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetInstalledChaincodePackageArgs package_id.
             * @member {string} package_id
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @instance
             */
            GetInstalledChaincodePackageArgs.prototype.package_id = "";
    
            /**
             * Creates a new GetInstalledChaincodePackageArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageArgs=} [properties] Properties to set
             * @returns {lifecycle.GetInstalledChaincodePackageArgs} GetInstalledChaincodePackageArgs instance
             */
            GetInstalledChaincodePackageArgs.create = function create(properties) {
                return new GetInstalledChaincodePackageArgs(properties);
            };
    
            /**
             * Encodes the specified GetInstalledChaincodePackageArgs message. Does not implicitly {@link lifecycle.GetInstalledChaincodePackageArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageArgs} message GetInstalledChaincodePackageArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstalledChaincodePackageArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.package_id != null && Object.hasOwnProperty.call(message, "package_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.package_id);
                return writer;
            };
    
            /**
             * Encodes the specified GetInstalledChaincodePackageArgs message, length delimited. Does not implicitly {@link lifecycle.GetInstalledChaincodePackageArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageArgs} message GetInstalledChaincodePackageArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstalledChaincodePackageArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetInstalledChaincodePackageArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.GetInstalledChaincodePackageArgs} GetInstalledChaincodePackageArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstalledChaincodePackageArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.GetInstalledChaincodePackageArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.package_id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetInstalledChaincodePackageArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.GetInstalledChaincodePackageArgs} GetInstalledChaincodePackageArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstalledChaincodePackageArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetInstalledChaincodePackageArgs message.
             * @function verify
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetInstalledChaincodePackageArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.package_id != null && message.hasOwnProperty("package_id"))
                    if (!$util.isString(message.package_id))
                        return "package_id: string expected";
                return null;
            };
    
            /**
             * Creates a GetInstalledChaincodePackageArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.GetInstalledChaincodePackageArgs} GetInstalledChaincodePackageArgs
             */
            GetInstalledChaincodePackageArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.GetInstalledChaincodePackageArgs)
                    return object;
                var message = new $root.lifecycle.GetInstalledChaincodePackageArgs();
                if (object.package_id != null)
                    message.package_id = String(object.package_id);
                return message;
            };
    
            /**
             * Creates a plain object from a GetInstalledChaincodePackageArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {lifecycle.GetInstalledChaincodePackageArgs} message GetInstalledChaincodePackageArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetInstalledChaincodePackageArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.package_id = "";
                if (message.package_id != null && message.hasOwnProperty("package_id"))
                    object.package_id = message.package_id;
                return object;
            };
    
            /**
             * Converts this GetInstalledChaincodePackageArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetInstalledChaincodePackageArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetInstalledChaincodePackageArgs;
        })();
    
        lifecycle.GetInstalledChaincodePackageResult = (function() {
    
            /**
             * Properties of a GetInstalledChaincodePackageResult.
             * @memberof lifecycle
             * @interface IGetInstalledChaincodePackageResult
             * @property {Uint8Array|null} [chaincode_install_package] GetInstalledChaincodePackageResult chaincode_install_package
             */
    
            /**
             * Constructs a new GetInstalledChaincodePackageResult.
             * @memberof lifecycle
             * @classdesc Represents a GetInstalledChaincodePackageResult.
             * @implements IGetInstalledChaincodePackageResult
             * @constructor
             * @param {lifecycle.IGetInstalledChaincodePackageResult=} [properties] Properties to set
             */
            function GetInstalledChaincodePackageResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetInstalledChaincodePackageResult chaincode_install_package.
             * @member {Uint8Array} chaincode_install_package
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @instance
             */
            GetInstalledChaincodePackageResult.prototype.chaincode_install_package = $util.newBuffer([]);
    
            /**
             * Creates a new GetInstalledChaincodePackageResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageResult=} [properties] Properties to set
             * @returns {lifecycle.GetInstalledChaincodePackageResult} GetInstalledChaincodePackageResult instance
             */
            GetInstalledChaincodePackageResult.create = function create(properties) {
                return new GetInstalledChaincodePackageResult(properties);
            };
    
            /**
             * Encodes the specified GetInstalledChaincodePackageResult message. Does not implicitly {@link lifecycle.GetInstalledChaincodePackageResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageResult} message GetInstalledChaincodePackageResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstalledChaincodePackageResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_install_package != null && Object.hasOwnProperty.call(message, "chaincode_install_package"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chaincode_install_package);
                return writer;
            };
    
            /**
             * Encodes the specified GetInstalledChaincodePackageResult message, length delimited. Does not implicitly {@link lifecycle.GetInstalledChaincodePackageResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageResult} message GetInstalledChaincodePackageResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstalledChaincodePackageResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetInstalledChaincodePackageResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.GetInstalledChaincodePackageResult} GetInstalledChaincodePackageResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstalledChaincodePackageResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.GetInstalledChaincodePackageResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode_install_package = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetInstalledChaincodePackageResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.GetInstalledChaincodePackageResult} GetInstalledChaincodePackageResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstalledChaincodePackageResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetInstalledChaincodePackageResult message.
             * @function verify
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetInstalledChaincodePackageResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_install_package != null && message.hasOwnProperty("chaincode_install_package"))
                    if (!(message.chaincode_install_package && typeof message.chaincode_install_package.length === "number" || $util.isString(message.chaincode_install_package)))
                        return "chaincode_install_package: buffer expected";
                return null;
            };
    
            /**
             * Creates a GetInstalledChaincodePackageResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.GetInstalledChaincodePackageResult} GetInstalledChaincodePackageResult
             */
            GetInstalledChaincodePackageResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.GetInstalledChaincodePackageResult)
                    return object;
                var message = new $root.lifecycle.GetInstalledChaincodePackageResult();
                if (object.chaincode_install_package != null)
                    if (typeof object.chaincode_install_package === "string")
                        $util.base64.decode(object.chaincode_install_package, message.chaincode_install_package = $util.newBuffer($util.base64.length(object.chaincode_install_package)), 0);
                    else if (object.chaincode_install_package.length)
                        message.chaincode_install_package = object.chaincode_install_package;
                return message;
            };
    
            /**
             * Creates a plain object from a GetInstalledChaincodePackageResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {lifecycle.GetInstalledChaincodePackageResult} message GetInstalledChaincodePackageResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetInstalledChaincodePackageResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.chaincode_install_package = "";
                    else {
                        object.chaincode_install_package = [];
                        if (options.bytes !== Array)
                            object.chaincode_install_package = $util.newBuffer(object.chaincode_install_package);
                    }
                if (message.chaincode_install_package != null && message.hasOwnProperty("chaincode_install_package"))
                    object.chaincode_install_package = options.bytes === String ? $util.base64.encode(message.chaincode_install_package, 0, message.chaincode_install_package.length) : options.bytes === Array ? Array.prototype.slice.call(message.chaincode_install_package) : message.chaincode_install_package;
                return object;
            };
    
            /**
             * Converts this GetInstalledChaincodePackageResult to JSON.
             * @function toJSON
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetInstalledChaincodePackageResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetInstalledChaincodePackageResult;
        })();
    
        lifecycle.QueryInstalledChaincodesArgs = (function() {
    
            /**
             * Properties of a QueryInstalledChaincodesArgs.
             * @memberof lifecycle
             * @interface IQueryInstalledChaincodesArgs
             */
    
            /**
             * Constructs a new QueryInstalledChaincodesArgs.
             * @memberof lifecycle
             * @classdesc Represents a QueryInstalledChaincodesArgs.
             * @implements IQueryInstalledChaincodesArgs
             * @constructor
             * @param {lifecycle.IQueryInstalledChaincodesArgs=} [properties] Properties to set
             */
            function QueryInstalledChaincodesArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new QueryInstalledChaincodesArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesArgs=} [properties] Properties to set
             * @returns {lifecycle.QueryInstalledChaincodesArgs} QueryInstalledChaincodesArgs instance
             */
            QueryInstalledChaincodesArgs.create = function create(properties) {
                return new QueryInstalledChaincodesArgs(properties);
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodesArgs message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesArgs} message QueryInstalledChaincodesArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodesArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodesArgs message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesArgs} message QueryInstalledChaincodesArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodesArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryInstalledChaincodesArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryInstalledChaincodesArgs} QueryInstalledChaincodesArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodesArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryInstalledChaincodesArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryInstalledChaincodesArgs} QueryInstalledChaincodesArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodesArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryInstalledChaincodesArgs message.
             * @function verify
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryInstalledChaincodesArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a QueryInstalledChaincodesArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryInstalledChaincodesArgs} QueryInstalledChaincodesArgs
             */
            QueryInstalledChaincodesArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryInstalledChaincodesArgs)
                    return object;
                return new $root.lifecycle.QueryInstalledChaincodesArgs();
            };
    
            /**
             * Creates a plain object from a QueryInstalledChaincodesArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {lifecycle.QueryInstalledChaincodesArgs} message QueryInstalledChaincodesArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryInstalledChaincodesArgs.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this QueryInstalledChaincodesArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryInstalledChaincodesArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryInstalledChaincodesArgs;
        })();
    
        lifecycle.QueryInstalledChaincodesResult = (function() {
    
            /**
             * Properties of a QueryInstalledChaincodesResult.
             * @memberof lifecycle
             * @interface IQueryInstalledChaincodesResult
             * @property {Array.<lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode>|null} [installed_chaincodes] QueryInstalledChaincodesResult installed_chaincodes
             */
    
            /**
             * Constructs a new QueryInstalledChaincodesResult.
             * @memberof lifecycle
             * @classdesc Represents a QueryInstalledChaincodesResult.
             * @implements IQueryInstalledChaincodesResult
             * @constructor
             * @param {lifecycle.IQueryInstalledChaincodesResult=} [properties] Properties to set
             */
            function QueryInstalledChaincodesResult(properties) {
                this.installed_chaincodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryInstalledChaincodesResult installed_chaincodes.
             * @member {Array.<lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode>} installed_chaincodes
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @instance
             */
            QueryInstalledChaincodesResult.prototype.installed_chaincodes = $util.emptyArray;
    
            /**
             * Creates a new QueryInstalledChaincodesResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesResult=} [properties] Properties to set
             * @returns {lifecycle.QueryInstalledChaincodesResult} QueryInstalledChaincodesResult instance
             */
            QueryInstalledChaincodesResult.create = function create(properties) {
                return new QueryInstalledChaincodesResult(properties);
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodesResult message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesResult} message QueryInstalledChaincodesResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodesResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.installed_chaincodes != null && message.installed_chaincodes.length)
                    for (var i = 0; i < message.installed_chaincodes.length; ++i)
                        $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.encode(message.installed_chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodesResult message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesResult} message QueryInstalledChaincodesResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodesResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryInstalledChaincodesResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryInstalledChaincodesResult} QueryInstalledChaincodesResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodesResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.installed_chaincodes && message.installed_chaincodes.length))
                            message.installed_chaincodes = [];
                        message.installed_chaincodes.push($root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryInstalledChaincodesResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryInstalledChaincodesResult} QueryInstalledChaincodesResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodesResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryInstalledChaincodesResult message.
             * @function verify
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryInstalledChaincodesResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.installed_chaincodes != null && message.hasOwnProperty("installed_chaincodes")) {
                    if (!Array.isArray(message.installed_chaincodes))
                        return "installed_chaincodes: array expected";
                    for (var i = 0; i < message.installed_chaincodes.length; ++i) {
                        var error = $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.verify(message.installed_chaincodes[i]);
                        if (error)
                            return "installed_chaincodes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryInstalledChaincodesResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryInstalledChaincodesResult} QueryInstalledChaincodesResult
             */
            QueryInstalledChaincodesResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryInstalledChaincodesResult)
                    return object;
                var message = new $root.lifecycle.QueryInstalledChaincodesResult();
                if (object.installed_chaincodes) {
                    if (!Array.isArray(object.installed_chaincodes))
                        throw TypeError(".lifecycle.QueryInstalledChaincodesResult.installed_chaincodes: array expected");
                    message.installed_chaincodes = [];
                    for (var i = 0; i < object.installed_chaincodes.length; ++i) {
                        if (typeof object.installed_chaincodes[i] !== "object")
                            throw TypeError(".lifecycle.QueryInstalledChaincodesResult.installed_chaincodes: object expected");
                        message.installed_chaincodes[i] = $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.fromObject(object.installed_chaincodes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryInstalledChaincodesResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {lifecycle.QueryInstalledChaincodesResult} message QueryInstalledChaincodesResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryInstalledChaincodesResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.installed_chaincodes = [];
                if (message.installed_chaincodes && message.installed_chaincodes.length) {
                    object.installed_chaincodes = [];
                    for (var j = 0; j < message.installed_chaincodes.length; ++j)
                        object.installed_chaincodes[j] = $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.toObject(message.installed_chaincodes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryInstalledChaincodesResult to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryInstalledChaincodesResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            QueryInstalledChaincodesResult.InstalledChaincode = (function() {
    
                /**
                 * Properties of an InstalledChaincode.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @interface IInstalledChaincode
                 * @property {string|null} [package_id] InstalledChaincode package_id
                 * @property {string|null} [label] InstalledChaincode label
                 * @property {Object.<string,lifecycle.QueryInstalledChaincodesResult.IReferences>|null} [references] InstalledChaincode references
                 */
    
                /**
                 * Constructs a new InstalledChaincode.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @classdesc Represents an InstalledChaincode.
                 * @implements IInstalledChaincode
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode=} [properties] Properties to set
                 */
                function InstalledChaincode(properties) {
                    this.references = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InstalledChaincode package_id.
                 * @member {string} package_id
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @instance
                 */
                InstalledChaincode.prototype.package_id = "";
    
                /**
                 * InstalledChaincode label.
                 * @member {string} label
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @instance
                 */
                InstalledChaincode.prototype.label = "";
    
                /**
                 * InstalledChaincode references.
                 * @member {Object.<string,lifecycle.QueryInstalledChaincodesResult.IReferences>} references
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @instance
                 */
                InstalledChaincode.prototype.references = $util.emptyObject;
    
                /**
                 * Creates a new InstalledChaincode instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} InstalledChaincode instance
                 */
                InstalledChaincode.create = function create(properties) {
                    return new InstalledChaincode(properties);
                };
    
                /**
                 * Encodes the specified InstalledChaincode message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode} message InstalledChaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InstalledChaincode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.package_id != null && Object.hasOwnProperty.call(message, "package_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.package_id);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                    if (message.references != null && Object.hasOwnProperty.call(message, "references"))
                        for (var keys = Object.keys(message.references), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.lifecycle.QueryInstalledChaincodesResult.References.encode(message.references[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified InstalledChaincode message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode} message InstalledChaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InstalledChaincode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InstalledChaincode message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} InstalledChaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InstalledChaincode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.package_id = reader.string();
                            break;
                        case 2:
                            message.label = reader.string();
                            break;
                        case 3:
                            if (message.references === $util.emptyObject)
                                message.references = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.lifecycle.QueryInstalledChaincodesResult.References.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.references[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InstalledChaincode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} InstalledChaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InstalledChaincode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InstalledChaincode message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InstalledChaincode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.package_id != null && message.hasOwnProperty("package_id"))
                        if (!$util.isString(message.package_id))
                            return "package_id: string expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.references != null && message.hasOwnProperty("references")) {
                        if (!$util.isObject(message.references))
                            return "references: object expected";
                        var key = Object.keys(message.references);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.lifecycle.QueryInstalledChaincodesResult.References.verify(message.references[key[i]]);
                            if (error)
                                return "references." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InstalledChaincode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} InstalledChaincode
                 */
                InstalledChaincode.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode();
                    if (object.package_id != null)
                        message.package_id = String(object.package_id);
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.references) {
                        if (typeof object.references !== "object")
                            throw TypeError(".lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.references: object expected");
                        message.references = {};
                        for (var keys = Object.keys(object.references), i = 0; i < keys.length; ++i) {
                            if (typeof object.references[keys[i]] !== "object")
                                throw TypeError(".lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.references: object expected");
                            message.references[keys[i]] = $root.lifecycle.QueryInstalledChaincodesResult.References.fromObject(object.references[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InstalledChaincode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} message InstalledChaincode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InstalledChaincode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.references = {};
                    if (options.defaults) {
                        object.package_id = "";
                        object.label = "";
                    }
                    if (message.package_id != null && message.hasOwnProperty("package_id"))
                        object.package_id = message.package_id;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    var keys2;
                    if (message.references && (keys2 = Object.keys(message.references)).length) {
                        object.references = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.references[keys2[j]] = $root.lifecycle.QueryInstalledChaincodesResult.References.toObject(message.references[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InstalledChaincode to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InstalledChaincode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InstalledChaincode;
            })();
    
            QueryInstalledChaincodesResult.References = (function() {
    
                /**
                 * Properties of a References.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @interface IReferences
                 * @property {Array.<lifecycle.QueryInstalledChaincodesResult.IChaincode>|null} [chaincodes] References chaincodes
                 */
    
                /**
                 * Constructs a new References.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @classdesc Represents a References.
                 * @implements IReferences
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodesResult.IReferences=} [properties] Properties to set
                 */
                function References(properties) {
                    this.chaincodes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * References chaincodes.
                 * @member {Array.<lifecycle.QueryInstalledChaincodesResult.IChaincode>} chaincodes
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @instance
                 */
                References.prototype.chaincodes = $util.emptyArray;
    
                /**
                 * Creates a new References instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IReferences=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodesResult.References} References instance
                 */
                References.create = function create(properties) {
                    return new References(properties);
                };
    
                /**
                 * Encodes the specified References message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.References.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IReferences} message References message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                References.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chaincodes != null && message.chaincodes.length)
                        for (var i = 0; i < message.chaincodes.length; ++i)
                            $root.lifecycle.QueryInstalledChaincodesResult.Chaincode.encode(message.chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified References message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.References.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IReferences} message References message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                References.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a References message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodesResult.References} References
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                References.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesResult.References();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.chaincodes && message.chaincodes.length))
                                message.chaincodes = [];
                            message.chaincodes.push($root.lifecycle.QueryInstalledChaincodesResult.Chaincode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a References message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodesResult.References} References
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                References.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a References message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                References.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                        if (!Array.isArray(message.chaincodes))
                            return "chaincodes: array expected";
                        for (var i = 0; i < message.chaincodes.length; ++i) {
                            var error = $root.lifecycle.QueryInstalledChaincodesResult.Chaincode.verify(message.chaincodes[i]);
                            if (error)
                                return "chaincodes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a References message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodesResult.References} References
                 */
                References.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodesResult.References)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodesResult.References();
                    if (object.chaincodes) {
                        if (!Array.isArray(object.chaincodes))
                            throw TypeError(".lifecycle.QueryInstalledChaincodesResult.References.chaincodes: array expected");
                        message.chaincodes = [];
                        for (var i = 0; i < object.chaincodes.length; ++i) {
                            if (typeof object.chaincodes[i] !== "object")
                                throw TypeError(".lifecycle.QueryInstalledChaincodesResult.References.chaincodes: object expected");
                            message.chaincodes[i] = $root.lifecycle.QueryInstalledChaincodesResult.Chaincode.fromObject(object.chaincodes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a References message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.References} message References
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                References.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.chaincodes = [];
                    if (message.chaincodes && message.chaincodes.length) {
                        object.chaincodes = [];
                        for (var j = 0; j < message.chaincodes.length; ++j)
                            object.chaincodes[j] = $root.lifecycle.QueryInstalledChaincodesResult.Chaincode.toObject(message.chaincodes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this References to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                References.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return References;
            })();
    
            QueryInstalledChaincodesResult.Chaincode = (function() {
    
                /**
                 * Properties of a Chaincode.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @interface IChaincode
                 * @property {string|null} [name] Chaincode name
                 * @property {string|null} [version] Chaincode version
                 */
    
                /**
                 * Constructs a new Chaincode.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @classdesc Represents a Chaincode.
                 * @implements IChaincode
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodesResult.IChaincode=} [properties] Properties to set
                 */
                function Chaincode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Chaincode name.
                 * @member {string} name
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @instance
                 */
                Chaincode.prototype.name = "";
    
                /**
                 * Chaincode version.
                 * @member {string} version
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @instance
                 */
                Chaincode.prototype.version = "";
    
                /**
                 * Creates a new Chaincode instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IChaincode=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodesResult.Chaincode} Chaincode instance
                 */
                Chaincode.create = function create(properties) {
                    return new Chaincode(properties);
                };
    
                /**
                 * Encodes the specified Chaincode message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.Chaincode.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IChaincode} message Chaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Chaincode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                    return writer;
                };
    
                /**
                 * Encodes the specified Chaincode message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.Chaincode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IChaincode} message Chaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Chaincode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Chaincode message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodesResult.Chaincode} Chaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Chaincode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesResult.Chaincode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.version = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Chaincode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodesResult.Chaincode} Chaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Chaincode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Chaincode message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Chaincode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    return null;
                };
    
                /**
                 * Creates a Chaincode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodesResult.Chaincode} Chaincode
                 */
                Chaincode.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodesResult.Chaincode)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodesResult.Chaincode();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.version != null)
                        message.version = String(object.version);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Chaincode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.Chaincode} message Chaincode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Chaincode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.version = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    return object;
                };
    
                /**
                 * Converts this Chaincode to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Chaincode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Chaincode;
            })();
    
            return QueryInstalledChaincodesResult;
        })();
    
        lifecycle.ApproveChaincodeDefinitionForMyOrgArgs = (function() {
    
            /**
             * Properties of an ApproveChaincodeDefinitionForMyOrgArgs.
             * @memberof lifecycle
             * @interface IApproveChaincodeDefinitionForMyOrgArgs
             * @property {number|Long|null} [sequence] ApproveChaincodeDefinitionForMyOrgArgs sequence
             * @property {string|null} [name] ApproveChaincodeDefinitionForMyOrgArgs name
             * @property {string|null} [version] ApproveChaincodeDefinitionForMyOrgArgs version
             * @property {string|null} [endorsement_plugin] ApproveChaincodeDefinitionForMyOrgArgs endorsement_plugin
             * @property {string|null} [validation_plugin] ApproveChaincodeDefinitionForMyOrgArgs validation_plugin
             * @property {Uint8Array|null} [validation_parameter] ApproveChaincodeDefinitionForMyOrgArgs validation_parameter
             * @property {protos.ICollectionConfigPackage|null} [collections] ApproveChaincodeDefinitionForMyOrgArgs collections
             * @property {boolean|null} [init_required] ApproveChaincodeDefinitionForMyOrgArgs init_required
             * @property {lifecycle.IChaincodeSource|null} [source] ApproveChaincodeDefinitionForMyOrgArgs source
             */
    
            /**
             * Constructs a new ApproveChaincodeDefinitionForMyOrgArgs.
             * @memberof lifecycle
             * @classdesc Represents an ApproveChaincodeDefinitionForMyOrgArgs.
             * @implements IApproveChaincodeDefinitionForMyOrgArgs
             * @constructor
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgArgs=} [properties] Properties to set
             */
            function ApproveChaincodeDefinitionForMyOrgArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs sequence.
             * @member {number|Long} sequence
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs name.
             * @member {string} name
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.name = "";
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs version.
             * @member {string} version
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.version = "";
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs endorsement_plugin.
             * @member {string} endorsement_plugin
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.endorsement_plugin = "";
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs validation_plugin.
             * @member {string} validation_plugin
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.validation_plugin = "";
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs validation_parameter.
             * @member {Uint8Array} validation_parameter
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.validation_parameter = $util.newBuffer([]);
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs collections.
             * @member {protos.ICollectionConfigPackage|null|undefined} collections
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.collections = null;
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs init_required.
             * @member {boolean} init_required
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.init_required = false;
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs source.
             * @member {lifecycle.IChaincodeSource|null|undefined} source
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.source = null;
    
            /**
             * Creates a new ApproveChaincodeDefinitionForMyOrgArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgArgs=} [properties] Properties to set
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} ApproveChaincodeDefinitionForMyOrgArgs instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.create = function create(properties) {
                return new ApproveChaincodeDefinitionForMyOrgArgs(properties);
            };
    
            /**
             * Encodes the specified ApproveChaincodeDefinitionForMyOrgArgs message. Does not implicitly {@link lifecycle.ApproveChaincodeDefinitionForMyOrgArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgArgs} message ApproveChaincodeDefinitionForMyOrgArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveChaincodeDefinitionForMyOrgArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sequence);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                if (message.endorsement_plugin != null && Object.hasOwnProperty.call(message, "endorsement_plugin"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.endorsement_plugin);
                if (message.validation_plugin != null && Object.hasOwnProperty.call(message, "validation_plugin"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.validation_plugin);
                if (message.validation_parameter != null && Object.hasOwnProperty.call(message, "validation_parameter"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.validation_parameter);
                if (message.collections != null && Object.hasOwnProperty.call(message, "collections"))
                    $root.protos.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.init_required != null && Object.hasOwnProperty.call(message, "init_required"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.init_required);
                if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                    $root.lifecycle.ChaincodeSource.encode(message.source, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ApproveChaincodeDefinitionForMyOrgArgs message, length delimited. Does not implicitly {@link lifecycle.ApproveChaincodeDefinitionForMyOrgArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgArgs} message ApproveChaincodeDefinitionForMyOrgArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveChaincodeDefinitionForMyOrgArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ApproveChaincodeDefinitionForMyOrgArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} ApproveChaincodeDefinitionForMyOrgArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveChaincodeDefinitionForMyOrgArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ApproveChaincodeDefinitionForMyOrgArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.int64();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.version = reader.string();
                        break;
                    case 4:
                        message.endorsement_plugin = reader.string();
                        break;
                    case 5:
                        message.validation_plugin = reader.string();
                        break;
                    case 6:
                        message.validation_parameter = reader.bytes();
                        break;
                    case 7:
                        message.collections = $root.protos.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.init_required = reader.bool();
                        break;
                    case 9:
                        message.source = $root.lifecycle.ChaincodeSource.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ApproveChaincodeDefinitionForMyOrgArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} ApproveChaincodeDefinitionForMyOrgArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveChaincodeDefinitionForMyOrgArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ApproveChaincodeDefinitionForMyOrgArgs message.
             * @function verify
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApproveChaincodeDefinitionForMyOrgArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    if (!$util.isString(message.endorsement_plugin))
                        return "endorsement_plugin: string expected";
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    if (!$util.isString(message.validation_plugin))
                        return "validation_plugin: string expected";
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    if (!(message.validation_parameter && typeof message.validation_parameter.length === "number" || $util.isString(message.validation_parameter)))
                        return "validation_parameter: buffer expected";
                if (message.collections != null && message.hasOwnProperty("collections")) {
                    var error = $root.protos.CollectionConfigPackage.verify(message.collections);
                    if (error)
                        return "collections." + error;
                }
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    if (typeof message.init_required !== "boolean")
                        return "init_required: boolean expected";
                if (message.source != null && message.hasOwnProperty("source")) {
                    var error = $root.lifecycle.ChaincodeSource.verify(message.source);
                    if (error)
                        return "source." + error;
                }
                return null;
            };
    
            /**
             * Creates an ApproveChaincodeDefinitionForMyOrgArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} ApproveChaincodeDefinitionForMyOrgArgs
             */
            ApproveChaincodeDefinitionForMyOrgArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ApproveChaincodeDefinitionForMyOrgArgs)
                    return object;
                var message = new $root.lifecycle.ApproveChaincodeDefinitionForMyOrgArgs();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.endorsement_plugin != null)
                    message.endorsement_plugin = String(object.endorsement_plugin);
                if (object.validation_plugin != null)
                    message.validation_plugin = String(object.validation_plugin);
                if (object.validation_parameter != null)
                    if (typeof object.validation_parameter === "string")
                        $util.base64.decode(object.validation_parameter, message.validation_parameter = $util.newBuffer($util.base64.length(object.validation_parameter)), 0);
                    else if (object.validation_parameter.length)
                        message.validation_parameter = object.validation_parameter;
                if (object.collections != null) {
                    if (typeof object.collections !== "object")
                        throw TypeError(".lifecycle.ApproveChaincodeDefinitionForMyOrgArgs.collections: object expected");
                    message.collections = $root.protos.CollectionConfigPackage.fromObject(object.collections);
                }
                if (object.init_required != null)
                    message.init_required = Boolean(object.init_required);
                if (object.source != null) {
                    if (typeof object.source !== "object")
                        throw TypeError(".lifecycle.ApproveChaincodeDefinitionForMyOrgArgs.source: object expected");
                    message.source = $root.lifecycle.ChaincodeSource.fromObject(object.source);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an ApproveChaincodeDefinitionForMyOrgArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} message ApproveChaincodeDefinitionForMyOrgArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ApproveChaincodeDefinitionForMyOrgArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.version = "";
                    object.endorsement_plugin = "";
                    object.validation_plugin = "";
                    if (options.bytes === String)
                        object.validation_parameter = "";
                    else {
                        object.validation_parameter = [];
                        if (options.bytes !== Array)
                            object.validation_parameter = $util.newBuffer(object.validation_parameter);
                    }
                    object.collections = null;
                    object.init_required = false;
                    object.source = null;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    object.endorsement_plugin = message.endorsement_plugin;
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    object.validation_plugin = message.validation_plugin;
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    object.validation_parameter = options.bytes === String ? $util.base64.encode(message.validation_parameter, 0, message.validation_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validation_parameter) : message.validation_parameter;
                if (message.collections != null && message.hasOwnProperty("collections"))
                    object.collections = $root.protos.CollectionConfigPackage.toObject(message.collections, options);
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    object.init_required = message.init_required;
                if (message.source != null && message.hasOwnProperty("source"))
                    object.source = $root.lifecycle.ChaincodeSource.toObject(message.source, options);
                return object;
            };
    
            /**
             * Converts this ApproveChaincodeDefinitionForMyOrgArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ApproveChaincodeDefinitionForMyOrgArgs;
        })();
    
        lifecycle.ChaincodeSource = (function() {
    
            /**
             * Properties of a ChaincodeSource.
             * @memberof lifecycle
             * @interface IChaincodeSource
             * @property {lifecycle.ChaincodeSource.IUnavailable|null} [unavailable] ChaincodeSource unavailable
             * @property {lifecycle.ChaincodeSource.ILocal|null} [local_package] ChaincodeSource local_package
             */
    
            /**
             * Constructs a new ChaincodeSource.
             * @memberof lifecycle
             * @classdesc Represents a ChaincodeSource.
             * @implements IChaincodeSource
             * @constructor
             * @param {lifecycle.IChaincodeSource=} [properties] Properties to set
             */
            function ChaincodeSource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeSource unavailable.
             * @member {lifecycle.ChaincodeSource.IUnavailable|null|undefined} unavailable
             * @memberof lifecycle.ChaincodeSource
             * @instance
             */
            ChaincodeSource.prototype.unavailable = null;
    
            /**
             * ChaincodeSource local_package.
             * @member {lifecycle.ChaincodeSource.ILocal|null|undefined} local_package
             * @memberof lifecycle.ChaincodeSource
             * @instance
             */
            ChaincodeSource.prototype.local_package = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * ChaincodeSource Type.
             * @member {"unavailable"|"local_package"|undefined} Type
             * @memberof lifecycle.ChaincodeSource
             * @instance
             */
            Object.defineProperty(ChaincodeSource.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["unavailable", "local_package"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new ChaincodeSource instance using the specified properties.
             * @function create
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {lifecycle.IChaincodeSource=} [properties] Properties to set
             * @returns {lifecycle.ChaincodeSource} ChaincodeSource instance
             */
            ChaincodeSource.create = function create(properties) {
                return new ChaincodeSource(properties);
            };
    
            /**
             * Encodes the specified ChaincodeSource message. Does not implicitly {@link lifecycle.ChaincodeSource.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {lifecycle.IChaincodeSource} message ChaincodeSource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeSource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.unavailable != null && Object.hasOwnProperty.call(message, "unavailable"))
                    $root.lifecycle.ChaincodeSource.Unavailable.encode(message.unavailable, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.local_package != null && Object.hasOwnProperty.call(message, "local_package"))
                    $root.lifecycle.ChaincodeSource.Local.encode(message.local_package, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeSource message, length delimited. Does not implicitly {@link lifecycle.ChaincodeSource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {lifecycle.IChaincodeSource} message ChaincodeSource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeSource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeSource message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ChaincodeSource} ChaincodeSource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeSource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeSource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.unavailable = $root.lifecycle.ChaincodeSource.Unavailable.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.local_package = $root.lifecycle.ChaincodeSource.Local.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeSource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ChaincodeSource} ChaincodeSource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeSource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeSource message.
             * @function verify
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeSource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.unavailable != null && message.hasOwnProperty("unavailable")) {
                    properties.Type = 1;
                    {
                        var error = $root.lifecycle.ChaincodeSource.Unavailable.verify(message.unavailable);
                        if (error)
                            return "unavailable." + error;
                    }
                }
                if (message.local_package != null && message.hasOwnProperty("local_package")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.lifecycle.ChaincodeSource.Local.verify(message.local_package);
                        if (error)
                            return "local_package." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeSource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ChaincodeSource} ChaincodeSource
             */
            ChaincodeSource.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ChaincodeSource)
                    return object;
                var message = new $root.lifecycle.ChaincodeSource();
                if (object.unavailable != null) {
                    if (typeof object.unavailable !== "object")
                        throw TypeError(".lifecycle.ChaincodeSource.unavailable: object expected");
                    message.unavailable = $root.lifecycle.ChaincodeSource.Unavailable.fromObject(object.unavailable);
                }
                if (object.local_package != null) {
                    if (typeof object.local_package !== "object")
                        throw TypeError(".lifecycle.ChaincodeSource.local_package: object expected");
                    message.local_package = $root.lifecycle.ChaincodeSource.Local.fromObject(object.local_package);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeSource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {lifecycle.ChaincodeSource} message ChaincodeSource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeSource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.unavailable != null && message.hasOwnProperty("unavailable")) {
                    object.unavailable = $root.lifecycle.ChaincodeSource.Unavailable.toObject(message.unavailable, options);
                    if (options.oneofs)
                        object.Type = "unavailable";
                }
                if (message.local_package != null && message.hasOwnProperty("local_package")) {
                    object.local_package = $root.lifecycle.ChaincodeSource.Local.toObject(message.local_package, options);
                    if (options.oneofs)
                        object.Type = "local_package";
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeSource to JSON.
             * @function toJSON
             * @memberof lifecycle.ChaincodeSource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeSource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            ChaincodeSource.Unavailable = (function() {
    
                /**
                 * Properties of an Unavailable.
                 * @memberof lifecycle.ChaincodeSource
                 * @interface IUnavailable
                 */
    
                /**
                 * Constructs a new Unavailable.
                 * @memberof lifecycle.ChaincodeSource
                 * @classdesc Represents an Unavailable.
                 * @implements IUnavailable
                 * @constructor
                 * @param {lifecycle.ChaincodeSource.IUnavailable=} [properties] Properties to set
                 */
                function Unavailable(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new Unavailable instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {lifecycle.ChaincodeSource.IUnavailable=} [properties] Properties to set
                 * @returns {lifecycle.ChaincodeSource.Unavailable} Unavailable instance
                 */
                Unavailable.create = function create(properties) {
                    return new Unavailable(properties);
                };
    
                /**
                 * Encodes the specified Unavailable message. Does not implicitly {@link lifecycle.ChaincodeSource.Unavailable.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {lifecycle.ChaincodeSource.IUnavailable} message Unavailable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unavailable.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified Unavailable message, length delimited. Does not implicitly {@link lifecycle.ChaincodeSource.Unavailable.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {lifecycle.ChaincodeSource.IUnavailable} message Unavailable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unavailable.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Unavailable message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.ChaincodeSource.Unavailable} Unavailable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unavailable.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeSource.Unavailable();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Unavailable message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.ChaincodeSource.Unavailable} Unavailable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unavailable.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Unavailable message.
                 * @function verify
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Unavailable.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an Unavailable message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.ChaincodeSource.Unavailable} Unavailable
                 */
                Unavailable.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.ChaincodeSource.Unavailable)
                        return object;
                    return new $root.lifecycle.ChaincodeSource.Unavailable();
                };
    
                /**
                 * Creates a plain object from an Unavailable message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {lifecycle.ChaincodeSource.Unavailable} message Unavailable
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Unavailable.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this Unavailable to JSON.
                 * @function toJSON
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Unavailable.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Unavailable;
            })();
    
            ChaincodeSource.Local = (function() {
    
                /**
                 * Properties of a Local.
                 * @memberof lifecycle.ChaincodeSource
                 * @interface ILocal
                 * @property {string|null} [package_id] Local package_id
                 */
    
                /**
                 * Constructs a new Local.
                 * @memberof lifecycle.ChaincodeSource
                 * @classdesc Represents a Local.
                 * @implements ILocal
                 * @constructor
                 * @param {lifecycle.ChaincodeSource.ILocal=} [properties] Properties to set
                 */
                function Local(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Local package_id.
                 * @member {string} package_id
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @instance
                 */
                Local.prototype.package_id = "";
    
                /**
                 * Creates a new Local instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {lifecycle.ChaincodeSource.ILocal=} [properties] Properties to set
                 * @returns {lifecycle.ChaincodeSource.Local} Local instance
                 */
                Local.create = function create(properties) {
                    return new Local(properties);
                };
    
                /**
                 * Encodes the specified Local message. Does not implicitly {@link lifecycle.ChaincodeSource.Local.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {lifecycle.ChaincodeSource.ILocal} message Local message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Local.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.package_id != null && Object.hasOwnProperty.call(message, "package_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.package_id);
                    return writer;
                };
    
                /**
                 * Encodes the specified Local message, length delimited. Does not implicitly {@link lifecycle.ChaincodeSource.Local.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {lifecycle.ChaincodeSource.ILocal} message Local message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Local.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Local message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.ChaincodeSource.Local} Local
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Local.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeSource.Local();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.package_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Local message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.ChaincodeSource.Local} Local
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Local.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Local message.
                 * @function verify
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Local.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.package_id != null && message.hasOwnProperty("package_id"))
                        if (!$util.isString(message.package_id))
                            return "package_id: string expected";
                    return null;
                };
    
                /**
                 * Creates a Local message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.ChaincodeSource.Local} Local
                 */
                Local.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.ChaincodeSource.Local)
                        return object;
                    var message = new $root.lifecycle.ChaincodeSource.Local();
                    if (object.package_id != null)
                        message.package_id = String(object.package_id);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Local message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {lifecycle.ChaincodeSource.Local} message Local
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Local.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.package_id = "";
                    if (message.package_id != null && message.hasOwnProperty("package_id"))
                        object.package_id = message.package_id;
                    return object;
                };
    
                /**
                 * Converts this Local to JSON.
                 * @function toJSON
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Local.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Local;
            })();
    
            return ChaincodeSource;
        })();
    
        lifecycle.ApproveChaincodeDefinitionForMyOrgResult = (function() {
    
            /**
             * Properties of an ApproveChaincodeDefinitionForMyOrgResult.
             * @memberof lifecycle
             * @interface IApproveChaincodeDefinitionForMyOrgResult
             */
    
            /**
             * Constructs a new ApproveChaincodeDefinitionForMyOrgResult.
             * @memberof lifecycle
             * @classdesc Represents an ApproveChaincodeDefinitionForMyOrgResult.
             * @implements IApproveChaincodeDefinitionForMyOrgResult
             * @constructor
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgResult=} [properties] Properties to set
             */
            function ApproveChaincodeDefinitionForMyOrgResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ApproveChaincodeDefinitionForMyOrgResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgResult=} [properties] Properties to set
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} ApproveChaincodeDefinitionForMyOrgResult instance
             */
            ApproveChaincodeDefinitionForMyOrgResult.create = function create(properties) {
                return new ApproveChaincodeDefinitionForMyOrgResult(properties);
            };
    
            /**
             * Encodes the specified ApproveChaincodeDefinitionForMyOrgResult message. Does not implicitly {@link lifecycle.ApproveChaincodeDefinitionForMyOrgResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgResult} message ApproveChaincodeDefinitionForMyOrgResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveChaincodeDefinitionForMyOrgResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ApproveChaincodeDefinitionForMyOrgResult message, length delimited. Does not implicitly {@link lifecycle.ApproveChaincodeDefinitionForMyOrgResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgResult} message ApproveChaincodeDefinitionForMyOrgResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveChaincodeDefinitionForMyOrgResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ApproveChaincodeDefinitionForMyOrgResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} ApproveChaincodeDefinitionForMyOrgResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveChaincodeDefinitionForMyOrgResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ApproveChaincodeDefinitionForMyOrgResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ApproveChaincodeDefinitionForMyOrgResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} ApproveChaincodeDefinitionForMyOrgResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveChaincodeDefinitionForMyOrgResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ApproveChaincodeDefinitionForMyOrgResult message.
             * @function verify
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApproveChaincodeDefinitionForMyOrgResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates an ApproveChaincodeDefinitionForMyOrgResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} ApproveChaincodeDefinitionForMyOrgResult
             */
            ApproveChaincodeDefinitionForMyOrgResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ApproveChaincodeDefinitionForMyOrgResult)
                    return object;
                return new $root.lifecycle.ApproveChaincodeDefinitionForMyOrgResult();
            };
    
            /**
             * Creates a plain object from an ApproveChaincodeDefinitionForMyOrgResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} message ApproveChaincodeDefinitionForMyOrgResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ApproveChaincodeDefinitionForMyOrgResult.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ApproveChaincodeDefinitionForMyOrgResult to JSON.
             * @function toJSON
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ApproveChaincodeDefinitionForMyOrgResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ApproveChaincodeDefinitionForMyOrgResult;
        })();
    
        lifecycle.CommitChaincodeDefinitionArgs = (function() {
    
            /**
             * Properties of a CommitChaincodeDefinitionArgs.
             * @memberof lifecycle
             * @interface ICommitChaincodeDefinitionArgs
             * @property {number|Long|null} [sequence] CommitChaincodeDefinitionArgs sequence
             * @property {string|null} [name] CommitChaincodeDefinitionArgs name
             * @property {string|null} [version] CommitChaincodeDefinitionArgs version
             * @property {string|null} [endorsement_plugin] CommitChaincodeDefinitionArgs endorsement_plugin
             * @property {string|null} [validation_plugin] CommitChaincodeDefinitionArgs validation_plugin
             * @property {Uint8Array|null} [validation_parameter] CommitChaincodeDefinitionArgs validation_parameter
             * @property {protos.ICollectionConfigPackage|null} [collections] CommitChaincodeDefinitionArgs collections
             * @property {boolean|null} [init_required] CommitChaincodeDefinitionArgs init_required
             */
    
            /**
             * Constructs a new CommitChaincodeDefinitionArgs.
             * @memberof lifecycle
             * @classdesc Represents a CommitChaincodeDefinitionArgs.
             * @implements ICommitChaincodeDefinitionArgs
             * @constructor
             * @param {lifecycle.ICommitChaincodeDefinitionArgs=} [properties] Properties to set
             */
            function CommitChaincodeDefinitionArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CommitChaincodeDefinitionArgs sequence.
             * @member {number|Long} sequence
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * CommitChaincodeDefinitionArgs name.
             * @member {string} name
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.name = "";
    
            /**
             * CommitChaincodeDefinitionArgs version.
             * @member {string} version
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.version = "";
    
            /**
             * CommitChaincodeDefinitionArgs endorsement_plugin.
             * @member {string} endorsement_plugin
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.endorsement_plugin = "";
    
            /**
             * CommitChaincodeDefinitionArgs validation_plugin.
             * @member {string} validation_plugin
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.validation_plugin = "";
    
            /**
             * CommitChaincodeDefinitionArgs validation_parameter.
             * @member {Uint8Array} validation_parameter
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.validation_parameter = $util.newBuffer([]);
    
            /**
             * CommitChaincodeDefinitionArgs collections.
             * @member {protos.ICollectionConfigPackage|null|undefined} collections
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.collections = null;
    
            /**
             * CommitChaincodeDefinitionArgs init_required.
             * @member {boolean} init_required
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.init_required = false;
    
            /**
             * Creates a new CommitChaincodeDefinitionArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionArgs=} [properties] Properties to set
             * @returns {lifecycle.CommitChaincodeDefinitionArgs} CommitChaincodeDefinitionArgs instance
             */
            CommitChaincodeDefinitionArgs.create = function create(properties) {
                return new CommitChaincodeDefinitionArgs(properties);
            };
    
            /**
             * Encodes the specified CommitChaincodeDefinitionArgs message. Does not implicitly {@link lifecycle.CommitChaincodeDefinitionArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionArgs} message CommitChaincodeDefinitionArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitChaincodeDefinitionArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sequence);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                if (message.endorsement_plugin != null && Object.hasOwnProperty.call(message, "endorsement_plugin"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.endorsement_plugin);
                if (message.validation_plugin != null && Object.hasOwnProperty.call(message, "validation_plugin"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.validation_plugin);
                if (message.validation_parameter != null && Object.hasOwnProperty.call(message, "validation_parameter"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.validation_parameter);
                if (message.collections != null && Object.hasOwnProperty.call(message, "collections"))
                    $root.protos.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.init_required != null && Object.hasOwnProperty.call(message, "init_required"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.init_required);
                return writer;
            };
    
            /**
             * Encodes the specified CommitChaincodeDefinitionArgs message, length delimited. Does not implicitly {@link lifecycle.CommitChaincodeDefinitionArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionArgs} message CommitChaincodeDefinitionArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitChaincodeDefinitionArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CommitChaincodeDefinitionArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.CommitChaincodeDefinitionArgs} CommitChaincodeDefinitionArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitChaincodeDefinitionArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.CommitChaincodeDefinitionArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.int64();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.version = reader.string();
                        break;
                    case 4:
                        message.endorsement_plugin = reader.string();
                        break;
                    case 5:
                        message.validation_plugin = reader.string();
                        break;
                    case 6:
                        message.validation_parameter = reader.bytes();
                        break;
                    case 7:
                        message.collections = $root.protos.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.init_required = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CommitChaincodeDefinitionArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.CommitChaincodeDefinitionArgs} CommitChaincodeDefinitionArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitChaincodeDefinitionArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CommitChaincodeDefinitionArgs message.
             * @function verify
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitChaincodeDefinitionArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    if (!$util.isString(message.endorsement_plugin))
                        return "endorsement_plugin: string expected";
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    if (!$util.isString(message.validation_plugin))
                        return "validation_plugin: string expected";
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    if (!(message.validation_parameter && typeof message.validation_parameter.length === "number" || $util.isString(message.validation_parameter)))
                        return "validation_parameter: buffer expected";
                if (message.collections != null && message.hasOwnProperty("collections")) {
                    var error = $root.protos.CollectionConfigPackage.verify(message.collections);
                    if (error)
                        return "collections." + error;
                }
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    if (typeof message.init_required !== "boolean")
                        return "init_required: boolean expected";
                return null;
            };
    
            /**
             * Creates a CommitChaincodeDefinitionArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.CommitChaincodeDefinitionArgs} CommitChaincodeDefinitionArgs
             */
            CommitChaincodeDefinitionArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.CommitChaincodeDefinitionArgs)
                    return object;
                var message = new $root.lifecycle.CommitChaincodeDefinitionArgs();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.endorsement_plugin != null)
                    message.endorsement_plugin = String(object.endorsement_plugin);
                if (object.validation_plugin != null)
                    message.validation_plugin = String(object.validation_plugin);
                if (object.validation_parameter != null)
                    if (typeof object.validation_parameter === "string")
                        $util.base64.decode(object.validation_parameter, message.validation_parameter = $util.newBuffer($util.base64.length(object.validation_parameter)), 0);
                    else if (object.validation_parameter.length)
                        message.validation_parameter = object.validation_parameter;
                if (object.collections != null) {
                    if (typeof object.collections !== "object")
                        throw TypeError(".lifecycle.CommitChaincodeDefinitionArgs.collections: object expected");
                    message.collections = $root.protos.CollectionConfigPackage.fromObject(object.collections);
                }
                if (object.init_required != null)
                    message.init_required = Boolean(object.init_required);
                return message;
            };
    
            /**
             * Creates a plain object from a CommitChaincodeDefinitionArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.CommitChaincodeDefinitionArgs} message CommitChaincodeDefinitionArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitChaincodeDefinitionArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.version = "";
                    object.endorsement_plugin = "";
                    object.validation_plugin = "";
                    if (options.bytes === String)
                        object.validation_parameter = "";
                    else {
                        object.validation_parameter = [];
                        if (options.bytes !== Array)
                            object.validation_parameter = $util.newBuffer(object.validation_parameter);
                    }
                    object.collections = null;
                    object.init_required = false;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    object.endorsement_plugin = message.endorsement_plugin;
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    object.validation_plugin = message.validation_plugin;
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    object.validation_parameter = options.bytes === String ? $util.base64.encode(message.validation_parameter, 0, message.validation_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validation_parameter) : message.validation_parameter;
                if (message.collections != null && message.hasOwnProperty("collections"))
                    object.collections = $root.protos.CollectionConfigPackage.toObject(message.collections, options);
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    object.init_required = message.init_required;
                return object;
            };
    
            /**
             * Converts this CommitChaincodeDefinitionArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitChaincodeDefinitionArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CommitChaincodeDefinitionArgs;
        })();
    
        lifecycle.CommitChaincodeDefinitionResult = (function() {
    
            /**
             * Properties of a CommitChaincodeDefinitionResult.
             * @memberof lifecycle
             * @interface ICommitChaincodeDefinitionResult
             */
    
            /**
             * Constructs a new CommitChaincodeDefinitionResult.
             * @memberof lifecycle
             * @classdesc Represents a CommitChaincodeDefinitionResult.
             * @implements ICommitChaincodeDefinitionResult
             * @constructor
             * @param {lifecycle.ICommitChaincodeDefinitionResult=} [properties] Properties to set
             */
            function CommitChaincodeDefinitionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new CommitChaincodeDefinitionResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionResult=} [properties] Properties to set
             * @returns {lifecycle.CommitChaincodeDefinitionResult} CommitChaincodeDefinitionResult instance
             */
            CommitChaincodeDefinitionResult.create = function create(properties) {
                return new CommitChaincodeDefinitionResult(properties);
            };
    
            /**
             * Encodes the specified CommitChaincodeDefinitionResult message. Does not implicitly {@link lifecycle.CommitChaincodeDefinitionResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionResult} message CommitChaincodeDefinitionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitChaincodeDefinitionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified CommitChaincodeDefinitionResult message, length delimited. Does not implicitly {@link lifecycle.CommitChaincodeDefinitionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionResult} message CommitChaincodeDefinitionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitChaincodeDefinitionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CommitChaincodeDefinitionResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.CommitChaincodeDefinitionResult} CommitChaincodeDefinitionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitChaincodeDefinitionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.CommitChaincodeDefinitionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CommitChaincodeDefinitionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.CommitChaincodeDefinitionResult} CommitChaincodeDefinitionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitChaincodeDefinitionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CommitChaincodeDefinitionResult message.
             * @function verify
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitChaincodeDefinitionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a CommitChaincodeDefinitionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.CommitChaincodeDefinitionResult} CommitChaincodeDefinitionResult
             */
            CommitChaincodeDefinitionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.CommitChaincodeDefinitionResult)
                    return object;
                return new $root.lifecycle.CommitChaincodeDefinitionResult();
            };
    
            /**
             * Creates a plain object from a CommitChaincodeDefinitionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {lifecycle.CommitChaincodeDefinitionResult} message CommitChaincodeDefinitionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitChaincodeDefinitionResult.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this CommitChaincodeDefinitionResult to JSON.
             * @function toJSON
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitChaincodeDefinitionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CommitChaincodeDefinitionResult;
        })();
    
        lifecycle.CheckCommitReadinessArgs = (function() {
    
            /**
             * Properties of a CheckCommitReadinessArgs.
             * @memberof lifecycle
             * @interface ICheckCommitReadinessArgs
             * @property {number|Long|null} [sequence] CheckCommitReadinessArgs sequence
             * @property {string|null} [name] CheckCommitReadinessArgs name
             * @property {string|null} [version] CheckCommitReadinessArgs version
             * @property {string|null} [endorsement_plugin] CheckCommitReadinessArgs endorsement_plugin
             * @property {string|null} [validation_plugin] CheckCommitReadinessArgs validation_plugin
             * @property {Uint8Array|null} [validation_parameter] CheckCommitReadinessArgs validation_parameter
             * @property {protos.ICollectionConfigPackage|null} [collections] CheckCommitReadinessArgs collections
             * @property {boolean|null} [init_required] CheckCommitReadinessArgs init_required
             */
    
            /**
             * Constructs a new CheckCommitReadinessArgs.
             * @memberof lifecycle
             * @classdesc Represents a CheckCommitReadinessArgs.
             * @implements ICheckCommitReadinessArgs
             * @constructor
             * @param {lifecycle.ICheckCommitReadinessArgs=} [properties] Properties to set
             */
            function CheckCommitReadinessArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CheckCommitReadinessArgs sequence.
             * @member {number|Long} sequence
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * CheckCommitReadinessArgs name.
             * @member {string} name
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.name = "";
    
            /**
             * CheckCommitReadinessArgs version.
             * @member {string} version
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.version = "";
    
            /**
             * CheckCommitReadinessArgs endorsement_plugin.
             * @member {string} endorsement_plugin
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.endorsement_plugin = "";
    
            /**
             * CheckCommitReadinessArgs validation_plugin.
             * @member {string} validation_plugin
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.validation_plugin = "";
    
            /**
             * CheckCommitReadinessArgs validation_parameter.
             * @member {Uint8Array} validation_parameter
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.validation_parameter = $util.newBuffer([]);
    
            /**
             * CheckCommitReadinessArgs collections.
             * @member {protos.ICollectionConfigPackage|null|undefined} collections
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.collections = null;
    
            /**
             * CheckCommitReadinessArgs init_required.
             * @member {boolean} init_required
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.init_required = false;
    
            /**
             * Creates a new CheckCommitReadinessArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {lifecycle.ICheckCommitReadinessArgs=} [properties] Properties to set
             * @returns {lifecycle.CheckCommitReadinessArgs} CheckCommitReadinessArgs instance
             */
            CheckCommitReadinessArgs.create = function create(properties) {
                return new CheckCommitReadinessArgs(properties);
            };
    
            /**
             * Encodes the specified CheckCommitReadinessArgs message. Does not implicitly {@link lifecycle.CheckCommitReadinessArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {lifecycle.ICheckCommitReadinessArgs} message CheckCommitReadinessArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckCommitReadinessArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sequence);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                if (message.endorsement_plugin != null && Object.hasOwnProperty.call(message, "endorsement_plugin"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.endorsement_plugin);
                if (message.validation_plugin != null && Object.hasOwnProperty.call(message, "validation_plugin"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.validation_plugin);
                if (message.validation_parameter != null && Object.hasOwnProperty.call(message, "validation_parameter"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.validation_parameter);
                if (message.collections != null && Object.hasOwnProperty.call(message, "collections"))
                    $root.protos.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.init_required != null && Object.hasOwnProperty.call(message, "init_required"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.init_required);
                return writer;
            };
    
            /**
             * Encodes the specified CheckCommitReadinessArgs message, length delimited. Does not implicitly {@link lifecycle.CheckCommitReadinessArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {lifecycle.ICheckCommitReadinessArgs} message CheckCommitReadinessArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckCommitReadinessArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CheckCommitReadinessArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.CheckCommitReadinessArgs} CheckCommitReadinessArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckCommitReadinessArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.CheckCommitReadinessArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.int64();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.version = reader.string();
                        break;
                    case 4:
                        message.endorsement_plugin = reader.string();
                        break;
                    case 5:
                        message.validation_plugin = reader.string();
                        break;
                    case 6:
                        message.validation_parameter = reader.bytes();
                        break;
                    case 7:
                        message.collections = $root.protos.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.init_required = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CheckCommitReadinessArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.CheckCommitReadinessArgs} CheckCommitReadinessArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckCommitReadinessArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CheckCommitReadinessArgs message.
             * @function verify
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckCommitReadinessArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    if (!$util.isString(message.endorsement_plugin))
                        return "endorsement_plugin: string expected";
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    if (!$util.isString(message.validation_plugin))
                        return "validation_plugin: string expected";
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    if (!(message.validation_parameter && typeof message.validation_parameter.length === "number" || $util.isString(message.validation_parameter)))
                        return "validation_parameter: buffer expected";
                if (message.collections != null && message.hasOwnProperty("collections")) {
                    var error = $root.protos.CollectionConfigPackage.verify(message.collections);
                    if (error)
                        return "collections." + error;
                }
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    if (typeof message.init_required !== "boolean")
                        return "init_required: boolean expected";
                return null;
            };
    
            /**
             * Creates a CheckCommitReadinessArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.CheckCommitReadinessArgs} CheckCommitReadinessArgs
             */
            CheckCommitReadinessArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.CheckCommitReadinessArgs)
                    return object;
                var message = new $root.lifecycle.CheckCommitReadinessArgs();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.endorsement_plugin != null)
                    message.endorsement_plugin = String(object.endorsement_plugin);
                if (object.validation_plugin != null)
                    message.validation_plugin = String(object.validation_plugin);
                if (object.validation_parameter != null)
                    if (typeof object.validation_parameter === "string")
                        $util.base64.decode(object.validation_parameter, message.validation_parameter = $util.newBuffer($util.base64.length(object.validation_parameter)), 0);
                    else if (object.validation_parameter.length)
                        message.validation_parameter = object.validation_parameter;
                if (object.collections != null) {
                    if (typeof object.collections !== "object")
                        throw TypeError(".lifecycle.CheckCommitReadinessArgs.collections: object expected");
                    message.collections = $root.protos.CollectionConfigPackage.fromObject(object.collections);
                }
                if (object.init_required != null)
                    message.init_required = Boolean(object.init_required);
                return message;
            };
    
            /**
             * Creates a plain object from a CheckCommitReadinessArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {lifecycle.CheckCommitReadinessArgs} message CheckCommitReadinessArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckCommitReadinessArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.version = "";
                    object.endorsement_plugin = "";
                    object.validation_plugin = "";
                    if (options.bytes === String)
                        object.validation_parameter = "";
                    else {
                        object.validation_parameter = [];
                        if (options.bytes !== Array)
                            object.validation_parameter = $util.newBuffer(object.validation_parameter);
                    }
                    object.collections = null;
                    object.init_required = false;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    object.endorsement_plugin = message.endorsement_plugin;
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    object.validation_plugin = message.validation_plugin;
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    object.validation_parameter = options.bytes === String ? $util.base64.encode(message.validation_parameter, 0, message.validation_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validation_parameter) : message.validation_parameter;
                if (message.collections != null && message.hasOwnProperty("collections"))
                    object.collections = $root.protos.CollectionConfigPackage.toObject(message.collections, options);
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    object.init_required = message.init_required;
                return object;
            };
    
            /**
             * Converts this CheckCommitReadinessArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckCommitReadinessArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CheckCommitReadinessArgs;
        })();
    
        lifecycle.CheckCommitReadinessResult = (function() {
    
            /**
             * Properties of a CheckCommitReadinessResult.
             * @memberof lifecycle
             * @interface ICheckCommitReadinessResult
             * @property {Object.<string,boolean>|null} [approvals] CheckCommitReadinessResult approvals
             */
    
            /**
             * Constructs a new CheckCommitReadinessResult.
             * @memberof lifecycle
             * @classdesc Represents a CheckCommitReadinessResult.
             * @implements ICheckCommitReadinessResult
             * @constructor
             * @param {lifecycle.ICheckCommitReadinessResult=} [properties] Properties to set
             */
            function CheckCommitReadinessResult(properties) {
                this.approvals = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CheckCommitReadinessResult approvals.
             * @member {Object.<string,boolean>} approvals
             * @memberof lifecycle.CheckCommitReadinessResult
             * @instance
             */
            CheckCommitReadinessResult.prototype.approvals = $util.emptyObject;
    
            /**
             * Creates a new CheckCommitReadinessResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {lifecycle.ICheckCommitReadinessResult=} [properties] Properties to set
             * @returns {lifecycle.CheckCommitReadinessResult} CheckCommitReadinessResult instance
             */
            CheckCommitReadinessResult.create = function create(properties) {
                return new CheckCommitReadinessResult(properties);
            };
    
            /**
             * Encodes the specified CheckCommitReadinessResult message. Does not implicitly {@link lifecycle.CheckCommitReadinessResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {lifecycle.ICheckCommitReadinessResult} message CheckCommitReadinessResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckCommitReadinessResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.approvals != null && Object.hasOwnProperty.call(message, "approvals"))
                    for (var keys = Object.keys(message.approvals), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.approvals[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CheckCommitReadinessResult message, length delimited. Does not implicitly {@link lifecycle.CheckCommitReadinessResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {lifecycle.ICheckCommitReadinessResult} message CheckCommitReadinessResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckCommitReadinessResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CheckCommitReadinessResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.CheckCommitReadinessResult} CheckCommitReadinessResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckCommitReadinessResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.CheckCommitReadinessResult(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.approvals === $util.emptyObject)
                            message.approvals = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = false;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bool();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.approvals[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CheckCommitReadinessResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.CheckCommitReadinessResult} CheckCommitReadinessResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckCommitReadinessResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CheckCommitReadinessResult message.
             * @function verify
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckCommitReadinessResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.approvals != null && message.hasOwnProperty("approvals")) {
                    if (!$util.isObject(message.approvals))
                        return "approvals: object expected";
                    var key = Object.keys(message.approvals);
                    for (var i = 0; i < key.length; ++i)
                        if (typeof message.approvals[key[i]] !== "boolean")
                            return "approvals: boolean{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a CheckCommitReadinessResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.CheckCommitReadinessResult} CheckCommitReadinessResult
             */
            CheckCommitReadinessResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.CheckCommitReadinessResult)
                    return object;
                var message = new $root.lifecycle.CheckCommitReadinessResult();
                if (object.approvals) {
                    if (typeof object.approvals !== "object")
                        throw TypeError(".lifecycle.CheckCommitReadinessResult.approvals: object expected");
                    message.approvals = {};
                    for (var keys = Object.keys(object.approvals), i = 0; i < keys.length; ++i)
                        message.approvals[keys[i]] = Boolean(object.approvals[keys[i]]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CheckCommitReadinessResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {lifecycle.CheckCommitReadinessResult} message CheckCommitReadinessResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckCommitReadinessResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.approvals = {};
                var keys2;
                if (message.approvals && (keys2 = Object.keys(message.approvals)).length) {
                    object.approvals = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.approvals[keys2[j]] = message.approvals[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this CheckCommitReadinessResult to JSON.
             * @function toJSON
             * @memberof lifecycle.CheckCommitReadinessResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckCommitReadinessResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CheckCommitReadinessResult;
        })();
    
        lifecycle.QueryChaincodeDefinitionArgs = (function() {
    
            /**
             * Properties of a QueryChaincodeDefinitionArgs.
             * @memberof lifecycle
             * @interface IQueryChaincodeDefinitionArgs
             * @property {string|null} [name] QueryChaincodeDefinitionArgs name
             */
    
            /**
             * Constructs a new QueryChaincodeDefinitionArgs.
             * @memberof lifecycle
             * @classdesc Represents a QueryChaincodeDefinitionArgs.
             * @implements IQueryChaincodeDefinitionArgs
             * @constructor
             * @param {lifecycle.IQueryChaincodeDefinitionArgs=} [properties] Properties to set
             */
            function QueryChaincodeDefinitionArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryChaincodeDefinitionArgs name.
             * @member {string} name
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @instance
             */
            QueryChaincodeDefinitionArgs.prototype.name = "";
    
            /**
             * Creates a new QueryChaincodeDefinitionArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionArgs=} [properties] Properties to set
             * @returns {lifecycle.QueryChaincodeDefinitionArgs} QueryChaincodeDefinitionArgs instance
             */
            QueryChaincodeDefinitionArgs.create = function create(properties) {
                return new QueryChaincodeDefinitionArgs(properties);
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionArgs message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionArgs} message QueryChaincodeDefinitionArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionArgs message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionArgs} message QueryChaincodeDefinitionArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryChaincodeDefinitionArgs} QueryChaincodeDefinitionArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryChaincodeDefinitionArgs} QueryChaincodeDefinitionArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryChaincodeDefinitionArgs message.
             * @function verify
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryChaincodeDefinitionArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a QueryChaincodeDefinitionArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryChaincodeDefinitionArgs} QueryChaincodeDefinitionArgs
             */
            QueryChaincodeDefinitionArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryChaincodeDefinitionArgs)
                    return object;
                var message = new $root.lifecycle.QueryChaincodeDefinitionArgs();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryChaincodeDefinitionArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.QueryChaincodeDefinitionArgs} message QueryChaincodeDefinitionArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryChaincodeDefinitionArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this QueryChaincodeDefinitionArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryChaincodeDefinitionArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryChaincodeDefinitionArgs;
        })();
    
        lifecycle.QueryChaincodeDefinitionResult = (function() {
    
            /**
             * Properties of a QueryChaincodeDefinitionResult.
             * @memberof lifecycle
             * @interface IQueryChaincodeDefinitionResult
             * @property {number|Long|null} [sequence] QueryChaincodeDefinitionResult sequence
             * @property {string|null} [version] QueryChaincodeDefinitionResult version
             * @property {string|null} [endorsement_plugin] QueryChaincodeDefinitionResult endorsement_plugin
             * @property {string|null} [validation_plugin] QueryChaincodeDefinitionResult validation_plugin
             * @property {Uint8Array|null} [validation_parameter] QueryChaincodeDefinitionResult validation_parameter
             * @property {protos.ICollectionConfigPackage|null} [collections] QueryChaincodeDefinitionResult collections
             * @property {boolean|null} [init_required] QueryChaincodeDefinitionResult init_required
             * @property {Object.<string,boolean>|null} [approvals] QueryChaincodeDefinitionResult approvals
             */
    
            /**
             * Constructs a new QueryChaincodeDefinitionResult.
             * @memberof lifecycle
             * @classdesc Represents a QueryChaincodeDefinitionResult.
             * @implements IQueryChaincodeDefinitionResult
             * @constructor
             * @param {lifecycle.IQueryChaincodeDefinitionResult=} [properties] Properties to set
             */
            function QueryChaincodeDefinitionResult(properties) {
                this.approvals = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryChaincodeDefinitionResult sequence.
             * @member {number|Long} sequence
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * QueryChaincodeDefinitionResult version.
             * @member {string} version
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.version = "";
    
            /**
             * QueryChaincodeDefinitionResult endorsement_plugin.
             * @member {string} endorsement_plugin
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.endorsement_plugin = "";
    
            /**
             * QueryChaincodeDefinitionResult validation_plugin.
             * @member {string} validation_plugin
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.validation_plugin = "";
    
            /**
             * QueryChaincodeDefinitionResult validation_parameter.
             * @member {Uint8Array} validation_parameter
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.validation_parameter = $util.newBuffer([]);
    
            /**
             * QueryChaincodeDefinitionResult collections.
             * @member {protos.ICollectionConfigPackage|null|undefined} collections
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.collections = null;
    
            /**
             * QueryChaincodeDefinitionResult init_required.
             * @member {boolean} init_required
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.init_required = false;
    
            /**
             * QueryChaincodeDefinitionResult approvals.
             * @member {Object.<string,boolean>} approvals
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.approvals = $util.emptyObject;
    
            /**
             * Creates a new QueryChaincodeDefinitionResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionResult=} [properties] Properties to set
             * @returns {lifecycle.QueryChaincodeDefinitionResult} QueryChaincodeDefinitionResult instance
             */
            QueryChaincodeDefinitionResult.create = function create(properties) {
                return new QueryChaincodeDefinitionResult(properties);
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionResult message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionResult} message QueryChaincodeDefinitionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sequence);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.endorsement_plugin != null && Object.hasOwnProperty.call(message, "endorsement_plugin"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.endorsement_plugin);
                if (message.validation_plugin != null && Object.hasOwnProperty.call(message, "validation_plugin"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.validation_plugin);
                if (message.validation_parameter != null && Object.hasOwnProperty.call(message, "validation_parameter"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.validation_parameter);
                if (message.collections != null && Object.hasOwnProperty.call(message, "collections"))
                    $root.protos.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.init_required != null && Object.hasOwnProperty.call(message, "init_required"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.init_required);
                if (message.approvals != null && Object.hasOwnProperty.call(message, "approvals"))
                    for (var keys = Object.keys(message.approvals), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.approvals[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionResult message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionResult} message QueryChaincodeDefinitionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryChaincodeDefinitionResult} QueryChaincodeDefinitionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionResult(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.int64();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.endorsement_plugin = reader.string();
                        break;
                    case 4:
                        message.validation_plugin = reader.string();
                        break;
                    case 5:
                        message.validation_parameter = reader.bytes();
                        break;
                    case 6:
                        message.collections = $root.protos.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.init_required = reader.bool();
                        break;
                    case 8:
                        if (message.approvals === $util.emptyObject)
                            message.approvals = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = false;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bool();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.approvals[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryChaincodeDefinitionResult} QueryChaincodeDefinitionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryChaincodeDefinitionResult message.
             * @function verify
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryChaincodeDefinitionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    if (!$util.isString(message.endorsement_plugin))
                        return "endorsement_plugin: string expected";
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    if (!$util.isString(message.validation_plugin))
                        return "validation_plugin: string expected";
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    if (!(message.validation_parameter && typeof message.validation_parameter.length === "number" || $util.isString(message.validation_parameter)))
                        return "validation_parameter: buffer expected";
                if (message.collections != null && message.hasOwnProperty("collections")) {
                    var error = $root.protos.CollectionConfigPackage.verify(message.collections);
                    if (error)
                        return "collections." + error;
                }
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    if (typeof message.init_required !== "boolean")
                        return "init_required: boolean expected";
                if (message.approvals != null && message.hasOwnProperty("approvals")) {
                    if (!$util.isObject(message.approvals))
                        return "approvals: object expected";
                    var key = Object.keys(message.approvals);
                    for (var i = 0; i < key.length; ++i)
                        if (typeof message.approvals[key[i]] !== "boolean")
                            return "approvals: boolean{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a QueryChaincodeDefinitionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryChaincodeDefinitionResult} QueryChaincodeDefinitionResult
             */
            QueryChaincodeDefinitionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryChaincodeDefinitionResult)
                    return object;
                var message = new $root.lifecycle.QueryChaincodeDefinitionResult();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.endorsement_plugin != null)
                    message.endorsement_plugin = String(object.endorsement_plugin);
                if (object.validation_plugin != null)
                    message.validation_plugin = String(object.validation_plugin);
                if (object.validation_parameter != null)
                    if (typeof object.validation_parameter === "string")
                        $util.base64.decode(object.validation_parameter, message.validation_parameter = $util.newBuffer($util.base64.length(object.validation_parameter)), 0);
                    else if (object.validation_parameter.length)
                        message.validation_parameter = object.validation_parameter;
                if (object.collections != null) {
                    if (typeof object.collections !== "object")
                        throw TypeError(".lifecycle.QueryChaincodeDefinitionResult.collections: object expected");
                    message.collections = $root.protos.CollectionConfigPackage.fromObject(object.collections);
                }
                if (object.init_required != null)
                    message.init_required = Boolean(object.init_required);
                if (object.approvals) {
                    if (typeof object.approvals !== "object")
                        throw TypeError(".lifecycle.QueryChaincodeDefinitionResult.approvals: object expected");
                    message.approvals = {};
                    for (var keys = Object.keys(object.approvals), i = 0; i < keys.length; ++i)
                        message.approvals[keys[i]] = Boolean(object.approvals[keys[i]]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryChaincodeDefinitionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {lifecycle.QueryChaincodeDefinitionResult} message QueryChaincodeDefinitionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryChaincodeDefinitionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.approvals = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.version = "";
                    object.endorsement_plugin = "";
                    object.validation_plugin = "";
                    if (options.bytes === String)
                        object.validation_parameter = "";
                    else {
                        object.validation_parameter = [];
                        if (options.bytes !== Array)
                            object.validation_parameter = $util.newBuffer(object.validation_parameter);
                    }
                    object.collections = null;
                    object.init_required = false;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    object.endorsement_plugin = message.endorsement_plugin;
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    object.validation_plugin = message.validation_plugin;
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    object.validation_parameter = options.bytes === String ? $util.base64.encode(message.validation_parameter, 0, message.validation_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validation_parameter) : message.validation_parameter;
                if (message.collections != null && message.hasOwnProperty("collections"))
                    object.collections = $root.protos.CollectionConfigPackage.toObject(message.collections, options);
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    object.init_required = message.init_required;
                var keys2;
                if (message.approvals && (keys2 = Object.keys(message.approvals)).length) {
                    object.approvals = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.approvals[keys2[j]] = message.approvals[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this QueryChaincodeDefinitionResult to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryChaincodeDefinitionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryChaincodeDefinitionResult;
        })();
    
        lifecycle.QueryChaincodeDefinitionsArgs = (function() {
    
            /**
             * Properties of a QueryChaincodeDefinitionsArgs.
             * @memberof lifecycle
             * @interface IQueryChaincodeDefinitionsArgs
             */
    
            /**
             * Constructs a new QueryChaincodeDefinitionsArgs.
             * @memberof lifecycle
             * @classdesc Represents a QueryChaincodeDefinitionsArgs.
             * @implements IQueryChaincodeDefinitionsArgs
             * @constructor
             * @param {lifecycle.IQueryChaincodeDefinitionsArgs=} [properties] Properties to set
             */
            function QueryChaincodeDefinitionsArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new QueryChaincodeDefinitionsArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsArgs=} [properties] Properties to set
             * @returns {lifecycle.QueryChaincodeDefinitionsArgs} QueryChaincodeDefinitionsArgs instance
             */
            QueryChaincodeDefinitionsArgs.create = function create(properties) {
                return new QueryChaincodeDefinitionsArgs(properties);
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionsArgs message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsArgs} message QueryChaincodeDefinitionsArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionsArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionsArgs message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsArgs} message QueryChaincodeDefinitionsArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionsArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionsArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryChaincodeDefinitionsArgs} QueryChaincodeDefinitionsArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionsArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionsArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionsArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryChaincodeDefinitionsArgs} QueryChaincodeDefinitionsArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionsArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryChaincodeDefinitionsArgs message.
             * @function verify
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryChaincodeDefinitionsArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a QueryChaincodeDefinitionsArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryChaincodeDefinitionsArgs} QueryChaincodeDefinitionsArgs
             */
            QueryChaincodeDefinitionsArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryChaincodeDefinitionsArgs)
                    return object;
                return new $root.lifecycle.QueryChaincodeDefinitionsArgs();
            };
    
            /**
             * Creates a plain object from a QueryChaincodeDefinitionsArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {lifecycle.QueryChaincodeDefinitionsArgs} message QueryChaincodeDefinitionsArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryChaincodeDefinitionsArgs.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this QueryChaincodeDefinitionsArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryChaincodeDefinitionsArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryChaincodeDefinitionsArgs;
        })();
    
        lifecycle.QueryChaincodeDefinitionsResult = (function() {
    
            /**
             * Properties of a QueryChaincodeDefinitionsResult.
             * @memberof lifecycle
             * @interface IQueryChaincodeDefinitionsResult
             * @property {Array.<lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition>|null} [chaincode_definitions] QueryChaincodeDefinitionsResult chaincode_definitions
             */
    
            /**
             * Constructs a new QueryChaincodeDefinitionsResult.
             * @memberof lifecycle
             * @classdesc Represents a QueryChaincodeDefinitionsResult.
             * @implements IQueryChaincodeDefinitionsResult
             * @constructor
             * @param {lifecycle.IQueryChaincodeDefinitionsResult=} [properties] Properties to set
             */
            function QueryChaincodeDefinitionsResult(properties) {
                this.chaincode_definitions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryChaincodeDefinitionsResult chaincode_definitions.
             * @member {Array.<lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition>} chaincode_definitions
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @instance
             */
            QueryChaincodeDefinitionsResult.prototype.chaincode_definitions = $util.emptyArray;
    
            /**
             * Creates a new QueryChaincodeDefinitionsResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsResult=} [properties] Properties to set
             * @returns {lifecycle.QueryChaincodeDefinitionsResult} QueryChaincodeDefinitionsResult instance
             */
            QueryChaincodeDefinitionsResult.create = function create(properties) {
                return new QueryChaincodeDefinitionsResult(properties);
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionsResult message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsResult} message QueryChaincodeDefinitionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionsResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode_definitions != null && message.chaincode_definitions.length)
                    for (var i = 0; i < message.chaincode_definitions.length; ++i)
                        $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.encode(message.chaincode_definitions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionsResult message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsResult} message QueryChaincodeDefinitionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionsResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionsResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryChaincodeDefinitionsResult} QueryChaincodeDefinitionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionsResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionsResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.chaincode_definitions && message.chaincode_definitions.length))
                            message.chaincode_definitions = [];
                        message.chaincode_definitions.push($root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryChaincodeDefinitionsResult} QueryChaincodeDefinitionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionsResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryChaincodeDefinitionsResult message.
             * @function verify
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryChaincodeDefinitionsResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode_definitions != null && message.hasOwnProperty("chaincode_definitions")) {
                    if (!Array.isArray(message.chaincode_definitions))
                        return "chaincode_definitions: array expected";
                    for (var i = 0; i < message.chaincode_definitions.length; ++i) {
                        var error = $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.verify(message.chaincode_definitions[i]);
                        if (error)
                            return "chaincode_definitions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryChaincodeDefinitionsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryChaincodeDefinitionsResult} QueryChaincodeDefinitionsResult
             */
            QueryChaincodeDefinitionsResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryChaincodeDefinitionsResult)
                    return object;
                var message = new $root.lifecycle.QueryChaincodeDefinitionsResult();
                if (object.chaincode_definitions) {
                    if (!Array.isArray(object.chaincode_definitions))
                        throw TypeError(".lifecycle.QueryChaincodeDefinitionsResult.chaincode_definitions: array expected");
                    message.chaincode_definitions = [];
                    for (var i = 0; i < object.chaincode_definitions.length; ++i) {
                        if (typeof object.chaincode_definitions[i] !== "object")
                            throw TypeError(".lifecycle.QueryChaincodeDefinitionsResult.chaincode_definitions: object expected");
                        message.chaincode_definitions[i] = $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.fromObject(object.chaincode_definitions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryChaincodeDefinitionsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {lifecycle.QueryChaincodeDefinitionsResult} message QueryChaincodeDefinitionsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryChaincodeDefinitionsResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincode_definitions = [];
                if (message.chaincode_definitions && message.chaincode_definitions.length) {
                    object.chaincode_definitions = [];
                    for (var j = 0; j < message.chaincode_definitions.length; ++j)
                        object.chaincode_definitions[j] = $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.toObject(message.chaincode_definitions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryChaincodeDefinitionsResult to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryChaincodeDefinitionsResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            QueryChaincodeDefinitionsResult.ChaincodeDefinition = (function() {
    
                /**
                 * Properties of a ChaincodeDefinition.
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult
                 * @interface IChaincodeDefinition
                 * @property {string|null} [name] ChaincodeDefinition name
                 * @property {number|Long|null} [sequence] ChaincodeDefinition sequence
                 * @property {string|null} [version] ChaincodeDefinition version
                 * @property {string|null} [endorsement_plugin] ChaincodeDefinition endorsement_plugin
                 * @property {string|null} [validation_plugin] ChaincodeDefinition validation_plugin
                 * @property {Uint8Array|null} [validation_parameter] ChaincodeDefinition validation_parameter
                 * @property {protos.ICollectionConfigPackage|null} [collections] ChaincodeDefinition collections
                 * @property {boolean|null} [init_required] ChaincodeDefinition init_required
                 */
    
                /**
                 * Constructs a new ChaincodeDefinition.
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult
                 * @classdesc Represents a ChaincodeDefinition.
                 * @implements IChaincodeDefinition
                 * @constructor
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition=} [properties] Properties to set
                 */
                function ChaincodeDefinition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ChaincodeDefinition name.
                 * @member {string} name
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.name = "";
    
                /**
                 * ChaincodeDefinition sequence.
                 * @member {number|Long} sequence
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * ChaincodeDefinition version.
                 * @member {string} version
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.version = "";
    
                /**
                 * ChaincodeDefinition endorsement_plugin.
                 * @member {string} endorsement_plugin
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.endorsement_plugin = "";
    
                /**
                 * ChaincodeDefinition validation_plugin.
                 * @member {string} validation_plugin
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.validation_plugin = "";
    
                /**
                 * ChaincodeDefinition validation_parameter.
                 * @member {Uint8Array} validation_parameter
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.validation_parameter = $util.newBuffer([]);
    
                /**
                 * ChaincodeDefinition collections.
                 * @member {protos.ICollectionConfigPackage|null|undefined} collections
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.collections = null;
    
                /**
                 * ChaincodeDefinition init_required.
                 * @member {boolean} init_required
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.init_required = false;
    
                /**
                 * Creates a new ChaincodeDefinition instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition=} [properties] Properties to set
                 * @returns {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} ChaincodeDefinition instance
                 */
                ChaincodeDefinition.create = function create(properties) {
                    return new ChaincodeDefinition(properties);
                };
    
                /**
                 * Encodes the specified ChaincodeDefinition message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition} message ChaincodeDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChaincodeDefinition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequence);
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                    if (message.endorsement_plugin != null && Object.hasOwnProperty.call(message, "endorsement_plugin"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.endorsement_plugin);
                    if (message.validation_plugin != null && Object.hasOwnProperty.call(message, "validation_plugin"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.validation_plugin);
                    if (message.validation_parameter != null && Object.hasOwnProperty.call(message, "validation_parameter"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.validation_parameter);
                    if (message.collections != null && Object.hasOwnProperty.call(message, "collections"))
                        $root.protos.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.init_required != null && Object.hasOwnProperty.call(message, "init_required"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.init_required);
                    return writer;
                };
    
                /**
                 * Encodes the specified ChaincodeDefinition message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition} message ChaincodeDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChaincodeDefinition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ChaincodeDefinition message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} ChaincodeDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChaincodeDefinition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.sequence = reader.int64();
                            break;
                        case 3:
                            message.version = reader.string();
                            break;
                        case 4:
                            message.endorsement_plugin = reader.string();
                            break;
                        case 5:
                            message.validation_plugin = reader.string();
                            break;
                        case 6:
                            message.validation_parameter = reader.bytes();
                            break;
                        case 7:
                            message.collections = $root.protos.CollectionConfigPackage.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.init_required = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ChaincodeDefinition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} ChaincodeDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChaincodeDefinition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ChaincodeDefinition message.
                 * @function verify
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChaincodeDefinition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.sequence != null && message.hasOwnProperty("sequence"))
                        if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                            return "sequence: integer|Long expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                        if (!$util.isString(message.endorsement_plugin))
                            return "endorsement_plugin: string expected";
                    if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                        if (!$util.isString(message.validation_plugin))
                            return "validation_plugin: string expected";
                    if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                        if (!(message.validation_parameter && typeof message.validation_parameter.length === "number" || $util.isString(message.validation_parameter)))
                            return "validation_parameter: buffer expected";
                    if (message.collections != null && message.hasOwnProperty("collections")) {
                        var error = $root.protos.CollectionConfigPackage.verify(message.collections);
                        if (error)
                            return "collections." + error;
                    }
                    if (message.init_required != null && message.hasOwnProperty("init_required"))
                        if (typeof message.init_required !== "boolean")
                            return "init_required: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a ChaincodeDefinition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} ChaincodeDefinition
                 */
                ChaincodeDefinition.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition)
                        return object;
                    var message = new $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.sequence != null)
                        if ($util.Long)
                            (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                        else if (typeof object.sequence === "string")
                            message.sequence = parseInt(object.sequence, 10);
                        else if (typeof object.sequence === "number")
                            message.sequence = object.sequence;
                        else if (typeof object.sequence === "object")
                            message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                    if (object.version != null)
                        message.version = String(object.version);
                    if (object.endorsement_plugin != null)
                        message.endorsement_plugin = String(object.endorsement_plugin);
                    if (object.validation_plugin != null)
                        message.validation_plugin = String(object.validation_plugin);
                    if (object.validation_parameter != null)
                        if (typeof object.validation_parameter === "string")
                            $util.base64.decode(object.validation_parameter, message.validation_parameter = $util.newBuffer($util.base64.length(object.validation_parameter)), 0);
                        else if (object.validation_parameter.length)
                            message.validation_parameter = object.validation_parameter;
                    if (object.collections != null) {
                        if (typeof object.collections !== "object")
                            throw TypeError(".lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.collections: object expected");
                        message.collections = $root.protos.CollectionConfigPackage.fromObject(object.collections);
                    }
                    if (object.init_required != null)
                        message.init_required = Boolean(object.init_required);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ChaincodeDefinition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} message ChaincodeDefinition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChaincodeDefinition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.sequence = options.longs === String ? "0" : 0;
                        object.version = "";
                        object.endorsement_plugin = "";
                        object.validation_plugin = "";
                        if (options.bytes === String)
                            object.validation_parameter = "";
                        else {
                            object.validation_parameter = [];
                            if (options.bytes !== Array)
                                object.validation_parameter = $util.newBuffer(object.validation_parameter);
                        }
                        object.collections = null;
                        object.init_required = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.sequence != null && message.hasOwnProperty("sequence"))
                        if (typeof message.sequence === "number")
                            object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                        else
                            object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                        object.endorsement_plugin = message.endorsement_plugin;
                    if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                        object.validation_plugin = message.validation_plugin;
                    if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                        object.validation_parameter = options.bytes === String ? $util.base64.encode(message.validation_parameter, 0, message.validation_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validation_parameter) : message.validation_parameter;
                    if (message.collections != null && message.hasOwnProperty("collections"))
                        object.collections = $root.protos.CollectionConfigPackage.toObject(message.collections, options);
                    if (message.init_required != null && message.hasOwnProperty("init_required"))
                        object.init_required = message.init_required;
                    return object;
                };
    
                /**
                 * Converts this ChaincodeDefinition to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChaincodeDefinition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ChaincodeDefinition;
            })();
    
            return QueryChaincodeDefinitionsResult;
        })();
    
        lifecycle.StateMetadata = (function() {
    
            /**
             * Properties of a StateMetadata.
             * @memberof lifecycle
             * @interface IStateMetadata
             * @property {string|null} [datatype] StateMetadata datatype
             * @property {Array.<string>|null} [fields] StateMetadata fields
             */
    
            /**
             * Constructs a new StateMetadata.
             * @memberof lifecycle
             * @classdesc Represents a StateMetadata.
             * @implements IStateMetadata
             * @constructor
             * @param {lifecycle.IStateMetadata=} [properties] Properties to set
             */
            function StateMetadata(properties) {
                this.fields = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateMetadata datatype.
             * @member {string} datatype
             * @memberof lifecycle.StateMetadata
             * @instance
             */
            StateMetadata.prototype.datatype = "";
    
            /**
             * StateMetadata fields.
             * @member {Array.<string>} fields
             * @memberof lifecycle.StateMetadata
             * @instance
             */
            StateMetadata.prototype.fields = $util.emptyArray;
    
            /**
             * Creates a new StateMetadata instance using the specified properties.
             * @function create
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {lifecycle.IStateMetadata=} [properties] Properties to set
             * @returns {lifecycle.StateMetadata} StateMetadata instance
             */
            StateMetadata.create = function create(properties) {
                return new StateMetadata(properties);
            };
    
            /**
             * Encodes the specified StateMetadata message. Does not implicitly {@link lifecycle.StateMetadata.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {lifecycle.IStateMetadata} message StateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.datatype != null && Object.hasOwnProperty.call(message, "datatype"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.datatype);
                if (message.fields != null && message.fields.length)
                    for (var i = 0; i < message.fields.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fields[i]);
                return writer;
            };
    
            /**
             * Encodes the specified StateMetadata message, length delimited. Does not implicitly {@link lifecycle.StateMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {lifecycle.IStateMetadata} message StateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.StateMetadata} StateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.StateMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.datatype = reader.string();
                        break;
                    case 2:
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.StateMetadata} StateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateMetadata message.
             * @function verify
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.datatype != null && message.hasOwnProperty("datatype"))
                    if (!$util.isString(message.datatype))
                        return "datatype: string expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!Array.isArray(message.fields))
                        return "fields: array expected";
                    for (var i = 0; i < message.fields.length; ++i)
                        if (!$util.isString(message.fields[i]))
                            return "fields: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a StateMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.StateMetadata} StateMetadata
             */
            StateMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.StateMetadata)
                    return object;
                var message = new $root.lifecycle.StateMetadata();
                if (object.datatype != null)
                    message.datatype = String(object.datatype);
                if (object.fields) {
                    if (!Array.isArray(object.fields))
                        throw TypeError(".lifecycle.StateMetadata.fields: array expected");
                    message.fields = [];
                    for (var i = 0; i < object.fields.length; ++i)
                        message.fields[i] = String(object.fields[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StateMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {lifecycle.StateMetadata} message StateMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fields = [];
                if (options.defaults)
                    object.datatype = "";
                if (message.datatype != null && message.hasOwnProperty("datatype"))
                    object.datatype = message.datatype;
                if (message.fields && message.fields.length) {
                    object.fields = [];
                    for (var j = 0; j < message.fields.length; ++j)
                        object.fields[j] = message.fields[j];
                }
                return object;
            };
    
            /**
             * Converts this StateMetadata to JSON.
             * @function toJSON
             * @memberof lifecycle.StateMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateMetadata;
        })();
    
        lifecycle.StateData = (function() {
    
            /**
             * Properties of a StateData.
             * @memberof lifecycle
             * @interface IStateData
             * @property {number|Long|null} [Int64] StateData Int64
             * @property {Uint8Array|null} [Bytes] StateData Bytes
             * @property {string|null} [String] StateData String
             */
    
            /**
             * Constructs a new StateData.
             * @memberof lifecycle
             * @classdesc Represents a StateData.
             * @implements IStateData
             * @constructor
             * @param {lifecycle.IStateData=} [properties] Properties to set
             */
            function StateData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateData Int64.
             * @member {number|Long|null|undefined} Int64
             * @memberof lifecycle.StateData
             * @instance
             */
            StateData.prototype.Int64 = null;
    
            /**
             * StateData Bytes.
             * @member {Uint8Array|null|undefined} Bytes
             * @memberof lifecycle.StateData
             * @instance
             */
            StateData.prototype.Bytes = null;
    
            /**
             * StateData String.
             * @member {string|null|undefined} String
             * @memberof lifecycle.StateData
             * @instance
             */
            StateData.prototype.String = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * StateData Type.
             * @member {"Int64"|"Bytes"|"String"|undefined} Type
             * @memberof lifecycle.StateData
             * @instance
             */
            Object.defineProperty(StateData.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["Int64", "Bytes", "String"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new StateData instance using the specified properties.
             * @function create
             * @memberof lifecycle.StateData
             * @static
             * @param {lifecycle.IStateData=} [properties] Properties to set
             * @returns {lifecycle.StateData} StateData instance
             */
            StateData.create = function create(properties) {
                return new StateData(properties);
            };
    
            /**
             * Encodes the specified StateData message. Does not implicitly {@link lifecycle.StateData.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.StateData
             * @static
             * @param {lifecycle.IStateData} message StateData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Int64 != null && Object.hasOwnProperty.call(message, "Int64"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Int64);
                if (message.Bytes != null && Object.hasOwnProperty.call(message, "Bytes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Bytes);
                if (message.String != null && Object.hasOwnProperty.call(message, "String"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.String);
                return writer;
            };
    
            /**
             * Encodes the specified StateData message, length delimited. Does not implicitly {@link lifecycle.StateData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.StateData
             * @static
             * @param {lifecycle.IStateData} message StateData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateData message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.StateData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.StateData} StateData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.StateData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Int64 = reader.int64();
                        break;
                    case 2:
                        message.Bytes = reader.bytes();
                        break;
                    case 3:
                        message.String = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.StateData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.StateData} StateData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateData message.
             * @function verify
             * @memberof lifecycle.StateData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.Int64 != null && message.hasOwnProperty("Int64")) {
                    properties.Type = 1;
                    if (!$util.isInteger(message.Int64) && !(message.Int64 && $util.isInteger(message.Int64.low) && $util.isInteger(message.Int64.high)))
                        return "Int64: integer|Long expected";
                }
                if (message.Bytes != null && message.hasOwnProperty("Bytes")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    if (!(message.Bytes && typeof message.Bytes.length === "number" || $util.isString(message.Bytes)))
                        return "Bytes: buffer expected";
                }
                if (message.String != null && message.hasOwnProperty("String")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    if (!$util.isString(message.String))
                        return "String: string expected";
                }
                return null;
            };
    
            /**
             * Creates a StateData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.StateData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.StateData} StateData
             */
            StateData.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.StateData)
                    return object;
                var message = new $root.lifecycle.StateData();
                if (object.Int64 != null)
                    if ($util.Long)
                        (message.Int64 = $util.Long.fromValue(object.Int64)).unsigned = false;
                    else if (typeof object.Int64 === "string")
                        message.Int64 = parseInt(object.Int64, 10);
                    else if (typeof object.Int64 === "number")
                        message.Int64 = object.Int64;
                    else if (typeof object.Int64 === "object")
                        message.Int64 = new $util.LongBits(object.Int64.low >>> 0, object.Int64.high >>> 0).toNumber();
                if (object.Bytes != null)
                    if (typeof object.Bytes === "string")
                        $util.base64.decode(object.Bytes, message.Bytes = $util.newBuffer($util.base64.length(object.Bytes)), 0);
                    else if (object.Bytes.length)
                        message.Bytes = object.Bytes;
                if (object.String != null)
                    message.String = String(object.String);
                return message;
            };
    
            /**
             * Creates a plain object from a StateData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.StateData
             * @static
             * @param {lifecycle.StateData} message StateData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.Int64 != null && message.hasOwnProperty("Int64")) {
                    if (typeof message.Int64 === "number")
                        object.Int64 = options.longs === String ? String(message.Int64) : message.Int64;
                    else
                        object.Int64 = options.longs === String ? $util.Long.prototype.toString.call(message.Int64) : options.longs === Number ? new $util.LongBits(message.Int64.low >>> 0, message.Int64.high >>> 0).toNumber() : message.Int64;
                    if (options.oneofs)
                        object.Type = "Int64";
                }
                if (message.Bytes != null && message.hasOwnProperty("Bytes")) {
                    object.Bytes = options.bytes === String ? $util.base64.encode(message.Bytes, 0, message.Bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.Bytes) : message.Bytes;
                    if (options.oneofs)
                        object.Type = "Bytes";
                }
                if (message.String != null && message.hasOwnProperty("String")) {
                    object.String = message.String;
                    if (options.oneofs)
                        object.Type = "String";
                }
                return object;
            };
    
            /**
             * Converts this StateData to JSON.
             * @function toJSON
             * @memberof lifecycle.StateData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateData;
        })();
    
        lifecycle.ChaincodeEndorsementInfo = (function() {
    
            /**
             * Properties of a ChaincodeEndorsementInfo.
             * @memberof lifecycle
             * @interface IChaincodeEndorsementInfo
             * @property {string|null} [version] ChaincodeEndorsementInfo version
             * @property {boolean|null} [init_required] ChaincodeEndorsementInfo init_required
             * @property {string|null} [endorsement_plugin] ChaincodeEndorsementInfo endorsement_plugin
             */
    
            /**
             * Constructs a new ChaincodeEndorsementInfo.
             * @memberof lifecycle
             * @classdesc Represents a ChaincodeEndorsementInfo.
             * @implements IChaincodeEndorsementInfo
             * @constructor
             * @param {lifecycle.IChaincodeEndorsementInfo=} [properties] Properties to set
             */
            function ChaincodeEndorsementInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeEndorsementInfo version.
             * @member {string} version
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @instance
             */
            ChaincodeEndorsementInfo.prototype.version = "";
    
            /**
             * ChaincodeEndorsementInfo init_required.
             * @member {boolean} init_required
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @instance
             */
            ChaincodeEndorsementInfo.prototype.init_required = false;
    
            /**
             * ChaincodeEndorsementInfo endorsement_plugin.
             * @member {string} endorsement_plugin
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @instance
             */
            ChaincodeEndorsementInfo.prototype.endorsement_plugin = "";
    
            /**
             * Creates a new ChaincodeEndorsementInfo instance using the specified properties.
             * @function create
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {lifecycle.IChaincodeEndorsementInfo=} [properties] Properties to set
             * @returns {lifecycle.ChaincodeEndorsementInfo} ChaincodeEndorsementInfo instance
             */
            ChaincodeEndorsementInfo.create = function create(properties) {
                return new ChaincodeEndorsementInfo(properties);
            };
    
            /**
             * Encodes the specified ChaincodeEndorsementInfo message. Does not implicitly {@link lifecycle.ChaincodeEndorsementInfo.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {lifecycle.IChaincodeEndorsementInfo} message ChaincodeEndorsementInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsementInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                if (message.init_required != null && Object.hasOwnProperty.call(message, "init_required"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.init_required);
                if (message.endorsement_plugin != null && Object.hasOwnProperty.call(message, "endorsement_plugin"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.endorsement_plugin);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeEndorsementInfo message, length delimited. Does not implicitly {@link lifecycle.ChaincodeEndorsementInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {lifecycle.IChaincodeEndorsementInfo} message ChaincodeEndorsementInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsementInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeEndorsementInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ChaincodeEndorsementInfo} ChaincodeEndorsementInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsementInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeEndorsementInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.string();
                        break;
                    case 2:
                        message.init_required = reader.bool();
                        break;
                    case 3:
                        message.endorsement_plugin = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeEndorsementInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ChaincodeEndorsementInfo} ChaincodeEndorsementInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsementInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeEndorsementInfo message.
             * @function verify
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeEndorsementInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    if (typeof message.init_required !== "boolean")
                        return "init_required: boolean expected";
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    if (!$util.isString(message.endorsement_plugin))
                        return "endorsement_plugin: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeEndorsementInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ChaincodeEndorsementInfo} ChaincodeEndorsementInfo
             */
            ChaincodeEndorsementInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ChaincodeEndorsementInfo)
                    return object;
                var message = new $root.lifecycle.ChaincodeEndorsementInfo();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.init_required != null)
                    message.init_required = Boolean(object.init_required);
                if (object.endorsement_plugin != null)
                    message.endorsement_plugin = String(object.endorsement_plugin);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeEndorsementInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {lifecycle.ChaincodeEndorsementInfo} message ChaincodeEndorsementInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeEndorsementInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.version = "";
                    object.init_required = false;
                    object.endorsement_plugin = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.init_required != null && message.hasOwnProperty("init_required"))
                    object.init_required = message.init_required;
                if (message.endorsement_plugin != null && message.hasOwnProperty("endorsement_plugin"))
                    object.endorsement_plugin = message.endorsement_plugin;
                return object;
            };
    
            /**
             * Converts this ChaincodeEndorsementInfo to JSON.
             * @function toJSON
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeEndorsementInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeEndorsementInfo;
        })();
    
        lifecycle.ChaincodeValidationInfo = (function() {
    
            /**
             * Properties of a ChaincodeValidationInfo.
             * @memberof lifecycle
             * @interface IChaincodeValidationInfo
             * @property {string|null} [validation_plugin] ChaincodeValidationInfo validation_plugin
             * @property {Uint8Array|null} [validation_parameter] ChaincodeValidationInfo validation_parameter
             */
    
            /**
             * Constructs a new ChaincodeValidationInfo.
             * @memberof lifecycle
             * @classdesc Represents a ChaincodeValidationInfo.
             * @implements IChaincodeValidationInfo
             * @constructor
             * @param {lifecycle.IChaincodeValidationInfo=} [properties] Properties to set
             */
            function ChaincodeValidationInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeValidationInfo validation_plugin.
             * @member {string} validation_plugin
             * @memberof lifecycle.ChaincodeValidationInfo
             * @instance
             */
            ChaincodeValidationInfo.prototype.validation_plugin = "";
    
            /**
             * ChaincodeValidationInfo validation_parameter.
             * @member {Uint8Array} validation_parameter
             * @memberof lifecycle.ChaincodeValidationInfo
             * @instance
             */
            ChaincodeValidationInfo.prototype.validation_parameter = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeValidationInfo instance using the specified properties.
             * @function create
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {lifecycle.IChaincodeValidationInfo=} [properties] Properties to set
             * @returns {lifecycle.ChaincodeValidationInfo} ChaincodeValidationInfo instance
             */
            ChaincodeValidationInfo.create = function create(properties) {
                return new ChaincodeValidationInfo(properties);
            };
    
            /**
             * Encodes the specified ChaincodeValidationInfo message. Does not implicitly {@link lifecycle.ChaincodeValidationInfo.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {lifecycle.IChaincodeValidationInfo} message ChaincodeValidationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeValidationInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.validation_plugin != null && Object.hasOwnProperty.call(message, "validation_plugin"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.validation_plugin);
                if (message.validation_parameter != null && Object.hasOwnProperty.call(message, "validation_parameter"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.validation_parameter);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeValidationInfo message, length delimited. Does not implicitly {@link lifecycle.ChaincodeValidationInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {lifecycle.IChaincodeValidationInfo} message ChaincodeValidationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeValidationInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeValidationInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ChaincodeValidationInfo} ChaincodeValidationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeValidationInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeValidationInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.validation_plugin = reader.string();
                        break;
                    case 2:
                        message.validation_parameter = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeValidationInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ChaincodeValidationInfo} ChaincodeValidationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeValidationInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeValidationInfo message.
             * @function verify
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeValidationInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    if (!$util.isString(message.validation_plugin))
                        return "validation_plugin: string expected";
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    if (!(message.validation_parameter && typeof message.validation_parameter.length === "number" || $util.isString(message.validation_parameter)))
                        return "validation_parameter: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeValidationInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ChaincodeValidationInfo} ChaincodeValidationInfo
             */
            ChaincodeValidationInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ChaincodeValidationInfo)
                    return object;
                var message = new $root.lifecycle.ChaincodeValidationInfo();
                if (object.validation_plugin != null)
                    message.validation_plugin = String(object.validation_plugin);
                if (object.validation_parameter != null)
                    if (typeof object.validation_parameter === "string")
                        $util.base64.decode(object.validation_parameter, message.validation_parameter = $util.newBuffer($util.base64.length(object.validation_parameter)), 0);
                    else if (object.validation_parameter.length)
                        message.validation_parameter = object.validation_parameter;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeValidationInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {lifecycle.ChaincodeValidationInfo} message ChaincodeValidationInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeValidationInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.validation_plugin = "";
                    if (options.bytes === String)
                        object.validation_parameter = "";
                    else {
                        object.validation_parameter = [];
                        if (options.bytes !== Array)
                            object.validation_parameter = $util.newBuffer(object.validation_parameter);
                    }
                }
                if (message.validation_plugin != null && message.hasOwnProperty("validation_plugin"))
                    object.validation_plugin = message.validation_plugin;
                if (message.validation_parameter != null && message.hasOwnProperty("validation_parameter"))
                    object.validation_parameter = options.bytes === String ? $util.base64.encode(message.validation_parameter, 0, message.validation_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validation_parameter) : message.validation_parameter;
                return object;
            };
    
            /**
             * Converts this ChaincodeValidationInfo to JSON.
             * @function toJSON
             * @memberof lifecycle.ChaincodeValidationInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeValidationInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeValidationInfo;
        })();
    
        return lifecycle;
    })();

    return $root;
});
