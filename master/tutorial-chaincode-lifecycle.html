<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Hyperledger Fabric SDK for node.js Tutorial: fabric-client: How to install and start your chaincode</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Hyperledger Fabric SDK for node.js</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-fabric-network.html">fabric-network</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="AffiliationService.html">AffiliationService</a></li><li><a href="BasePackager.html">BasePackager</a></li><li><a href="BasicCommitHandler.html">BasicCommitHandler</a></li><li><a href="BlockDecoder.html">BlockDecoder</a></li><li><a href="CertificateAuthority.html">CertificateAuthority</a></li><li><a href="Chaincode.html">Chaincode</a></li><li><a href="ChaincodeRegistration.html">ChaincodeRegistration</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ChannelEventHub.html">ChannelEventHub</a></li><li><a href="ChannelPeer.html">ChannelPeer</a></li><li><a href="Client.html">Client</a></li><li><a href="CommitHandler.html">CommitHandler</a></li><li><a href="DiscoveryEndorsementHandler.html">DiscoveryEndorsementHandler</a></li><li><a href="EndorsementHandler.html">EndorsementHandler</a></li><li><a href="EndorsementPolicy.html">EndorsementPolicy</a></li><li><a href="Endpoint.html">Endpoint</a></li><li><a href="event_hub_number.html">event_hub_number</a></li><li><a href="FabricCAClient.html">FabricCAClient</a></li><li><a href="FabricCAServices.html">FabricCAServices</a></li><li><a href="IdentityService.html">IdentityService</a></li><li><a href="module-fabric-network.BaseCheckpointer.html">fabric-network.BaseCheckpointer</a></li><li><a href="module-fabric-network.BaseEventListener.html">fabric-network.BaseEventListener</a></li><li><a href="module-fabric-network.CommitEventListener.html">fabric-network.CommitEventListener</a></li><li><a href="module-fabric-network.Contract.html">fabric-network.Contract</a></li><li><a href="module-fabric-network.ContractEventListener.html">fabric-network.ContractEventListener</a></li><li><a href="module-fabric-network.EventHubDisconnectError.html">fabric-network.EventHubDisconnectError</a></li><li><a href="module-fabric-network.EventServiceManager.html">fabric-network.EventServiceManager</a></li><li><a href="module-fabric-network.FabricError.html">fabric-network.FabricError</a></li><li><a href="module-fabric-network.FileSystemCheckpointer.html">fabric-network.FileSystemCheckpointer</a></li><li><a href="module-fabric-network.Gateway.html">fabric-network.Gateway</a></li><li><a href="module-fabric-network.HsmX509Provider.html">fabric-network.HsmX509Provider</a></li><li><a href="module-fabric-network.IdentityProviderRegistry.html">fabric-network.IdentityProviderRegistry</a></li><li><a href="module-fabric-network.Network.html">fabric-network.Network</a></li><li><a href="module-fabric-network.TimeoutError.html">fabric-network.TimeoutError</a></li><li><a href="module-fabric-network.Transaction.html">fabric-network.Transaction</a></li><li><a href="module-fabric-network.Wallet.html">fabric-network.Wallet</a></li><li><a href="module-fabric-network.Wallets.html">fabric-network.Wallets</a></li><li><a href="MSP.html">MSP</a></li><li><a href="MSPManager.html">MSPManager</a></li><li><a href="NetworkConfig.html">NetworkConfig</a></li><li><a href="NetworkConfig_1_0.html">NetworkConfig_1_0</a></li><li><a href="Orderer.html">Orderer</a></li><li><a href="Organization.html">Organization</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Remote.html">Remote</a></li><li><a href="TransactionID.html">TransactionID</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="interfaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Interfaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-fabric-network.WalletStore.html">fabric-network.WalletStore</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-app-dev-env-setup.html">Setting up the Application Developer's Environment</a></li><li><a href="tutorial-chaincode-lifecycle.html">fabric-client: How to install and start your chaincode</a></li><li><a href="tutorial-channel-create.html">fabric-client: How to create a Hyperledger Fabric channel</a></li><li><a href="tutorial-channel-events.html">fabric-client: How to use the channel-based event service</a></li><li><a href="tutorial-discovery.html">fabric-client: How to use the discovery service</a></li><li><a href="tutorial-event-checkpointer.html">fabric-network: How to replay missed events</a></li><li><a href="tutorial-event-hub-management.html">fabric-network: How to automatically select and reconnect to event hubs</a></li><li><a href="tutorial-grpc-settings.html">fabric-client: How to set gRPC settings</a></li><li><a href="tutorial-handlers.html">fabric-client: How to use the endorsement and commit handlers</a></li><li><a href="tutorial-listening-to-events.html">fabric-network: How to listen to events</a></li><li><a href="tutorial-logging.html">fabric-client: How to use logging</a></li><li><a href="tutorial-metadata-chaincode.html">fabric-client: How to add CouchDB indexes during chaincode installation</a></li><li><a href="tutorial-mutual-tls.html">fabric-client: How to configure mutual TLS</a></li><li><a href="tutorial-network-config.html">fabric-client: How to use a common connection profile</a></li><li><a href="tutorial-private-data.html">How to use private data</a></li><li><a href="tutorial-query-peers.html">fabric-network: How to select peers for evaluating transactions (queries)</a></li><li><a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a></li><li><a href="tutorial-transaction-commit-events.html">fabric-network: How to wait for transactions to be committed to the ledger</a></li><li><a href="tutorial-wallet.html">fabric-network: Using wallets to manage identities</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#CLIENT">CLIENT</a></li><li><a href="global.html#finalPackage">finalPackage</a></li><li><a href="global.html#HFAFFILIATIONMGR">HFAFFILIATIONMGR</a></li><li><a href="global.html#HFGENCRL">HFGENCRL</a></li><li><a href="global.html#HFINTERMEDIATECA">HFINTERMEDIATECA</a></li><li><a href="global.html#HFREGISTRARATTRIBUTES">HFREGISTRARATTRIBUTES</a></li><li><a href="global.html#HFREGISTRARDELEGATEROLES">HFREGISTRARDELEGATEROLES</a></li><li><a href="global.html#HFREGISTRARROLES">HFREGISTRARROLES</a></li><li><a href="global.html#HFREVOKER">HFREVOKER</a></li><li><a href="global.html#loadConfigGroup">loadConfigGroup</a></li><li><a href="global.html#loadConfigValue">loadConfigValue</a></li><li><a href="global.html#ORDERER">ORDERER</a></li><li><a href="global.html#package">package</a></li><li><a href="global.html#PEER">PEER</a></li><li><a href="global.html#toEnvelope">toEnvelope</a></li><li><a href="global.html#USER">USER</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			<section class="tutorial-section">

<header>
    

    <h2>fabric-client: How to install and start your chaincode</h2>
</header>

<article>
    <p>This tutorial describes how to use your application to install a chaincode on
your peers and define it on a channel. This tutorial uses the Fabric chaincode
lifecycle introduced in the Fabric V2.0 Alpha and the fabric-client 2.0 Alpha.
The APIs for using the previous chaincode lifecycle will still be available in
the fabric-client, but will not be discussed in this tutorial.</p>
<p>For more information on the new Fabric Chaincode lifecycle, visit the
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4noah.html">Chaincode for Operators tutorial</a> in the Hyperledger Fabric documentation.</p>
<p>For more information on:</p>
<ul>
<li>getting started with Hyperledger Fabric see
<a href="http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html">Building your first network</a>.</li>
<li>the configuration of a channel in Hyperledger Fabric and the internal
process of creating and updating a channel, see
<a href="http://hyperledger-fabric.readthedocs.io/en/latest/configtx.html">Hyperledger Fabric channel configuration</a></li>
</ul>
<p>The following tutorial assumes an understanding of the components of a
Hyperledger Fabric network (orderers and peers) and of Node application
development, including the use of the Javascript <code>promise</code> and <code>async await</code>.</p>
<h3>Overview</h3>
<p>The Fabric 2.0 Alpha introduces decentralized governance for chaincode. The new
Fabric chaincode lifecycle allows multiple organizations to come to agreement
on the parameters of a chaincode, such as the chaincode endorsement policy,
before it can be used to interact with the ledger. You will need to enable the
new Fabric chaincode lifecycle on your channel definition by setting the
Applications capabilities to <code>V2_0: true</code> to use the steps in this tutorial.</p>
<p>Channel members need to complete the following steps before they can start
using a chaincode:</p>
<ul>
<li><code>Setup</code>- create the necessary application objects</li>
<li><code>Package</code> - create a chaincode package from your source code</li>
<li><code>Install</code> - install the chaincode package on your peers</li>
<li><code>Approve a definition for organization</code> - each organization needs to
approve a chaincode definition in order to use the chaincode</li>
<li><code>Commit the definition to a channel</code> - After a sufficient number of
organizations have approved a chaincode definition, the definition can be
committed to a channel by one organization</li>
<li><code>Initialize</code> - (Optional) initialize the chaincode and start the chaincode
container</li>
</ul>
<h4>New Class</h4>
<p>A new class <a href="Chaincode.html">Chaincode</a> has been added to the fabric-client to encapsulate
a chaincode definition.
A <a href="Chaincode.html">Chaincode</a> instance will be created by a client instance's
<a href="Client.html#newChaincode">newChaincode(name,version)</a> method.
Then using the new instance, you will be able to build up a chaincode definition
with the following methods.</p>
<ul>
<li><a href="Chaincode.html#setEndorsementPolicyDefinition">setEndorsementPolicyDefinition</a> - Provide the endorsement policy for this chaincode.</li>
<li><a href="Chaincode.html#setCollectionConfigPackageDefinition">setCollectionConfigPackageDefinition</a> - Provide the collection configuration for this chaincode.</li>
<li><a href="Chaincode.html#setSequence">setSequence</a> - Provide the modification number for this chaincode definition.</li>
<li><a href="Chaincode.html#setPackage">setPackage</a> - Provide the package when not packaging this chaincode locally.</li>
<li><a href="Chaincode.html#setPackage">setPackageId</a> - Provide the package ID when not installing this chaincode package locally.</li>
</ul>
<p>The chaincode instance will allow you to package a chaincode and install it on
your peers with the following methods:</p>
<ul>
<li><a href="Chaincode.html#package">package</a> Package the files at the locations provided.</li>
<li><a href="Chaincode.html#install">install</a> Install the package on the specified peers.</li>
</ul>
<p>Once the chaincode definition has all the necessary attributes, it may be used
by a channel instance to be approved both for an organization and
then committed for use on the channel.</p>
<h4>New methods on Channel</h4>
<p>The <a href="Channel.html">Channel</a> class has been updated to include methods to approve a
chaincode definition for your organization and commit the definition to a
channel.</p>
<ul>
<li><a href="Channel.html#approveChaincodeForOrg">approveChaincodeForOrg</a> - will approve
the chaincode for an organization on this channel</li>
<li><a href="Channel.html#commitChaincode">commitChaincode</a> - will commit
the chaincode for use on this channel.</li>
<li><a href="Channel.html#queryChaincodeDefinition">queryChaincodeDefinition</a> - will return
a {Chaincode} instance as defined on this peer on this channel</li>
<li>queryApprovalStatus - will indicate the
approval status for a chaincode name on this channel</li>
<li><a href="Channel.html#queryInstalledChaincode">queryInstalledChaincode</a> will indicate
by returning the label if the package ID is installed on this peer</li>
<li><a href="Channel.html#queryInstalledChaincodes">queryInstalledChaincodes</a> will indicate
all the package IDs and labels of installed chaincode on this peer</li>
<li>queryNamespaceDefinitions will indicate
the chaincode names committed (running) on this channel</li>
</ul>
<h4>New method on Client</h4>
<p>The <a href="Client.html">Client</a> class has been enhanced to include a new method to create
a <a href="Chaincode.html">Chaincode</a> instance. This is the object used for creating a chaincode
definition and managing a chaincode.</p>
<ul>
<li><a href="Client.html#newChaincode">newChaincode</a> - Create a <a href="Chaincode.html">Chaincode</a> instance.</li>
</ul>
<h3>Step 1: Setup</h3>
<p>In this step we will build the application objects needed to perform the
operational steps that follow. You will first need to create a fabric-client
operational environment. The client instance will need to have a user store,
crypto suite, and a user assigned. The target peers, orderer, and channel
instance objects will also be required prior to working with chaincode. The
following sample code assumes that all of the normal fabric-client setup has
been completed and only shows the new chaincode lifecycle related calls.</p>
<p>The chaincode object needs specifies the parameters that will define how your
chaincode will operate on the channel. These parameters include the name, version,
endorsement policy, and the collection configuration. This chaincode object also
specifies that the <code>Init</code> function will need to be executed before the chaincode
can be started on the channel.</p>
<pre class="prettyprint source"><code>// get the chaincode instance associated with the client
const mychaincode = client.newChaincode('mychaincode', 'v1');

// The endorsement policy
const policy_def = {
   identities: [
      {role: {name: 'member', mspId: 'org1'}},
      {role: {name: 'member', mspId: 'org2'}}
   ],
   policy: {
       '1-of': [{'signed-by': 0}, {'signed-by': 1}]
   }
};
mychaincode.setEndorsementPolicyDefinition(policy_def);

// The collection configuration - optional.
const config_def = [{
   name: 'detailCol',
   policy: {
      identities: [
         {role: {name: 'member', mspId: 'Org1MSP'}},
         {role: {name: 'member', mspId: 'Org2MSP'}}
      ],
      policy: {
         '1-of': [{'signed-by': 0}, {'signed-by': 1}]
      }
   },
   requiredPeerCount: 1,
   maxPeerCount: 1,
   blockToLive: 100
}];
mychaincode.setCollectionConfigPackageDefinition(config_def));

mychaincode.setInitRequired(true);

// set the sequence (modification) number - default is 1
mychaincode.setSequence(1); // must increment for each definition change
</code></pre>
<h3>Step 2: Package</h3>
<p>The chaincode needs to be packaged before it can be installed on your peers. You
can use the package method to create a chaincode package in the required format.</p>
<p>The method creates a tar file from your chaincode source code, artifacts, and
metadata files. This step can be done by one organization if you want to ensure
that every channel member is using the same chaincode package. Optional you may
create a package label and assign it to this package to help identify the
chaincode package after it is installed on your peers.</p>
<p>The following example packages a golang chaincode. This package can then be
optionally be sent to other channel members out of band.</p>
<pre class="prettyprint source"><code>// package the source code
const package_request = {
   chaincodeType: 'golang',
   goPath: '/gopath',
   chaincodePath: '/path/to/code',
   metadataPath: '/path/to/metadata'
}
const cc_package = await mychaincode.package(package_request);
</code></pre>
<p>If you are given the channel package out of band by another organization, use
the following method to import the chaincode package before it can be installed.</p>
<pre class="prettyprint source"><code>// use an existing package
mychaincode.setPackage(cc_package);
</code></pre>
<h3>Step 3: Install</h3>
<p>Once the chaincode is packaged, it can be installed on your peers. This step will
be required by all organizations that want to use the chaincode to query the
ledger and endorse transactions. The install method will send the packaged
chaincode to the target peers in your organization. This request will need to be
sent by a peer administrator. The installation will return a package ID, a
unique identifer for the chaincode package. You will need the package ID when
you approve a chaincode definition for your organization.</p>
<p>The following sample assumes that the chaincode object being used has been setup
and packaged or an error would be thrown. Note how the package ID is returned
from the <code>install</code>, and is also available from the <code>mychaincode</code> object using
the <code>getPackageId()</code> method.</p>
<pre class="prettyprint source"><code>// install chaincode package on peers
 const install_request = {
   targets: [peer1, peer2],
   request_timeout: 20000 // give the peers some extra time
 }
const package_id = await mychaincode.install(install_request);

// package ID value is stored in the chaincode instance
const package_id = mychaincode.getPackageId();
</code></pre>
<h3>Step 4: Approve for your organization</h3>
<p>Each organization that wants to use the chaincode needs to approve a chaincode
definition for their organization. The transaction to approve a chaincode
definition may be submitted at any time, but must be submitted before the
commit transaction is submitted, or an organization can use the chaincode. Each
organization needs to submit separate approval transactions.</p>
<p>Approving a chaincode definition may be thought of as a vote for a set of
chaincode parameters by your organization. These approved definitions allow
channel members to agree on a chaincode before it can be used on a channel. As a
result, the approved definitions needs to be consistent across organizations. If
the chaincode is already running and a definition has already been committed to
the channel, an organization can use the chaincode by installing the chaincode
package on their peers and approving the committed chaincode definition.</p>
<p>The chaincode definition needs to contain the package identifier to associate
the definition approved by your organization with the chaincode installed on
your peers. If your organization does not plan on using the chaincode, you can
approve a chaincode definition without a package ID. This may be helpful if you
want to ensure that a definition has a sufficient number of approvals to be
committed to the channel.</p>
<p>We used the chaincode object created in step one, <code>mychaincode</code>, to create a
chaincode definition that our organization is ready to approve. The definition
includes all the parameters that were specified in the step one sample code,
such as the name, version, and the endorsement policy. The object also contains
the package ID returned by the install method in step three.</p>
<pre class="prettyprint source"><code>// send a approve chaincode for organization transaction
const tx_id = client.newTransactionID();
const request = {
   target: peer1,
   chaincode: mychaincode, // The chaincode instance fully populated
   txId: tx_id
}
// send to the peer to be endorsed
const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
// send to the orderer to be committed
const results = await mychannel.sendTransaction(orderer_request);
</code></pre>
<h3>Step 5: Commit definition to the channel</h3>
<p>Once a sufficient number of channel members have approved a chaincode definition,
one organization can commit the definition to the channel. In order for the
chaincode definition to be committed successfully, a sufficient number of
organizations need to approve the definition to meet the
<code>Channel/Application/LifecycleEndorsement</code> policy. By default, this policy is set
to a majority of the organizations on the channel.</p>
<p>You can find a sample commit transaction below. The commit transaction needs to
target a sufficient number of peers in other organizations to collect their
endorsements for the definition. Think of this as a tally of the votes for the
chaincode. If the commit transaction can collect a sufficient number of votes
to meet the LifecycleEndorsement policy, the definition can be committed to the
channel and the chaincode used by channel members.</p>
<pre class="prettyprint source"><code>// send a commit chaincode for channel transaction
const tx_id = client.newTransactionID();
const request = {
   targets: [peer1, peer3],
   chaincode: mychaincode,
   txId: tx_id
}
// send to the peers to be endorsed
const {proposalResponses, proposal} = await mychannel.commitChaincode(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
// send to the orderer to be committed
const results = await mychannel.sendTransaction(orderer_request);
</code></pre>
<h3>Step 6: Initialize</h3>
<p>The chaincode is ready to be used after it is defined on a channel. If you did
not request the execution of your chaincode's <code>Init</code> function, then the chaincode
container will start after the first invoke. If you used <code>setInitRequired(true)</code>
then you need to invoke with <code>is_init</code> set to <code>true</code>
before any other transactions can be executed.</p>
<p>The following code snippet below requests the initialization of your chaincode.
Note that <code>is_init</code> needs to be set to <code>true</code> as part of the request, and the
<code>Init</code> method will be called rather than the
<code>Invoke</code> method of your chaincode.</p>
<pre class="prettyprint source"><code>// initialize the chaincode
const tx_id = client.newTransactionID();
const request = {
   chaincodeId : chaincodeId,
   fcn: 'Init',
   args: args,
   txId: tx_id,
   is_init: true // must be set to initialization
}
// starting the container will take longer than the normal request-timeout
const init_results = await mychannel.sendTransaction(request, 20000);
const orderer_request = {
   proposalResponses: init_results[0],
   proposal: init_results[1]
}
// send to the orderer to be committed
const results = await mychannel.sendTransaction(orderer_request);
</code></pre>
<h3>Sample situations</h3>
<p>In addition to being necessary to use a new chaincode, the chaincode definition
provides you additional flexibility in updating a chaincode and managing
chaincode policies. The following samples will provide code snippets for the
following scenarios:</p>
<ul>
<li><code>Intalling a new chaincode</code></li>
<li><code>Upgrading a chaincode</code></li>
<li><code>Modifying an endorsement policy</code></li>
<li><code>Join a channel with a running chaincode</code></li>
</ul>
<h4>New chaincode</h4>
<p>When installing chaincode for the first time, All 5 or 6 steps must be run.</p>
<p>The following sample shows one organization packaging and installing the
chaincode, followed by the organization approving and committing the chaincode
definition for the entire channel. The organization also executes the <code>Init</code>
function in this example.</p>
<pre class="prettyprint source"><code>// step 1: setup
const mychaincode = client.newChaincode('mychaincode', 'version1');
const policy_def = { ... };
mychaincode.setEndorsementPolicyDefinition(policy_def);
mychaincode.setSequence(1); //set to one for a new chaincode
mychaincode.setInitRequired(true);

// step 2: package
const package_request = {
   chaincodeType: 'golang',
   goPath: '/gopath',
   chaincodePath: '/path/to/code',
   metadataPath: '/path/to/metadata'
}
const cc_package = await mychaincode.package(package_request);

// step 3: install
 const install_request = {
   target: peer1,
   request_timeout: 10000 // give the peer some extra time
 }
const package_id = await mychaincode.install(install_request);

// step 4: approve
const tx_id = client.newTransactionID();
const request = {
   targets: [peer1],
   chaincode: mychaincode,
   txId: tx_id
}
const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
const results = await mychannel.sendTransaction(orderer_request);

//step 5: commit
const tx_id = client.newTransactionID();
const request = {
   targets: [peer1, peer3],
   chaincode: mychaincode,
   txId: tx_id
}
const {proposalResponses, proposal} = await mychannel.commitChaincode(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
const results = await mychannel.sendTransaction(orderer_request);

// step 6: init
const tx_id = client.newTransactionID();
const request = {
   chaincodeId : chaincodeId,
   fcn: 'Init',
   args: args,
   txId: tx_id,
   is_init: true
}
const init_results = await mychannel.sendTransaction(request, 20000);
const orderer_request = {
   proposalResponses: init_results[0],
   proposal: init_results[1]
}
const results = await mychannel.sendTransaction(orderer_request);
</code></pre>
<h4>Upgrade the chaincode code</h4>
<p>When upgrading the chaincode binaires, all 5 or 6 steps must be run. The flow
and commands are the same for upgrading a chaincode, but the sequence number
needs to be incremented by one. You will also need to change the chaincode
version.</p>
<p>The following sample shows the code needed when the organization
will be packaging the chaincode, installing it, and being the organization
to approve and commit it for the entire channel.</p>
<pre class="prettyprint source"><code>// step 1: setup
const mychaincode = client.newChaincode('mychaincode', 'version2');
const policy_def = { ... };
mychaincode.setEndorsementPolicyDefinition(policy_def);
mychaincode.setSequence(2);

// step 2: package
// package the source code
const package_request = {
   chaincodeType: 'golang',
   goPath: '/gopath',
   chaincodePath: '/path/to/code',
   metadataPath: '/path/to/metadata'
}
const cc_package = await mychaincode.package(package_request);

// step 3: install
 const install_request = {
   target: peer1,
   request_timeout: 10000 // give the peer some extra time
 }
const package_id = await mychaincode.install(install_request);

// step 4: approve
const tx_id = client.newTransactionID();
const request = {
   targets: [peer1],
   chaincode: mychaincode,
   txId: tx_id
}
const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
const results = await mychannel.sendTransaction(orderer_request);

//step 5: commit
const tx_id = client.newTransactionID();
const request = {
   targets: [peer1, peer3],
   chaincode: mychaincode,
   txId: tx_id
}
// send to the peers to be endorsed
const {proposalResponses, proposal} = await mychannel.commitChaincode(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
// send to the orderer to be committed
const results = await mychannel.sendTransaction(orderer_request);

</code></pre>
<h4>Modify the Endorsement policy</h4>
<p>When updating the endorsement policy, you only need to perform 4 steps.
Organizations can use the chaincode definition to update the endorsement policy
without having to repackage the chaincode or initializing the chaincode. You
need to increment the sequence number by one to change the chaincode definition.
In this case let us assume that the chaincode has been updated once, so the
sequence number will be 3. It might seem that we can also skip the install step,
but we still need the package ID value to uniquely identify the chaincode source
that was installed earlier and has not been changed.</p>
<p>The following sample shows the code needed when the organization updates an
endorsement policy and is then approves and commits the new definition to the
channel.</p>
<pre class="prettyprint source"><code>// step 1: setup
const mychaincode = client.newChaincode('mychaincode', 'version2');
const new_policy_def = { ... };
mychaincode.setEndorsementPolicyDefinition(new_policy_def);
mychaincode.setSequence(3);

// step 3: install
mychaincode.setPackageId(package_id);

// step 4: approve
const tx_id = client.newTransactionID();
const request = {
   target: peer1,
   chaincode: mychaincode,
   txId: tx_id
}
const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
const results = await mychannel.sendTransaction(orderer_request);

//step 5: commit
const tx_id = client.newTransactionID();
const request = {
   targets: [peer1, peer3],
   chaincode: mychaincode,
   txId: tx_id
}
// send to the peers to be endorsed
const {proposalResponses, proposal} = await mychannel.commitChaincode(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
// send to the orderer to be committed
const results = await mychannel.sendTransaction(orderer_request);
</code></pre>
<h4>Joining a channel with a running chaincode</h4>
<p>When a new organization wishes to run an existing chaincode it will have to
perform all but the commit step. This sample assumes that the endorsement
policy allows the new organization to endorse transactions. Otherwise, this
organization will only be able to audit the ledger.</p>
<pre class="prettyprint source"><code>// step 1: setup
const mychaincode = client.newChaincode('mychaincode', 'version2');
const policy_def = { ... }; // must be the same as what the other organizations have used
mychaincode.setEndorsementPolicyDefinition(policy_def);
mychaincode.setSequence(3); // use existing value, if there is change, then up this number

// step 2: package
// package the source code
const package_request = {
   chaincodeType: 'golang',
   goPath: '/gopath',
   chaincodePath: '/path/to/code',
   metadataPath: '/path/to/metadata'
}
const cc_package = await mychaincode.package(package_request);

// step 3: install
 const install_request = {
   target: peer1,
   request_timeout: 10000 // give the peer some extra time
 }
const package_id = await mychaincode.install(install_request);

// step 4: approve
// only the new organization has to run, unless there is change
// to the definition
const tx_id = client.newTransactionID();
const request = {
   targets: [peer1], // this peer is in my org
   chaincode: mychaincode,
   txId: tx_id
}
const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request);
const orderer_request = {
   proposalResponses: proposalResponses,
   proposal, proposal
}
const results = await mychannel.sendTransaction(orderer_request);

// step 5: commit
// This step is not required, however if there was a change to the
// chaincode definition and the sequence number had to change,
// then it must be run
</code></pre>
<h3>Querying chaincode and chaincode definitions.</h3>
<p>The Fabric chaincode allows for decentralized governance and may require
coordination between multiple organizations. You can use query methods to help
manage chaincode lifecycle.</p>
<h4>Querying the chaincode defintion on a channel</h4>
<p>You can use the <code>QueryChaincodeDefinition</code> method to find which definition has
been approved for a given chaincode. You can only send this request to one peer.
This query could be useful in finding the current sequence of a definition
before submitting an upgrade request.</p>
<pre class="prettyprint source"><code>const tx_id = client.newTransactionID();
const request = {
   target: peer,
   chaincodeId: chaincodeId,
   txId: tx_id
}
// send to the peers to be endorsed
const approved_defintion = await mychannel.QueryChaincodeDefinition(request);
</code></pre>
<h4>Querying the approved chaincode defintions</h4>
<p>You can use the <code>QueryApprovalStatus</code> method to find which organizations have
approved a given chaincode definition. You need to build a chaincode object and
pass it to the query. The response will be a JSON mapping of which organizations
on the channel have approved the chaincode definition specified by the chaincode
object. You can use this query to find whether a sufficient number of
organizations have approved a chaincode to meet the LifecycleEndorsement policy
before you commit the chaincode definition the channel, and which peers to
target with the commit transaction.</p>
<pre class="prettyprint source"><code>const tx_id = client.newTransactionID();
const request = {
   target: peer,
   chaincode: mychaincode
   txId: tx_id
}
// send to the peers to be endorsed
const approval_status = await mychannel.QueryApprovalStatus(request);
</code></pre>
<p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>
</article>

</section>

		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
	
		on 2020-01-23T16:52:11+00:00
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : false,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>