<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Global Members &lt;constant&gt; CLIENT CLIENT indicates that an identity is acting as a client &lt;constant&gt; HFAFFILIATIONMGR HFAFFILIATIONMGR is a boolean attribute that allows an identity to manage affiliations &lt;constant&gt; HFGENCRL HFGENCRL is an attribute that allows an identity to generate a CRL &lt;constant&gt; HFINTERMEDIATECA HFINTERMEDIATECA is a boolean attribute that allows an identity to enroll as an intermediate CA &lt;constant&gt; HFREGISTRARATTRIBUTES HFREGISTRARATTRIBUTES is an attribute that has a list of attributes that the registrar is allowed to register for an identity &lt;constant&gt; HFREGISTRARDELEGATEROLES HFREGISTRARDELEGATEROLES is an attribute that allows a registrar to give the roles specified to a registree for its 'hf.Registrar.Roles' attribute &lt;constant&gt; HFREGISTRARROLES HFREGISTRARROLES is an attribute that allows a registrar to manage identities of the specified roles &lt;constant&gt; HFREVOKER HFREVOKER is a boolean attribute that allows an identity to revoker a user and/or certificates &lt;constant&gt; ORDERER ORDERER indicates that an identity is acting as an orderer &lt;constant&gt; PEER PEER indicates that an identity is acting as a peer &lt;constant&gt; USER USER indicates that an identity is acting as a user Methods finalPackage(label, chaincodeType, packageBytes, chaincodePath) Utility function to do the final packaging of chaincode. This will create the tar ball needed by the Chaincode Lifecycle system chaincode. The content produced will be used as the InstallChaincodeArgs Chaincode Install Package bytes. The contents will be returned as a byte array. Parameters: Name Type Description label string The label of the chaincode package chaincodeType string The chaincode type packageBytes Array.&lt;Byte&gt; The chaincode package chaincodePath string Optional unless chaincodeType is \"golang\". Returns: A promise for the data as a byte array Type Promise.&lt;Array.&lt;byte&gt;&gt; loadConfigGroup(config_items, versions, group, name, org, top) utility method to load in a config group Parameters: Name Type Description config_items Object holder of values found in the configuration versions Object group Object used for recursive calls name string used to help with the recursive calls org string Organizational name top bool to handle the differences in the structure of groups See: /protos/common/configtx.proto loadConfigValue() utility method to load in a config value See: /protos/common/configtx.proto /protos/msp/mspconfig.proto /protos/orderer/configuration.proto /protos/peer/configuration.proto package(chaincodePath, chaincodeType, devmode, metadataPath) Utility function to package a chaincode. The contents will be returned as a byte array. Parameters: Name Type Description chaincodePath string required - String of the path to location of the source code of the chaincode chaincodeType string String of the type of chaincode ['golang', 'node', 'car', 'java'] (default 'golang') devmode boolean Set to true to use chaincode development mode metadataPath string Optional. The path to the top-level directory containing metadata descriptors Properties: Name Type Argument Description goPath string &lt;optional&gt; Optional. The path to be used with the golang chaincode. Will default to the environment \"GOPATH\" value. Returns: A promise for the data as a byte array Type Promise toEnvelope(signature, proposal_bytes) convert proposal.proto:SignedProposal to be common.proto:Envelope Parameters: Name Type Description signature proposal_bytes Type Definitions AffiliationRequest Type: Object Properties: Name Type Description name string Required. The affiliation path to create caname string Optional. Name of the CA to send the request to within the Fabric CA server force boolean Optional. For create affiliation request, if any of the parent affiliations do not exist and 'force' is true, create all parent affiliations also. For delete affiliation request, if force is true and there are any child affiliations or any identities are associated with this affiliation or child affiliations, these identities and child affiliations will be deleted; otherwise, an error is returned. For update affiliation request, if any identities are associated with this affiliation, 'force' is true causes these identities' affiliations to be renamed; otherwise, an error is returned. AttributeRequest Type: Object Properties: Name Type Description name string The name of the attribute to include in the certificate optional boolean throw an error if the identity does not have the attribute Block An object of a fully decoded protobuf message \"Block\". A Block may contain the configuration of the channel or transactions on the channel. A Block object will have the following object structure. header number -- {int} previous_hash -- {byte[]} data_hash -- {byte[]} data data -- {array} signature -- {byte[]} payload header -- {Header} data -- {ConfigEnvelope | Transaction} metadata metadata -- {array} #each array item has it's own layout [0] #SIGNATURES signatures -- {MetadataSignature[]} [1] #LAST_CONFIG value index -- {number} signatures -- {MetadataSignature[]} [2] #TRANSACTIONS_FILTER {int[]} #see TxValidationCode in proto/peer/transaction.proto Type: Object Examples Get the block number: var block_num = block.header.number; Get the number of transactions, including the invalid transactions: var block_num = block.data.data.legnth; Get the Id of the first transaction in the block: var tx_id = block.data.data[0].payload.header.channel_header.tx_id; BlockchainInfo Type: Object Properties: Name Type Description height number How many blocks exist on the channel's ledger currentBlockHash Array.&lt;byte&gt; A block hash is calculated by hashing over the concatenated ASN.1 encoded bytes of: the block number, previous block hash, and current block data hash. It's the chain of the block hashs that guarantees the immutability of the ledger previousBlockHash Array.&lt;byte&gt; The block hash of the previous block. BroadcastResponse Type: Object Properties: Name Type Description status string Value is 'SUCCESS' or a descriptive error string info string Optional. Additional information about the status ChaincodeEvent Type: Object Properties: Name Type Description chaincode_id string The name of chaincode that sourced this event. tx_id string The transaction ID of this event. event_name string The string that is the event_name of this event as set by the chaincode during endorsement. stub.SetEvent(event_name, payload) payload Array.&lt;byte&gt; Application-specific byte array that the chaincode set when it called stub.SetEvent(event_name, payload) ChaincodeInfo Type: Object Properties: Name Type Description name string version string path string the path as specified by the install/instantiate transaction input string the chaincode function upon instantiation and its arguments. This will be blank if the query is returning information about installed chaincodes. escc string the name of the ESCC for this chaincode. This will be blank if the query is returning information about installed chaincodes. vscc string the name of the VSCC for this chaincode. This will be blank if the query is returning information about installed chaincodes. ChaincodeInstallRequest Type: Object Properties: Name Type Description target Peer Required. The peer to use for this request request_timeout number Optional. The amount of time for the to respond. The default will be the system configuration value of 'request-timeout'. txId TransactionID Optional. The transaction ID object to use with the install request. If not included it will be generated. ChaincodeInstantiateUpgradeRequest Type: Object Properties: Name Type Argument Description targets Array.&lt;Peer&gt; | Array.&lt;string&gt; &lt;optional&gt; Optional. An array of endorsing Peer objects or peer names as the targets of the request. When this parameter is omitted the target list will include peers assigned to this channel instance that are in the endorsing role. chaincodeType string &lt;optional&gt; Optional. Type of chaincode. One of 'golang', 'car', 'java' or 'node'. Default is 'golang'. Note that 'java' is not yet supported. chaincodeId string Required. The name of the chaincode chaincodeVersion string Required. Version string of the chaincode, such as 'v1' txId TransactionID Required. Object with the transaction id and nonce collections-config string &lt;optional&gt; Optional. The path to the collections config. transientMap object &lt;optional&gt; Optional. Object with String property names and Buffer property values that can be used by the chaincode but not saved in the ledger. Data such as cryptographic information for encryption can be passed to the chaincode using this technique. Data that is to be kept in a private data store (a collection) should be passed to the chaincode in the transientMap. fcn string &lt;optional&gt; Optional. The function name to be returned when calling stub.GetFunctionAndParameters() in the target chaincode. args Array.&lt;string&gt; &lt;optional&gt; Optional. Array of string arguments to pass to the function identified by the fcn value. endorsement-policy Object &lt;optional&gt; Optional. EndorsementPolicy object for this chaincode (see examples below). If not specified, a default policy of \"a signature by any member from any of the organizations corresponding to the array of member service providers\" is used. WARNING: The default policy is NOT recommended for production, because this allows an application to bypass the proposal endorsement and send a manually constructed transaction, with arbitrary output in the write set, to the orderer directly. The user context assigned to the client instance that creates the signature will allow the transaction to be successfully validated and committed to the ledger. Examples Endorsement policy: \"Signed by any member from one of the organizations\" { identities: [ { role: { name: \"member\", mspId: \"org1\" }}, { role: { name: \"member\", mspId: \"org2\" }} ], policy: { \"1-of\": [{ \"signed-by\": 0 }, { \"signed-by\": 1 }] } } Endorsement policy: \"Signed by admin of the ordererOrg and any member from one of the peer organizations\" { identities: [ { role: { name: \"member\", mspId: \"peerOrg1\" }}, { role: { name: \"member\", mspId: \"peerOrg2\" }}, { role: { name: \"admin\", mspId: \"ordererOrg\" }} ], policy: { \"2-of\": [ { \"signed-by\": 2}, { \"1-of\": [{ \"signed-by\": 0 }, { \"signed-by\": 1 }]} ] } } ChaincodeInvocationSpec An endorsement proposal, which includes the name of the chaincode to be invoked and the arguments to be passed to the chaincode. A \"ChaincodeInvocationSpec\" has the following object structure. chaincode_spec type -- {int} chaincode_id path -- {string} name -- {string} version -- {string} input args -- {byte[][]} decorations -- {map of string to byte[]} timeout -- {int} Type: Object ChaincodeInvokeRequest This object contains many properties that will be used by the Discovery service. Type: Object Properties: Name Type Argument Description targets Array.&lt;Peer&gt; | Array.&lt;string&gt; &lt;optional&gt; Optional. The peers that will receive this request, when not provided the list of peers added to this channel object will be used. When this channel has been initialized to use the discovery service, the proposal will be sent to the peers on the list provided by the discovery service if no targets are specified. chaincodeId string Required. The id of the chaincode to process the transaction proposal endorsement_hint DiscoveryChaincodeInterest &lt;optional&gt; Optional. A of DiscoveryChaincodeInterest object that will be used by discovery service to calculate an appropriate endorsement plan. The parameter is only required when the endorsement will be preformed by a chaincode that will call other chaincodes or if the endorsement should be made by only peers within a collection or collections. txId TransactionID &lt;optional&gt; Optional. TransactionID object with the transaction id and nonce. txId is required for sendTransactionProposal and optional for generateUnsignedProposal transientMap object &lt;optional&gt; Optional. Object with String property names and Buffer property values that can be used by the chaincode but not saved in the ledger. Data such as cryptographic information for encryption can be passed to the chaincode using this technique. Data that is to be kept in a private data store (a collection) should be passed to the chaincode in the transientMap. fcn string &lt;optional&gt; Optional. The function name to be returned when calling stub.GetFunctionAndParameters() in the target chaincode. Default is 'invoke' args Array.&lt;string&gt; An array of string arguments specific to the chaincode's 'Invoke' method is_init boolean &lt;optional&gt; Optional. Boolean to indicate that this invoke is to call the 'Init' function on the chaincode rather than the 'Invoke'. TODO more text here required Array.&lt;string&gt; &lt;optional&gt; Optional. An array of strings that represent the names of peers that are required for the endorsement. These will be the only peers which the proposal will be sent. This list only applies to endorsements using the discovery service. This property is used by the DiscoveryEndorsementHandler. ignore Array.&lt;string&gt; &lt;optional&gt; Optional. An array of strings that represent the names of peers that should be ignored by the endorsement. This list only applies to endorsements using the discovery service. This property is used by the DiscoveryEndorsementHandler. preferred Array.&lt;string&gt; &lt;optional&gt; Optional. An array of strings that represent the names of peers that should be given priority by the endorsement. Priority means that these peers will be chosen first for endorsements when an endorsement plan has more peers in a group then needed to satisfy the endorsement policy. This list only applies to endorsements using the discovery service. This property is used by the DiscoveryEndorsementHandler. requiredOrgs Array.&lt;string&gt; &lt;optional&gt; Optional. An array of strings that represent the names of an organization's MSP id that are required for the endorsement. Only peers in these organizations will be sent the proposal. This list only applies to endorsements using the discovery service. This property is used by the DiscoveryEndorsementHandler. ignoreOrgs Array.&lt;string&gt; &lt;optional&gt; Optional. An array of strings that represent the names of an organization's MSP id that should be ignored by the endorsement. This list only applies to endorsements using the discovery service. This property is used by the DiscoveryEndorsementHandler. preferredOrgs Array.&lt;string&gt; &lt;optional&gt; Optional. An array of strings that represent the names of an organization's MSP id that should be given priority by the endorsement. Peers within an organization may have their ledger height considered using the optional property preferredHeightGap before being added to the priority list. This list only applies to endorsements using the discovery service. This property is used by the DiscoveryEndorsementHandler. preferredHeightGap Number &lt;optional&gt; Optional. An integer representing the maximum difference in the block height of a peer and the highest block height found in a group of peers within an endorsement plan allowed to be a preferred peer. A peer will not be given priority if it's block height is less than the highest block height by an amount greater than this value. There is no default, if this value is not provided the block height of the peer will not be considered when being added to the preferred list. This list only applies to endorsements using the discovery service. This property is used by the DiscoveryEndorsementHandler. sort string &lt;optional&gt; Optional. A string value that indicates how the peers within groups should be chosen. \"ledgerHeight\", sort the peers descending by the number of blocks on the channel ledger. \"random\", pull the peers randomly from the list, the preferred will be pulled first. The default will be to sort by ledger height. ChaincodePackageRequest Type: Object Properties: Name Type Argument Description label string &lt;optional&gt; Optional. This string will identify this package. This will be used to associate the package_id returned by the Peer when this package is installed. The package_id will uniquely identity the package on the Peer, however it may be difficult to associate with this package. Since the label is supplied by the user, the label will be easier to association with the chaincode package. The name and version will be combined with a colon (name:version) to be the label if not supplied. chaincodeType string Required. Type of chaincode. One of 'golang', 'car', 'node' or 'java'. chaincodePath string Required. The path to the location of the source code of the chaincode. If the chaincode type is golang, then this path is the fully qualified package name, such as 'mycompany.com/myproject/mypackage/mychaincode' metadataPath string Optional. The path to the top-level directory containing metadata descriptors. goPath string &lt;optional&gt; Optional. The path to be used with the golang chaincode. Will default to the environment \"GOPATH\" value. Will be used to locate the actual Chaincode 'goLang' files by building a fully qualified path = &lt; goPath &gt; / 'src' / &lt; chaincodePath &gt; ChaincodeQueryRequest Type: Object Properties: Name Type Argument Description targets Array.&lt;Peer&gt; &lt;optional&gt; Optional. The peers that will receive this request, when not provided the list of peers added to this channel object will be used. chaincodeId string Required. The id of the chaincode to process the transaction proposal transientMap object &lt;optional&gt; Optional. Object with String property names and Buffer property values that can be used by the chaincode but not saved in the ledger. Data such as cryptographic information for encryption can be passed to the chaincode using this technique. Data that is to be kept in a private data store (a collection) should be passed to the chaincode in the transientMap. fcn string &lt;optional&gt; Optional. The function name to be returned when calling stub.GetFunctionAndParameters() in the target chaincode. Default is 'invoke' args Array.&lt;string&gt; An array of string arguments specific to the chaincode's 'Invoke' method request_timeout integer &lt;optional&gt; Optional. The timeout value to use for this request txId TransactionID &lt;optional&gt; Optional. Transaction ID to use for the query. ChaincodeQueryResponse Type: Object Properties: Name Type Description chaincodes Array.&lt;ChaincodeInfo&gt; ChaincodeRequest This object contains the properties needed when approving a chaincode on the channel for an organization Type: Object Properties: Name Type Argument Description targets Array.&lt;Peer&gt; | Array.&lt;string&gt; &lt;optional&gt; Optional. The peers that will receive the define request. When not provided, peers that have been added to the channel with the 'endorser' role. chaincode object Required. The chaincode object containing all the chaincode information required by the approve chaincode fabric network action. see Chaincode txId Object Required. The transaction object that has the ID and nonce to use for this request. request_timeout integer &lt;optional&gt; Optional. The timeout value to use for this request ChannelConfigGroup The configuration settings that govern how the fabric should maintain a channel are included in the blocks of the channel itself. When a block contains the channel configuration, the channel configuration record is the only item in the block's data array. Every block, including the configuration blocks themselves, has a pointer to the latest configuration block, making it easy to query for the latest channel configuration settings. A channel configuration record will have the following object structure. version -- {int} mod_policy -- {string} groups Orderer version -- {int} groups &lt;orderer_org_name&gt; -- {OrganizationConfigGroup} values ConsensusType version -- {int} mod_policy -- {string} value type -- {string} BatchSize version -- {int} mod_policy -- {string} value max_message_count -- {int} absolute_max_bytes -- {int} preferred_max_bytes -- {int} BatchTimeout version -- {int} mod_policy -- {string} value timeout -- {duration} ChannelRestrictions version -- {int} mod_policy -- {string} value max_count -- {int} policies Admins version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} Writers version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} Readers version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} BlockValidation version -- {int} mod_policy -- {string} policy -- {SignaturePolicy} Application version -- {int} groups &lt;peer_org_name&gt; -- {OrganizationConfigGroup} values policies Admins version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} Writers version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} Readers version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} values OrdererAddresses version -- {int} mod_policy -- {string} value addresses -- {array} {string - host:port} HashingAlgorithm version -- {int} mod_policy -- {string} value name -- {string} BlockDataHashingStructure version -- {int} mod_policy -- {string} value width -- {int} Consortium version -- {int} mod_policy -- {string} value name -- {string} Type: Object Properties: Name Type Description groups.Orderer.groups.&lt;orderer_org_name&gt; OrganizationConfigGroup These are the orderer organizatoin names defined on the network groups.Application.groups.&lt;peer_org_name&gt; OrganizationConfigGroup These are the peer organization names defined on the network policy ImplicitMetaPolicy These policies point to other policies and specify a threshold as in \"ANY\", \"MAJORITY\" or \"ALL\" ChannelInfo Type: Object Properties: Name Type Description channel_id string ChannelPeerRoles Type: Object Properties: Name Type Argument Description endorsingPeer boolean &lt;optional&gt; Optional. This peer may be sent transaction proposals for endorsements. The peer must have the chaincode installed. The app can also use this property to decide which peers to send the chaincode install request. Default: true chaincodeQuery boolean &lt;optional&gt; Optional. This peer may be sent transaction proposals meant only as a query. The peer must have the chaincode installed. The app can also use this property to decide which peers to send the chaincode install request. Default: true ledgerQuery boolean &lt;optional&gt; Optional. This peer may be sent query proposals that do not require chaincodes, like queryBlock(), queryTransaction(), etc. Default: true eventSource boolean &lt;optional&gt; Optional. This peer may be the target of a event listener registration? All peers can produce events, but the application typically only needs to connect to one. Default: true discover boolean &lt;optional&gt; Optional. This peer may be the target of service discovery. Default: true ChannelQueryResponse Type: Object Properties: Name Type Description channels Array.&lt;ChannelInfo&gt; ChannelRequest Type: Object Properties: Name Type Description name string Required. The name of the new channel orderer Orderer | string Required. An Orderer object or an orderer name representing the orderer node to send the channel create request envelope Array.&lt;byte&gt; Optional. Bytes of the envelope object containing all required settings and signatures to initialize this channel. This envelope would have been created by the command line tool configtxgen or configtxlator config Array.&lt;byte&gt; Optional. Protobuf ConfigUpdate object extracted from a ConfigEnvelope created by the configtxgen tool. See extractChannelConfig(). The ConfigUpdate object may also be created by the configtxlator tool. signatures Array.&lt;ConfigSignature&gt; | Array.&lt;string&gt; Required. The list of signatures required by the channel creation or update policy when using the `config` parameter. txId TransactionID Required. TransactionID object with the transaction id and nonce collectionConfig Type: Object Properties: Name Type Description name string policy maxPeerCount number integer requiredPeerCount number integer blockToLive Long | number | string | Object param will be converted to unsigned int64 as Long memberOnlyRead boolean denotes whether only collection member clients can read the private data memberOnlyWrite boolean denotes whether only collection member clients can write the private data CollectionQueryOptions Type: Object Properties: Name Type Argument Description chaincodeId string &lt;optional&gt; Required. Name of the chaincode target string | Peer &lt;optional&gt; Optional. The peer that will receive this request, when not provided the first peer in this channel object will be used. CollectionQueryResponse Type: Object Properties: Name Type Description type string The collection type name string the name of the collection inside the denoted chaincode required_peer_count number The minimum number of peers private data will be sent to upon endorsement. The endorsement would fail if dissemination to at least this number of peers is not achieved. maximum_peer_count number The maximum number of peers that private data will be sent to upon endorsement. This number has to be bigger than required_peer_count. block_to_live number The number of blocks after which the collection data expires. For instance if the value is set to 10, a key last modified by block number 100 will be purged at block number 111. A zero value is treated same as MaxUint64, where the data will not be purged. member_read_only boolean The member only read access denotes whether only collection member clients can read the private data (if set to true), or even non members can read the data (if set to false, for example if you want to implement more granular access logic in the chaincode) member_write_only boolean The member only write access denotes whether only collection member clients can write the private data (if set to true), or even non members can write the data (if set to false, for example if you want to implement more granular access logic in the chaincode) policy Policy The \"member_orgs_policy\" policy CommitHandlerParameters Type: Object Properties: Name Type Description request Object TransactionRequest signed_envelope Object An object that will be sent to the orderer that contains the encoded endorsed proposals and the signature of the sender. timeout Number the timeout setting passed on sendTransaction method. ConfigEnvelope A ConfigEnvelope contains the channel configurations data and is the main content of a configuration block. Another type of blocks are those that contain endorser transactions, where the main content is an array of Transaction. A \"ConfigEnvelope\" will have the following object structure. config sequence -- {int} channel_group -- {ConfigGroup} type -- {int} last_update signature -- {byte[]} payload header -- {Header} data -- {ConfigUpdateEnvelope} Type: Object ConfigSignature Type: Object Properties: Name Type Description signature_header Array.&lt;byte&gt; Encoded bytes of a SignatureHeader signature Array.&lt;byte&gt; Encoded bytes of the signature over the concatenation of the signatureHeader bytes and config bytes ConfigUpdateEnvelope An object of a protobuf message \"ConfigUpdateEnvelope\". A \"ConfigUpdateEnvelope\" will have the following object structure. config_update channel_id -- {string} read_set -- {ChannelConfigGroup} write_set -- {ChannelConfigGroup} type -- {int} signatures -- {array} signature_header -- {SignatureHeader} signature -- {byte[]} Type: Object Properties: Name Type Description config_update.read_set ChannelConfigGroup A set of the current version numbers of all configuration items being updated config_update.write_set ChannelConfigGroup A set of all configuration items being updated. Must have a version number one greater than the version number of the same item in the read_set along with the new value. ConnectionOpts Type: Object Properties: Name Type Description name string Optional. To gives this remote endpoint a name. The endpoint will be known by its URL if no name is provided. request-timeout number An integer value in milliseconds to be used as maximum amount of time to wait on the request to respond. pem string The certificate file, in PEM format, to use with the gRPC protocol (that is, with TransportCredentials). Required when using the grpcs protocol. ssl-target-name-override string Used in test environment only, when the server certificate's hostname (in the 'CN' field) does not match the actual host endpoint that the server process runs at, the application can work around the client TLS verify failure by setting this property to the value of the server certificate's hostname &lt;any&gt; any any other standard grpc call options will be passed to the grpc service calls directly ConnectOptions Type: Object Properties: Name Type Argument Description full_block boolean &lt;optional&gt; Optional. To indicate that the connection with the peer will be sending full blocks or filtered blocks to this ChannelEventHub. The default will be to establish a connection using filtered blocks. Filtered blocks have the required information to provided transaction status and chaincode events (no payload). When using the non filtered blocks (full blocks) the user will be required to have access to establish the connection to receive full blocks. Registering a block listener on a filtered block connection may not provide sufficient information. private_data boolean &lt;optional&gt; Optional. To indicate that the connection with the peer will be sending full blocks with private data. The default will be to establish a connection without retrieving private data. Blocks with private data have an extra field called 'private_data' which contains a map of the key-values writes of the private data collections the peer can access. The private_data option can only be set to true if the option full_block is set to true, otherwise it will throw an error. startBlock Number | string &lt;optional&gt; Optional. This will have the connection setup to start sending blocks back to the event hub at the block with this number. If connecting with a a startBlock then event listeners may not be registered with a startBlock or endBlock. If the event hub should start with the last block it has seen use the string 'last_seen'. If the event hub should start with the oldest block on the ledger use the string 'oldest'. If the event hub should start with the latest block on the ledger, use the string 'latest' or do use a startBlock. Default is to start with the latest block on the ledger. endBlock Number | string &lt;optional&gt; Optional. This will have the connection setup to end sending blocks back to the event hub at the block with this number. If connecting with a a endBlock then event listeners may not be registered with a startBlock or endBlock. If the event hub should end with the last block it has seen use the string 'last_seen'. If the event hub should end with the current block on the ledger use the string 'newest'. Default is to not stop sending. signedEvent SignedEvent &lt;optional&gt; Optional. The signed event to be sent to the peer. This option is useful when the fabric-client application does not have the user's privateKey and can not sign requests to the fabric network. target Peer | string &lt;optional&gt; Optional. The peer that provides the fabric event service. When using a string, the Channel must have a peer assigned with that name. This peer will replace the current peer endpoint of this channel event hub. CryptoContent Type: Object Properties: Name Type Description privateKey string the PEM file path for the private key privateKeyPEM string the PEM string for the private key (not required if privateKey or privateKeyObj is set) privateKeyObj module:api.Key private key object (not required if privateKey or privateKeyPEM is set) signedCert string the PEM file path for the certificate signedCertPEM string the PEM string for the certificate (not required if signedCert is set) Deprecated_ChaincodeInstallRequest Type: Object Properties: Name Type Description targets Array.&lt;Peer&gt; | Array.&lt;string&gt; Optional. An array of Peer objects or peer names where the chaincode will be installed. When excluded, the peers assigned to this client's organization will be used as defined in the common connection profile. If the 'channelNames' property is included, the target peers will be based the peers defined in the channels. chaincodePath string Required. The path to the location of the source code of the chaincode. If the chaincode type is golang, then this path is the fully qualified package name, such as 'mycompany.com/myproject/mypackage/mychaincode' metadataPath string Optional. The path to the top-level directory containing metadata descriptors. chaincodeId string Required. Name of the chaincode goPath string Optional. The path to be used with the golang chaincode. chaincodeVersion string Required. Version string of the chaincode, such as 'v1' chaincodePackage Array.&lt;byte&gt; Optional. Byte array of the archive content for the chaincode source. The archive must have a 'src' folder containing subfolders corresponding to the 'chaincodePath' field. For instance, if the chaincodePath is 'mycompany.com/myproject/mypackage/mychaincode', then the archive must contain a folder 'src/mycompany.com/myproject/mypackage/mychaincode', where the chaincode source code resides. chaincodeType string Optional. Type of chaincode. One of 'golang', 'car', 'node' or 'java'. Default is 'golang'. channelNames Array.&lt;string&gt; | string Optional. When no targets are provided. The loaded common connection profile will be searched for suitable target peers. Peers that are defined in the channels named by this property and in this client's organization and that are in the endorsing or chain code query role on the named channel will be selected. txId TransactionID Optional. TransactionID object for this request. DiscoveryChaincodeCall Type: Object Properties: Name Type Description name string The name of the chaincode collection_names Array.&lt;string&gt; The names of the related collections Examples \"single chaincode\" { name: \"mychaincode\"} \"chaincode to chaincode\" [ { name: \"mychaincode\"}, { name: \"myotherchaincode\"} ] \"single chaincode with a collection\" { name: \"mychaincode\", collection_names: [\"mycollection\"] } \"chaincode to chaincode with a collection\" [ { name: \"mychaincode\", collection_names: [\"mycollection\"] }, { name: \"myotherchaincode\", collection_names: [\"mycollection\"] }} ] \"chaincode to chaincode with collections\" [ { name: \"mychaincode\", collection_names: [\"mycollection\", \"myothercollection\"] }, { name: \"myotherchaincode\", collection_names: [\"mycollection\", \"myothercollection\"] }} ] DiscoveryChaincodeInterest Type: Object Properties: Name Type Description chaincodes Array.&lt;DiscoveryChaincodeCall&gt; The chaincodes names and collections that will be sent to the discovery service to calculate an endorsement plan. DiscoveryChaincodeQuery Requests DiscoveryResults for a given list invocations. Each interest is a separate invocation of one or more chaincodes, which may include invocation on collections. The endorsement policy is evaluated independantly for each given interest. Type: Object Properties: Name Type Description interests Array.&lt;DiscoveryChaincodeInterest&gt; defines interests in an invocations of chaincodes Examples \"chaincode and no collection\" { interests: [ { chaincodes: [{ name: \"mychaincode\"}]} ] } \"chaincode with collection\" { interests: [ { chaincodes: [{ name: \"mychaincode\", collection_names: [\"mycollection\"] }]} ] } \"chaincode to chaincode with collection\" { interests: [ { chaincodes: [ { name: \"mychaincode\", collection_names: [\"mycollection\"] }}, { name: \"myotherchaincode\", collection_names: [\"mycollection\"] }} ] } ] } \"query for multiple invocations\" { interests: [ { chaincodes: [ { name: \"mychaincode\", collection_names: [\"mycollection\"] }}, { name: \"myotherchaincode\", collection_names: [\"mycollection\"] }} ] }, { chaincodes: [{ name: \"mychaincode\", collection_names: [\"mycollection\"] }]}, { chaincodes: [{ name: \"mychaincode\"}]} ] } DiscoveryResultChaincode Type: Object Properties: Name Type Description name string version string DiscoveryResultEndorsementGroup Type: Object Properties: Name Type Description peers Array.&lt;DiscoveryResultPeer&gt; the peers in this group DiscoveryResultEndorsementLayout lists the group names, and the amount of signatures needed from each group. Type: Object.&lt;string, number&gt; DiscoveryResultEndorsementPlan Type: Object Properties: Name Type Description chaincode string The chaincode name that is the first chaincode in the interest that was used to calculate this plan. plan_id string The string of the JSON object that represents the hint that was used to build the query for this result. The hint is a DiscoveryChaincodeInterest that contains chaincode names and collections that the discovery service uses to calculate the returned plan. groups Object.&lt;string, DiscoveryResultEndorsementGroup&gt; Specifies the endorsers, separated to groups. layouts Array.&lt;DiscoveryResultEndorsementLayout&gt; Specifies options of fulfulling the endorsement policy DiscoveryResultEndpoint Type: Object Properties: Name Type Argument Description host string port number name string &lt;optional&gt; Optional. the name of this endpoint DiscoveryResultEndpoints Type: Object Properties: Name Type Description endpoints Array.&lt;DiscoveryResultEndpoint&gt; DiscoveryResultMSPConfig Type: Object Properties: Name Type Description rootCerts string List of root certificates trusted by this MSP. They are used upon certificate validation. intermediateCerts string List of intermediate certificates trusted by this MSP. They are used upon certificate validation as follows: Validation attempts to build a path from the certificate to be validated (which is at one end of the path) and one of the certs in the RootCerts field (which is at the other end of the path). If the path is longer than 2, certificates in the middle are searched within the IntermediateCerts pool. admins string Identity denoting the administrator of this MSP id string the identifier of the MSP orgs Array.&lt;string&gt; fabric organizational unit identifiers that belong to this MSP configuration tls_root_certs string TLS root certificates trusted by this MSP tls_intermediate_certs string TLS intermediate certificates trusted by this MSP DiscoveryResultPeer Type: Object Properties: Name Type Description mspid string endpoint string host:port for this peer ledger_height Long name string chaincodes Array.&lt;DiscoveryResultChaincode&gt; DiscoveryResultPeers Type: Object Properties: Name Type Description peers Array.&lt;DiscoveryResultPeer&gt; DiscoveryResults Type: Object Properties: Name Type Argument Description msps Object.&lt;string, DiscoveryResultMSPConfig&gt; &lt;optional&gt; Optional. The msp config found. orderers Object.&lt;string, DiscoveryResultEndpoints&gt; &lt;optional&gt; Optional. The orderers found. peers_by_org Object.&lt;string, DiscoveryResultPeers&gt; &lt;optional&gt; Optional. The peers by org found. endorsement_plans Array.&lt;DiscoveryResultEndorsementPlan&gt; &lt;optional&gt; Optional. timestamp number The timestamp at which the discovery results are updated. Endorsement An endorsement is a signature of an endorser over a proposal response. By producing an endorsement message, an endorser implicitly \"approves\" that proposal response and the actions contained therein. When enough endorsements have been collected, a transaction can be generated out of a set of proposal responses An endorsement message has the following structure: endorser Mspid -- {string] IdBytes -- {byte[]} signature -- {byte[]} Type: Object EndorsementHandlerParameters Type: Object Properties: Name Type Description request Object ChaincodeInvokeRequest signed_proposal Object the encoded protobuf \"SignedProposal\" created by the sendTransactionProposal method before calling the handler. Will be the object to be endorsed by the target peers. timeout Number the timeout setting passed on sendTransactionProposal method. Enrollment Type: Object Properties: Name Type Description key Object the private key certificate string The enrollment certificate in base 64 encoded PEM format rootCertificate string Base 64 encoded PEM-encoded certificate chain of the CA's signing certificate EnrollmentRequest Type: Object Properties: Name Type Description enrollmentID string The registered ID to use for enrollment enrollmentSecret string The secret associated with the enrollment ID profile string The profile name. Specify the 'tls' profile for a TLS certificate; otherwise, an enrollment certificate is issued. csr string Optional. PEM-encoded PKCS#10 Certificate Signing Request. The message sent from client side to Fabric-ca for the digital identity certificate. attr_reqs Array.&lt;AttributeRequest&gt; An array of AttributeRequest EnrollmentResponse Type: Object Properties: Name Type Description enrollmentCert string PEM-encoded X509 enrollment certificate caCertChain string PEM-encoded X509 certificate chain for the issuing certificate authority EventCount Type: Object Properties: Name Type Description success Number Number of successful events received. fail Number Number of errors received. expected Number Number of event services for which response events (or errors) are expected. EventHubRegistrationRequest Type: Object Properties: Name Type Description identity Identity the identity who is doing this registration txId TransactionID a transaction id for this registration certificate string The certificate file, in PEM format mspId string The member service provider Id used to process the identity GetInstalledChaincodePackageRequest Type: Object Properties: Name Type Argument Description target Peer | string Required. The peer that will receive this request package_id string Required. Package Id of the chaincode request_timeout integer &lt;optional&gt; Optional. The timeout value to use for this request txId TransactionID &lt;optional&gt; Optional. Transaction ID to use for the query. Required when using the admin idendity. GetInstalledChaincodePackageResult Type: Object Properties: Name Type Description chaincode_install_package Array.&lt;byte&gt; The package bytes Header Headers describe basic information about a transaction record, such as its type (configuration update, or endorser transaction, etc.), the id of the channel it belongs to, the transaction id and so on. The header message also contains a common field SignatureHeader that describes critical information about how to verify signatures. A \"Header\" will have the following object structure. channel_header type -- {string} version -- {int} timestamp -- {time} channel_id -- {string} tx_id -- {string} epoch -- {int} signature_header -- {SignatureHeader} Type: Object HTTPEndpoint Type: Object Properties: Name Type Description hostname string port number protocol string Identity Type: Object Properties: Name Type Description role Role Any identity of a particular role OrganizationUnit Any identities belonging to an organization unit per certificate chain of trust Identity A specific identity IdentityRequest Type: Object Properties: Name Type Description enrollmentID string Required. The enrollment ID which uniquely identifies an identity affiliation string Required. The affiliation path of the new identity attrs Array.&lt;KeyValueAttribute&gt; Array of KeyValueAttribute attributes to assign to the user type string Optional. The type of the identity (e.g. *user*, *app*, *peer*, *orderer*, etc) enrollmentSecret string Optional. The enrollment secret. If not provided, a random secret is generated. maxEnrollments number Optional. The maximum number of times that the secret can be used to enroll. If 0, use the configured max_enrollments of the fabric-ca-server; If &gt; 0 and configured max enrollments of the fabric-ca-server, error. caname string Optional. Name of the CA to send the request to within the Fabric CA server ImplicitMetaPolicy ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration It is implicit because the rule is generate implicitly based on the number of sub policies It is meta because it depends only on the result of other policies When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy of name sub_policy, evaluates the collection and applies the rule. For example, with 4 sub-groups, and a policy name of \"Readers\", ImplicitMetaPolicy retrieves each sub-group, retrieves policy \"Readers\" for each subgroup, evaluates it, and, in the case of ANY 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures. An \"ImplicitMetaPolicy\" will have the following object structure. type -- IMPLICIT_META policy sub_policy -- {string} rule -- ANY | ALL | MAJORITY Type: Object InitializeRequest Type: Object Properties: Name Type Argument Description target string | Peer | ChannelPeer &lt;optional&gt; Optional. The target peer to be used to make the initialization requests for configuration information. When used with `targets` parameter, the peer referenced here will be added to the `targets` array. Default is to use the first ChannelPeer assigned to this channel. targets Array.&lt;string&gt; | Array.&lt;Peer&gt; | Array.&lt;ChannelPeer&gt; &lt;optional&gt; Optional. The target peers to be used to make the initialization requests for configuration information. When used with `target` parameter, the peer referenced there will be added to the `targets` array. Default is to use the first ChannelPeer assigned to this channel. discover boolean &lt;optional&gt; Optional. Use the discovery service on the the target peer to load the configuration and network information. Default is false. When false, the target peer will use the Peer query to load only the configuration information. endorsementHandler string &lt;optional&gt; Optional. The path to a custom endorsement handler implementing EndorsementHandler. commitHandler string &lt;optional&gt; Optional. The path to a custom commit handler implementing CommitHandler. asLocalhost boolean &lt;optional&gt; Optional. Convert discovered host addresses to be 'localhost'. Will be needed when running a docker composed fabric network on the local system; otherwise should be disabled. Defaults to true. configUpdate Array.&lt;byte&gt; &lt;optional&gt; Optional. To initialize this channel with a serialized ConfigUpdate protobuf object. JoinChannelRequest Type: Object Properties: Name Type Argument Description targets Array.&lt;Peer&gt; | Array.&lt;string&gt; &lt;optional&gt; Optional. An array of Peer objects or Peer names that will be asked to join this channel. When using Peer names or left empty (use default targets) there must be a loaded network configuration. See loadFromConfig() block Array.&lt;byte&gt; The encoded bytes of the channel's genesis block. See getGenesisBlock() method txId TransactionID Required. TransactionID object with the transaction id and nonce KeyValueAttribute Type: Object Properties: Name Type Description name string The key used to reference the attribute value string The value of the attribute ecert boolean Optional, A value of true indicates that this attribute should be included in an enrollment certificate by default MetadataSignature A signature over the metadata of a block, to ensure the authenticity of the metadata that describes a Block. signature_header {SignatureHeader} signature -- {byte[]} Type: Object OrdererRequest Type: Object Properties: Name Type Argument Description txId TransactionID &lt;optional&gt; Optional. Object with the transaction id and nonce orderer Orderer &lt;optional&gt; Optional. The orderer instance or string name of the orderer to retrieve genesis block from OrganizationConfigGroup Each participating organization of the channel gets represented in a section in the configuration block as described below. Critical information about the organzation such as its Membership Service Provider (MSP) content and its pre-defined policies that form the basis of the channel's access control policies (Admins, Writers and Readers) are contained in these sections. A organizational configuration will have the following object structure. version -- {int} mod_policy -- {string} values MSP version -- {int} mod_policy -- {string} value type -- {int} config name -- {string} root_certs -- {string[]} intermediate_certs -- {string[]} admins -- {string[]} revocation_list -- {string[]} signing_identity -- {byte[]} organizational_unit_identifiers -- {string[]} policies Admins version -- {int} mod_policy -- {string} policy -- {SignaturePolicy} Writers version -- {int} mod_policy -- {string} policy -- {SignaturePolicy} Readers version -- {int} mod_policy -- {string} policy -- {SignaturePolicy} Type: Object OrganizationIdentifier Type: Object Properties: Name Type Description id string The organization's MSP id PeerQueryRequest Type: Object Properties: Name Type Description target Peer | string The Peer object or peer name to use for the service discovery request useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. An administrative identity must have been loaded by a connection profile or by using the 'setAdminSigningIdentity' method. PeerQueryResponse Type: Object Properties: Name Type Description peers_by_org Object Example { \"peers_by_org\": { \"Org1MSP\": { \"peers\":[ {\"mspid\":\"Org1MSP\", \"endpoint\":\"peer0.org1.example.com:7051\"} ] }, \"Org2MSP\": { \"peers\":[ {\"mspid\":\"Org2MSP\",\"endpoint\":\"peer0.org2.example.com:8051\"} ] } } } Policy Defines the endorsement policies Type: Object Properties: Name Type Description identities Array.&lt;Identity&gt; List of identities to be referenced in the \"policy\" section policy Array.&lt;PolicySpec&gt; The specification of the policy using a combination of \"signed-by\" and \"n-of\" structures. The design allows recursion PolicySpec Type: Object Properties: Name Type Description type Object The type of policy can be \"signed-by\" for a single identity signature or \"n-of\" where \"n\" is a numeric value. If the type property is \"signed-by\", the value is the numeric index into the array of identities specified in the policy. If the type property is \"n-of\", the value is an array of PolicySpec objects. As you can see, this structure allows recursive definitions of complex policies. ProcessedTransaction Type: Object Properties: Name Type Description validationCode number See this list for all the defined validation codes transactionEnvelope Object Encapsulates the transaction and the signature over it. It has the following structure: signature -- {byte[]} payload -- {} header -- {Header} data -- {Transaction} ProposalRequest Type: Object Properties: Name Type Argument Description fcn string Required. The function name. args Array.&lt;string&gt; Required. Arguments to send to chaincode. chaincodeId string Required. ChaincodeId. argbytes Buffer &lt;optional&gt; Optional. Include when an argument must be included as bytes. transientMap object &lt;optional&gt; Optional. Object with String property names and Buffer property values that can be used by the chaincode but not saved in the ledger. Data such as cryptographic information for encryption can be passed to the chaincode using this technique. Data that is to be kept in a private data store (a collection) should be passed to the chaincode in the transientMap. ProposalResponse A protobuf message that gets returned by endorsing peers on proposal requests. The peer node runs the target chaincode, as designated by the proposal, and decides on whether to endorse the proposal or not, and sends back the endorsement result along with the read and write sets inside the proposal response message. Type: Object Properties: Name Type Description version number timestamp Timestamp Time the proposal was created by the submitter response Response payload Array.&lt;byte&gt; The payload of the response. It is the encoded bytes of the \"ProposalResponsePayload\" protobuf message endorsement Endorsement The endorsement of the proposal, basically the endorser's signature over the payload peer RemoteCharacteristics The characteristics of the peer that created this ProposalResponse. Items include the url, name, and connection options. This information is not returned from the peer, it is not part of the serialized protobuf data returned by the peer. This information is added by the client instance peer object to help identify this ProposalResponse object. ProposalResponseObject All calls to the endorsing peers for proposal endorsement return this standard array of objects. Type: array Properties: Name Type Description index:0 Array.&lt;(ProposalResponse|Error)&gt; Array where each element is either a ProposalResponse object (for a successful response from the endorsing peer) or an Error object (for an unsuccessful peer response or runtime error). index:1 Object The original Proposal object needed when sending the transaction request to the orderer QueryApprovalStatusRequest Type: Object Properties: Name Type Argument Description target Peer | string Required. The peer that will receive this request chaincode object Required. The chaincode object containing all the chaincode information required by the approve chaincode fabric network action. see Chaincode txId Object Required. The transaction object that has the ID and nonce to use for this request. request_timeout integer &lt;optional&gt; Optional. The timeout value to use for this request QueryChaincodeDefinitionRequest Type: Object Properties: Name Type Argument Description target Peer | string Required. The peer that will receive this request chaincodeId string Required. Name of the chaincode request_timeout integer &lt;optional&gt; Optional. The timeout value to use for this request txId TransactionID &lt;optional&gt; Optional. Transaction ID to use for the query. Required when using the admin idendity. QueryChaincodeDefinitionsRequest Type: Object Properties: Name Type Argument Description target Peer | string Required. The peer that will receive this request request_timeout integer &lt;optional&gt; Optional. The timeout value to use for this request txId TransactionID &lt;optional&gt; Optional. Transaction ID to use for the query. Required when using the admin idendity. QueryInstalledChaincodeRequest Type: Object Properties: Name Type Argument Description target Peer | string Required. The peer that will receive this request package_id string Required. Package Id of the chaincode request_timeout integer &lt;optional&gt; Optional. The timeout value to use for this request txId TransactionID &lt;optional&gt; Optional. Transaction ID to use for the query. Required when using the admin idendity. QueryInstalledChaincodeResult Type: Object Properties: Name Type Description package_id string The package ID of the installed chaincode label string The label as provided by the client application QueryInstalledChaincodesRequest Type: Object Properties: Name Type Argument Description target Peer | string Required. The peer that will receive this request request_timeout integer &lt;optional&gt; Optional. The timeout value to use for this request txId TransactionID &lt;optional&gt; Optional. Transaction ID to use for the query. Required when using the admin idendity. RegisterRequest Type: Object Properties: Name Type Description enrollmentID string ID which will be used for enrollment enrollmentSecret string Optional enrollment secret to set for the registered user. If not provided, the server will generate one. role string Optional arbitrary string representing a role value for the user affiliation string Affiliation with which this user will be associated, like a company or an organization maxEnrollments number The maximum number of times this user will be permitted to enroll attrs Array.&lt;KeyValueAttribute&gt; Array of KeyValueAttribute attributes to assign to the user RegistrationOpts Type: Object Properties: Name Type Description startBlock integer Optional - The starting block number for event checking. When included, the peer's fabric service will be asked to start sending blocks from this block number. This is how to resume or replay missed blocks that were added to the ledger. Default is the latest block on the ledger. Setting a startBlock may confuse other event listeners, therefore only one listener will be allowed on a ChannelEventHub when a startBlock is being used. Setting a startBlock also requires this ChannelEventHub to connect to the fabric service using different options. The registration with a startBlock must be done before calling connect(). endBlock integer | 'newest' Optional - The ending block number for event checking. The value 'newest' indicates that the endBlock will be calculated by the peer as the newest block on the ledger at the time of registration. This allows the application to replay up to the latest block on the ledger and then the listener will stop and be notified by the 'onError' callback. When included, the peer's fabric service will be asked to stop sending blocks once this block is delivered. This is how to replay missed blocks that were added to the ledger. When a startBlock is not included, the endBlock must be equal to or larger the current channel block height. Setting an endBlock may confuse other event listeners, therefore only one listener will be allowed on a ChannelEventHub when an endBlock is being used. Setting a endBlock also requires this ChannelEventHub to connect to the fabric service using different options. The a registration with an endBlock must be done before calling connect(). unregister boolean Optional - This options setting indicates the registration should be removed (unregister) when the event is seen. When the application is using a timeout to only wait a specified amount of time for the transaction to be seen, the timeout processing should included the manual 'unregister' of the transaction event listener to avoid the event callbacks being called unexpectedly. The default for this setting is different for the different type of event listeners. For block listeners the default is true, however the event listener is assumed to have seen the final event only if the end_block was set as a option and that end_block was seen by the the listener. For transaction listeners the default is true and the listener will be unregistered when a transaction with the id is seen by this listener. For chaincode listeners the default will be false as the match filter might be intended for many transactions rather than a specific transaction or block as in the other listeners. If not set and the endBlock has been set, the listener will be automatically unregistered. disconnect boolean Optional - This option setting Indicates to the ChannelEventHub instance to automatically disconnect itself from the peer's fabric service once the event has been seen. The default is false. If not set and the endBlock has been set, the the ChannelEventHub instance will automatically disconnect itself. RemoteCharacteristics Information related to the peer instance object. Type: Object Properties: Name Type Description url string The url of this peer name string The name of this peer, this will be the host and port if the peer was not created with the name option. options Object The options object that this peer built based on defaults and what was passed when it was created. Typical options will include the GRPC connection settings. REQUEST_TIMEOUT The Error message string that indicates that the request operation has timed out due to a remote node issue. If there is an issue with the local system a 'SYSTEM_TIMEOUT' error message will be returned. The operation will only use one timer for both types of timeouts. The timer will start running as the operation begins. If the timer expires before the local instance is able to make the outbound request then 'SYSTEM_TIMEOUT' error will be returned. If the local instance is able to make the outbound request and the timer expires before the remote node responds then the 'REQUEST_TIMEOUT' is returned. The timer is controlled by the 'request-timeout' setting or passed on a call that makes an outbound request Type: Error Examples 'client.setConfigSetting('request-timeout', 3000)' 'channel.sendTranaction(request, 3000)' Response A response message indicating whether the endorsement of the proposal was successful Type: Object Properties: Name Type Description status number Status code. Follows HTTP status code definitions message string A message associated with the response status code payload Array.&lt;byte&gt; A payload that can be used to include metadata with this response Restriction Type: Object Properties: Name Type Description revokedBefore Date Include certificates that were revoked before this UTC timestamp (in RFC3339 format) in the CRL revokedAfter Date Include certificates that were revoked after this UTC timestamp (in RFC3339 format) in the CRL expireBefore Date Include revoked certificates that expire before this UTC timestamp (in RFC3339 format) in the CRL expireAfter Date Include revoked certificates that expire after this UTC timestamp (in RFC3339 format) in the CRL Role Type: Object Properties: Name Type Description name string Name of the role. Value can be \"member\" or \"admin\" mspId string The member service provider Id used to process the identity ServiceResponse Type: Object Properties: Name Type Description Success boolean Boolean indicating if the request was successful Result Object The result of this request Errors Array.&lt;ServiceResponseMessage&gt; An array of error messages (code and message) Messages Array.&lt;ServiceResponseMessage&gt; An array of information messages (code and message) ServiceResponseMessage Type: Object Properties: Name Type Description code number Integer code denoting the type of message message string A more specific message SignatureHeader An object that is part of all signatures in Hyperledger Fabric. The \"creator\" field has two important pieces of information about the identity of the signer, the organization (Mspid) that the signer belongs to, and the certificate (IdBytes). The \"nonce\" field is a unique value to guard against replay attacks. creator Mspid -- {string} IdBytes -- {byte[]} nonce -- {byte[]} Type: Object SignaturePolicy SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing policies which are more complicated than 'exactly this signature'. The NOutOf operator is sufficent to express AND as well as OR, as well as of course N out of the following M policies. SignedBy implies that the signature is from a valid certificate which is signed by the trusted authority specified in the bytes. This will be the certificate itself for a self-signed certificate and will be the CA for more traditional certificates A \"SignaturePolicy\" will have the following object structure. type -- SIGNATURE rule Type -- n_out_of n_out_of N -- {int} rules -- {array} Type -- signed_by signed_by -- {int} identities -- {array} principal_classification -- {int} msp_identifier -- {string} Role -- MEMBER | ADMIN Type: Object SignedCommitProposal Type: Object Properties: Name Type Argument Description request TransactionRequest Required. The commit request signedTransaction Buffer Required. The signed transaction orderer Orderer | string &lt;optional&gt; Optional. The orderer instance or string name of the orderer to operate. See Client.getTargetOrderer SignedEvent Type: Object Properties: Name Type Description signature Buffer the signature over this payload payload Buffer the payload byte array to be sent to the peer SignedProposal Type: Object Properties: Name Type Description targets Array.&lt;Peer&gt; Required. The function name. signedProposal Buffer Required. The signed endorse proposal SYSTEM_TIMEOUT The Error message string that indicates that the request operation has timed out due to a system issue. This will indicate that the issue is local rather than remote. If there is an issue with the remote node a 'REQUEST_TIMEOUT' error message will be returned. The operation will only use one timer for both types of timeouts. The timer will start running as the operation begins. If the timer expires before the local instance is able to make the outbound request then 'SYSTEM_TIMEOUT' error will be returned. If the local instance is able to make the outbound request and the timer expires before the remote node responds then the 'REQUEST_TIMEOUT' is returned. The timer is controlled by the 'request-timeout' setting or passed on a call that makes an outbound request Type: Error Examples 'client.setConfigSetting('request-timeout', 3000)' 'channel.sendTranaction(request, 3000)' TLSOptions Type: Object Properties: Name Type Argument Default Description trustedRoots Array.&lt;string&gt; Array of PEM-encoded trusted root certificates verify boolean &lt;optional&gt; true Determines whether or not to verify the server certificate when using TLS Transaction A Transaction, or \"Endorser Transaction\", is the result of invoking chaincodes to collect endorsements, getting globally ordered in the context of a channel, and getting validated by the committer peer as part of a block before finally being formally \"committed\" to the ledger inside a Block. Each transaction contains an array of \"actions\" representing different steps for executing a transaction, and those steps will be processed atomically, meaning if any one step failed then the whole transaction will be marked as rejected. Each entry of the \"actions\" array contains a chaincode proposal and corresponding proposal responses that encapsulate the endorsing peer's decisions on whether the proposal is considered valid. Note that even if a transaction proposal(s) is considered valid by the endorsing peers, it may still be rejected by the committers during transaction validation. Whether a transaction as a whole is valid or not, is not reflected in the transaction record itself, but rather recorded in a separate field in the Block's metadata. A \"Transaction\" will have the following object structure. actions {array} header -- {SignatureHeader} payload chaincode_proposal_payload input -- {ChaincodeInvocationSpec} for a endorser transaction action proposal_response_payload proposal_hash -- {byte[]} extension results data_model -- {int} ns_rwset -- {array} namespace -- {string} rwset reads -- {array} key -- {string} version block_num -- {number} tx_num -- {number} range_queries_info -- {array} writes -- {array} key -- {string} is_delete -- {boolean} value -- {string} metadata_writes -- {array} key -- {string} entries -- {array} name -- {string} value -- {byte[]} collection_hashed_rwset -- {array} collection_name -- {string} hashed_rwset hashed_reads -- {array} key_hash -- {byte[]} version block_num -- {number} tx_num -- {number} hashed_writes -- {array} key_hash -- {byte[]} is_delete -- {boolean} value_hash -- {byte[]} metadata_writes -- {array} key_hash -- {byte[]} entries -- {array} name -- {string} value -- {byte[]} pvt_rwset_hash -- {byte[]} events chaincode_id -- {string} tx_id -- {string} event_name -- {string} payload -- {byte[]} response status -- {int} message -- {string} payload -- {byte[]} endorsements -- {Endorsement[]} Type: Object TransactionOptions Type: Object Properties: Name Type Argument Default Description commitTimeout Number &lt;optional&gt; 0 Number of seconds to wait for transaction completion. A value of zero indicates that the handler should wait indefinitely. TransactionRequest Type: Object Properties: Name Type Argument Description proposalResponses Array.&lt;ProposalResponse&gt; An array of or a single ProposalResponse object containing the response from the endorsement call proposal Proposal A Proposal object containing the original request for endorsement(s) txID TransactionId &lt;optional&gt; Optional. - Must be the transaction ID object used in the proposal endorsement. The transactionID will only be used to determine if the signing of the request should be done by the admin identity or the user assigned to the client instance. orderer Orderer | string &lt;optional&gt; Optional. The orderer instance or string name of the orderer to operate. See Client.getTargetOrderer UserNamePasswordObject An alternate object to use on the 'setUserContext' call in place of the 'User' object. When using this object it is assumed that the current 'Client' instance has been loaded with a common connection profile. Type: Object Properties: Name Type Description username string Required. A string representing the user name of the user password string Optional. A string representing the password of the user caName string Optional. A string representing the name of the Certificate Authority. If not specified, will use the first Certificate Authority on the list. UserOpts Type: Object Properties: Name Type Description username string the user name used for enrollment mspid string the MSP id cryptoContent CryptoContent the private key and certificate skipPersistence boolean whether to save this new user object into persistence.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Modules Classes AffiliationService BasePackager BasicCommitHandler BlockDecoder CertificateAuthority Chaincode ChaincodeRegistration Channel ChannelEventHub ChannelPeer Client CommitHandler DiscoveryEndorsementHandler EndorsementHandler EndorsementPolicy Endpoint event_hub_number FabricCAClient FabricCAServices IdentityService BaseCheckpointer BaseEventListener CommitEventListener Contract ContractEventListener EventHubDisconnectError EventServiceManager FabricError FileSystemCheckpointer Gateway HsmX509Provider IdentityProviderRegistry Network TimeoutError Transaction Wallet Wallets MSP MSPManager NetworkConfig NetworkConfig_1_0 Orderer Organization Peer Remote TransactionID  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Classes Classes AffiliationService BasePackager BasicCommitHandler BlockDecoder CertificateAuthority Chaincode ChaincodeRegistration Channel ChannelEventHub ChannelPeer Client CommitHandler DiscoveryEndorsementHandler EndorsementHandler EndorsementPolicy Endpoint event_hub_number FabricCAClient FabricCAServices IdentityService BaseCheckpointer BaseEventListener CommitEventListener Contract ContractEventListener EventHubDisconnectError EventServiceManager FabricError FileSystemCheckpointer Gateway HsmX509Provider IdentityProviderRegistry Network TimeoutError Transaction Wallet Wallets MSP MSPManager NetworkConfig NetworkConfig_1_0 Orderer Organization Peer Remote TransactionID  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Interfaces Classes AffiliationService BasePackager BasicCommitHandler BlockDecoder CertificateAuthority Chaincode ChaincodeRegistration Channel ChannelEventHub ChannelPeer Client CommitHandler DiscoveryEndorsementHandler EndorsementHandler EndorsementPolicy Endpoint event_hub_number FabricCAClient FabricCAServices IdentityService BaseCheckpointer BaseEventListener CommitEventListener Contract ContractEventListener EventHubDisconnectError EventServiceManager FabricError FileSystemCheckpointer Gateway HsmX509Provider IdentityProviderRegistry Network TimeoutError Transaction Wallet Wallets MSP MSPManager NetworkConfig NetworkConfig_1_0 Orderer Organization Peer Remote TransactionID  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Tutorials Classes AffiliationService BasePackager BasicCommitHandler BlockDecoder CertificateAuthority Chaincode ChaincodeRegistration Channel ChannelEventHub ChannelPeer Client CommitHandler DiscoveryEndorsementHandler EndorsementHandler EndorsementPolicy Endpoint event_hub_number FabricCAClient FabricCAServices IdentityService BaseCheckpointer BaseEventListener CommitEventListener Contract ContractEventListener EventHubDisconnectError EventServiceManager FabricError FileSystemCheckpointer Gateway HsmX509Provider IdentityProviderRegistry Network TimeoutError Transaction Wallet Wallets MSP MSPManager NetworkConfig NetworkConfig_1_0 Orderer Organization Peer Remote TransactionID  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER The Hyperledger Fabric SDK for Node.js provides a powerful API to interact with a Hyperledger Fabric blockchain. The SDK is designed to be used in the Node.js JavaScript runtime. Overview Hyperledger Fabric is the operating system of an enterprise-strength permissioned blockchain network. For a high-level overview of the fabric, visit http://hyperledger-fabric.readthedocs.io/en/latest/. Applications can be developed to interact with the blockchain network on behalf of the users. APIs are available to: create channels ask peer nodes to join the channel install chaincodes in peers instantiate chaincodes in a channel invoke transactions by calling the chaincode query the ledger for transactions or blocks How Different Components of the Fabric Work Together The Transaction Flow document provides an excellent description of the application/SDK, peers, and orderers working together to process transactions and producing blocks. Security on the Fabric is enforced with digital signatures. All requests made to the fabric must be signed by users with appropriate enrollment certificates. For a user's enrollment certificate to be considered valid on the Fabric, it must be signed by a trusted Certificate Authority (CA). Fabric supports any standard CAs. In addition, Fabric provides a CA server. See this overview. Features of the SDK for Node.js The Hyperledger Fabric SDK for Node.js is designed in an Object-Oriented programming style. Its modular construction enables application developers to plug in alternative implementations of key functions such as crypto suites, the state persistence store, and logging utility. The SDK's list of features include: fabric-network (the recommended API for): Submitting transactions to a smart contract. Querying a smart contract for the latest application state. fabric-client: create a new channel send channel information to a peer to join install chaincode on a peer instantiate chaincode in a channel, which involves two steps: propose and transact submitting a transaction, which also involves two steps: propose and transact query a chaincode for the latest application state various query capabilities: channel height block-by-number, block-by-hash all channels that a peer is part of all installed chaincodes in a peer all instantiated chaincodes in a channel transaction-by-id channel configuration data monitoring events: connect to a peer's event stream listen on block events listen on transactions events and find out if the transaction was successfully committed to the ledger or marked invalid listen on custom events produced by chaincodes serializable User object with signing capabilities hierarchical configuration settings with multiple layers of overrides: files, environment variable, program arguments, in-memory settings logging utility with a built-in logger (winston) and can be overriden with a number of popular loggers including log4js and bunyan pluggable CryptoSuite interface describe the cryptographic operations required for successful interactions with the Fabric. Two implementations are provided out of box: Software-based ECDSA PKCS#11-compliant ECDSA pluggable State Store interface for persisting state caches such as users File-based store CouchDB-base store which works with both CouchDB database and IBM Cloudant customizable Crypto Key Store for any software-based cryptographic suite implementation supports both TLS (grpcs://) or non-TLS (grpc://) connections to peers and orderers, see Remote which is the superclass for peers and orderers fabric-ca-client: register a new user enroll a user to obtain the enrollment certificate signed by the Fabric CA revoke an existing user by enrollment ID or revoke a specific certificate customizable persistence store API Reference The SDK is made up of 4 top-level modules that can be accessed through the navigation menu Modules: fabric-network: Provides high level APIs for client applications to submit transactions and evaluate queries for a smart contract (chaincode). api: Pluggable APIs for application developers to supply alternative implementations of key interfaces used by the SDK. For each interface there are built-in default implementations. fabric-client: Provides APIs to interact with the core components of a Hypreledger Fabric-based blockchain network, namely the peers, orderers and event streams. fabric-ca-client: Provides APIs to interact with the optional component, fabric-ca, that contains services for membership management. This work is licensed under a Creative Commons Attribution 4.0 International License. Compatibility The following tables show versions of Fabric, Node and other dependencies that are explicitly tested and that are supported for use with version 2.0 of the Fabric SDK for Node. Tested Supported Fabric 2.0 2.0.x Node 12 10.13+, 12.13+ Platform Ubuntu 18.04  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"AffiliationService.html":{"id":"AffiliationService.html","title":"Class: AffiliationService","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: AffiliationService AffiliationService This is an implementation of the Affiliation service which communicates with the Fabric CA server using the Fabric CA client FabricCAClient. new AffiliationService() Methods create(req, registrar) Create a new affiliation. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description req AffiliationRequest Required. The AffiliationRequest registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise delete(req, registrar) Delete an affiliation. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description req AffiliationRequest Required. The AffiliationRequest registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise getAll(registrar) List all affiliations equal to and below the caller's affiliation. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise getOne(affiliation, registrar) List a specific affiliation at or below the caller's affinity. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description affiliation string The affiliation path to be queried. registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise update(affiliation, req, registrar) Rename an affiliation. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description affiliation string The affiliation path to be updated req AffiliationRequest Required. The AffiliationRequest registrar User Returns: ServiceResponse Type Promise  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"BasePackager.html":{"id":"BasePackager.html","title":"Class: BasePackager","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: BasePackager BasePackager new BasePackager( [keep]) Constructor Parameters: Name Type Argument Description keep * &lt;optional&gt; Array of valid source file extensions Methods &lt;async&gt; finalPackage(chaincodeName, chaincodeVersion, chaincodeType, packageBytes [, chaincodePath]) Package the final chaincode package for installation on a Hyperledger Fabric Peer using the v2 Lifecycle process. Parameters: Name Type Argument Description chaincodeName string The name of the chaincode chaincodeVersion string The version of the chaincode chaincodeType string The chaincode type packageBytes Array.&lt;Byte&gt; The chaincode package chaincodePath string &lt;optional&gt; Optional. The chaincode path Returns: Type Promise.&lt;TResult&gt; findMetadataDescriptors(filePath) Find the metadata descriptor files. Parameters: Name Type Description filePath The top-level directory containing the metadata descriptors. Only files with a \".json\" extension will be included in the results. Returns: Type Promise findSource(filepath) Given an input 'filePath', recursively parse the filesystem for any files that fit the criteria for being valid chaincode source (ISREG + keep) Parameters: Name Type Description filepath generateTarGz(descriptors, dest) Creates an .tar.gz stream from the provided descriptor entries Parameters: Name Type Description descriptors dest Returns: Type Promise isMetadata(filePath) Predicate function for determining whether a given path should be considered a valid metadata descriptor based entirely on the file extension. Parameters: Name Type Description filePath The top-level directory containing the metadata descriptors. Returns: Returns true for valid metadata descriptors. Type boolean isSource(filePath) Predicate function for determining whether a given path should be considered valid source code, based entirely on the extension. It is assumed that other checks for file type (e.g. ISREG) have already been performed. Parameters: Name Type Description filePath Returns: Type boolean &lt;async&gt; package(chaincodePath, metadataPath [, goPath]) All of the files in the directory of request.chaincodePath will be included in an archive file. Parameters: Name Type Argument Description chaincodePath string metadataPath string goPath string &lt;optional&gt; Optional. Must be provided or environment \"GOPATH\" must be set when packaging goLang chaincode. packFileEntry(pack, desc) Given {fqp, name} generate a tar entry complete with sensible header and contents read from the filesystem. Parameters: Name Type Description pack desc Returns: Type Promise packMemoryEntry(pack, desc) Given {bytes, name} generate a tar entry complete with sensible header and contents from memory (the bytes). Parameters: Name Type Description pack desc Returns: Type Promise  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"BasicCommitHandler.html":{"id":"BasicCommitHandler.html","title":"Class: BasicCommitHandler","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: BasicCommitHandler BasicCommitHandler This is an implementation of the CommitHandler API. It will submit transactions to be committed to one orderer at time from a provided list or a list currently assigned to the channel. new BasicCommitHandler(channel) constructor Parameters: Name Type Description channel Channel The channel for this handler. Extends CommitHandler Methods &lt;static&gt; create(channel) Factory method to create an instance of a committer handler. Parameters: Name Type Description channel Channel the channel instance that this commit handler will be servicing. Returns: The instance of the handler Type BasicCommitHandler commit(params) This method will process the parameters to determine the orderers. The handler will use the provided orderers or use the orderers assigned to the channel. The handler is expected to preform failover and use all available orderers to send the endorsed transaction. Parameters: Name Type Description params CommitHandlerParameters A CommitHandlerParameters Inherited From: CommitHandler#commit Overrides: CommitHandler#commit Returns: A Promise for the BroadcastResponse, the same results as calling the Channel#sendTransaction method directly. Type Promise initialize() This method will be called by the channel when the channel is initialized. Inherited From: CommitHandler#initialize Overrides: CommitHandler#initialize  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"BlockDecoder.html":{"id":"BlockDecoder.html","title":"Class: BlockDecoder","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: BlockDecoder BlockDecoder Utility class to convert a protobuf encoded byte array of a Hyperledger Fabric block message into a pure Javascript object new BlockDecoder() Methods &lt;static&gt; decode(block_bytes) Constructs a JSON object containing all decoded values from the protobuf encoded `Block` bytes. Parameters: Name Type Description block_bytes Array.&lt;byte&gt; The encoded bytes of a Block protobuf message Returns: An object of the Block Type Block &lt;static&gt; decodeBlock(block_data) Constructs an object containing all decoded values from the protobuf encoded `Block` object Parameters: Name Type Description block_data Object an object that represents the protobuf common.Block Returns: An object of the fully decoded protobuf common.Block Type Block &lt;static&gt; decodeBlockWithPrivateData(block_with_private_data) Constructs an object containing all decoded values from the protobuf encoded `BlockAndPrivateData` object Parameters: Name Type Description block_with_private_data Object an object that represents the protobuf common.BlockAndPrivateData Returns: An object of the fully decoded protobuf common.Block with its private data as a new property Type Block &lt;static&gt; decodeTransaction(processed_transaction_bytes) Constructs an object containing all decoded values from the protobuf encoded \"ProcessedTransaction\" bytes Parameters: Name Type Description processed_transaction_bytes Array.&lt;byte&gt; The encode bytes of a protobuf message \"ProcessedTransaction\" Returns: A fully decoded ProcessedTransaction object Type ProcessedTransaction  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"CertificateAuthority.html":{"id":"CertificateAuthority.html","title":"Class: CertificateAuthority","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: CertificateAuthority CertificateAuthority The CertificateAuthority class represents a Certificate Authority configuration as defined in a Connection Profile. This class will wrapper a FabricCAClientImpl fabric-ca-client implementation as a FabricCAServices instance when this class is returned from the Client#getCertificateAuthority method. This class has all the same methods as the FabricCAServices so that this class may be used directly or use this class's CertificateAuthority#getFabricCAServices method to get the actual FabricCAServices instance. new CertificateAuthority(name) Construct a CertificateAuthority object Parameters: Name Type Description name string The name of this Certificate Authority Returns: The url of this CertificateAuthority Type string The CertificateAuthority instance. Type CertificateAuthority Methods enroll() see FabricCAServices#enroll generateCRL() see FabricCAServices#generateCRL getCaName() Gets the name of this CertificateAuthority to use in request Returns: The ca name of this CertificateAuthority Type string getConnectionOptions() Gets the connection options of this CertificateAuthority Returns: The connection options of this CertificateAuthority Type object getFabricCAServices() Get the FabricCAServices implementation Returns: FabricCAServices getName() Gets the name of this CertificateAuthority Returns: The name of this CertificateAuthority Type string getRegistrar() Gets the registrar of this CertificateAuthority Returns: The registrar of this CertificateAuthority Type object getTlsCACerts() Gets the TLS CA Cert of this CertificateAuthority Returns: The TLS CA Cert PEM string of this CertificateAuthority Type string getUrl() Gets the url of this CertificateAuthority Returns: The url of this CertificateAuthority Type string newAffiliationService() see FabricCAServices#newAffiliationService newCertificateService() see FabricCAServices#newCertificateService newIdentityService() see FabricCAServices#newIdentityService reenroll() see FabricCAServices#reenroll register() see FabricCAServices#register revoke() see FabricCAServices#revoke setFabricCAServices(ca_services) Set the FabricCAServices implementation Parameters: Name Type Description ca_services FabricCAServices FabricCAServices toString() return a printable representation of this object  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"Chaincode.html":{"id":"Chaincode.html","title":"Class: Chaincode","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Chaincode Chaincode The Chaincode class represents an Chaincode definition. see the tutorial fabric-client: How to install and start your chaincode This class allows an application to contain all chaincode attributes and artifacts in one place during runtime. This will assist the administration of the chaincode's lifecycle. From your Client instance use the Client#newChaincode method. This will return a Chaincode object instance that has been associated with that client. This will provide access to user credentials used for signing requests, access to peer, orderer, and channel information. new Chaincode(name, version, client) Construct a Chaincode object. Parameters: Name Type Description name string The name of this chaincode version string The version of this chaincode client Client The Client instance. Returns: The Chaincode instance. Type Chaincode Methods &lt;static&gt; fromQueryResult(name, payload, client) Build a Chaincode instance from the QueryChaincodeDefinitionResult protobuf object that is the result of the \"QueryChaincodeDefinition\" request to the Chaincode Lifecycle. Parameters: Name Type Description name * payload * client * Returns: Type Chaincode getChaincodePath() Get the chaincode path Returns: Type string getCollectionConfigPackage() Get the collection config package. This is the protobuf object built by the CollectionConfig class using the collection package JSON input. Returns: Type CollectionConfigPackage getCollectionConfigPackageDefinition() Get the collection config package JSON. This is the input to the CollectionConfig class to build the protobuf object needed by the Approve Chaincode Fabric request see Channel#approveChaincodeForOrg. Returns: Type Object getEndorsementPolicy() Get the serialized endorsement policy generated by the endorsement policy definition or directly assigned to this chaincode instance. The serialized bytes will be generated when the endorsement policy definition is assigned with setEndorsementPolicyDefinition(). getEndorsementPolicyDefinition() Get the endorsement policy JSON definition. Returns: The JSON endorsement policy Type Object getGoLangPath() Get the goLang path Returns: Type string getInitRequired() Get the initialize required setting Returns: Type boolean getLabel() Get the chaincode package label Returns: The label value Type string getMetadataPath() Get the chaincode path Returns: Type string getName() Get the name of this chaincode. Returns: The name of this chaincode Type string getPackage() Get the source code package Returns: The package of this chaincode Type Array.&lt;byte&gt; getPackageId() Get the package id value Returns: The package id value is generated by the peer when the package is installed Type string getSequence() Get the modification sequence of the chaincode definition. Returns: The sequence of this chaincode Type Long getType() Get the chaincode type Returns: The type of this chaincode Type string getVersion() Get the version of this chaincode. Returns: The version of this chaincode Type string &lt;async&gt; install(request) Install the package on the specified peers. This method will send the package to the peers provided. Each peer will return a hash value of the installed package. Parameters: Name Type Description request ChaincodeInstallRequest The request object with the install attributes and settings. Returns: The hash value as calculated by the target peer(s). Type string &lt;async&gt; package(request) Package the files at the locations provided. This method will both return the package and set the package on this instance. This method will set the label, type, and paths (if provided in the request). The package_id will be set by the install method or manually by the application. The package_id must be set before using this object on the Channel#approveChaincodeForOrg. Parameters: Name Type Description request ChaincodePackageRequest Optional. The parameters to build the chaincode package. Parameters will be required when the parameter has not been set on this instance. setChaincodePath(path) Set the chaincode path Parameters: Name Type Description path string The path of this chaincode. setCollectionConfigPackageDefinition(configPackage) Set a collection package for this chaincode. The input is a JSON object. Parameters: Name Type Description configPackage Object The JSON representation of a fabric collection package definition. Example Collection package An array of collection configurations. [{ name: \"detailCol\", policy: { identities: [ {role: {name: \"member\", mspId: \"Org1MSP\"}}, {role: {name: \"member\", mspId: \"Org2MSP\"}} ], policy: { 1-of: [ {signed-by: 0}, {signed-by: 1} ] } }, requiredPeerCount: 1, maxPeerCount: 1, blockToLive: 100 }] setEndorsementPolicy(policy) Set the serialized endorsement policy required for the chaincode approval. The serialized bytes may have been generated when the endorsement policy JSON definition was assigned to a Chaincode. see setEndorsementPolicyDefinition(). Parameters: Name Type Description policy Array.&lt;byte&gt; the serialized endorsement policy setEndorsementPolicyDefinition(policy) Provide the endorsement policy definition for this chaincode. The input is a JSON object. Parameters: Name Type Description policy string | object When the policy is a string it will be the canonical path to a policy in the Channel configuration. When an object, it will be the fabric-client's JSON representation of an fabric endorsement policy. Examples Object Endorsement policy: \"Signed by any member from one of the organizations\" { identities: [ { role: {name: \"member\", mspId: \"org1\"}}, { role: {name: \"member\", mspId: \"org2\"}} ], policy: { \"1-of\": [{\"signed-by\": 0}, {\"signed-by\": 1}] } } Object Endorsement policy: \"Signed by admin of the ordererOrg and any member from one of the peer organizations\" { identities: [ {role: {name: \"member\", mspId: \"peerOrg1\"}}, {role: {name: \"member\", mspId: \"peerOrg2\"}}, {role: {name: \"admin\", mspId: \"ordererOrg\"}} ], policy: { \"2-of\": [ {\"signed-by\": 2}, {\"1-of\": [{\"signed-by\": 0}, {\"signed-by\": 1}]} ] } } String Endorsement policy: \"Policy reference of an existing policy in your channel configuration\" /Channel/Application/Endorsement setGoLangPath(path) Set the goLang path Parameters: Name Type Description path string The golang path. setInitRequired(required) Set if the chaincode initialize is required Parameters: Name Type Description required boolean Indicates if this chaincode must be initialized setLabel(The) Set the label to be used for this packaged chaincode The default of name:version will be used if not set when the package() method is called. Parameters: Name Type Description The string label value setMetadataPath(path) Set the metadata path Parameters: Name Type Description path string The path of this metadata. setPackage(package) Set the chaincode package It is recommended to set the package label associated with this package. Parameters: Name Type Description package Array.&lt;byte&gt; The source package setPackageId(package_id) Sets the chaincode package id Parameters: Name Type Description package_id string The source package id value setSequence(sequence) Set the modification sequence of the chaincode definition. The sequence value gives a unique number to a set of attributes for the the chaincode. When a attribute changes for a chaincode, the sequence value must be incremented and all organizations must again run the defineChaincodeForOrg() method to agree to the new definition. The default is 1, new chaincode. Parameters: Name Type Description sequence Long sequence of this chaincode setType(type) Set the chaincode type Parameters: Name Type Description type string The type of this chaincode. Must be \"golang\", \"node\", \"java\" or \"car\". setVersion() Set the version of this chaincode. toString() return a printable representation of this object validate() Verify that this Chaincode instance has all the required attributes required for an approval or commit request.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"ChaincodeRegistration.html":{"id":"ChaincodeRegistration.html","title":"Class: ChaincodeRegistration","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: ChaincodeRegistration ChaincodeRegistration new ChaincodeRegistration(chaincode_id, event_name, event_reg, as_array) Constructs a chaincode callback entry Parameters: Name Type Description chaincode_id string chaincode id event_name string | RegExp The regex used to filter events event_reg EventRegistration event registrations callbacks as_array as_array should all the chaincode events found that match this definition be sent to the callback as an array or call the callback for each one individually.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"Channel.html":{"id":"Channel.html","title":"Class: Channel","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Channel Channel Channels provide data isolation for a set of participating organizations. A Channel object captures the settings needed to interact with a fabric backend in the context of a channel. These settings including the list of participating organizations, represented by instances of Membership Service Providers (MSP), the list of endorsing peers, and an orderer. A client application can use the Channel object to create new channels with the orderer, update an existing channel, send various channel-aware requests to the peers such as invoking chaincodes to process transactions or queries. A Channel object is also responsible for verifying endorsement signatures in transaction proposal responses. A channel object must be initialized after it has been configured with the list of peers and orderers. The initialization sends a get configuration block request to the primary orderer to retrieve the configuration settings for this channel. new Channel(name, clientContext) Returns a new instance of the class. This is a client-side-only call. To create a new channel in the fabric, call createChannel(). Parameters: Name Type Description name string Name to identify the channel. This value is used as the identifier of the channel when making channel-aware requests with the fabric, such as invoking chaincodes to endorse transactions. The naming of channels is enforced by the ordering service and must be unique within the fabric backend. Channel name in fabric network is subject to a pattern revealed in the configuration setting channel-name-regx-checker. clientContext Client The client instance, which provides operational context such as the signing identity Methods &lt;async, static&gt; sendSignedProposal(request, timeout) Send signed transaction proposal to peer Parameters: Name Type Description request SignedProposal signed endorse transaction proposal, this signed proposal would be send to peer directly. timeout number the timeout setting passed on sendSignedProposal &lt;async&gt; _discover(request) Send a request to a known peer to discover information about the fabric network. Parameters: Name Type Description request DiscoveryRequest - Returns: The results from the discovery service //TODO missing typeDef DiscoveryResponse Type Promise.&lt;DiscoveryResponse&gt; addOrderer(orderer, replace) Add the orderer object to the channel object, this is a client-side-only operation. An application may add more than one orderer object to the channel object, however the SDK only uses the first one in the list to send broadcast messages to the orderer backend. Parameters: Name Type Description orderer Orderer An instance of the Orderer class. replace boolean If an orderer exist with the same name, replace with this one. addPeer(peer, mspid [, roles], replace) Add the peer object to the channel object. A channel object can be optionally configured with a list of peer objects, which will be used when calling certain methods such as sendInstantiateProposal(), sendUpgradeProposal(), sendTransactionProposal. Parameters: Name Type Argument Description peer Peer An instance of the Peer class that has been initialized with URL and other gRPC options such as TLS credentials and request timeout. mspid string The mpsid of the organization this peer belongs. roles ChannelPeerRoles &lt;optional&gt; Optional. The roles this peer will perform on this channel. A role that is not defined will default to true replace boolean If a peer exist with the same name, replace with this one. &lt;async&gt; approveChaincodeForOrg(request) This method will build and send an \"approve chaincode definition for organization for channel\" transaction to the fabric lifecycle system chaincode. see Chaincode Parameters: Name Type Description request ChaincodeRequest Required. Returns: Return object will contain the proposalResponses and the proposal Type Object &lt;async&gt; checkCommitReadiness(request) Sends a QueryApprovalStatus request to one peer. Parameters: Name Type Description request QueryApprovalStatusRequest Returns: A Promise for a Chaincode instance Type Promise close() Close the service connections of all assigned peers and orderers &lt;async&gt; commitChaincode(request) This method will build and send a \"commit chaincode definition for channel\" transaction to the fabric lifecycle system chaincode. see Chaincode Parameters: Name Type Description request ChaincodeRequest Required. Returns: Return object will contain the proposalResponses and the proposal Type Object compareProposalResponseResults(proposal_responses) Utility method to examine a set of proposals to check they contain the same endorsement result write sets. This will validate that the endorsing peers all agree on the result of the chaincode execution. Parameters: Name Type Description proposal_responses Array.&lt;ProposalResponse&gt; The proposal responses from all endorsing peers Returns: True when all proposals compare equally, false otherwise. Type boolean generateUnsignedProposal(request, mspId, certificate, admin) Generates the endorse proposal bytes for a transaction Current the sendTransactionProposal sign a transaction using the user identity from SDK's context (which contains the user's private key). This method is designed to build the proposal bytes at SDK side, and user can sign this proposal with their private key, and send the signed proposal to peer by [sendSignedProposal] so the user's private key would not be required at SDK side. Parameters: Name Type Description request ProposalRequest chaincode invoke request mspId string the mspId for this identity certificate string PEM encoded certificate admin boolean if this transaction is invoked by admin Returns: Type Proposal generateUnsignedTransaction(request) generate the commit proposal for a transaction Parameters: Name Type Description request TransactionRequest &lt;async&gt; getChannelConfig( [target] [, timeout]) Asks the peer for the current (latest) configuration block for this channel. Parameters: Name Type Argument Description target string | Peer &lt;optional&gt; Optional. The peer to be used to make the request. timeout Number &lt;optional&gt; Optional. A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance(s) and the global timeout in the config settings. Returns: A Promise for a ConfigEnvelope object containing the configuration items. Type Promise &lt;async&gt; getChannelConfigFromOrderer() Asks the orderer for the current (latest) configuration block for this channel. This is similar to getGenesisBlock(), except that instead of getting block number 0 it gets the latest block that contains the channel configuration, and only returns the decoded ConfigEnvelope. Returns: A Promise for a ConfigEnvelope object containing the configuration items. Type Promise getChannelEventHub(name) Returns a ChannelEventHub object. An event hub object encapsulates the properties of an event stream on a peer node, through which the peer publishes notifications of blocks being committed in the channel's ledger. This method will create a new ChannelEventHub if one does not exist. Parameters: Name Type Description name string The peer name associated with this channel event hub. Use the Peer#getName method to get the name of a peer instance that has been added to this channel. Returns: - The ChannelEventHub associated with the peer. Type ChannelEventHub getChannelEventHubsForOrg( [mspid]) Returns a list of ChannelEventHub based on the peers that are defined in this channel that are in the organization. Parameters: Name Type Argument Description mspid string &lt;optional&gt; Optional. The mspid of an organization Returns: An array of ChannelEventHub instances Type Array.&lt;ChannelEventHub&gt; getChannelPeer(name) This method will return a ChannelPeer. This object holds a reference to the Peer and the ChannelEventHub objects and the attributes of how the peer is defined on the channel. Parameters: Name Type Description name string The name of the peer assigned to this channel Returns: The ChannelPeer instance Type ChannelPeer getChannelPeers() Returns a list of ChannelPeer assigned to this channel instance. A ChannelPeer provides a reference to peer and channel event hub along with how this peer is being used on this channel. Returns: The channel peer list on the channel. Type Array.&lt;ChannelPeer&gt; &lt;async&gt; getDiscoveryResults(endorsement_hints) Return the discovery results. Discovery results are only available if this channel has been initialized. If the results are too old, they will be refreshed Parameters: Name Type Description endorsement_hints Array.&lt;DiscoveryChaincodeInterest&gt; Indicate to discovery how to calculate the endorsement plans. Returns: Type Promise.&lt;DiscoveryResults&gt; &lt;async&gt; getEndorsementPlan(endorsement_hint) Return a single endorsement plan based off a DiscoveryChaincodeInterest. Parameters: Name Type Description endorsement_hint DiscoveryChaincodeInterest The chaincodes and collections of how the discovery service will calculate an endorsement plan. Returns: The endorsement plan based on the hint provided. Type DiscoveryResultEndorsementPlan getGenesisBlock( [request]) A channel's first block is called the \"genesis block\". This block captures the initial channel configuration. For a peer node to join the channel, it must be provided the genesis block. This method must be called before calling joinChannel(). Parameters: Name Type Argument Description request OrdererRequest &lt;optional&gt; Optional - A transaction ID object Returns: A Promise for an encoded protobuf \"Block\" Type Promise &lt;async&gt; getInstalledChaincodePackage(request) Sends a QueryInstalledChaincode request to one peer. Parameters: Name Type Description request GetInstalledChaincodePackageRequest Returns: A Promise for a {byte[]} the installed package. Type Promise getMSPManager() Get the MSP Manager for this channel Returns: Type MSPManager getName() Get the channel name. Returns: The name of the channel. Type string getOrderer(name) This method will return a Orderer instance if assigned to this channel. Peers that have been created by the Client#newOrderer method and then added to this channel may be reference by the url if no name was provided in the options during the create. Parameters: Name Type Description name string The name or url of the orderer Returns: The Orderer instance. Type Orderer getOrderers() Returns the orderers of this channel object. Returns: The list of orderers in the channel object Type Array.&lt;Orderer&gt; getOrganizations() Get organization identifiers from the MSP's for this channel Returns: Array of OrganizationIdentifier Objects representing the channel's participating organizations Type Array.&lt;OrganizationIdentifier&gt; getPeer(name) This method will return a ChannelPeer instance if assigned to this channel. Peers that have been created by the Client#newPeer method and then added to this channel may be reference by the url if no name was provided in the options during the create. A ChannelPeer provides a reference to peer and channel event hub along with how this peer is being used on this channel. Parameters: Name Type Description name string The name of the peer Returns: The ChannelPeer instance. Type ChannelPeer getPeers() Returns a list of ChannelPeer assigned to this channel instance. A ChannelPeer provides a reference to peer and channel event hub along with how this peer is being used on this channel. Returns: The channel peer list on the channel. Type Array.&lt;ChannelPeer&gt; getPeersForOrg( [mspid]) Returns a list of Peer that are defined in this channel that are in the named organization. Parameters: Name Type Argument Description mspid string &lt;optional&gt; Optional. The name of an organization Returns: An array of Peer instances Type Array.&lt;Peer&gt; &lt;async&gt; initialize( [request]) Initializes the channel object with the Membership Service Providers (MSPs). The channel's MSPs are critical in providing applications the ability to validate certificates and verify signatures in messages received from the fabric backend. For instance, after calling sendTransactionProposal(), the application can verify the signatures in the proposal response's endorsements to ensure they have not been tampered with. This method retrieves the configuration from the orderer if no \"config\" parameter is passed in. Optionally a configuration may be passed in to initialize this channel without making the call to the orderer. This method will also automatically load orderers and peers that represent the fabric network when using discovery. This application must provide a peer running the fabric discovery service. Parameters: Name Type Argument Description request InitializeRequest &lt;optional&gt; Optional. a InitializeRequest Returns: A Promise that will resolve when the action is complete Type Promise joinChannel(request, timeout) For a peer node to become part of a channel, it must be sent the genesis block, as explained here. This method sends a join channel proposal to one or more endorsing peers. Parameters: Name Type Description request JoinChannelRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance(s) and the global timeout in the config settings. Returns: A Promise for an array of ProposalResponse from the target peers Type Promise newChannelEventHub( [peer]) Returns a ChannelEventHub object. An event hub object encapsulates the properties of an event stream on a peer node, through which the peer publishes notifications of blocks being committed in the channel's ledger. This method will create a new ChannelEventHub and not save a reference. Use the {getChannelEventHub} to reuse a ChannelEventHub. Parameters: Name Type Argument Description peer Peer | string &lt;optional&gt; Optional. A Peer instance or the name of a peer that has been assigned to the channel. If not provided the ChannelEventHub must be connected with a \"target\" peer. Returns: The ChannelEventHub instance Type ChannelEventHub &lt;async&gt; queryBlock(blockNumber [, target] [, useAdmin] [, skipDecode]) Queries the ledger on the target peer for Block by block number. Parameters: Name Type Argument Description blockNumber number The number of the Block in question. target Peer &lt;optional&gt; Optional. The peer to send this query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean &lt;optional&gt; Optional. Indicates that the admin credentials should be used in making this call to the peer. skipDecode boolean &lt;optional&gt; Optional. If true, this function returns an encoded block. Returns: A Promise for a Block at the blockNumber slot in the ledger, fully decoded into an object. Type Promise &lt;async&gt; queryBlockByHash(blockHash [, target] [, useAdmin] [, skipDecode]) Queries the ledger on the target peer for a Block by block hash. Parameters: Name Type Argument Description blockHash Array.&lt;byte&gt; of the Block in question. target Peer &lt;optional&gt; Optional. The peer to send the query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean &lt;optional&gt; Optional. Indicates that the admin credentials should be used in making this call to the peer. skipDecode boolean &lt;optional&gt; Optional. If true, this function returns an encoded block. Returns: A Promise for a Block matching the hash, fully decoded into an object. Type Promise &lt;async&gt; queryBlockByTxID(tx_id [, target] [, useAdmin] [, skipDecode]) Queries the ledger on the target peer for a Block TransactionID. Parameters: Name Type Argument Description tx_id string The TransactionID of the Block in question. target Peer &lt;optional&gt; Optional. The peer to send the query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean &lt;optional&gt; Optional. Indicates that the admin credentials should be used in making this call to the peer. skipDecode boolean &lt;optional&gt; Optional. If true, this function returns an encoded block. Returns: A Promise for a Block matching the tx_id, fully decoded into an object. Type Promise &lt;async&gt; queryByChaincode(request [, useAdmin]) Sends a proposal to one or more endorsing peers that will be handled by the chaincode. There is no difference in how the endorsing peers process a request to invoke a chaincode for transaction vs. to invoke a chaincode for query. All requests will be presented to the target chaincode's 'Invoke' method which must be implemented to understand from the arguments that this is a query request. The chaincode must also return results in the byte array format and the caller will have to be able to decode these results. If the request contains a txId property, that transaction ID will be used, and its administrative privileges will apply. In this case the useAdmin parameter to this function will be ignored. Parameters: Name Type Argument Description request ChaincodeQueryRequest useAdmin boolean &lt;optional&gt; Optional. Indicates that the admin credentials should be used in making this call. Ignored if the request contains a txId property. Returns: A Promise for an array of byte array results returned from the chaincode on all Endorsing Peers Type Promise Example Get the list of query results returned by the chaincode const responsePayloads = await channel.queryByChaincode(request); for (let i = 0; i &lt; responsePayloads.length; i++) { console.log(util.format('Query result from peer [%s]: %s', i, responsePayloads[i].toString('utf8'))); } &lt;async&gt; queryChaincodeDefinition(request) Sends a QueryChaincodeDefintion request to one peer. Parameters: Name Type Description request QueryChaincodeDefinitionRequest Returns: A Promise for a Chaincode instance Type Promise &lt;async&gt; queryChaincodeDefinitions(request) Sends a QueryChaincodeDefinitions request to one peer. Parameters: Name Type Description request QueryChaincodeDefinitionsRequest Returns: A Promise for a QueryChaincodeDefinitionsResult[] Type Promise &lt;async&gt; queryCollectionsConfig(options [, useAdmin]) Query for the collection definitions associated with a chaincode. Parameters: Name Type Argument Description options CollectionQueryOptions Required. The options to query the collections config. useAdmin boolean &lt;optional&gt; Optional. To indicate that the admin identity should be used to make the query request Returns: returns a promise for an array of CollectionQueryResponse objects. Type Promise.&lt;Array.&lt;CollectionQueryResponse&gt;&gt; &lt;async&gt; queryInfo( [target] [, useAdmin]) Queries for various useful information on the state of the Channel (height, known peers). Parameters: Name Type Argument Description target Peer &lt;optional&gt; Optional. The peer that is the target for this query. If no target is passed, the query will use the first peer that was added to the channel object. useAdmin boolean &lt;optional&gt; Optional. Indicates that the admin credentials should be used in making this call to the peer. Returns: A Promise for a BlockchainInfo object with blockchain height, current block hash and previous block hash. Type Promise &lt;async&gt; queryInstalledChaincode(request) Sends a QueryInstalledChaincode request to one peer. Parameters: Name Type Description request QueryInstalledChaincodeRequest Returns: A Promise for a QueryInstalledChaincodeResult Type Promise &lt;async&gt; queryInstalledChaincodes(request) Sends a QueryInstalledChaincodes request to one peer. Parameters: Name Type Description request QueryInstalledChaincodesRequest Returns: A Promise for a QueryInstalledChaincodeResult[] Type Promise &lt;async&gt; queryInstantiatedChaincodes( [target] [, useAdmin]) Queries the ledger on the target peer for instantiated chaincodes on this channel. Parameters: Name Type Argument Description target Peer &lt;optional&gt; Optional. The peer to send this query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean &lt;optional&gt; Optional. Indicates that the admin credentials should be used in making this call to the peer. An administrative identity must have been loaded by common connection profile or by using the 'setAdminSigningIdentity' method. Returns: A Promise for a fully decoded ChaincodeQueryResponse object. Type Promise &lt;async&gt; queryTransaction(tx_id [, target] [, useAdmin] [, skipDecode]) Queries the ledger on the target peer for Transaction by id. Parameters: Name Type Argument Description tx_id string The id of the transaction target Peer &lt;optional&gt; Optional. The peer to send this query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean &lt;optional&gt; Optional. Indicates that the admin credentials should be used in making this call to the peer. skipDecode boolean &lt;optional&gt; Optional. If true, this function returns an encoded transaction. Returns: A Promise for a fully decoded ProcessedTransaction object. Type Promise &lt;async&gt; refresh() Refresh the channel's configuration. The MSP configurations, peers, orderers, and endorsement plans will be queired from the peer using the Discover Service. The queries will be made to the peer used previously for discovery if the 'target' parameter is not provided. Returns: - The results of refreshing Type DiscoveryResults removeOrderer(orderer) Remove the first orderer object in the channel object's list of orderers whose endpoint url property matches the url of the orderer that is passed in. Parameters: Name Type Description orderer Orderer An instance of the Orderer class. removePeer(peer) Remove the peer object in the channel object's list of peers whose endpoint url property matches the url or name of the peer that is passed in. Parameters: Name Type Description peer Peer An instance of the Peer class. sendInstantiateProposal(request, timeout) Sends a chaincode instantiate proposal to one or more endorsing peers. A chaincode must be instantiated on a channel-by-channel basis before it can be used. The chaincode must first be installed on the endorsing peers where this chaincode is expected to run, by calling client.installChaincode(). Instantiating a chaincode is a full transaction operation, meaning it must be first endorsed as a proposal, then the endorsements are sent to the orderer to be processed for ordering and validation. When the transaction finally gets committed to the channel's ledger on the peers, the chaincode is then considered activated and the peers are ready to take requests to process transactions. Parameters: Name Type Description request ChaincodeInstantiateUpgradeRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Deprecated: Yes Returns: A Promise for the ProposalResponseObject Type Promise &lt;async&gt; sendSignedProposal(request, timeout) Send signed transaction proposal to peer Parameters: Name Type Description request SignedProposal signed endorse transaction proposal, this signed proposal would be send to peer directly. timeout number the timeout setting passed on sendSignedProposal &lt;async&gt; sendSignedTransaction(request, timeout) send the signed commit proposal for a transaction Parameters: Name Type Description request SignedCommitProposal the signed commit proposal timeout number the timeout setting passed on sendSignedProposal &lt;async&gt; sendTransaction(request, timeout) Send the proposal responses that contain the endorsements of a transaction proposal to the orderer for further processing. This is the 2nd phase of the transaction lifecycle in the fabric. The orderer will globally order the transactions in the context of this channel and deliver the resulting blocks to the committing peers for validation against the chaincode's endorsement policy. When the committing peers successfully validate the transactions, it will mark the transaction as valid inside the block. After all transactions in a block have been validated, and marked either as valid or invalid (with a reason code), the block will be appended (committed) to the channel's ledger on the peer. The caller of this method must use the proposal responses returned from the endorser along with the original proposal that was sent to the endorser. Both of these objects are contained in the ProposalResponseObject returned by calls to any of the following methods: sendInstantiateProposal() sendUpgradeProposal() sendTransactionProposal() Parameters: Name Type Description request TransactionRequest TransactionRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Orderer instance and the global timeout in the config settings. Returns: A Promise for a BroadcastResponse message returned by the orderer that contains a single \"status\" field for a standard HTTP response code. This will be an acknowledgement from the orderer of a successfully submitted transaction. Type Promise &lt;async&gt; sendTransactionProposal(request, timeout) Sends a transaction proposal to one or more endorsing peers. After a chaincode gets installed and instantiated, it's ready to take endorsement proposals and participating in transaction processing. A chaincode transaction starts with a proposal that gets sent to the endorsing peers, which executes the target chaincode and decides whether the proposal should be endorsed (if it executes successfully) or not (if the chaincode returns an error). Parameters: Name Type Description request ChaincodeInvokeRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Returns: A Promise for the ProposalResponseObject Type Promise sendUpgradeProposal(request, timeout) Sends a chaincode upgrade proposal to one or more endorsing peers. Upgrading a chaincode involves steps similar to instantiating a chaincode. The new chaincode must first be installed on the endorsing peers where this chaincode is expected to run. Similar to instantiating a chaincode, upgrading chaincodes is also a full transaction operation. Parameters: Name Type Description request ChaincodeInstantiateUpgradeRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Deprecated: Yes Returns: A Promise for the ProposalResponseObject Type Promise setMSPManager(msp_manager) Set the MSP Manager for this channel. This utility method will not normally be use as the initialize() method will read this channel's current configuration and reset MSPManager with the MSP's found in the channel configuration. Parameters: Name Type Description msp_manager MSPManager The msp manager for this channel toString() return a printable representation of this channel object &lt;async&gt; verifyProposalResponse(proposal_response) Utility method to verify a single proposal response. It checks the following aspects: The endorser's identity belongs to a legitimate MSP of the channel and can be successfully deserialized The endorsement signature can be successfully verified with the endorser's identity certificate This method requires that the initialize method of this channel object has been called to load this channel's MSPs. The MSPs will have the trusted root certificates for this channel. Parameters: Name Type Description proposal_response ProposalResponse The endorsement response from the peer, includes the endorser certificate and signature over the proposal + endorsement result + endorser certificate. Returns: A boolean value of true when both the identity and the signature are valid, false otherwise. Type boolean  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"ChannelEventHub.html":{"id":"ChannelEventHub.html","title":"Class: ChannelEventHub","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: ChannelEventHub ChannelEventHub new ChannelEventHub(channel, peer) Constructs a ChannelEventHub object Parameters: Name Type Description channel Channel An instance of the Channel class were this ChannelEventHub will receive blocks peer Peer Optional. An instance of the Peer class this ChannelEventHub connects. Returns: An instance of this class Type ChannelEventHub Methods checkConnection(force_reconnect) Returns if the stream is ready. and will attempt a restart when forced Parameters: Name Type Description force_reconnect boolean attempt to reconnect if the stream is not in the 'READY' state close() Disconnects the ChannelEventHub from the fabric peer service. Will close all event listeners and send an EventHubDisconnectError object with the message \"ChannelEventHub has been shutdown\" to all listeners that provided an \"onError\" callback. connect(options, connectCallback) Establishes a connection with the fabric peer service. The connection will be established asynchronously. If the connection fails to get established, the application will be notified via the 'connectCallback' provided. Additionally the error callbacks from the registerXXXEvent() methods will be notified if provided. It is recommended that an application relay on 'connectCallback' to determine connect status and relay on the 'errCallback' of the event listeners for runtime connection issues. Register event listeners and the error callbacks by calling any one of the registerBlockEvent, registerTxEvent or registerChaincodeEvent methods, after calling connect(). Parameters: Name Type Description options ConnectOptions | boolean Optional. If of type boolean then it will be assumed to how to connect to receive full (true) or filtered (false) blocks. connectCallback function Optional. This callback will report completion of the connection to the peer or will report any errors encountered during connection to the peer. When there is an error, this ChannelEventHub will be shutdown (disconnected). Callback function should take two parameters as (error, value). disconnect() Disconnects the ChannelEventHub from the peer event source. Will close all event listeners and send an EventHubDisconnectError object with the message \"ChannelEventHub has been shutdown\" to all listeners that provided an \"onError\" callback. generateUnsignedRegistration(options) Generate the unsigned fabric service registration, this should be signed by the identity's private key. Parameters: Name Type Description options EventHubRegistrationRequest the options for register this ChannelEventHub with the fabric peer service. Notice the options should contain either both identity and txId or both certificate and mspId Returns: the byte array contains the registration payload to be signed. Type Buffer getName() Return the name of this ChannelEventHub, will be the name of the associated peer. getPeerAddr() Return the peer url isconnected() Is this ChannelEventHub connected to the fabric service? Returns: True if connected to the event source, false otherwise Type boolean reconnect(options, connectCallback) Reestablishes a connection with the fabric peer service. Parameters: Name Type Description options ConnectOptions Optional. connectCallback function Optional. This callback will report completion of the connection to the peer or will report any errors encountered during connection to the peer. When there is an error, this ChannelEventHub will be shutdown (disconnected). Callback function should take two parameters as (error, value). registerBlockEvent(onEvent, onError, options) Register a listener to receive all block committed to this channel. The listener's \"onEvent\" callback gets called on the arrival of every block. An error may occur in the connection establishment which runs asynchronously. The best practice would be to provide an \"onError\" callback to be notified when this ChannelEventHub has an issue. Parameters: Name Type Description onEvent function Callback function that takes a single parameter of a Block object onError function Optional callback function to be notified when this ChannelEventHub is shutdown. The shutdown may be caused by a network or connection error, by a call to the \"disconnect()\" method or when the fabric service ends the connection this ChannelEventHub. This callback will also be called when the ChannelEventHub is shutdown due to the last block being received if replaying and requesting the endBlock to be 'newest'. options RegistrationOpts Options on the registrations to allow for start and end block numbers, automatically unregister and automatically disconnect. Returns: This is the block registration number that must be used to unregister this block listener. see unregisterBlockEvent() Type int registerChaincodeEvent(chaincode_id, event_name, onEvent, onError, options) Register a listener to receive chaincode events. An error may occur in the connection establishment which runs asynchronously. The best practice would be to provide an \"onError\" callback to be notified when this ChannelEventHub has an issue. Parameters: Name Type Description chaincode_id string Id of the chaincode of interest event_name string | RegExp The exact name of the chaincode event or regular expression that will be matched against the name given to the target chaincode's call stub.SetEvent(name, payload)) onEvent function callback function for matched events. It will be called with four parameters when not using \"as_array\". ChaincodeEvent - The chaincode event as produced by the chaincode, {Long} - the block number that contains this chaincode event {string} - the transaction ID that contains this chaincode event {string} - the transaction status of the transaction that contains this chaincode event When using \"as_array: true\" option, there will be one parameter of an array of an event objects with the above values which may be used as in the example below. onError function Optional callback function to be notified when this ChannelEventHub is shutdown. The shutdown may be caused by a network or connection error, by a call to the \"disconnect()\" method or when the fabric service ends the connection this ChannelEventHub. This callback will also be called when the ChannelEventHub is shutdown due to the last block being received if replaying and requesting the endBlock to be 'newest'. options RegistrationOpts Options on the registrations to allow for start and end block numbers, automatically unregister and automatically disconnect. Chaincode event listeners may also use the \"as_array\" option to indicate that all the chaincode events found that match this definition be sent to the callback as an array or call the callback for each one individually. Returns: An object that should be treated as an opaque handle used to unregister (see unregisterChaincodeEvent()) Type Object Example Chaincode callback to process events when as_array:true function myCallback(...events) { for ({chaincode_event, block_num, tx_id, tx_status} of events) { // process the chaincode event } } registerTxEvent(txid, onEvent, onError, options) Register a callback function to receive a notification when the transaction by the given id has been committed into a block. Using the special string 'all' will indicate that this listener will notify (call) the callback for every transaction received from the fabric service. An error may occur in the connection establishment which runs asynchronously. The best practice would be to provide an \"onError\" callback to be notified when this ChannelEventHub has an issue. Parameters: Name Type Description txid string Transaction id string or 'all' onEvent function Callback function that takes a parameter of transaction ID, a string parameter indicating the transaction status, and the block number of this transaction committed to the ledger onError function Optional callback function to be notified when this ChannelEventHub is shutdown. The shutdown may be caused by a network or connection error, by a call to the \"disconnect()\" method or when the fabric event service ends the connection this ChannelEventHub. This callback will also be called when the ChannelEventHub is shutdown due to the last block being received if replaying and requesting the endBlock to be 'newest'. options RegistrationOpts Options on the registrations to allow for start and end block numbers, automatically unregister and automatically disconnect. Returns: The transaction ID that was used to register this event listener. May be used to unregister this event listener. Type string unregisterBlockEvent(block_registration_number, throwError) Unregister the block event listener using the block registration number that is returned by the call to the registerBlockEvent() method. Parameters: Name Type Description block_registration_number int The block registration number that was returned during registration. throwError boolean Optional - throw an error if the block registration does not exist, default is to not throw an error unregisterChaincodeEvent(listener_handle, throwError) Unregister the chaincode event listener represented by the listener_handle object returned by the registerChaincodeEvent() method Parameters: Name Type Description listener_handle Object The handle object returned from the call to registerChaincodeEvent. throwError boolean Optional - throw an error if the chaincode event registration does not exist, default is to not throw an error unregisterTxEvent(txid, throwError) Unregister transaction event listener for the transaction id. Parameters: Name Type Description txid string The transaction id throwError boolean Optional - throw an error if the transaction registration does not exist, default is to not throw an error  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"ChannelPeer.html":{"id":"ChannelPeer.html","title":"Class: ChannelPeer","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: ChannelPeer ChannelPeer The ChannelPeer class represents a peer in the target blockchain network on this channel. new ChannelPeer(mspid, channel, peer, roles) Construct a ChannelPeer object with the given Peer and opts. A channel peer object holds channel based references: MSP ID of the Organization this peer belongs. Channel object used to know the channel this peer is interacting. Peer object used for interacting with the Hyperledger fabric network. ChannelEventHub object used for listening to block changes on the channel. List of ChannelPeerRoles to indicate the roles this peer performs on the channel. The roles this Peer performs on this channel are indicated with is object. Parameters: Name Type Description mspid string The mspid of the organization this peer belongs. channel Channel The Channel instance. peer Peer The Peer instance. roles ChannelPeerRoles The roles for this peer. Methods close() Close the associated peer service connections. see Peer#close see ChannelEventHub#close getChannelEventHub() Get the channel event hub for this channel peer. The ChannelEventHub instance will be assigned when using the Channel newChannelEventHub() method. When using a common connection profile, the ChannelEventHub will be automatically assigned on the Channel Peers as they are created and added to the channel. Returns: - The ChannelEventHub instance associated with this Peer instance. Type ChannelEventHub getMspid() Get the MSP ID. Returns: The mspId. Type string getName() Get the name. This is a client-side only identifier for this object. Returns: The name of the object Type string getPeer() Get the Peer instance this ChannelPeer represents on the channel. Returns: The associated Peer instance. Type Peer getUrl() Get the URL of this object. Returns: Get the URL associated with the peer object. Type string isInOrg(mspid) Checks if this peer is in the specified organization. The default is true when the incoming organization name is not defined. The default will be true when this peer does not have the organization name defined. Parameters: Name Type Description mspid string The mspid of the organnization Returns: If this peer belongs to the organization. Type boolean isInRole() Checks if this peer is in the specified role. The default is true when the incoming role is not defined. The default will be true when this peer does not have the role defined. Returns: If this peer has this role. Type boolean sendDiscovery() Wrapper method for the associated peer so this object may be used as a Peer Peer#sendDiscovery sendProposal() Wrapper method for the associated peer so this object may be used as a Peer Peer#sendProposal setRole(role, isIn) Set a role for this peer. Parameters: Name Type Description role string The name of the role isIn boolean The boolean value of does this peer have this role  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Client Client A client instance provides the main API surface to interact with a network of peers and orderers. An application using the SDK may need to interact with multiple networks, each through a separate instance of the Client. An important aspect of the current design of the Client class is that it is stateful. An instance must be configured with a userContext before it can be used to talk to the fabric backend. A userContext is an instance of the User class, which encapsulates the ability to sign requests. If the SDK is used in a multi-user environment, there are two recommended techniques to manage the authenticated users and instances of clients. Use a dedicated client instance per authenticated user. Create a new instance for each authenticated user. You can enroll each authenticated user separately so that each user gets its own signing identity. Use a shared client instance and a common signing identity among authenticated users. It is important to understand that switching userContexts with the same client instance is considered an anti-pattern. This is the direct result of the stateful design. A JIRA work item has been opened to discuss adding support for stateless usage of the SDK: FAB-4563 The client also supports persistence via a stateStore. A state store is a simple storage plugin that implements the module:api.KeyValueStore interface, which helps the SDK save critical information to be used across server restarts/crashes. Out of the box, the SDK saves the signing identities (instances of the User class) in the state store. new Client() Extends BaseClient Methods &lt;async, static&gt; loadFromConfig(loadConfig) Load a common connection profile object or load a JSON file and return a Client object. Parameters: Name Type Description loadConfig object | string This may be the config object or a path to the configuration file Returns: An instance of this class initialized with the network end points. Type Client &lt;async&gt; _setUserFromConfig(opts) Utility Method Sets the user context based on the passed in username and password and the organization in the client section of the common connection profile settings. Parameters: Name Type Description opts Object contains - username [required] - username of the user - password [optional] - password of the user - caName [optional] - name of the Certificate Authority addConnectionOptions(options) Add a set of connection options to this client. These will be available to be merged into an application's options when new peers and orderers are created or when a channel uses discovery to automatically create the peers and orderers on the channel. This would be a convenient place to store common GRPC settings that affect all connections from this client. These settings will be used when this client object builds new Peer or Orderer instances when the Client#newPeer, Client#getPeer, Client#newOrderer or Client#getOrderer methods are called. Options will be automatically added when loading a common connection profile and the client section has the 'connection' section with an 'options' attribute. Default connection options will be initially loaded from the system configuration 'connection-options' setting. Parameters: Name Type Description options object The connection options that will be added to this client instance. addTlsClientCertAndKey(opts) Utility method to add the mutual tls client material to a set of options. Parameters: Name Type Description opts object The options object holding the connection settings that will be updated with the mutual TLS clientCert and clientKey. Throws: Will throw an error if generating the tls client material fails buildConnectionOptions(options) Utility method to merge connection options into a set of options and return a new options object. The client's options and default connection options will not override any passed settings by the same name, these will only be added as new settings to the application's options being passed in. see Client#addConnectionOptions for how this client will have connection options to merge. Parameters: Name Type Description options object The object holding the application options that will be merged on top of this client's options. Returns: - The object holding both the application's options and this client's options. Type object createChannel(request) Calls the orderer to start building the new channel. A channel typically has more than one participating organizations. To create a new channel, one of the participating organizations should call this method to submit the creation request to the orderer service. Once the channel is successfully created by the orderer, the next step is to have each organization's peer nodes join the channel, by sending the channel configuration to each of the peer nodes. The step is accomplished by calling the joinChannel() method. Parameters: Name Type Description request ChannelRequest The request object. Returns: Promise for a result object with status on the acceptance of the create request by the orderer. Note that this is not the confirmation of successful creation of the channel. The client application must poll the orderer to discover whether the channel has been created completely or not. Type Promise &lt;async&gt; createUser(opts) Returns a User object with signing identities based on the private key and the corresponding x509 certificate. This allows applications to use pre-existing crypto materials (private keys and certificates) to construct user objects with signing capabilities, as an alternative to dynamically enrolling users with fabric-ca Note that upon successful creation of the new user object, it is set to the client instance as the current userContext. Parameters: Name Type Description opts UserOpts Essential information about the user Returns: Promise for the user object. Type Promise extractChannelConfig(config_envelope) Extracts the protobuf 'ConfigUpdate' object out of the 'ConfigEnvelope' object that is produced by the configtxgen tool. The returned object may then be signed using the signChannelConfig() method of this class. Once the all signatures have been collected, the 'ConfigUpdate' object and the signatures may be used on the createChannel() or updateChannel() calls. Parameters: Name Type Description config_envelope Array.&lt;byte&gt; The encoded bytes of the ConfigEnvelope protobuf Returns: The encoded bytes of the ConfigUpdate protobuf, ready to be signed Type Array.&lt;byte&gt; getCertificateAuthority(name) Returns a CertificateAuthority implementation as defined by the settings in the currently loaded common connection profile and the client configuration. A common connection profile must be loaded for this get method to return a Certificate Authority. A crypto suite must be assigned to this client instance. Running the 'initCredentialStores' method will build the stores and create a crypto suite as defined in the common connection profile. Parameters: Name Type Description name string Optional - the name of the Certificate Authority defined in the loaded connection profile. Returns: Type CertificateAuthority getChannel(name, throwError) Get a Channel instance from the client instance. This is a memory-only lookup. If the loaded common connection profile has a channel by the 'name', a new channel instance will be created and populated with Orderer objects and Peer objects as defined in the common connection profile. Parameters: Name Type Default Description name string Optional. The name of the channel. When omitted the first channel defined in the loaded common connection profile will be returned throwError boolean true Indicates if this method will throw an error if the channel is not found. Default is true. Returns: The channel instance Type Channel getClientCertHash(create) Get the client certificate hash Parameters: Name Type Description create boolean Optional. Create the hash based on the current user if the client cert has not been assigned to this client Returns: The hash of the client certificate Type Array.&lt;byte&gt; getClientConfig() Returns the \"client\" section of the common connection profile. Returns: The client section from the configuration Type object getMspid() Returns the mspid of the client. The mspid is also used as the reference to the organization. Returns: the mspid of the organization defined in the client section of the loaded common connection profile Type string getOrderer(name) This method will create the Orderer if it does not exist and hold a reference to the instance object by name. This method is only able to create an instance of an orderer if there is a loaded connection profile that contains an orderer with the name. Orderers that have been created by the newOrderer method may be reference by the url if no name was provided in the options. Parameters: Name Type Description name string The name or url of the orderer Returns: The Orderer instance. Type Orderer getPeer(name) This method will create a Peer instance. This method is only able to create an instance of a peer if there is a loaded connection profile that contains a peer with the name. Parameters: Name Type Description name string The name of the peer Returns: The Peer instance. Type Peer getPeersForOrg(mspid) Returns a list of Peer for the mspid of an organization as defined in the currently loaded common connection profile. If no id is provided then the organization named in the currently active network configuration's client section will be used. Parameters: Name Type Description mspid string Optional - The mspid of an organization Returns: An array of Peer instances that are defined for this organization Type Array.&lt;Peer&gt; getStateStore() A convenience method for obtaining the state store object in use by this client. Returns: The KeyValueStore implementation object set on this Client, or null if one has not been set. Type module:api.KeyValueStore &lt;async&gt; getUserContext(name, checkPersistence) Returns the user by the given name. This can be a synchronous call or asynchronous call, depending on whether \"checkPersistent\" is truthy or not. If truthy, the method is asynchronous and returns a Promise, otherwise it's synchronous. As explained above, the client instance can have an optional state store. The SDK saves enrolled users in the storage which can be accessed by authorized users of the application (authentication is done by the application outside of the SDK). This function attempts to load the user by name from the local storage (via the KeyValueStore interface). The loaded user object must represent an enrolled user with a valid enrollment certificate signed by a trusted CA (such as the CA server). Parameters: Name Type Description name string Optional. If not specified, will only return the current in-memory user context object, or null if none has been set. If \"name\" is specified, will also attempt to load it from the state store if search in memory failed. checkPersistence boolean Optional. If specified and truthy, the method returns a Promise and will attempt to check the state store for the requested user by the \"name\". If not specified or falsey, the method is synchronous and returns the requested user from memory Returns: Promise for the user object corresponding to the name, or null if the user does not exist or if the state store has not been set. Type Promise.&lt;User&gt; &lt;async&gt; initCredentialStores() Sets the state and crypto suite for use by this client. This requires that a common connection profile has been loaded. Will use the settings from the common connection profile along with the system configuration to build instances of the stores and assign them to this client and the crypto suites if needed. &lt;async&gt; installChaincode(request, timeout) A chaincode must be installed to peers and instantiated on a channel before it can be called to process transactions. Chaincode installation is simply uploading the chaincode source and dependencies to the peers. This operation is \"channel-agnostic\" and is performed on a peer-by-peer basis. Only the peer organization's ADMIN identities are allowed to perform this operation. Parameters: Name Type Description request Deprecated_ChaincodeInstallRequest The request object timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Deprecated: Yes Returns: A Promise for a ProposalResponseObject Type Promise isDevMode() Determine if the fabric backend is started in development mode. In development mode, the endorsing peers will not attempt to spin up a docker instance to run the target chaincode requested by a transaction proposal, but instead redirect the invocation requests to the chaincode process that has registered itself with the endorsing peer. This makes it easier to test changes to the chaincode during chaincode development. The client instance can be set to dev mode to reflect the backend's development mode. This will cause the SDK to make adjustments in certain behaviors such as not sending the chaincode package to the peers during chaincode install. &lt;async&gt; loadFromConfig(config) Load a common connection profile object or load a JSON file and update this client with any values in the config. Parameters: Name Type Description config object | string This may be the config object or a path to the configuration file &lt;async&gt; loadUserFromStateStore(name) Restore the state of the User by the given name from the key value store (if found). If not found, return null. Parameters: Name Type Description name string Name of the user Returns: A Promise for a {User} object upon successful restore, or if the user by the name does not exist in the state store, returns null without rejecting the promise Type Promise newChaincode(name, version) Returns a Chaincode instance with the given name. This represents an administrative object to be used when an application is maintaining the lifecycle of chaincode. Parameters: Name Type Description name string version string Returns: a new instance of Chaincode. Type Chaincode newChannel(name) Returns a Channel instance with the given name. This represents a channel and its associated ledger. Parameters: Name Type Description name string The name of the channel. Recommend using namespaces to avoid collision. Returns: The uninitialized channel instance. Type Channel newOrderer(url, opts) Returns an Orderer object with the given url and opts. An orderer object encapsulates the properties of an orderer node and the interactions with it via the grpc stream API. Orderer objects are used by the Client objects to broadcast requests for creating and updating channels. They are used by the Channel objects to broadcast requests for ordering transactions. This method will create the orderer. Parameters: Name Type Description url string The URL with format of \"grpc(s)://host:port\". opts ConnectionOpts The options for the connection to the orderer. Returns: The Orderer instance. Type Orderer newPeer(url, opts) Returns a Peer object with the given url and opts. A peer object encapsulates the properties of an endorsing peer and the interactions with it via the grpc service API. Peer objects are used by the Client objects to send channel-agnostic requests such as installing chaincode, querying peers for installed chaincodes, etc. They are also used by the Channel objects to send channel-aware requests such as instantiating chaincodes, and invoking transactions. This method will return a new Peer object. Parameters: Name Type Description url string The URL with format of \"grpc(s)://host:port\". opts ConnectionOpts The options for the connection to the peer. Returns: The Peer instance. Type Peer newTransactionID(admin) Returns a new TransactionID object. Fabric transaction ids are constructed as a hash of a nonce concatenated with the signing identity's serialized bytes. The TransactionID object keeps the nonce and the resulting id string bundled together as a coherent pair. This method requires the client instance to have been assigned a userContext. Parameters: Name Type Description admin boolean If true, this transactionID should be built based on the admin credentials Default is a non admin TransactionID based on the userContext. Returns: An object that contains a transaction id based on the client's userContext and a randomly generated nonce value. Type TransactionID &lt;async&gt; queryChannels(peer, useAdmin) Queries the target peer for the names of all the channels that a peer has joined. Parameters: Name Type Description peer Peer The target peer to send the query useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. An administrative identity must have been loaded by common connection profile or by using the 'setAdminSigningIdentity' method. Returns: A promise to return a ChannelQueryResponse Type Promise &lt;async&gt; queryInstalledChaincodes(peer, useAdmin) Queries the installed chaincodes on a peer. Parameters: Name Type Description peer Peer The target peer useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. An administrative identity must have been loaded by common connection profile or by using the 'setAdminSigningIdentity' method. Returns: Promise for a ChaincodeQueryResponse object Type Promise &lt;async&gt; queryPeers(request) Queries the target peer for a list of Peer objects of all peers known by the target peer. Parameters: Name Type Description request PeerQueryRequest The request parameters. Returns: The list of peer information Type PeerQueryResponse &lt;async&gt; saveUserToStateStore() Persist the current userContext to the key value store. Returns: A Promise for the userContext object upon successful persistence Type Promise &lt;async&gt; setAdminSigningIdentity(private_key, certificate, mspid) Set the admin signing identity object. This method will only assign a signing identity for use by this client instance and will not persist the identity. Parameters: Name Type Description private_key string the private key PEM string certificate string the PEM-encoded string of certificate mspid string The Member Service Provider id for the local signing identity setDevMode(devMode) Set dev mode to true or false to reflect the mode of the fabric backend. See Client#isDevMode for details. Parameters: Name Type Description devMode boolean setStateStore(keyValueStore) Set an optional state store to persist application states. The state store must implement the module:api.KeyValueStore interface. The SDK supports persisting the User objects so that the heavy-weight objects such as the certificate and private keys do not have to be passed in repeatedly. Out of the box the SDK provides a file-based implementation, and a CouchDB-based implementation, which also supports Cloudant. Applications can provide alternative implementations. Parameters: Name Type Description keyValueStore module:api.KeyValueStore Instance of a KeyValueStore implementation setTlsClientCertAndKey(clientCert, clientKey) Sets the mutual TLS client side certificate and key necessary to build network endpoints when working with a common connection profile (connection profile). This must be called before a peer, orderer, or channel eventhub is needed. If the tls client material has not been provided for the client, it will be generated if the user has been assigned to this client. Note that it will always use the default software cryptosuite, not the one assigned to the client. Parameters: Name Type Description clientCert string The pem encoded client certificate. clientKey Array.&lt;byte&gt; The client key. &lt;async&gt; setUserContext(user, skipPersistence) Sets an instance of the User class as the security context of this client instance. This users signing identity (the private key and its corresponding certificate), will be used to sign all requests with the fabric backend. Upon setting the user context, the SDK saves the object in a persistence cache if the state store has been set on the Client instance. If no state store has been set, this cache will not be established and the application is responsible for setting the user context again if the application crashes and is recovered. Parameters: Name Type Description user User | UserNamePasswordObject An instance of the User class encapsulating the authenticated users signing materials (private key and enrollment certificate). The parameter may also be a UserNamePasswordObject that contains the username and optionally the password and caName. A common connection profile must has been loaded to use the UserNamePasswordObject which will also create the user context and set it on this client instance. The created user context will be based on the current network configuration( i.e. the current organization's CA, current persistence stores). skipPersistence boolean Whether to skip saving the user object into persistence. Default is false and the method will attempt to save the user object to the state store. When using a common connection profile and UserNamePasswordObject, the user object will always be stored to the persistence store. Returns: Promise of the 'user' object upon successful persistence of the user to the state store Type Promise signChannelConfig(loadConfig) Channel configuration updates can be sent to the orderers to be processed. The orderer enforces the Channel creation or update policies such that the updates will be made only when enough signatures from participating organizations are discovered in the request. Typically channel creation or update requests must be signed by participating organizations' ADMIN principals, although this policy can be customized when the consortium is defined. This method uses the client instance's current signing identity to sign over the configuration bytes passed in, and returns the signature that is ready to be included in the configuration update protobuf message to send to the orderer. Parameters: Name Type Description loadConfig Array.&lt;byte&gt; The Configuration Update in byte form Returns: - The signature of the current user on the config bytes Type ConfigSignature updateChannel(request) Calls the orderer to update an existing channel. After the channel updates are successfully processed by the orderer, the orderer cuts a new block containing the new channel configuration and delivers it to all the participating peers in the channel. Parameters: Name Type Description request ChannelRequest The request object. Returns: Promise for a result object with status on the acceptance of the update request by the orderer. A channel update is finally completed when the new channel configuration block created by the orderer has been committed to the channel's peers. To be notified of the successful update of the channel, an application should use the ChannelEventHub to connect to the peers and register a block listener. Type Promise  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"CommitHandler.html":{"id":"CommitHandler.html","title":"Class: CommitHandler","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: CommitHandler CommitHandler Base class for commit handling new CommitHandler() Methods &lt;static&gt; create() This static method will be called by the channel to create an instance of this handler. It will be passed the channel object this handler is working with. commit(params) This method will process the parameters to determine the orderers. The handler will use the provided orderers or use the orderers assigned to the channel. The handler is expected to preform failover and use all available orderers to send the endorsed transaction. Parameters: Name Type Description params CommitHandlerParameters A CommitHandlerParameters Returns: A Promise for the BroadcastResponse, the same results as calling the Channel#sendTransaction method directly. Type Promise initialize() This method will be called by the channel when the channel is initialized.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"DiscoveryEndorsementHandler.html":{"id":"DiscoveryEndorsementHandler.html","title":"Class: DiscoveryEndorsementHandler","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: DiscoveryEndorsementHandler DiscoveryEndorsementHandler This is an implementation of the EndorsementHandler API. It will submit transactions to be endorsed to a target list generated from the results of service discovery. new DiscoveryEndorsementHandler(channel) constructor Parameters: Name Type Description channel Channel The channel for this handler. Extends EndorsementHandler Methods &lt;static&gt; create(channel) Factory method to create an instance of an endorsement handler. Parameters: Name Type Description channel Channel the channel instance that this endorsement handler will be servicing. Returns: The instance of the handler Type DiscoveryEndorsementHandler endorse(params) This method will process the request object to calculate the target peers. Once the targets have been determined, the channel to send the endorsement transaction to all targets. The results will be analyzed to see if enough completed endorsements have been received. Parameters: Name Type Description params EndorsementHandlerParameters A EndorsementHandlerParameters that contains enough information to determine the targets and contains a ChaincodeInvokeRequest to be sent using the included channel with the Channel 'sendTransactionProposal' method. Inherited From: EndorsementHandler#endorse Overrides: EndorsementHandler#endorse Returns: A Promise for the ProposalResponseObject, the same results as calling the Channel#sendTransactionProposal method directly. Type Promise initialize() This method will be called by the channel when the channel is initialized. Inherited From: EndorsementHandler#initialize Overrides: EndorsementHandler#initialize  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"EndorsementHandler.html":{"id":"EndorsementHandler.html","title":"Class: EndorsementHandler","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: EndorsementHandler EndorsementHandler Base class for endorsement handling new EndorsementHandler() Methods &lt;static&gt; create() This static method will be called by the channel to create an instance of this handler. It will be passed the channel object this handler is working with. endorse(params) This method will process the request object to calculate the target peers. Once the targets have been determined, the channel to send the endorsement transaction to all targets. The results will be analyzed to see if enough completed endorsements have been received. Parameters: Name Type Description params EndorsementHandlerParameters A EndorsementHandlerParameters that contains enough information to determine the targets and contains a ChaincodeInvokeRequest to be sent using the included channel with the Channel 'sendTransactionProposal' method. Returns: A Promise for the ProposalResponseObject, the same results as calling the Channel#sendTransactionProposal method directly. Type Promise initialize() This method will be called by the channel when the channel is initialized.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"EndorsementPolicy.html":{"id":"EndorsementPolicy.html","title":"Class: EndorsementPolicy","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: EndorsementPolicy EndorsementPolicy Governs the constructions of endorsement policies to be passed into the calls to instantiate chaincodes new EndorsementPolicy() Methods &lt;static&gt; buildPolicy(msps, policy [, returnProto]) Constructs an endorsement policy envelope. If the optional \"policy\" object is not present, a default policy of \"a signature by any member from any of the organizations corresponding to the array of member service providers\" is returned. Parameters: Name Type Argument Description msps Array.&lt;MSP&gt; Array of Member Service Provider objects representing the participants of the endorsement policy to be constructed policy Policy The policy specification. It has two high-level properties: identities and policy. see the type definition of Policy for details. returnProto boolean &lt;optional&gt; Optional. If the return value should be in bytes or protobuf.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"Endpoint.html":{"id":"Endpoint.html","title":"Class: Endpoint","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Endpoint Endpoint The Endpoint class represents a remote grpc or grpcs target new Endpoint(url, pem, clientKey, clientCert) Parameters: Name Type Description url string pem string clientKey string clientCert string Methods isTLS() Determine whether or not this endpoint uses TLS. Returns: True if this endpoint uses TLS, false otherwise. Type boolean  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"event_hub_number.html":{"id":"event_hub_number.html","title":"Class: event_hub_number","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: event_hub_number event_hub_number new event_hub_number() Transaction processing in fabric v1.1 is a long operation spanning multiple components (application, endorsing peer, orderer, committing peer) and takes a relatively lengthy period of time (think seconds instead of milliseconds) to complete. As a result the applications must design their handling of the transaction lifecycle in an asynchronous fashion. After the transaction proposal has been successfully endorsed, and before the transaction message has been successfully sent to the orderer, the application should register a listener to be notified when the transaction achieves finality, which is when the block containing the transaction gets added to the peer's ledger/blockchain. Fabric committing peers provide a block delivery service to publish blocks or filtered blocks to connected fabric-clients. See connect on connection options and how this ChannelEventHub may connect to the fabric service. For more information on the service see deliver. A block gets published whenever the committing peer adds a validated block to the ledger. When a fabric-client receives a block it will investigate the block and notify interested listeners with the related contents of the block (e.g. transactionId, status). There are three types of listeners that will get notified by the fabric-client after it receives a published block from the fabric deliver service. A \"block listener\" gets called for every block received. The listener will be passed a fully decoded Block object unless the connection to the fabric service is using filtered blocks. See registerBlockEvent A \"transaction listener\" gets called when the specific transaction is committed (discovered inside a published block). The listener may also be registered to listen to \"all\" transactions. The listener will be passed the transaction id, transaction status and block number. See registerTxEvent A \"chaincode event listener\" gets called when a specific chaincode event is discovered within a block. The listener will be passed the block number, transaction id, and transaction status. The ChaincodeEvent will be also be passed, however the payload of the event will not be passed if the connection to the fabric service is publishing filtered blocks. See registerChaincodeEvent When the fabric-client connects to the peer, it tells the peer which block to begin delivering from. If no start block is provided, then the client will only receive events for the most recently committed block onwards. To avoid missing events in blocks that are published while the client is crashed/offline, the client should record the most recently processed block, and resume event delivery from this block number on startup. In this way, there is no custom recovery path for missed events, and the normal processing code may execute instead. You may also include an endBlock number if you wish to stop listening after receiving a range of events. Example const eh = channel.newChannelEventHub(peer); // register the listener before calling \"connect()\" so there // is an error callback ready to process an error in case the // connect() call fails eh.registerTxEvent( 'all', // this listener will be notified of all transactions (tx, status, block_num) =&gt; { record(tx, status, block_num); console.log(util.format('Transaction %s has completed', tx)); }, (err) =&gt; { eh.unregisterTxEvent('all'); reportError(err); console.log(util.format('Error %s! Transaction listener has been ' + 'deregistered for %s', err, eh.getPeerAddr())); } ); eh.connect();  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"FabricCAClient.html":{"id":"FabricCAClient.html","title":"Class: FabricCAClient","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: FabricCAClient FabricCAClient Client for communciating with the Fabric CA APIs new FabricCAClient(connect_opts) constructor Parameters: Name Type Description connect_opts object Connection options for communicating with the Fabric CA server Properties Name Type Description protocol string The protocol to use (either HTTP or HTTPS) hostname string The hostname of the Fabric CA server endpoint port number The port of the Fabric CA server endpoint tlsOptions TLSOptions The TLS settings to use when the Fabric CA endpoint uses \"https\" caname string The optional name of the CA. Fabric-ca servers support multiple Certificate Authorities from a single server. If omitted or null or an empty string, then the default CA is the target of requests Throws: Will throw an error if connection options are missing or invalid Methods enroll(enrollmentID, enrollmentSecret, csr, profile, attr_reqs) Enroll a registered user in order to receive a signed X509 certificate Parameters: Name Type Description enrollmentID string The registered ID to use for enrollment enrollmentSecret string The secret associated with the enrollment ID csr string PEM-encoded PKCS#10 certificate signing request profile string The profile name. Specify the 'tls' profile for a TLS certificate; otherwise, an enrollment certificate is issued. attr_reqs Array.&lt;AttributeRequest&gt; An array of AttributeRequest Throws: Will throw an error if all parameters are not provided Will throw an error if calling the enroll API fails for any reason Returns: EnrollmentResponse Type Promise newAffiliationService() Create a new AffiliationService instance Returns: instance Type AffiliationService newCertificateService() Create a new CertificateService instance Returns: instance Type CertificateService newIdentityService() Creates a new IdentityService instance Returns: instance Type IdentityService reenroll(csr, signingIdentity, attr_reqs) Re-enroll an existing user. Parameters: Name Type Description csr string PEM-encoded PKCS#10 certificate signing request signingIdentity SigningIdentity The instance of a SigningIdentity encapsulating the signing certificate, hash algorithm and signature algorithm attr_reqs Array.&lt;AttributeRequest&gt; An array of AttributeRequest Returns: EnrollmentResponse Type Promise register(enrollmentID, enrollmentSecret, role, affiliation, maxEnrollments, attrs, signingIdentity) Register a new user and return the enrollment secret Parameters: Name Type Description enrollmentID string ID which will be used for enrollment enrollmentSecret string Optional enrollment secret to set for the registered user. If not provided, the server will generate one. When not including, use a null for this parameter. role string Optional type of role for this user. When not including, use a null for this parameter. affiliation string Affiliation with which this user will be associated maxEnrollments number The maximum number of times the user is permitted to enroll attrs Array.&lt;KeyValueAttribute&gt; Array of key/value attributes to assign to the user signingIdentity SigningIdentity The instance of a SigningIdentity encapsulating the signing certificate, hash algorithm and signature algorithm Returns: The enrollment secret to use when this user enrolls Type Promise revoke(enrollmentID, aki, serial, reason, gencrl, signingIdentity) Revoke an existing certificate (enrollment certificate or transaction certificate), or revoke all certificates issued to an enrollment id. If revoking a particular certificate, then both the Authority Key Identifier and serial number are required. If revoking by enrollment id, then all future requests to enroll this id will be rejected. Parameters: Name Type Description enrollmentID string ID to revoke aki string Authority Key Identifier string, hex encoded, for the specific certificate to revoke serial string Serial number string, hex encoded, for the specific certificate to revoke reason string The reason for revocation. See https://godoc.org/golang.org/x/crypto/ocsp for valid values gencrl bool GenCRL specifies whether to generate a CRL signingIdentity SigningIdentity The instance of a SigningIdentity encapsulating the signing certificate, hash algorithm and signature algorithm Returns: The revocation results Type Promise  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"FabricCAServices.html":{"id":"FabricCAServices.html","title":"Class: FabricCAServices","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: FabricCAServices FabricCAServices This is an implementation of the member service client which communicates with the Fabric CA server. new FabricCAServices(url, tlsOptions, caName, cryptoSuite) constructor Parameters: Name Type Description url string | object The endpoint URL for Fabric CA services of the form: \"http://host:port\" or \"https://host:port\" When this parameter is an object then it must include the parameters listed as key value pairs. tlsOptions TLSOptions The TLS settings to use when the Fabric CA services endpoint uses \"https\" caName string The optional name of the CA. Fabric-ca servers support multiple Certificate Authorities from a single server. If omitted or null or an empty string, then the default CA is the target of requests cryptoSuite CryptoSuite The optional cryptoSuite instance to be used if options other than defaults are needed. If not specified, an instance of CryptoSuite will be constructed based on the current configuration settings: - crypto-hsm: use an implementation for Hardware Security Module (if set to true) or software-based key management (if set to false) - crypto-keysize: security level, or key size, to use with the digital signature public key algorithm. Currently ECDSA is supported and the valid key sizes are 256 and 384 - crypto-hash-algo: hashing algorithm - key-value-store: some CryptoSuite implementation requires a key store to persist private keys. A CryptoKeyStore is provided for this purpose, which can be used on top of any implementation of the KeyValueStore interface, such as a file-based store or a database-based one. The specific implementation is determined by the value of this configuration setting. Extends BaseClient Methods &lt;async&gt; enroll(req) Enroll the member and return an opaque member object. Parameters: Name Type Description req the EnrollmentRequest If the request contains the field \"csr\", this csr will be used for getting the certificate from Fabric-CA. Otherwise , a new private key will be generated and be used to generate a csr later. Returns: If the request does not contain the field \"csr\", the returned promise resolves an Enrollment object with \"key\" for the new generated private key. If the request contains the field \"csr\", the resolved Enrollment object does not contain the property \"key\". Type Promise.&lt;Enrollment&gt; generateCRL(request, registrar) Parameters: Name Type Description request Restriction registrar User The identity of the registrar (i.e. who is performing the revocation) Returns: The Certificate Revocation List (CRL) Type Promise getCaName() Returns the name of the certificate authority. Returns: caName Type string newAffiliationService() Create a new AffiliationService object Returns: object Type AffiliationService newCertificateService() Create a new CertificateService instance Returns: object Type CertificateService newIdentityService() Creates a new IdentityService object Returns: object Type IdentityService reenroll(currentUser, Optional) Re-enroll the member in cases such as the existing enrollment certificate is about to expire, or it has been compromised Parameters: Name Type Description currentUser User The identity of the current user that holds the existing enrollment certificate Optional Array.&lt;AttributeRequest&gt; an array of AttributeRequest that indicate attributes to be included in the certificate Returns: Promise for an object with \"key\" for private key and \"certificate\" for the signed certificate register(req, registrar) Register the member and return an enrollment secret. Parameters: Name Type Description req RegisterRequest The RegisterRequest registrar User . The identity of the registrar (i.e. who is performing the registration) Returns: The enrollment secret to use when this user enrolls Type Promise revoke(request, registrar) Revoke an existing certificate (enrollment certificate or transaction certificate), or revoke all certificates issued to an enrollment id. If revoking a particular certificate, then both the Authority Key Identifier and serial number are required. If revoking by enrollment id, then all future requests to enroll this id will be rejected. Parameters: Name Type Description request Object Request object with the following fields: - enrollmentID {string}. ID to revoke - aki {string}. Authority Key Identifier string, hex encoded, for the specific certificate to revoke - serial {string}. Serial number string, hex encoded, for the specific certificate to revoke - reason {string}. The reason for revocation. See https://godoc.org/golang.org/x/crypto/ocsp - gencrl {bool}. GenCRL specifies whether to generate a CRL for valid values. The default value is 0 (ocsp.Unspecified). registrar User The identity of the registrar (i.e. who is performing the revocation) Returns: The revocation results Type Promise toString() return a printable representation of this object  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"IdentityService.html":{"id":"IdentityService.html","title":"Class: IdentityService","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: IdentityService IdentityService This is an implementation of the Identity service which communicates with the Fabric CA server using the Fabric CA client FabricCAClient. new IdentityService() Methods create(req, registrar) Create a new identity with the Fabric CA server. An enrollment secret is returned which can then be used, along with the enrollment ID, to enroll a new identity. The caller must have `hf.Registrar` authority. Parameters: Name Type Description req IdentityRequest The IdentityRequest registrar User The identity of the registrar (i.e. who is performing the registration). Returns: Return the secret of this new identity Type Promise delete(enrollmentID, registrar, force) Delete an existing identity. The caller must have `hf.Registrar` authority. Parameters: Name Type Description enrollmentID string registrar User force boolean Optional. With force, some identity can delete itself Returns: ServiceResponse Type Promise getAll(registrar) Get all identities that the registrar is entitled to see. Parameters: Name Type Description registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise getOne(enrollmentID, registrar) Get an identity. The caller must have `hf.Registrar` authority. Parameters: Name Type Description enrollmentID string Required. The enrollment ID which uniquely identifies an identity registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise update(enrollmentID, req, registrar) Update an existing identity. The caller must have `hf.Registrar` authority. Parameters: Name Type Description enrollmentID string req IdentityRequest registrar User Returns: ServiceResponse Type Promise  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.html":{"id":"module-fabric-network.html","title":"Module: fabric-network","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Module: fabric-network Overview This module provides a higher level API for interacting with smart contracts, and is the recommended API for client applications to interact with smart contracts deployed to a Hyperledger Fabric blockchain network. Note that administrative capabilities, such as installing and starting smart contracts, are not currently provided by this API. For these tasks or other specific advanced usage, the lower level fabric-client API should be used. Access to related fabric-client objects is provided through the fabric-network API objects. TypeScript definitions are included in this module. Getting started The entry point used to interact with a Hyperledger Fabric blockchain network is the Gateway class. Once instantiated, this long-living object provides a reusable connection to a peer within the blockchain network, and enables access to any of the blockchain Networks (channels) for which that peer is a member. This in turn provides access to Smart Contracts (chaincode) running within that blockchain network, and to which Transactions can be submitted or queries can be evaluated. Private data can be submitted to transactions as transient data to prevent it from being recorded on the ledger. Example // Obtain the smart contract with which our application wants to interact const wallet = await Wallets.newFileSystemWallet(walletDirectoryPath); const gatewayOptions: GatewayOptions = { identity: 'user@example.org', // Previously imported identity wallet, }; const gateway = new Gateway(); await gateway.connect(commonConnectionProfile, gatewayOptions); const network = await gateway.getNetwork(channelName); const contract = network.getContract(chaincodeId); // Submit transactions for the smart contract const args = [arg1, arg2]; const submitResult = await contract.submitTransaction(\"transactionName\", ...args); // Evaluate queries for the smart contract const evalResult = await contract.evaluateTransaction(\"transactionName\", ...args); // Create and submit transactions for the smart contract with transient data const transientResult = await contract.createTransaction(transactionName) .setTransient(privateData) .submit(arg1, arg2); Classes BaseCheckpointer BaseEventListener CommitEventListener Contract ContractEventListener EventHubDisconnectError EventServiceManager FabricError FileSystemCheckpointer Gateway HsmX509Provider IdentityProviderRegistry Network TimeoutError Transaction Wallet Wallets Type Definitions DefaultEventHandlerStrategies Properties: Name Type Description MSPID_SCOPE_ALLFORTX Listen for transaction commit events from all peers in the client identity's organization. The submitTransaction function will wait until successful events are received from all currently connected peers (minimum 1). MSPID_SCOPE_ANYFORTX Listen for transaction commit events from all peers in the client identity's organization. The submitTransaction function will wait until a successful event is received from any peer. NETWORK_SCOPE_ALLFORTX Listen for transaction commit events from all peers in the network. The submitTransaction function will wait until successful events are received from all currently connected peers (minimum 1). NETWORK_SCOPE_ANYFORTX Listen for transaction commit events from all peers in the network. The submitTransaction function will wait until a successful event is received from any peer. HsmOptions Options describing how to connect to a hardware security module. Options without default values are mandatory but may be be omitted from this object if they are specified through environment variables or external configuration. Type: object Properties: Name Type Argument Default Description lib string &lt;optional&gt; Path to implementation-specific PKCS#11 library used to interact with the HSM. pin string &lt;optional&gt; PIN used to access the HSM. slot number &lt;optional&gt; The hardware slot number where data is stored in the HSM. usertype number &lt;optional&gt; 1 Specify the user type for accessing the HSM. readwrite boolean &lt;optional&gt; true True if the session should be read/write; false if read-only. HsmX509Identity Identity described by an X.509 certificate where the private key is stored in a hardware security module. To use identities of this type, a suitable HsmX509Provider must be created and added to the identity provider registry of the wallet containing the identity. Type: object Properties: Name Type Description type 'HSM-X.509' The type of the identity. credentials.certificate string Certificate in PEM format. Implements: module:fabric-network.Identity Identity A base user identity. Actual identity objects will extend this basic structure with credentials applicable to their type. See X509Identity and HsmX509Identity. Type: object Properties: Name Type Description type string The type of the identity. mspId string The member services provider with which this identity is associated. IdentityProvider Understands the format of identities of a given type. Converts identity objects to/from the persistent format used within wallet stores, and configures the client with a given identity. Properties: Name Type Description type string The type identifier for identities that this provider understands. QueryHandlerStrategies Properties: Name Type Description MSPID_SCOPE_SINGLE function Query any one of the event services for the connected organisation. Continue to use the same event service for all queries unless it fails. MSPID_SCOPE_ROUND_ROBIN function Query any one of the event services for the connected organisation. Use the next available peer for each successive query. X509Identity Identity described by an X.509 certificate. Type: object Properties: Name Type Description type 'X.509' The type of the identity. credentials.certificate string Certificate in PEM format. credentials.privateKey string Private key in PEM format. Implements: module:fabric-network.Identity  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.BaseCheckpointer.html":{"id":"module-fabric-network.BaseCheckpointer.html","title":"Class: BaseCheckpointer","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: BaseCheckpointer fabric-network~ BaseCheckpointer Base checkpointer providing an interface for checkpointers new BaseCheckpointer(options) The constructor Parameters: Name Type Description options Object The options to configure the checkpointer Methods &lt;async&gt; check(blockNumber [, transactionId]) checks the storage mechanism for the transactionId and blockNumber. The transactionId is optional. Parameters: Name Type Argument Description blockNumber string transactionId string &lt;optional&gt; Returns: True when the block number or the block number and the transactionId have been seen by this checkpointer. Type boolean &lt;async&gt; getStartBlock() Returns a blockNumber of the last block received in order. May not be the last block received or be the highest block received if the blocks are received out of order. For example if blocks 1, 2, 4, 5 have been received, then block 2 should be returned, this is the last block before a break in receiving the blocks in order. The listening should start at block 2 since block 3 is missing. This method should only be used when using the checkpointer with a block listener or a commit listener that is listening for all transactions, other listeners will not receive all blocks. The event listeners will use the getBlockNumber() or getTransactionId() methods to avoid processing blocks/transactions that have been seen. Returns: The block number as string Type string &lt;async&gt; initialize() Initializes the checkpointer using the options provided when the instance was constructed &lt;async&gt; prune() Prunes the checkpointer store to be the same as the in memory checkpoints &lt;async&gt; save(blockNumber [, transactionId]) Updates the storage mechanism to save the checkpoint. Parameters: Name Type Argument Description blockNumber string The blockNumber of the checkpoint to save transactionId string &lt;optional&gt; Optional, The transactionId of the checkpoint to save Type Definitions Checkpoint Type: Object Properties: Name Type Argument Description blockNumber number transactionIds Array.&lt;string&gt; expectedTotal number &lt;optional&gt; The expected number of events in the block  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.BaseEventListener.html":{"id":"module-fabric-network.BaseEventListener.html","title":"Class: BaseEventListener","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: BaseEventListener fabric-network~ BaseEventListener Event listener base class handles initializing common properties across contract, transaction and block event listeners. Instances of the event listeners are stateful and must only be used for one low level listener new BaseEventListener(network, eventCallback, options) Constructor Parameters: Name Type Description network module:fabric-network.Network The network eventCallback function The function called when the event is triggered. It has signature (err, ...args) where args changes depending on the event type options module:fabric-network.Network~EventListenerOptions Event handler options Methods &lt;async&gt; onEvent(error, event) This is the callback used by the EventService for this registered listener Parameters: Name Type Description error Error An error causing this regisistered listener to be shutdown event EventInfo The block information of the triggered event &lt;async&gt; register() Called by the super classes register function. Saves information needed to start listening, and disconnects an event service if it is the incorrect type unregister() Called by the super classes unregister function.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.CommitEventListener.html":{"id":"module-fabric-network.CommitEventListener.html","title":"Class: CommitEventListener","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: CommitEventListener fabric-network~ CommitEventListener The Commit Event Listener handles transaction commit events new CommitEventListener(network, transactionId, eventCallback, options) Parameters: Name Type Description network module:fabric-network.Network The fabric network transactionId string the transaction id being listened to eventCallback function The event callback called when a transaction is committed. It has signature (err, transactionId, status, blockNumber) options module:fabric-network.Network~EventListenerOptions  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.Contract.html":{"id":"module-fabric-network.Contract.html","title":"Class: Contract","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Contract fabric-network~ Contract Represents a smart contract (chaincode) instance in a network. Applications should get a Contract instance using the networks's getContract method. new Contract() Methods &lt;async&gt; addContractListener(callback [, options] [, eventService]) Create a commit event listener for this transaction. Parameters: Name Type Argument Description callback function This callback will be triggered when a transaction commit event is emitted. It takes parameters of Error, Long, ChaincodeEvent[]. NOTE: All contract events contained within the block that match the eventName will be provided at one time to the callback. options module:fabric-network.Network~EventListenerOptions &lt;optional&gt; Optional. Options on registrations allowing start and end block numbers and an application event checkpointer eventService EventService &lt;optional&gt; Optional. Used to override the event service selection Returns: Type module:fabric-network~ContractEventListener createTransaction(name) Create an object representing a specific invocation of a transaction function implemented by this contract, and provides more control over the transaction invocation. A new transaction object must be created for each transaction invocation. Parameters: Name Type Description name String Transaction function name. Returns: A transaction object. Type module:fabric-network.Transaction &lt;async&gt; evaluateTransaction(name [, args]) Evaluate a transaction function and return its results. The transaction function name will be evaluated on the endorsing peers but the responses will not be sent to the ordering service and hence will not be committed to the ledger. This is used for querying the world state. This function is equivalent to calling createTransaction(name).evaluate(). Parameters: Name Type Argument Description name string Transaction function name. args string &lt;optional&gt; &lt;repeatable&gt; Transaction function arguments. Returns: Payload response from the transaction function. Type Buffer &lt;async&gt; submitTransaction(name [, args]) Submit a transaction to the ledger. The transaction function name will be evaluated on the endorsing peers and then submitted to the ordering service for committing to the ledger. This function is equivalent to calling createTransaction(name).submit(). Parameters: Name Type Argument Description name string Transaction function name. args string &lt;optional&gt; &lt;repeatable&gt; Transaction function arguments. Throws: If the transaction was successfully submitted to the orderer but timed out before a commit event was received from peers. Type module:fabric-network.TimeoutError Returns: Payload response from the transaction function. Type Buffer  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.ContractEventListener.html":{"id":"module-fabric-network.ContractEventListener.html","title":"Class: ContractEventListener","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: ContractEventListener fabric-network~ ContractEventListener The Contract Event Listener handles contract events from the chaincode. new ContractEventListener(contract, eventName, eventCallback, options) Constructor. Parameters: Name Type Description contract Contract The contract instance eventName string The name of the contract event being listened for eventCallback function The event callback called when an event is received. It has signature (err, BlockEvent, blockNumber, transactionId) options module:fabric-network.Network~EventListenerOptions  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.EventHubDisconnectError.html":{"id":"module-fabric-network.EventHubDisconnectError.html","title":"Class: EventHubDisconnectError","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: EventHubDisconnectError fabric-network~ EventHubDisconnectError Error when an event hub is disconnected. new EventHubDisconnectError() Properties: Name Type Argument Description message String &lt;optional&gt; The error message  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.EventServiceManager.html":{"id":"module-fabric-network.EventServiceManager.html","title":"Class: EventServiceManager","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: EventServiceManager fabric-network~ EventServiceManager The Event Service Manager is responsible for creating and distributing EventService instances. It uses the event Service factory to reuse event Services that exists, and maintains its own list of new event Services that are used for event replay new EventServiceManager(network) Constructor Parameters: Name Type Description network module:fabric-network.Network The network Methods dispose() Closes and deletes all event services getEventService( [blockType]) Gets an event Service. If given a peer, it will get that peer's event Service, otherwise it will get the next peer as defined by the event service pool. NOTE: The returned event service will not be able to replay events. Use the {@EventServiceManager#getReplayEventService} to get an event service capable of replay. Parameters: Name Type Argument Description blockType string &lt;optional&gt; The block type (filtered, full or private) that event service is receiving, the default will be filtered events Returns: The event Service Type EventService getEventServices( [peers]) Gets a list of EventServices for a list of peers Endorser provided. The returned event services will be receiving filtered blocks. If the peer list is not provided the event service selection strategy will be asked for it's full list of peers. Parameters: Name Type Argument Description peers Array.&lt;Endorser&gt; &lt;optional&gt; A list of endorser instances Returns: A list of event services Type Array.&lt;EventService&gt; getReplayEventService( [peer]) Gets an event Service instance for a given peer endpoint. Parameters: Name Type Argument Description peer Endorser &lt;optional&gt; An Endorser peer instance. If the peer is not provided, the next peer will be selected by the event service selection strategy. Returns: The event Service Type EventService newEventService(peers, name) This method will build fabric-common Eventers and the fabric-common EventService. The Eventers will not be connected to the endpoint at this time. Since the endorsers have been previously connected, the endpoint should be accessable. The EventService will check the connection and perform the connect during the send() when it starts the service. Parameters: Name Type Description peers Array.&lt;Endorser&gt; The Endorser service endpoints used to build a a list of Eventer service endpoints that will be used as the targets of the new EventService. name string The name of this new EventService &lt;async&gt; startEventService(eventService, options) Use this method to be sure the eventService has been connected and has been started. It will start the service based on the options provided. It will check that the a started service matches the options provided Parameters: Name Type Description eventService EventService EventService to be started if it not already started. options any The options to start the event service which may include blocktype, startBlock, endBlock.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.FabricError.html":{"id":"module-fabric-network.FabricError.html","title":"Class: FabricError","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: FabricError fabric-network~ FabricError Base type for Fabric-specific errors. new FabricError() Properties: Name Type Argument Description cause Error &lt;optional&gt; Underlying error that caused this error. transactionId string &lt;optional&gt; ID of the associated transaction.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.FileSystemCheckpointer.html":{"id":"module-fabric-network.FileSystemCheckpointer.html","title":"Class: FileSystemCheckpointer","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: FileSystemCheckpointer fabric-network~ FileSystemCheckpointer Created a checkpointer in a file per event listener new FileSystemCheckpointer(channelName, listenerName [, options]) Parameters: Name Type Argument Description channelName string listenerName string The name of the listener being checkpointer options module:fabric-network.FileSystemCheckpointer~FileSystemCheckpointerOptions &lt;optional&gt; Extends module:fabric-network~BaseCheckpointer Methods &lt;async&gt; check() &lt;async&gt; getStartBlock() &lt;async&gt; initialize() &lt;async&gt; prune() &lt;async&gt; save() Type Definitions FileSystemCheckpointerOptions Properties: Name Type Argument Description checkpointPath string The path to the checkpoint. maxLength number &lt;optional&gt; The maximum number of blocks that can be in the checkpointer. The default is 1000.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.Gateway.html":{"id":"module-fabric-network.Gateway.html","title":"Class: Gateway","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Gateway fabric-network~ Gateway The gateway peer provides the connection point for an application to access the Fabric network. It is instantiated using the default constructor. It can then be connected to a fabric network using the connect method by passing either a common connection profile definition or an existing Client object. Once connected, it can then access individual Network instances (channels) using the getNetwork method which in turn can access the smart contracts installed on a network and submit transactions to the ledger. new Gateway() Methods &lt;async&gt; connect(config, options) Connect to the Gateway with a connection profile or a prebuilt Client instance. Parameters: Name Type Description config string | object | Client The configuration for this Gateway which can be: A fully qualified common connection profile file path (String) A common connection profile JSON (Object) A pre-configured client instance options module:fabric-network.Gateway~GatewayOptions specific options for creating this Gateway instance Example const gateway = new Gateway(); const wallet = new FileSystemWallet('./WALLETS/wallet'); const ccpFile = fs.readFileSync('./network.json'); const ccp = JSON.parse(ccpFile.toString()); await gateway.connect(ccp, { identity: 'admin', wallet: wallet }); disconnect() Clean up and disconnect this Gateway connection in preparation for it to be discarded and garbage collected &lt;async&gt; getNetwork(networkName) Returns an object representing a network Parameters: Name Type Description networkName string The name of the network (channel name) Returns: Type module:fabric-network.Network getOptions() Returns the set of options associated with the Gateway connection Returns: The Gateway connection options Type module:fabric-network.Gateway~GatewayOptions Type Definitions DiscoveryOptions Type: Object Properties: Name Type Argument Default Description enabled boolean &lt;optional&gt; true True if discovery should be used; otherwise false. asLocalhost boolean &lt;optional&gt; false Convert discovered host addresses to be 'localhost'. Will be needed when running a docker composed fabric network on the local system; otherwise should be disabled. GatewayOptions Type: Object Properties: Name Type Argument Description wallet module:fabric-network.Wallet The identity wallet implementation for use with this Gateway instance. identity string The identity in the wallet for all interactions on this Gateway instance. clientTlsIdentity string &lt;optional&gt; The identity in the wallet to use as the client TLS identity. transaction module:fabric-network.Gateway~TransactionOptions &lt;optional&gt; Options for the default event handler capability. query module:fabric-network.Gateway~QueryOptions &lt;optional&gt; Options for the default query handler capability. discovery module:fabric-network.Gateway~DiscoveryOptions &lt;optional&gt; Discovery options. QueryHandler Type: Object Properties: Name Type Description evaluate function Async function that takes a Query and resolves with the result of the query evaluation. QueryHandlerFactory(network, options) Parameters: Name Type Description network module:fabric-network.Network The network on which queries are being evaluated. options Object The request options to use when queries are being evaluated. Returns: A query handler. Type module:fabric-network.Gateway~QueryHandler QueryOptions Type: Object Properties: Name Type Argument Default Description timeout number &lt;optional&gt; 30 The timeout period in seconds to wait for the query to complete. strategy module:fabric-network.Gateway~QueryHandlerFactory &lt;optional&gt; MSPID_SCOPE_SINGLE Query handling strategy used to evaluate queries. The default is MSPID_SCOPE_SINGLE. TransactionOptions Type: Object Properties: Name Type Argument Default Description commitTimeout number &lt;optional&gt; 300 The timeout period in seconds to wait for commit notification to complete. endorseTimeout number &lt;optional&gt; 30 The timeout period in seconds to wait for the endorsement to complete. strategy module:fabric-network.Gateway~TxEventHandlerFactory &lt;optional&gt; &lt;nullable&gt; MSPID_SCOPE_ALLFORTX Event handling strategy to identify successful transaction commits. A null value indicates that no event handling is desired. The default is MSPID_SCOPE_ALLFORTX. TxEventHandler Type: Object Properties: Name Type Description startListening function Async function that resolves when the handler has started listening for transaction commit events. Called after the transaction proposal has been accepted and prior to submission of the transaction to the orderer. waitForEvents function Async function that resolves (or rejects) when suitable transaction commit events have been received. Called after submission of the transaction to the orderer. cancelListening function Cancel listening. Called if submission of the transaction to the orderer fails. TxEventHandlerFactory(transaction, network) Parameters: Name Type Description transaction Transaction The transaction for which the handler should listen for commit events. network module:fabric-network.Network The network on which this transaction is being submitted. Returns: A transaction event handler. Type module:fabric-network.Gateway~TxEventHandler  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.HsmX509Provider.html":{"id":"module-fabric-network.HsmX509Provider.html","title":"Class: HsmX509Provider","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: HsmX509Provider fabric-network~ HsmX509Provider Identity provider to handle X.509 identities where the private key is stored in a hardware security module. new HsmX509Provider( [options]) Create a provider instance. Parameters: Name Type Argument Default Description options module:fabric-network.HsmOptions &lt;optional&gt; {} Options specifying how to connect to the HSM. Mandatory unless this information is provided through external configuration. Implements: module:fabric-network.IdentityProvider  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.IdentityProviderRegistry.html":{"id":"module-fabric-network.IdentityProviderRegistry.html","title":"Class: IdentityProviderRegistry","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: IdentityProviderRegistry fabric-network~ IdentityProviderRegistry Registry of identity providers for use by a wallet. new IdentityProviderRegistry() Methods addProvider(provider) Add a provider to the registry. Parameters: Name Type Description provider module:fabric-network.IdentityProvider Identity provider. getProvider(type) Get the provider for a given type from the registry. Throws an error if no provider for the type exists. Parameters: Name Type Description type string Identity type identifier. Returns: An identity provider. Type module:fabric-network.IdentityProvider  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.Network.html":{"id":"module-fabric-network.Network.html","title":"Class: Network","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Network fabric-network~ Network A Network represents the set of peers in a Fabric network. Applications should get a Network instance using the gateway's getNetwork method. new Network() Methods &lt;async&gt; addBlockListener(callback [, options] [, eventService]) Create a block event listener. Parameters: Name Type Argument Description callback function the function to be called when an event is triggered with signature (error, block) options module:fabric-network.Network~EventListenerOptions &lt;optional&gt; Optional. eventService EventService &lt;optional&gt; Optional. Used to override the event service selection Returns: Type module:fabric-network~BlockEventListener &lt;async&gt; addCommitListener(callback [, options] [, eventService]) Create a commit event listener for committed transactions. Parameters: Name Type Argument Description callback function the function to be called when an event is triggered with signature (error, block) options module:fabric-network.Network~EventListenerOptions &lt;optional&gt; Optional. eventService EventService &lt;optional&gt; Optional. Used to override the event service selection Returns: Type module:fabric-network~CommitEventListener getContract(chaincodeId [, name], {string[) Get an instance of a contract (chaincode) on the current network. Parameters: Name Type Argument Description chaincodeId string the chaincode identifier. name string &lt;optional&gt; the name of the contract. {string[ [collections] - the names of collections defined for this chaincode. Returns: the contract. Type module:fabric-network.Contract Type Definitions EventListenerOptions Type: Object Properties: Name Type Argument Default Description checkpointer Object a checkpointer instance replay boolean &lt;optional&gt; false event replay on listener filtered boolean &lt;optional&gt; true used to receive filtered block events or not privateData boolean &lt;optional&gt; false when receiving full blocks (filtered=false) include this user's private data, will be ignored when receiving filtered blocks and will only include private data this user is allowed to see unregister boolean &lt;optional&gt; unregisters the listener after first event is received startBlock number &lt;optional&gt; the first block to play events endBlock number &lt;optional&gt; the final block to play events transactionId string &lt;optional&gt; the transactionId to monitor for commit events. Only used for transaction commit events and will be ignored for other event types. The default is to call the application commit event listener on every transaction committed to the ledger.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.TimeoutError.html":{"id":"module-fabric-network.TimeoutError.html","title":"Class: TimeoutError","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: TimeoutError fabric-network~ TimeoutError Error indicating a timeout. new TimeoutError() Extends module:fabric-network.FabricError  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.Transaction.html":{"id":"module-fabric-network.Transaction.html","title":"Class: Transaction","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Transaction fabric-network~ Transaction Represents a specific invocation of a transaction function, and provides felxibility over how that transaction is invoked. Applications should obtain instances of this class by calling Contract#createTransaction(). Instances of this class are stateful. A new instance must be created for each transaction invocation. new Transaction() Methods &lt;async&gt; evaluate( [args]) Evaluate a transaction function and return its results. The transaction function will be evaluated on the endorsing peers but the responses will not be sent to the ordering service and hence will not be committed to the ledger. This is used for querying the world state. Parameters: Name Type Argument Description args String &lt;optional&gt; &lt;repeatable&gt; Transaction function arguments. Returns: Payload response from the transaction function. Type Buffer getNetwork() Returns the network from the contract Returns: Type module:fabric-network.Network setEndorsingOrganizations(orgs) Set the organizations that should be used for endorsement when this transaction is submitted to the ledger. Peers that are in the organizations will be used for the endorsement. This will override the setEndorsingPeers if previously called. Setting the endorsing organizations will not override discovery, however it will filter the peers provided by discovery to be those in these organizatons. Parameters: Name Type Argument Description orgs Array.&lt;string&gt; &lt;repeatable&gt; Endorsing organizations. Returns: This object, to allow function chaining. Type module:fabric-network.Transaction setEndorsingPeers(peers) Set the peers that should be used for endorsement when this transaction is submitted to the ledger. Setting the peers will override the use of discovery and the submit will send the proposal to these peers. This will override the setEndorsingOrganizations if previously called. Parameters: Name Type Description peers Array.&lt;Endorser&gt; Endorsing peers. Returns: This object, to allow function chaining. Type module:fabric-network.Transaction setEventHandlerStrategy(eventHandlerStrategyFactory) Override the Gateway option for event handler strategy Parameters: Name Type Description eventHandlerStrategyFactory * setTransient(transientMap) Set transient data that will be passed to the transaction function but will not be stored on the ledger. This can be used to pass private data to a transaction function. Parameters: Name Type Description transientMap Object Object with String property names and Buffer property values. Returns: This object, to allow function chaining. Type module:fabric-network.Transaction &lt;async&gt; submit( [args]) Submit a transaction to the ledger. The transaction function name will be evaluated on the endorsing peers and then submitted to the ordering service for committing to the ledger. Parameters: Name Type Argument Description args String &lt;optional&gt; &lt;repeatable&gt; Transaction function arguments. Throws: If the transaction was successfully submitted to the orderer but timed out before a commit event was received from peers. Type module:fabric-network.TimeoutError Returns: Payload response from the transaction function. Type Buffer  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.Wallet.html":{"id":"module-fabric-network.Wallet.html","title":"Class: Wallet","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Wallet fabric-network~ Wallet Stores identity information for use when connecting a Gateway. The wallet is backed by a store that handles persistence of identity information. Default implementations using various stores can be obtained using static factory functions on Wallets. new Wallet(store) Create a wallet instance backed by a given store. This can be used to create a wallet using your own custom store implementation. Parameters: Name Type Description store module:fabric-network.WalletStore Backing store implementation. Methods &lt;async&gt; get(label) Get an identity from the wallet. The actual properties of this identity object will vary depending on its type. Parameters: Name Type Description label Label used to identify the identity within the wallet. Returns: An identity if it exists; otherwise undefined. Type Promise.&lt;(module:fabric-network.Identity|undefined)&gt; getProviderRegistry() Get the identity provider registry for this wallet. All identity types stored in the wallet must have a corresponding provider in the registry. Returns: An identity provider registry. Type module:fabric-network.IdentityProviderRegistry &lt;async&gt; list() Get the labels of all identities in the wallet. Returns: Identity labels. Type Promise.&lt;Array.&lt;string&gt;&gt; &lt;async&gt; put(label, identity) Put an identity in the wallet. Parameters: Name Type Description label string Label used to identify the identity within the wallet. identity module:fabric-network.Identity Identity to store in the wallet. Returns: Type Promise.&lt;void&gt; &lt;async&gt; remove(label) Remove an identity from the wallet. Parameters: Name Type Description label Label used to identify the identity within the wallet. Returns: Type Promise.&lt;void&gt;  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.Wallets.html":{"id":"module-fabric-network.Wallets.html","title":"Class: Wallets","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Wallets fabric-network. Wallets Factory for creating wallets backed by default store implementations. new Wallets() Methods &lt;async, static&gt; newCouchDBWallet(config [, dbName]) Create a wallet backed by a CouchDB database. Parameters: Name Type Argument Default Description config string | nano.Configuration URL string or configuration for a CouchDB server. dbName string &lt;optional&gt; wallet Name of a database hosted on the CouchDB server. Returns: A wallet. Type Promise.&lt;module:fabric-network.Wallet&gt; &lt;async, static&gt; newFileSystemWallet(directory) Create a wallet backed by the provided file system directory. Parameters: Name Type Description directory string A directory path. Returns: A wallet. Type Promise.&lt;module:fabric-network.Wallet&gt; &lt;async, static&gt; newInMemoryWallet() Create a wallet backed by an in-memory (non-persistent) store. Each wallet instance created will have its own private in-memory store. Returns: A wallet. Type Promise.&lt;module:fabric-network.Wallet&gt;  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"module-fabric-network.WalletStore.html":{"id":"module-fabric-network.WalletStore.html","title":"Interface: WalletStore","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Interface: WalletStore fabric-network. WalletStore Interface for store implementations that provide backing storage for identities in a Wallet. Methods &lt;async&gt; get(label) Get data associated with a given label. Parameters: Name Type Description label string A label identifying stored data. Returns: Stored data as a Buffer if it exists; otherwise undefined. Type Promise.&lt;(Buffer|undefined)&gt; &lt;async&gt; list() List the labels for all stored data. Returns: A list of labels. Type Promise.&lt;Array.&lt;string&gt;&gt; &lt;async&gt; put(label, data) Put data associated with a given label. Parameters: Name Type Description label string A label identifying stored data. data Buffer Data to store. Returns: Type Promise.&lt;void&gt; &lt;async&gt; remove(label) Remove data associated with a given label. Parameters: Name Type Description label string A label identifying stored data. Returns: Type Promise.&lt;void&gt;  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"MSP.html":{"id":"MSP.html","title":"Class: MSP","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: MSP MSP MSP is the minimal Membership Service Provider Interface to be implemented to manage identities (in terms of signing and signature verification) represented by private keys and certificates generated from different algorithms (ECDSA, RSA, etc) and PKIs (software-managed or HSM based) new MSP(config) Setup the MSP instance according to configuration information Parameters: Name Type Description config Object A configuration object specific to the implementation. For this implementation it uses the following fields: `rootCerts`: array of Identity representing trust anchors for validating signing certificates. Required for MSPs used in verifying signatures `intermediateCerts`: array of Identity representing trust anchors for validating signing certificates. optional for MSPs used in verifying signatures `admins`: array of Identity representing admin privileges `signer`: SigningIdentity signing identity. Required for MSPs used in signing `id`: {string} value for the identifier of this instance `orgs`: {string} array of organizational unit identifiers `cryptoSuite': the underlying module:api.CryptoSuite for crypto primitive operations Methods &lt;async&gt; deserializeIdentity(serializedIdentity, storeKey) DeserializeIdentity deserializes an identity Parameters: Name Type Description serializedIdentity Array.&lt;byte&gt; A protobuf-based serialization of an object with two fields: mspid and idBytes for certificate PEM bytes storeKey boolean if the user should be stored in the key store. Only when false will a promise not be returned Returns: Promise for an Identity instance or or the Identity object itself if \"storeKey\" argument is false Type Promise getDefaultSigningIdentity() Returns the default signing identity Returns: Type SigningIdentity getId() Get provider identifier Returns: Type string getOrganizationUnits() Get organizational unit identifiers Returns: Type Array.&lt;string&gt; getPolicy() Obtain the policy to govern changes Returns: Type Object getSigningIdentity(identifier) Returns a signing identity corresponding to the provided identifier Parameters: Name Type Description identifier string The identifier of the requested identity object Returns: Type SigningIdentity toProtobuf() Returns the Protobuf representation of this MSP Config validate(id) Checks whether the supplied identity is valid Parameters: Name Type Description id Identity Returns: Type boolean  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"MSPManager.html":{"id":"MSPManager.html","title":"Class: MSPManager","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: MSPManager MSPManager MSPManager is an interface defining a manager of one or more MSPs. This essentially acts as a mediator to MSP calls and routes MSP related calls to the appropriate MSP. This object is immutable, it is initialized once and never changed. new MSPManager() Methods addMSP(config) Create and add MSP instance to this manager according to configuration information Parameters: Name Type Description config Object A configuration object specific to the implementation. For this implementation it uses the following fields: `rootCerts`: array of Identity representing trust anchors for validating signing certificates. Required for MSPs used in verifying signatures `intermediateCerts`: array of Identity representing trust anchors for validating signing certificates. optional for MSPs used in verifying signatures `admins`: array of Identity representing admin privileges `signer`: SigningIdentity signing identity. Required for MSPs used in signing `id`: {string} value for the identifier of this instance `orgs`: {string} array of organizational unit identifiers `cryptoSuite': the underlying module:api.CryptoSuite for crypto primitive operations Returns: The newly created MSP instance Type MSP deserializeIdentity(serializedIdentity) DeserializeIdentity deserializes an identity Parameters: Name Type Description serializedIdentity Array.&lt;byte&gt; A protobuf-based serialization of an object with two fields: mspid and idBytes for certificate PEM bytes Returns: Promise for an Identity instance Type Promise getMSP() Returns a validating MSP getMSPs() Returns the validating MSPs. Note that this does NOT return the local MSP loadMSPs(mspConfigs) Instantiates MSPs for validating identities (like the endorsor in the ProposalResponse). The MSPs loaded via this method require the CA certificate representing the Certificate Authority that signed the identities to be validated. They also optionally contain the certificates for the administrators of the organization that the CA certs represent. Parameters: Name Type Description mspConfigs protos/msp/mspconfig.proto An array of MSPConfig objects as defined by the protobuf protos/msp/mspconfig.proto  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"NetworkConfig.html":{"id":"NetworkConfig.html","title":"Class: NetworkConfig","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: NetworkConfig NetworkConfig This is an implementation of the NetworkConfig API. It will be used to work with the v1.0.1 version of a JSON based common connection profile. (also known as a network configuration). new NetworkConfig()  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"NetworkConfig_1_0.html":{"id":"NetworkConfig_1_0.html","title":"Class: NetworkConfig_1_0","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: NetworkConfig_1_0 NetworkConfig_1_0 This is an implementation of the NetworkConfig API. It will be used to work with the v1.0.1 version of a JSON based common connection profile. (also known as a network configuration). new NetworkConfig_1_0(network_config) constructor Parameters: Name Type Description network_config Object Common Connection Profile as represented in a JSON object Extends module:api.NetworkConfig Methods getNetworkConfigLocation() Get the file system path that the network config was loaded from, if any. Returns: The file system path that the network config was loaded from, or null if it was not loaded directly from the file system. Type string  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"Orderer.html":{"id":"Orderer.html","title":"Class: Orderer","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Orderer Orderer The Orderer class encapsulates the client capabilities to interact with an Orderer node in the target blockchain network. The orderer node exposes two APIs: broadcast() and deliver(). Both are streaming APIs so there's a persistent grpc streaming connection between the client and the orderer where messages are exchanged in both directions. The broadcast() API is for sending transactions to the orderer for processing. The deliver() API is for asking the orderer for information such as channel configurations. new Orderer(url, opts) Constructs an Orderer object with the given url and opts. An orderer object encapsulates the properties of an orderer node and the interactions with it via the grpc stream API. Orderer objects are used by the Client objects to broadcast requests for creating and updating channels. They are also used by the Channel objects to broadcast requests for ordering transactions. Parameters: Name Type Description url string The URL with format of \"grpc(s)://host:port\". opts ConnectionOpts The options for the connection to the orderer. Returns: The Orderer instance. Type Orderer Extends Remote Methods close() Close the service connection. getCharacteristics() Get this remote endpoints characteristics It's name, url, and connection options are the items that make this instance unique. These items may be useful when debugging issues or validating responses. Inherited From: Remote#getCharacteristics Overrides: Remote#getCharacteristics getClientCertHash() Get the client certificate hash Inherited From: Remote#getClientCertHash Overrides: Remote#getClientCertHash Returns: The hash of the client certificate Type Array.&lt;byte&gt; getName() Get the name. This is a client-side only identifier for this object. Inherited From: Remote#getName Overrides: Remote#getName Returns: The name of the object Type string getUrl() Get the URL of this object. Inherited From: Remote#getUrl Overrides: Remote#getUrl Returns: Get the URL associated with the object. Type string isTLS() Determine whether or not this remote endpoint uses TLS. Inherited From: Remote#isTLS Overrides: Remote#isTLS Returns: True if this endpoint uses TLS, false otherwise. Type boolean sendBroadcast(envelope, timeout) Send a Broadcast message to the orderer service. Parameters: Name Type Description envelope Array.&lt;byte&gt; Byte data to be included in the broadcast. This must be a protobuf encoded byte array of the common.Envelope that contains either a ConfigUpdateEnvelope or a Transaction in the payload.data property of the envelope. timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Throws: SYSTEM_TIMEOUT | REQUEST_TIMEOUT Returns: A Promise for a BroadcastResponse object Type Promise sendDeliver(envelope) Send a Deliver message to the orderer service. Parameters: Name Type Description envelope Array.&lt;byte&gt; Byte data to be included in the broadcast. This must be a protobuf encoded byte array of the common.Envelope that contains a SeekInfo in the payload.data property of the envelope. The header.channelHeader.type must be set to common.HeaderType.DELIVER_SEEK_INFO Throws: SYSTEM_TIMEOUT | REQUEST_TIMEOUT Returns: A Promise for a protobuf object of type common.Block. Note that this is NOT the same type of object as the Block returned by the BlockDecoder.decode() method and various other methods. A Block is a pure javascript object, whereas the object returned by this method is a protobuf object that contains accessor methods, getters and setters, and toBuffer() for each property to be used for further manipulating the object and convert to and from byte arrays. Type Promise setName(name) Set the name as a client-side only identifier of this object. Parameters: Name Type Description name string Inherited From: Remote#setName Overrides: Remote#setName toString() return a printable representation of this object Overrides: Remote#toString  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"Organization.html":{"id":"Organization.html","title":"Class: Organization","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Organization Organization The Organization class represents an organization in the target blockchain network. new Organization(name, mspid) Construct a Organization object Parameters: Name Type Description name string The name of this organization mspid string The mspid of this organization Returns: The Organization instance. Type Organization Methods addCertificateAuthority(certificateAuthority) Add a CertificateAuthority to this organization Parameters: Name Type Description certificateAuthority CertificateAuthority The CertificateAuthority instance to add to this organizations list of CertificateAuthorities addPeer(peer) Add a Peer to this organization Parameters: Name Type Description peer Peer The peer instance to add to this organizations list of peers getAdminCert() Gets the admin signing certificate in PEM format for this organization. getAdminPrivateKey() Gets the admin private key in PEM format for this organization. getCertificateAuthorities() Gets the list of this CertificateAuthorities CertificateAuthority Returns: [] An array of CertificateAuthority objects Type CertificateAuthority getMspid() Gets the MSPID of this organization Returns: The mspid of this organization Type string getName() Gets the name of this organization Returns: The name of this organization Type string getPeers() Gets the list of this organizations Peer Returns: [] An array of Peer objects Type Peer setAdminCert() Sets the admin signing certificate in PEM format for this organization. setAdminPrivateKey() Sets the admin private key in PEM format for this organization. toString() return a printable representation of this object  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"Peer.html":{"id":"Peer.html","title":"Class: Peer","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Peer Peer The Peer class represents a peer in the target blockchain network. The application can send endorsement proposals, and query requests through this class. new Peer(url, opts) Construct a Peer object with the given url and opts. A peer object encapsulates the properties of an endorsing peer and the interactions with it via the grpc service API. Peer objects are used by the Client objects to send channel-agnostic requests such as installing chaincode, querying peers for installed chaincodes, etc. They are also used by the Channel objects to send channel-aware requests such as instantiating chaincodes, and invoking transactions. Parameters: Name Type Description url string The URL with format of \"grpc(s)://host:port\". opts ConnectionOpts The options for the connection to the peer. Returns: The Peer instance. Type Peer Extends Remote Methods close() Close the service connections. getCharacteristics() Get this remote endpoints characteristics It's name, url, and connection options are the items that make this instance unique. These items may be useful when debugging issues or validating responses. Inherited From: Remote#getCharacteristics Overrides: Remote#getCharacteristics getClientCertHash() Get the client certificate hash Inherited From: Remote#getClientCertHash Overrides: Remote#getClientCertHash Returns: The hash of the client certificate Type Array.&lt;byte&gt; getName() Get the name. This is a client-side only identifier for this object. Inherited From: Remote#getName Overrides: Remote#getName Returns: The name of the object Type string getUrl() Get the URL of this object. Inherited From: Remote#getUrl Overrides: Remote#getUrl Returns: Get the URL associated with the object. Type string isTLS() Determine whether or not this remote endpoint uses TLS. Inherited From: Remote#isTLS Overrides: Remote#isTLS Returns: True if this endpoint uses TLS, false otherwise. Type boolean sendDiscovery(request, timeout) Send an discovery request to this peer. Parameters: Name Type Description request SignedRequest A protobuf encoded byte array of type Proposal timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Returns: A Promise for a DiscoveryResponse Type Promise &lt;async&gt; sendProposal(proposal, timeout) Send an endorsement proposal to an endorser. This is used to call an endorsing peer to execute a chaincode to process a transaction proposal, or runs queries. Parameters: Name Type Description proposal Proposal A protobuf encoded byte array of type Proposal timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Returns: A Promise for a ProposalResponse Type Promise setName(name) Set the name as a client-side only identifier of this object. Parameters: Name Type Description name string Inherited From: Remote#setName Overrides: Remote#setName toString() return a printable representation of this object Overrides: Remote#toString  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"Remote.html":{"id":"Remote.html","title":"Class: Remote","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: Remote Remote The Remote class represents a the base class for all remote nodes, Peer, Orderer , and MemberServicespeer. new Remote(url, opts) Constructs an object with the endpoint configuration settings. Parameters: Name Type Description url string The orderer URL with format of 'grpc(s)://host:port'. opts Object An Object that may contain options to pass to grpcs calls - pem {string} The certificate file, in PEM format, to use with the gRPC protocol (that is, with TransportCredentials). Required when using the grpcs protocol. - clientKey {string} The private key file, in PEM format, to use with the gRPC protocol (that is, with TransportCredentials). Required when using the grpcs protocol with client certificates. - clientCert {string} The public certificate file, in PEM format, to use with the gRPC protocol (that is, with TransportCredentials). Required when using the grpcs protocol with client certificates. - ssl-target-name-override {string} Used in test environment only, when the server certificate's hostname (in the 'CN' field) does not match the actual host endpoint that the server process runs at, the application can work around the client TLS verify failure by setting this property to the value of the server certificate's hostname - any other standard grpc call options will be passed to the grpc service calls directly grpc options must be an object with string keys and integer or string values Methods getCharacteristics() Get this remote endpoints characteristics It's name, url, and connection options are the items that make this instance unique. These items may be useful when debugging issues or validating responses. getClientCertHash() Get the client certificate hash Returns: The hash of the client certificate Type Array.&lt;byte&gt; getName() Get the name. This is a client-side only identifier for this object. Returns: The name of the object Type string getUrl() Get the URL of this object. Returns: Get the URL associated with the object. Type string isTLS() Determine whether or not this remote endpoint uses TLS. Returns: True if this endpoint uses TLS, false otherwise. Type boolean setName(name) Set the name as a client-side only identifier of this object. Parameters: Name Type Description name string toString() return a printable representation of this object  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"TransactionID.html":{"id":"TransactionID.html","title":"Class: TransactionID","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Class: TransactionID TransactionID The class representing the transaction identifier. Provides for automatically creating the `nonce` value when an instance of this object is created. new TransactionID(signer_or_userContext, admin) Builds a new transaction Id based on a user's certificate and an automatically generates a nonce value. Parameters: Name Type Description signer_or_userContext Identity An instance of Identity that provides an unique base for this transaction id. This also may be an instance of a {@User}. admin boolean Indicates that this instance will be used for administrative transactions. Methods getNonce() The nonce value getTransactionID() The transaction ID isAdmin() indicates if this transactionID was generated for an admin  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"tutorial-app-dev-env-setup.html":{"id":"tutorial-app-dev-env-setup.html","title":"Tutorial: Setting up the Application Developer's Environment","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Setting up the Application Developer's Environment This tutorial describes how to prepare a development environment in order to build a business application to use a blockchain network based on Hyperledger Fabric. At a high level, a business application running on a Hyperledger Fabric network is made up of two parts: chaincode that runs in the servers (endorser nodes), and client code that runs in the Node.js application. For chaincode development, please visit the Hyperledger Fabric chaincode tutorials. For complete information on starting a Hyperledger Fabric network, please see the Build your first network tutorial. The following tutorial assumes a chaincode has been developed and the focus is developing the client application. What makes up a Hyperledger Fabric application development environment? Below you'll find a high level summary of the Hyperledger Fabric design aimed at an introductory level of understanding, so that you can be on your way to setting up the development environment. For a comprehensive description of the concepts, the architecture, please visit the official Hyperledger Fabric documentation. First of all, you will need an orderer. But isn't an orderer responsible for the consensus? Why start here? It's true that the main responsibility of the ordering service of a Hyperledger Fabric blockchain network is to provide consensus on a transaction among the maintainers of the ledger, a.k.a the committer nodes. However, the ordering service also maintains critical data about the overall network: what organizations are participating, what channels have been created, which organizations are part of a given channel, and last but not least what policies are in place for any kind of change to the network. In essence, the ordering service holds the network together. Ok we've got to have an orderer node so we can add participating organizations to it and get a network started. Next you would need peers for each participating organization in order to participate in transaction endorsing and maintaining the ledger. The peer nodes play two roles: endorser and committer. A peer's endorser role may be enabled or disabled based on the bootstrap configuration. Note that all peers are always committers. For high availability you would want more than one peer for each organization in a real deployment. For the development environment, one peer per organization is sufficient under most circumstances. This peer will be both an endorser and a committer. It will be sent transaction proposals to endorse and queries to discover information from the ledger. Another important role that peer nodes play is broadcasting events to interested parties. Whenever a block is added to the ledger, an event is sent by the peer through a dedicated streaming port. Any application within the organization can register themselves to listen on that port to get notified. The final piece of the puzzle is identities. Every operation in a Hyperledger Fabric network must be digitally signed for the purposes of access control, or provenance/auditing (who did what), or both. Identities are based on the Public Key Infrastructure (PKI)) standards. Every orderer node, every peer node and every user/transactor must have a key pair with the public key wrapped in a x.509 certificate signed by a Certificate Authority (CA). Since x.509 is an open standard, Hyperledger Fabric would work with any existing certificate authority. This is typically a painful process with lots of potential red tape to get real certificates, so for the development purposes it is a popular practice to use self-signed certificates locally generated. As you will see in the later section, the Hyperledger Fabric provides tools to make this less painful. Also related to identities, you should make a decision on whether Fabric-CA should be part of your solution. This is a server with REST APIs that supports dynamic identity management with registration, enrollment (getting certificates), revocation and re-enrollment. So it is very useful in providing user identities on the fly. Note that user identities provisioned this way are only of the MEMBER role, which means it won't be able to perform certain operations reserved for the ADMIN role: create/update channel install/instantiate chaincode query installed/instantiated chaincodes For these privileged operations, the client must use an ADMIN user to submit the request. If you choose to not use Fabric-CA, everything will still work, but the application is responsible for managing the user certificates. Prerequisites You will need the following software: Docker and Docker Compose - see Hyperledger Fabric for details Nodejs v8.9.0 or higher, up to 9.0 ( Node v9.0+ is not supported ) Prepare crypto materials As discussed above, identities are established with x.509 certificates. If you think about it, we will need a whole bunch of certificates because there are many identities involved: peers need identities to sign endorsements orderers need identities to sign proposed blocks for the committers to validate and append to the ledger applications need identities to sign transaction requests the Fabric CA themselves also need identities, so their signatures in the certificates can be validated Luckily there is a tool for that. Follow this guide to use the cryptogen tool to generate all the required keys and certificates in one swoop. Note that the cryptogen tool will automatically generate identities for the Fabric CA nodes for each orderer and peer organization, which can be used to start the Fabric-CA servers (if you choose to use it as part of the solution as discussed above). In addition, it also generates one admin user of the ADMIN role with the privileges to perform admin-level operations listed above. Finally, it also generates regular users (MEMBER role) for submitting transactions. This would get us all the crypto materials needed to start things up. Getting things rolling for real - the genesis block As discussed above, the orderer should be the first step to bootstrap (launch) a network. The orderer will need the initial configurations wrapped inside a genesis block. Follow the instructions here to use the configtxgen tool to generate a genesis.block. The output, a genesis block file for the orderer, will be used in the next step to launch the orderer node. Notice some features are non-backwards compatible. To enable features from a particular fabric version, the Capabilities section in configtx.yaml should be updated before generate the genesis.block. Start the network Now we are ready to put it all together. The easiest way to launch the development environment is to use docker-compose. Follow the instructions here to start the network. To minimize the chances of a mistake, you may wish to run the network without TLS. The above steps give you a development environment. Now before you can ask it to process any transactions, you must first create a channel. This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:29+00:00 using the DocStrap template. "},"tutorial-chaincode-lifecycle.html":{"id":"tutorial-chaincode-lifecycle.html","title":"Tutorial: fabric-client: How to install and start your chaincode","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to install and start your chaincode This tutorial describes how to use your application to install a chaincode on your peers and define it on a channel. This tutorial uses the Fabric chaincode lifecycle introduced in the Fabric V2.0 Alpha and the fabric-client 2.0 Alpha. The APIs for using the previous chaincode lifecycle will still be available in the fabric-client, but will not be discussed in this tutorial. For more information on the new Fabric Chaincode lifecycle, visit the Chaincode for Operators tutorial in the Hyperledger Fabric documentation. For more information on: getting started with Hyperledger Fabric see Building your first network. the configuration of a channel in Hyperledger Fabric and the internal process of creating and updating a channel, see Hyperledger Fabric channel configuration The following tutorial assumes an understanding of the components of a Hyperledger Fabric network (orderers and peers) and of Node application development, including the use of the Javascript promise and async await. Overview The Fabric 2.0 Alpha introduces decentralized governance for chaincode. The new Fabric chaincode lifecycle allows multiple organizations to come to agreement on the parameters of a chaincode, such as the chaincode endorsement policy, before it can be used to interact with the ledger. You will need to enable the new Fabric chaincode lifecycle on your channel definition by setting the Applications capabilities to V2_0: true to use the steps in this tutorial. Channel members need to complete the following steps before they can start using a chaincode: Setup- create the necessary application objects Package - create a chaincode package from your source code Install - install the chaincode package on your peers Approve a definition for organization - each organization needs to approve a chaincode definition in order to use the chaincode Commit the definition to a channel - After a sufficient number of organizations have approved a chaincode definition, the definition can be committed to a channel by one organization Initialize - (Optional) initialize the chaincode and start the chaincode container New Class A new class Chaincode has been added to the fabric-client to encapsulate a chaincode definition. A Chaincode instance will be created by a client instance's newChaincode(name,version) method. Then using the new instance, you will be able to build up a chaincode definition with the following methods. setEndorsementPolicyDefinition - Provide the endorsement policy for this chaincode. setCollectionConfigPackageDefinition - Provide the collection configuration for this chaincode. setSequence - Provide the modification number for this chaincode definition. setPackage - Provide the package when not packaging this chaincode locally. setPackageId - Provide the package ID when not installing this chaincode package locally. The chaincode instance will allow you to package a chaincode and install it on your peers with the following methods: package Package the files at the locations provided. install Install the package on the specified peers. Once the chaincode definition has all the necessary attributes, it may be used by a channel instance to be approved both for an organization and then committed for use on the channel. New methods on Channel The Channel class has been updated to include methods to approve a chaincode definition for your organization and commit the definition to a channel. approveChaincodeForOrg - will approve the chaincode for an organization on this channel commitChaincode - will commit the chaincode for use on this channel. queryChaincodeDefinition - will return a {Chaincode} instance as defined on this peer on this channel queryApprovalStatus - will indicate the approval status for a chaincode name on this channel queryInstalledChaincode will indicate by returning the label if the package ID is installed on this peer queryInstalledChaincodes will indicate all the package IDs and labels of installed chaincode on this peer queryNamespaceDefinitions will indicate the chaincode names committed (running) on this channel New method on Client The Client class has been enhanced to include a new method to create a Chaincode instance. This is the object used for creating a chaincode definition and managing a chaincode. newChaincode - Create a Chaincode instance. Step 1: Setup In this step we will build the application objects needed to perform the operational steps that follow. You will first need to create a fabric-client operational environment. The client instance will need to have a user store, crypto suite, and a user assigned. The target peers, orderer, and channel instance objects will also be required prior to working with chaincode. The following sample code assumes that all of the normal fabric-client setup has been completed and only shows the new chaincode lifecycle related calls. The chaincode object needs specifies the parameters that will define how your chaincode will operate on the channel. These parameters include the name, version, endorsement policy, and the collection configuration. This chaincode object also specifies that the Init function will need to be executed before the chaincode can be started on the channel. // get the chaincode instance associated with the client const mychaincode = client.newChaincode('mychaincode', 'v1'); // The endorsement policy const policy_def = { identities: [ {role: {name: 'member', mspId: 'org1'}}, {role: {name: 'member', mspId: 'org2'}} ], policy: { '1-of': [{'signed-by': 0}, {'signed-by': 1}] } }; mychaincode.setEndorsementPolicyDefinition(policy_def); // The collection configuration - optional. const config_def = [{ name: 'detailCol', policy: { identities: [ {role: {name: 'member', mspId: 'Org1MSP'}}, {role: {name: 'member', mspId: 'Org2MSP'}} ], policy: { '1-of': [{'signed-by': 0}, {'signed-by': 1}] } }, requiredPeerCount: 1, maxPeerCount: 1, blockToLive: 100 }]; mychaincode.setCollectionConfigPackageDefinition(config_def)); mychaincode.setInitRequired(true); // set the sequence (modification) number - default is 1 mychaincode.setSequence(1); // must increment for each definition change Step 2: Package The chaincode needs to be packaged before it can be installed on your peers. You can use the package method to create a chaincode package in the required format. The method creates a tar file from your chaincode source code, artifacts, and metadata files. This step can be done by one organization if you want to ensure that every channel member is using the same chaincode package. Optional you may create a package label and assign it to this package to help identify the chaincode package after it is installed on your peers. The following example packages a golang chaincode. This package can then be optionally be sent to other channel members out of band. // package the source code const package_request = { chaincodeType: 'golang', goPath: '/gopath', chaincodePath: '/path/to/code', metadataPath: '/path/to/metadata' } const cc_package = await mychaincode.package(package_request); If you are given the channel package out of band by another organization, use the following method to import the chaincode package before it can be installed. // use an existing package mychaincode.setPackage(cc_package); Step 3: Install Once the chaincode is packaged, it can be installed on your peers. This step will be required by all organizations that want to use the chaincode to query the ledger and endorse transactions. The install method will send the packaged chaincode to the target peers in your organization. This request will need to be sent by a peer administrator. The installation will return a package ID, a unique identifer for the chaincode package. You will need the package ID when you approve a chaincode definition for your organization. The following sample assumes that the chaincode object being used has been setup and packaged or an error would be thrown. Note how the package ID is returned from the install, and is also available from the mychaincode object using the getPackageId() method. // install chaincode package on peers const install_request = { targets: [peer1, peer2], request_timeout: 20000 // give the peers some extra time } const package_id = await mychaincode.install(install_request); // package ID value is stored in the chaincode instance const package_id = mychaincode.getPackageId(); Step 4: Approve for your organization Each organization that wants to use the chaincode needs to approve a chaincode definition for their organization. The transaction to approve a chaincode definition may be submitted at any time, but must be submitted before the commit transaction is submitted, or an organization can use the chaincode. Each organization needs to submit separate approval transactions. Approving a chaincode definition may be thought of as a vote for a set of chaincode parameters by your organization. These approved definitions allow channel members to agree on a chaincode before it can be used on a channel. As a result, the approved definitions needs to be consistent across organizations. If the chaincode is already running and a definition has already been committed to the channel, an organization can use the chaincode by installing the chaincode package on their peers and approving the committed chaincode definition. The chaincode definition needs to contain the package identifier to associate the definition approved by your organization with the chaincode installed on your peers. If your organization does not plan on using the chaincode, you can approve a chaincode definition without a package ID. This may be helpful if you want to ensure that a definition has a sufficient number of approvals to be committed to the channel. We used the chaincode object created in step one, mychaincode, to create a chaincode definition that our organization is ready to approve. The definition includes all the parameters that were specified in the step one sample code, such as the name, version, and the endorsement policy. The object also contains the package ID returned by the install method in step three. // send a approve chaincode for organization transaction const tx_id = client.newTransactionID(); const request = { target: peer1, chaincode: mychaincode, // The chaincode instance fully populated txId: tx_id } // send to the peer to be endorsed const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } // send to the orderer to be committed const results = await mychannel.sendTransaction(orderer_request); Step 5: Commit definition to the channel Once a sufficient number of channel members have approved a chaincode definition, one organization can commit the definition to the channel. In order for the chaincode definition to be committed successfully, a sufficient number of organizations need to approve the definition to meet the Channel/Application/LifecycleEndorsement policy. By default, this policy is set to a majority of the organizations on the channel. You can find a sample commit transaction below. The commit transaction needs to target a sufficient number of peers in other organizations to collect their endorsements for the definition. Think of this as a tally of the votes for the chaincode. If the commit transaction can collect a sufficient number of votes to meet the LifecycleEndorsement policy, the definition can be committed to the channel and the chaincode used by channel members. // send a commit chaincode for channel transaction const tx_id = client.newTransactionID(); const request = { targets: [peer1, peer3], chaincode: mychaincode, txId: tx_id } // send to the peers to be endorsed const {proposalResponses, proposal} = await mychannel.commitChaincode(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } // send to the orderer to be committed const results = await mychannel.sendTransaction(orderer_request); Step 6: Initialize The chaincode is ready to be used after it is defined on a channel. If you did not request the execution of your chaincode's Init function, then the chaincode container will start after the first invoke. If you used setInitRequired(true) then you need to invoke with is_init set to true before any other transactions can be executed. The following code snippet below requests the initialization of your chaincode. Note that is_init needs to be set to true as part of the request, and the Init method will be called rather than the Invoke method of your chaincode. // initialize the chaincode const tx_id = client.newTransactionID(); const request = { chaincodeId : chaincodeId, fcn: 'Init', args: args, txId: tx_id, is_init: true // must be set to initialization } // starting the container will take longer than the normal request-timeout const init_results = await mychannel.sendTransaction(request, 20000); const orderer_request = { proposalResponses: init_results[0], proposal: init_results[1] } // send to the orderer to be committed const results = await mychannel.sendTransaction(orderer_request); Sample situations In addition to being necessary to use a new chaincode, the chaincode definition provides you additional flexibility in updating a chaincode and managing chaincode policies. The following samples will provide code snippets for the following scenarios: Intalling a new chaincode Upgrading a chaincode Modifying an endorsement policy Join a channel with a running chaincode New chaincode When installing chaincode for the first time, All 5 or 6 steps must be run. The following sample shows one organization packaging and installing the chaincode, followed by the organization approving and committing the chaincode definition for the entire channel. The organization also executes the Init function in this example. // step 1: setup const mychaincode = client.newChaincode('mychaincode', 'version1'); const policy_def = { ... }; mychaincode.setEndorsementPolicyDefinition(policy_def); mychaincode.setSequence(1); //set to one for a new chaincode mychaincode.setInitRequired(true); // step 2: package const package_request = { chaincodeType: 'golang', goPath: '/gopath', chaincodePath: '/path/to/code', metadataPath: '/path/to/metadata' } const cc_package = await mychaincode.package(package_request); // step 3: install const install_request = { target: peer1, request_timeout: 10000 // give the peer some extra time } const package_id = await mychaincode.install(install_request); // step 4: approve const tx_id = client.newTransactionID(); const request = { targets: [peer1], chaincode: mychaincode, txId: tx_id } const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } const results = await mychannel.sendTransaction(orderer_request); //step 5: commit const tx_id = client.newTransactionID(); const request = { targets: [peer1, peer3], chaincode: mychaincode, txId: tx_id } const {proposalResponses, proposal} = await mychannel.commitChaincode(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } const results = await mychannel.sendTransaction(orderer_request); // step 6: init const tx_id = client.newTransactionID(); const request = { chaincodeId : chaincodeId, fcn: 'Init', args: args, txId: tx_id, is_init: true } const init_results = await mychannel.sendTransaction(request, 20000); const orderer_request = { proposalResponses: init_results[0], proposal: init_results[1] } const results = await mychannel.sendTransaction(orderer_request); Upgrade the chaincode code When upgrading the chaincode binaires, all 5 or 6 steps must be run. The flow and commands are the same for upgrading a chaincode, but the sequence number needs to be incremented by one. You will also need to change the chaincode version. The following sample shows the code needed when the organization will be packaging the chaincode, installing it, and being the organization to approve and commit it for the entire channel. // step 1: setup const mychaincode = client.newChaincode('mychaincode', 'version2'); const policy_def = { ... }; mychaincode.setEndorsementPolicyDefinition(policy_def); mychaincode.setSequence(2); // step 2: package // package the source code const package_request = { chaincodeType: 'golang', goPath: '/gopath', chaincodePath: '/path/to/code', metadataPath: '/path/to/metadata' } const cc_package = await mychaincode.package(package_request); // step 3: install const install_request = { target: peer1, request_timeout: 10000 // give the peer some extra time } const package_id = await mychaincode.install(install_request); // step 4: approve const tx_id = client.newTransactionID(); const request = { targets: [peer1], chaincode: mychaincode, txId: tx_id } const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } const results = await mychannel.sendTransaction(orderer_request); //step 5: commit const tx_id = client.newTransactionID(); const request = { targets: [peer1, peer3], chaincode: mychaincode, txId: tx_id } // send to the peers to be endorsed const {proposalResponses, proposal} = await mychannel.commitChaincode(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } // send to the orderer to be committed const results = await mychannel.sendTransaction(orderer_request); Modify the Endorsement policy When updating the endorsement policy, you only need to perform 4 steps. Organizations can use the chaincode definition to update the endorsement policy without having to repackage the chaincode or initializing the chaincode. You need to increment the sequence number by one to change the chaincode definition. In this case let us assume that the chaincode has been updated once, so the sequence number will be 3. It might seem that we can also skip the install step, but we still need the package ID value to uniquely identify the chaincode source that was installed earlier and has not been changed. The following sample shows the code needed when the organization updates an endorsement policy and is then approves and commits the new definition to the channel. // step 1: setup const mychaincode = client.newChaincode('mychaincode', 'version2'); const new_policy_def = { ... }; mychaincode.setEndorsementPolicyDefinition(new_policy_def); mychaincode.setSequence(3); // step 3: install mychaincode.setPackageId(package_id); // step 4: approve const tx_id = client.newTransactionID(); const request = { target: peer1, chaincode: mychaincode, txId: tx_id } const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } const results = await mychannel.sendTransaction(orderer_request); //step 5: commit const tx_id = client.newTransactionID(); const request = { targets: [peer1, peer3], chaincode: mychaincode, txId: tx_id } // send to the peers to be endorsed const {proposalResponses, proposal} = await mychannel.commitChaincode(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } // send to the orderer to be committed const results = await mychannel.sendTransaction(orderer_request); Joining a channel with a running chaincode When a new organization wishes to run an existing chaincode it will have to perform all but the commit step. This sample assumes that the endorsement policy allows the new organization to endorse transactions. Otherwise, this organization will only be able to audit the ledger. // step 1: setup const mychaincode = client.newChaincode('mychaincode', 'version2'); const policy_def = { ... }; // must be the same as what the other organizations have used mychaincode.setEndorsementPolicyDefinition(policy_def); mychaincode.setSequence(3); // use existing value, if there is change, then up this number // step 2: package // package the source code const package_request = { chaincodeType: 'golang', goPath: '/gopath', chaincodePath: '/path/to/code', metadataPath: '/path/to/metadata' } const cc_package = await mychaincode.package(package_request); // step 3: install const install_request = { target: peer1, request_timeout: 10000 // give the peer some extra time } const package_id = await mychaincode.install(install_request); // step 4: approve // only the new organization has to run, unless there is change // to the definition const tx_id = client.newTransactionID(); const request = { targets: [peer1], // this peer is in my org chaincode: mychaincode, txId: tx_id } const {proposalResponses, proposal} = await mychannel.approveChaincodeForOrg(request); const orderer_request = { proposalResponses: proposalResponses, proposal, proposal } const results = await mychannel.sendTransaction(orderer_request); // step 5: commit // This step is not required, however if there was a change to the // chaincode definition and the sequence number had to change, // then it must be run Querying chaincode and chaincode definitions. The Fabric chaincode allows for decentralized governance and may require coordination between multiple organizations. You can use query methods to help manage chaincode lifecycle. Querying the chaincode defintion on a channel You can use the QueryChaincodeDefinition method to find which definition has been approved for a given chaincode. You can only send this request to one peer. This query could be useful in finding the current sequence of a definition before submitting an upgrade request. const tx_id = client.newTransactionID(); const request = { target: peer, chaincodeId: chaincodeId, txId: tx_id } // send to the peers to be endorsed const approved_defintion = await mychannel.QueryChaincodeDefinition(request); Querying the approved chaincode defintions You can use the QueryApprovalStatus method to find which organizations have approved a given chaincode definition. You need to build a chaincode object and pass it to the query. The response will be a JSON mapping of which organizations on the channel have approved the chaincode definition specified by the chaincode object. You can use this query to find whether a sufficient number of organizations have approved a chaincode to meet the LifecycleEndorsement policy before you commit the chaincode definition the channel, and which peers to target with the commit transaction. const tx_id = client.newTransactionID(); const request = { target: peer, chaincode: mychaincode txId: tx_id } // send to the peers to be endorsed const approval_status = await mychannel.QueryApprovalStatus(request); This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-channel-create.html":{"id":"tutorial-channel-create.html","title":"Tutorial: fabric-client: How to create a Hyperledger Fabric channel","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to create a Hyperledger Fabric channel This tutorial illustrates the creation of a Hyperledger Fabric channel using the Node.js fabric-client SDK. It shows how to use an initial (default) channel definition and how to start with that definition to build a custom definition. The process to create a network and channels also involves creating and working with cryptographic material, this will not be discussed here. For more information on: getting started with Hyperledger Fabric see Building your first network. the configuration of a channel in Hyperledger Fabric and the internal process of creating and updating see Hyperledger Fabric channel configuration cryptographic generation see cryptogen configuration transaction generator see configtxgen configuration translation tool see configtxlator The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), protobuf, and of Node application development, including the use of the Javascript Promise. The examples shown below are based on the balance-transfer sample application. see Hyperledger Fabric Samples steps of a channel create: run the configtxgen tool to generate a genesis block run the configtxgen tool to generate an initial binary configuration definition get a sign-able channel definition in one of two ways use the initial binary channel configuration definition use the fabric-client SDK to extract the sign-able channel definition from the initial binary channel configuration definition build a custom definition use the configtxlator to convert the initial binary channel configuration definition to readable text edit the readable text more info use the configtxlator to convert the edited text to a sign-able channel definition use the fabric-client SDK to sign the sign-able channel definition use the fabric-client SDK to send the signatures and the sign-able channel definition to the orderer use the fabric-client SDK to have the peer join the channel then new channel may be used Use the initial definition to build a sign-able channel definition The initial binary channel configuration definition generated by the configtxgen tool is a binary file containing the Hyperledger Fabric configuration protobuf common.Envelope element. Inside this element is the common.ConfigUpdate protobuf element. This configuration element is the one that must be signed. A profile element in the configtx.yaml is the source for the initial binary channel configuration definition created by the configtxgen tool. ../../../bin/configtxgen -channelID mychannel -outputCreateChannelTx mychannel.tx -profile TwoOrgsChannel Have the fabric-client SDK extract the config update element from the mychannel.tx file // first read in the file, this gives us a binary config envelope let envelope_bytes = fs.readFileSync(path.join(__dirname, 'fabric-samples/balance-transfer/artifacts/channel/mychannel.tx')); // have the nodeSDK extract out the config update var config_update = client.extractChannelConfig(envelope_bytes); The binary config_update may now be used in the signing process and sent to the orderer for channel creation. You may ask why is a common.ConfigUpdate used for a create. This makes the process of create and update the same. The create of a new channel is a delta on what is defined in the system channel and an update is a delta on what is defined in the channel. The common.ConfigUpdate object submitted will only contain the changes for both a create and an update. Creating a custom sign-able channel definition The easiest way to get started with creating a custom channel configuration is to have the configtxlator convert an existing binary that has been or could be used to create a new channel to human readable JSON. There are many elements of the configuration and it would be very difficult to start with nothing. Using the same configtx.yaml file used to generate your Hyperledger Fabric network, use the configtxgen tool to create a initial binary configuration definition for a new channel. Then by sending that binary to the configtxlator to convert it to JSON, you will be able to see the layout and have a starting point. That JSON could also be used as a template for creating other new channels on your network. A new channel will inherit settings from the system channel for settings not defined in the new channel configuration. Organizations that will be on the new channel must be defined in a consortium on the system channel. Therefore having the readable definition of the system channel of your network would be helpful when creating a new channel. Send the genesis.block that was used to start the Hyperledger Fabric network to the configtxlator to get a JSON file to be used as a reference. Use the configtxgen tool to produce the binary config files. From the sample directory fabric-samples/balance-transfer/artifacts/channel. export FABRIC_CFG_PATH=$PWD ../../../bin/configtxgen -outputBlock genesis.block -profile TwoOrgsOrdererGenesis ../../../bin/configtxgen -channelID mychannel -outputCreateChannelTx mychannel.tx -profile TwoOrgsChannel Send the two binary files to the configtxlator service. Since this step is done only once and does not require a Node.js application, we will use cURL to simplify and speed up getting the results. Notice that configtxlator service path has decode (convert from binary to JSON). The path must also include the type of object of the binary, in the first case, it is a common.Block. The \"decode\" or \"encode\" may be done for any of the protobuf message object types found in the fabric-client\\lib\\protos directory protobuf files. First start the configtxlator service, from the fabric-samples/bin directory ./configtxlator start Then curl -X POST --data-binary @genesis.block http://127.0.0.1:7059/protolator/decode/common.Block &gt; genesis.json curl -X POST --data-binary @mychannel.tx http://127.0.0.1:7059/protolator/decode/common.Envelope &gt; mychannel.json The results of decoding the file mychannel.tx which is a common.Envelope produced by the configtxgen tool contains a common.ConfigUpdate object. This object has the name \"config_update\" within the \"payload.data\" JSON object. This is the object that is needed as the source of the template to be used for creating new channels. The common.ConfigUpdate is the object that will be signed by all organizations and submitted to the orderer to create a new channel. The following is the extracted JSON \"config_update\" (common.ConfigUpdate) object from the decode of the \"TwoOrgsChannel\" channel create binary generated above. { \"channel_id\": \"mychannel\", \"read_set\": { \"groups\": { \"Application\": { \"groups\": { \"Org1MSP\": {} } } }, \"values\": { \"Consortium\": { \"value\": { \"name\": \"SampleConsortium\" } } } }, \"write_set\": { \"groups\": { \"Application\": { \"groups\": { \"Org1MSP\": {} }, \"mod_policy\": \"Admins\", \"policies\": { \"Admins\": { \"policy\": { \"type\": 3, \"value\": { \"rule\": \"MAJORITY\", \"sub_policy\": \"Admins\" } } }, \"Readers\": { \"policy\": { \"type\": 3, \"value\": { \"sub_policy\": \"Readers\" } } }, \"Writers\": { \"policy\": { \"type\": 3, \"value\": { \"sub_policy\": \"Writers\" } } } }, \"version\": \"1\" } }, \"values\": { \"Consortium\": { \"value\": { \"name\": \"SampleConsortium\" } } } } } Note that the Consortium name used must exist on the system channel. All organizations that you wish to add to the new channel must be defined under in the Consortium section with that name on the system channel. Use the decoded genesis block to verify all values, for example by looking in the genesis.json file generated above. To add an organizations to the channel, they must be placed under the groups section under the Applications section as shown above. See that Org1MSP is a property of Applications.groups section. In this example all of the settings for the organization Org1MSP will be inherited from the system channel (notice the empty object \"{}\" for this organization's properties). To see the current settings for this organization look within the SampleConsortium section under the Consortium section of the system channel (the genesis block of the system channel). Once you have a JSON configuration representing your channel, send it the configtxlator to be encoded into a configuration binary. The following example of sending a REST request to the configtxlator uses the Node.js package superagent because of the ease of use for HTTP requests. var response = superagent.post('http://127.0.0.1:7059/protolator/encode/common.ConfigUpdate', config_json.toString()) .buffer() .end((err, res) =&gt; { if(err) { logger.error(err); return; } config_proto = res.body; }); Signing and submitting the channel update The binary configuration must be signed by all organizations. The application will have to store the binary configuration and have it available to be signed along with storing all the signatures as it collects them. Then once the signing is complete, the application will send the binary configuration and all the signatures to the orderer using the fabric-client SDK API createChannel(). First the signing, assuming the client fabric-client SDK object has a valid user in a required organization var signature = client.signChannelConfig(config_proto); signatures.push(signature); Now it is time for the channel create, assuming that the signatures object is an array of common.ConfigSignature returned by the client.signChannelConfig() method. Note: The orderer must be started with the genesis.block that was generated from the same configuration file as the initial binary channel configuration definition // create an orderer object to represent the orderer of the network var orderer = client.newOrderer(url,opts); // have the SDK generate a transaction id let tx_id = client.newTransactionID(); request = { config: config_proto, //the binary config signatures : signatures, // the collected signatures name : 'mychannel', // the channel name orderer : orderer, //the orderer from above txId : tx_id //the generated transaction id }; // this call will return a Promise client.createChannel(request) The createChannel API returns a Promise to return the status of the submit. The channel create will take place asynchronously by the orderer. After a small delay of a few seconds the channel will have been created by the orderer and may now be joined by the peers. Issue the following to the peers that are required on the channel. This is a two step process of first getting the genesis block of the channel and then sending it to the peer. In the following example the genesis block was retrieved from the orderer, but could have also been loaded from a file. // set the channel up with network endpoints var orderer = client.newOrderer(orderer_url,orderer_opts); channel.addOrderer(orderer); var peer = client.newPeer(peer_url,peer_opts); channel.addPeer(peer); tx_id = client.newTransactionID(); let g_request = { txId : tx_id }; // get the genesis block from the orderer channel.getGenesisBlock(g_request).then((block) =&gt;{ genesis_block = block; tx_id = client.newTransactionID(); let j_request = { targets : targets, block : genesis_block, txId : tx_id }; // send genesis block to the peer return channel.joinChannel(j_request); }).then((results) =&gt;{ if(results &amp;&amp; results.response &amp;&amp; results.response.status == 200) { // join successful } else { // not good } }); This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-channel-events.html":{"id":"tutorial-channel-events.html","title":"Tutorial: fabric-client: How to use the channel-based event service","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to use the channel-based event service This tutorial discusses the channel event service and how to use the Hyperledger Fabric Node.js client (fabric-client) ChannelEventHub class. For more information on getting started with Fabric see Building your first network. For more information on Hyperledger Fabric Peer channel-based event services. See the NPM module fabric-client. The following assumes an understanding of Fabric networks (orderers and peers), and of Node application development, including the use of the Javascript await, async and Promise. Overview The channel event service is made up both the fabric network's Peer channel-based event services and the Node.js fabric-client class ChannelEventHub. A Hyperledger Fabric Peer's channel-based event service will deliver the requested blocks to a client application's ChannelEventHub running instance. The ChannelEventHub processes the blocks as they are delivered from the Hyperledger Fabric Peer. Client applications register event listeners with the ChannelEventHub to be notified when a block is received that is of interest. Together, the Peer's channel-based event service and the fabric-client's ChannelEventHub class provide the channel event service for the client application. The ChannelEventHub will de-serialize the blocks as they are received from the peer. The ChannelEventHub will then look at the block contents to see if there is match to an event listener. If there is a match, the event listener will be notified. The client application may choose to start the delivery of blocks at a selected block number or start from the latest block. The client application may choose to end the delivery of blocks at a selected block number, end at the latest block, or continue to send blocks as they are added to the ledger. Client applications typically are not interested that a new block was added to the ledger, but would be interested in knowing that the transaction that has just been submitted has been committed and if it was valid. For example when a transaction with the id of '12345' has been submitted. The client application would have to register a \"transaction event listener\" to be notified when the transaction is committed. The notification is a javascript call to a javascript function provided on the registration. This function known as a callback, will be called by the ChannelEventHub with information defined for a \"transaction\" event from a block that the ChannelEventHub has received from the Peer's channel-based event service. In this example the ChannelEventHub will notify the \"event listener\" (the client application program) with the transaction id 12345, the transaction status VALID, and the block number 73 that contains the committed transaction. fabric-client ChannelEventHub provides for three types of events: block - An application program will be notified when the fabric-client receives a block. There is no checking the contents of the block for a match with this event type as the application program will be notified for each block received. These blocks may be old or new depending on how the connection was setup. transaction - An application program will be notified when the fabric-client receives a block containing a specific transaction id. The transaction may have been just added to the ledger or may be from existing blocks depending on how the connection was setup. chaincode - An application program will be notified when the fabric-client receives a block containing a specific chaincode event. The value of a chaincode event is generated by the chaincode during the endorsement of a proposal and placed into the endorsement results, however a block must be committed with the transaction that contains the chaincode event before the event will be seen by the channel event service. The fabric-client will see the chaincode event when it looks at each block received. If the fabric-client finds a chaincode event it will check for a matching \"event listener\" to notify. The Peer's channel-based event service allows fabric-clients to receive \"filtered\" blocks (which allow for receiving transaction validation status without providing other sensitive information). Access to \"filtered\" blocks or \"full\" blocks is configured when the connection is setup to a Peer's channel-based event service. The default behavior is to connect to receive filtered blocks. For more information on filtered blocks see Peer channel-based event services. Channel methods newChannelEventHub(peer) -- A Channel instance method to get a new instance of a ChannelEventHub. getChannelEventHub(name) -- A Channel instance method to get an existing instance of a ChannelEventHub by the name of the peer. getChannelEventHubsForOrg(org) -- Gets a list of ChannelEventHubs based on an organization. If the organization name is omitted then the current organization of the current user is used. Note: Use the mspid of the organization as the organization name. ChannelEventHub methods The following are the methods of the ChannelEventHub that will be used for registering and removing registrations for event listeners. registerBlockEvent(eventCallBack, errorCallBack, options) -- To register for block events. unregisterBlockEvent(reg_num) -- To remove a block registration. registerTxEvent(tx_id, eventCallBack, errorCallBack, options) -- To register for a specific transaction event. unregisterTxEvent(tx_id) -- To remove a specific transaction registration. registerChaincodeEvent(ccid, eventCallBack, errorCallBack, options) -- To register for chaincode events. unregisterChaincodeEvent(cc_handle) -- To remove a chaincode event registration. lastBlockNumber lastBlockNumber() -- To get the last block number this channel event hub has seen. The following are the methods of ChannelEventHub that will be used to control a connection to a Peer's channel-based event service on the fabric network. disconnect() -- To have the client channel event hub shutdown the connection to the fabric network channel-based event service and notify all current channel event registrations of the shutdown by using the registered errorCallBacks. connect() -- Deprecated - To have the client channel event hub connect with the fabric channel-based event service. This call must be made before events will be received by your instance of a ChannelEventHub. When the channel-based event hub connects with the service, it will request to receive blocks or filtered blocks. If the parameter is omitted, it will default to false and filtered blocks will be requested. connect(options, connectCallBack) -- To have the client channel event hub connect with the fabric channel-based event service using the options provided and report back the results of the connect using the provided call back. see connect options for details and see connect callback for details. reconnect(options, connectCallBack) -- To have the client channel event hub reconnect with the fabric channel-based event service using the options provided and report back the results of the connect using the provided call back. parameters The following are descriptions for the parameters shown above on the method descriptions. 'peer' parameter for newChannelEventHub This optional parameter on the Channel newChannelEventHub may be included when creating a new instance of the ChannelEventHub. The value is a Peer instance or the name of a peer when using a connection profile see How to use a common common connection profile file. This is the target peer that will provide the fabric event service. If the application wishes to pass the target peer on the connect call then this parameter may be left empty. 'eventCallback' parameter for registration This parameter must be included in all event listener registrations. This is the callback function to be notified (called) when the fabric-client receives a block and finds an \"event listener\" that is a match for the block. 'errorCallback' parameter for registration This is an optional parameter. This is the callback function to be notified (called) when this channel event hub is shutdown. The shutdown may be caused by a fabric network error, network connection problem or by a call to the ChannelEventHub disconnect() method. This callback will also be called when the channel event hub is shutdown due to the last block being received when replaying events with the endBlock set. options parameter for connect and reconnect This is an optional parameter for the ChannelEventHub connect() and reconnect() methods. This parameter may contain the following optional properties: {integer | 'newest' | 'oldest' | 'last_seen'} startBlock (Optional) The starting block number for event checking. When included, the Peer's channel-based event service will be asked to start sending blocks from this block number. This is how to resume listening or replay missed blocks that were added to the ledger. Replaying events may confuse event listeners and will not be allowed if listeners have registered with startBlock or endBlock. When this parameter is excluded (as it will be normally) the event service will be asked to start sending blocks from the newest block on the ledger. Number - A number value may be specified as the block number. 'newest' - The string of 'newest'. This will have the block number determined by the Peer's channel-based event service at connect time of the the newest block on the ledger. 'oldest' - The string of 'oldest'. This will have the block number determined by the Peer's channel-based event service at connect time of the the oldest block on the ledger, unless your ledger has been pruned, this will be block 0. 'last_seen' - The string of 'last_seen'. This will have the channel event hub instance determine the block number at the time of the registration. The number will be based on the last block that this channel event hub has received from the Peer's channel-based event service. Using this option on an event listener does require that this channel event hub has been previously running. {integer | 'newest' | 'oldest' | 'last_seen' } endBlock (Optional) The ending block number for event checking. When included, the Peer's channel-based event service will be asked to stop sending blocks once this block is delivered. This is how to replay missed blocks that were added to the ledger. When a startBlock is not included, the endBlock must be equal to or larger than the current channel block height. The value 'newest' will indicate that 'endBlock' will be calculated by the peer as the newest block on the ledger. This allows the application to replay up to the latest block on the ledger and then the listener will stop and be notified by the 'onError' callback. Number - A number value may be specified as the block number. 'newest' - The string of 'newest'. This will have the block number determined by the Peer's channel-based event service at connect time of the the newest block on the ledger. 'oldest' - The string of 'oldest'. This will have the block number determined by the Peer's channel-based event service at connect time of the the oldest block on the ledger, unless your ledger has been pruned, this will be block 0. 'last_seen' - The string of 'last_seen'. This will have the channel event hub instance determine the block number at the time of the registration. The number will be based on the last block that this channel event hub has received from the Peer's channel-based event service. Using this option on an event listener does require that this channel event hub has been previously running. {SignedEvent} signedEvent (Optional) The signed event to be sent to the peer. This option is useful when the fabric-client application does not have the user's privateKey and can not sign requests to the fabric network. see Working with an offline private key. {Peer | string} target (Optional) The peer that provides the fabric event service. When using a string, the Channel associated with this ChannelEventHub must have the peer assigned with that as the name of the peer. When used on the ChannelEventHub connect() method or the reconnect() method the target peer will replace the existing target endpoint assigned to this ChannelEventHub instance. options parameter for event listener registration This is an optional parameter. This parameter may contain the following optional properties: {integer | 'newest' | 'oldest' | 'last_seen'} startBlock (Optional) The starting block number for event checking. When included, the Peer's channel-based event service will be asked to start sending blocks from this block number. This is how to resume listening or replay missed blocks that were added to the ledger. This option changes how the connection is made to the fabric Peer's channel-based event service, therefore the registration must be made before the channel event hub has setup the connection. Replaying events may confuse other event listeners; therefore, only one listener will be allowed on a ChannelEventHub when startBlock and/or endBlock are used on a listener registration. Number - A number value may be specified as the block number. 'newest' - The string of 'newest'. This will have the block number determined by the Peer's channel-based event service at connect time of the the newest block on the ledger. 'oldest' - The string of 'oldest'. This will have the block number determined by the Peer's channel-based event service at connect time of the the oldest block on the ledger, unless your ledger has been pruned, this will be block 0. 'last_seen' - The string of 'last_seen'. This will have the channel event hub instance determine the block number at the time of the registration. The number will be based on the last block that this channel event hub has received from the Peer's channel-based event service. Using this option on an event listener does require that this channel event hub has been previously running. {integer | 'newest' | 'oldest' | 'last_seen' } endBlock (Optional) The ending block number for event checking. When included, the Peer's channel-based event service will be asked to stop sending blocks once this block is delivered. This is how to replay missed blocks that were added to the ledger. When a startBlock is not included, the endBlock must be equal to or larger than the current channel block height. This option changes how the connection is made to the fabric Peer's channel-based event service, therefore the registration must be made before the channel event hub has setup the connection. Replaying events may confuse other event listeners; therefore, only one listener will be allowed on a ChannelEventHub when startBlock and/or endBlock are used. The value 'newest' will indicate that 'endBlock' will be calculated by the peer as the newest block on the ledger. This allows the application to replay up to the latest block on the ledger and then the listener will stop and be notified by the 'onError' callback. Number - A number value may be specified as the block number. 'newest' - The string of 'newest'. This will have the block number determined by the Peer's channel-based event service at connect time of the the newest block on the ledger. 'oldest' - The string of 'oldest'. This will have the block number determined by the Peer's channel-based event service at connect time of the the oldest block on the ledger, unless your ledger has been pruned, this will be block 0. 'last_seen' - The string of 'last_seen'. This will have the channel event hub instance determine the block number at the time of the registration. The number will be based on the last block that this channel event hub has received from the Peer's channel-based event service. Using this option on an event listener does require that this channel event hub has been previously running. {boolean} unregister -- (Optional) This setting indicates that the registration should be removed (unregister) after the event is seen. When the application is using a timeout to only wait a specified amount of time for the transaction to be seen, the timeout processing should include the manual 'unregister' of the transaction event listener to avoid the event callbacks being called unexpectedly. The default for this setting is different for the different types of event listeners. For block listeners the default is true when an end_block was set as a option, the listener will be active and receiving blocks until the end block is received and then the listener will be automatically unregistered. For transaction listeners the default is true and once the transaction event has occurred the listener will be automatically unregistered. If the transaction listener has used an endBlock, the default will be to automatically unregister the listener even if the transaction has not been seen. For chaincode event listeners the default will be false as the match filter might be intended for many transactions, however if the chaincode event listener has set an endBlock it will be automatically unregistered after the endBlock is seen. {boolean} disconnect -- (Optional) This setting indicates to the ChannelEventHub instance to automatically disconnect itself from the peer's channel-based event service once the event has been seen. The default is false. When not set and the endBlock has been set the ChannelEventHub instance will automatically disconnect itself. {boolean} as_array -- (Optional) This setting indicates to the ChannelEventHub instance to send all chaincode events to the callback as array rather than one at a time. This setting is only available for chaincode events. How to use a Channel Event Hub The ChannelEventHub class is very flexible. It allows for many usage models. waiting for my transaction to complete looking at chaincode events auditing a channel for all new blocks replay events Transaction events A majority of users will need to know when a transaction is committed to the ledger. All transactions have an unique identifier that may be monitored. Users may register an event listener to indicate that a specific transaction has been written to the ledger. This will be known as a transaction event. Steps to be notified for a transaction event: Get a channel event hub instance, this may be done for every transaction or may be done once and reused. Connect the channel event hub instance with the peer's event service. You may wish to connect before registering when reusing the ChannelEventHub instance for many transactions. Create transaction and have it endorsed. Register your callback using the transaction ID string of the transaction with the channel event hub instance. Connect the channel event hub if not already connected. Submit the endorsed transaction to be ordered. Wait to be notified of the transaction being committed to the ledger or timeout if there is an issue. Unregister the event listener when transaction is seen, which will be done automatically by default. Disconnect the channel event hub when finished listening, which could be done automatically if configured. Chaincode events Chaincode programs running on the fabric network are able to add into a transaction a name and a value, this is known as a chaincode event. The \"name\" will most likely not be unique and more than one transaction may contain the chaincode event name, therefore the listener callback may be called many times. The listener may be setup to use a regular expression when looking for a name match such that a single listener may be notified with many different names. NOTE: Chaincode events must be committed and written to the ledger before a listener will be notified. The ChannelEventHub instance will not see chaincode events in transactions until the transactions commits and is written to the peer's ledger on the peer that ChannelEventHub has connected to the event service. Steps to be notified when a chaincode event occurs: Get a channel event hub instance, this should be done once and reused. Connect the channel event hub instance with the peer's event service. You should connect before registering when reusing the ChannelEventHub instance for many transactions and if waiting for a chaincode event in a transaction that will be committed. Note: When the ChannelEventHub connect completes to the Peer's event service blocks will start to be delivered to the ChannelEventHub instance. If the startBlock parameter is not used, the first block received will be the latest block. The latest block may contain a chaincode event and it may match the chaincode event that you will register. This latest block is not the block that will contain the transaction that you will commit shortly and is just the last block on the channel ledger. We know that it is not our block because we have not committed our transaction, however the Peer was asked to start and keep sending the latest blocks. So you should connect first then register and then commit when using chaincode events. Register your callback with the name of the chaincode event, you may use a regular expression to match on more than one name. Somewhere on the network a transaction is endorsed and committed containing a chaincode event. Process the chaincode events as they come in. Unregister the event listener when finished. Disconnect the channel event hub when finished listening. Block events Once a ChannelEventHub connects to the Peer's event service it will start receiving blocks as they are added to the ledger, unless a \"startBlock\" is specified, then it will start receiving blocks from the block specified. When a block is received by the ChannelEventHub instance from the Peer's event service, this is known as a block event, Steps to be notified when a block event occurs: Get a channel event hub instance. Register to receive blocks. Connect the channel event hub instance with the peer's event service. Somewhere on the network a transaction is endorsed and committed. Process the blocks as they come in. Disconnect the channel event hub when finished listening. Replay events If you wish to look at events that already happened, use the \"startBlock\" option to replay the events. Using the start block will connect to the Peer's event service and have it start sending existing blocks starting with the block number specified rather than the latest block. Blocks will be continued to be sent until the \"endBlock\" is seen. If no end block is specified, then blocks will continue to be sent as they are added to the ledger. Replay may be used to look again for your transaction or chaincode events when your application was off-line. When not specifying an end block the channel event hub may continued to be used to monitor for new events as they happen on the channel after catching up on existing events. Steps to be notified when a replay event occurs: Get a channel event hub instance. Register to receive your events. Connect the channel event hub instance with the peer's event service using a \"startBlock\" Process the events as they come in. Disconnect the channel event hub when finished listening. Get a Channel Event Hub Use the fabric-client Channel newChannelEventHub object to create new instances of ChannelEventHub objects. Use the following to get a ChannelEventHub instances that will be setup to work with the Peer's channel-based event service. A ChannelEventHub instance will use all the same endpoint configuration settings that the peer instance is using, like the tls certs and the host and port address. // peer is a instance const channel_event_hub = channel.newChannelEventHub(peer); // using the peer name const channel_event_hub = channel.newChannelEventHub('peer0.org1.example.com'); When using a connection profile (see How to use a common common connection profile file) then the peer's name may be used to get a channel event hub. This will return the same ChannelEventHub instance each time the \"getChannelEventHub\" is called. // must use peer name const channel_event_hub = channel.getChannelEventHub('peer0.org1.example.com'); Here is an example of how to get a list of channel event hubs when using a connection profile. The following will get a list based on the current organization that is defined in the currently active client section of the connection profile. Peers defined in the organization that have the eventSource set to true will be added to the list. const channel_event_hubs = channel.getChannelEventHubsForOrg(); When creating a peer instance, you can get a ChannelEventHub instance by using the peer instance. const data = fs.readFileSync(path.join(__dirname, 'somepath/tlscacerts/org1.example.com-cert.pem')); const peer = client.newPeer( 'grpcs://localhost:7051', { pem: Buffer.from(data).toString(), 'ssl-target-name-override': 'peer0.org1.example.com' } ); const channel_event_hub = channel.newChannelEventHub(peer); Connect a Channel Event Hub Once you have a ChannelEventHub instance you will need to connect to the peer's event service. The \"connect\" call setups up a connection to the peer's event service. The connection with the peer's event service must indicate which blocks to receive. By default the ChannelEventHub will specify the latest block as the starting point. This is usually the point on the ledger where monitoring is required. Users may specify both a starting point and an ending point. Specifying a \"startBlock\" is useful when the application needs to look at existing transactions, chaincode events, or blocks. The connect call may be made before or after registration, however start blocks and end blocks may not be changed after the connect call is made. The connection with the peer's event service must also indicate full blocks or filtered blocks. By default the connection will be setup to receive filtered blocks as this contains transaction status and does not contain sensitive data. The best practice is to connect before registering for transaction events and provide a callback. const channel_event_hub = ... channel_event_hub.connect({full_block: false}, (err, status) =&gt; { if (err) { // process the error } else { // connect was good } }); channel_event_hub.register... The best practice is to connect before registering for chaincode events. When connect is not part of the registration flow then it is easily modified to include the \"startBlock\" (for replay). Since filtered blocks contain very little information, chaincode events and block events may not be useful unless full blocks are received. The user performing the connect must have the access authority to see full blocks. const channel_event_hub = ... channel_event_hub.register... channel_event_hub.connect({full_block: true}, (err, status) =&gt; { if (err) { // process the error } else { // connect was good } }); With replay, notice that the user gets the start block from a previous ChannelEventHub. const channel_event_hub = ... const my_start = old_channel_event_hub.lastBlockNumber(); channel_event_hub.register... channel_event_hub.connect({full_block: true, startBlock: my_start}, (err, status) =&gt; { if (err) { // process the error } else { // connect was good } }); Block Listener When there is a need to monitor for new blocks being added to the ledger, use a block event listener. The Fabric client Node.js will be notified when a new block is committed to the ledger on the peer. The client Node.js will then call the registered callback of the application program. The callback will be passed a JSON representation of the newly added block. Note that when connect() is not called with {full_block: true} the callback will receive a filtered block. The access rights of the user registering to receive full blocks will be checked by the Peer's channel-based event service. When there is a need to see previously added blocks, the registration of the callback may include a starting block number. The callback will start receiving blocks from this number and continue to receive new blocks as they are added to the ledger. This is a way for the application to resume and replay events that may have been lost if the application were to be offline. The application should remember the last block it has processed to avoid replaying the entire ledger. The following example will register a block listener to start receiving new blocks as they are added to the ledger. // keep the block_reg to unregister with later if needed block_reg = channel_event_hub.registerBlockEvent((block) =&gt; { console.log('Successfully received the block event'); &lt;do something with the block&gt; }, (error)=&gt; { console.log('Failed to receive the block event ::'+error); &lt;do something with the error&gt; }); The following example will register with a start block number because this application needs to resume at a specific block and replay the missed blocks. The application callback will handle the replayed blocks in the same manor like current events. The block listener will continue to receive blocks as they are committed to the ledger on the peer. // keep the block_reg to unregister with later if needed block_reg = channel_event_hub.registerBlockEvent((block) =&gt; { console.log('Successfully received the block event'); &lt;do something with the block&gt; }, (error)=&gt; { console.log('Failed to receive the block event ::'+error); &lt;do something with the error&gt; }, {startBlock:23} ); The following example will register with a start block number and an end block. The application needs to replay the missed blocks. The application callback will handle the replayed blocks in the same manor as current events. The block listener will be automatically unregistered and the ChannelEventHub shutdown when the end block event is seen by the listener. The application will not have to handle this housekeeping. block_reg = channel_event_hub.registerBlockEvent((full_block) =&gt; { console.log('Successfully received a block event'); &lt;do something with the block&gt; const event_block = Long.fromValue(full_block.header.number); if(event_block.equals(current_block)) { console.log('Successfully got the last block number'); &lt;application is now up to date&gt; } }, (error)=&gt; { console.log('Failed to receive the block event ::'+error); &lt;do something with the error&gt; }, // for block listeners, the defaults for unregister and disconnect are true, // so they are not required to be set in the following example {startBlock:23, endBlock:30, unregister: true, disconnect: true} ); The following example will register with a start block number and an end block set to 'newest'. The error callback will be called to notify the application that the last block has been delivered and that the listener has been shutdown. block_reg = channel_event_hub.registerBlockEvent((block) =&gt; { console.log('Successfully received the block event'); &lt;do something with the block&gt; }, (error)=&gt; { if(error.toString().indexOf('Newest block received')) { console.log('Received latest block'); &lt;application is now up to date&gt; } else { console.log('Failed to receive the block event ::'+error); &lt;do something with the error&gt; } }, {startBlock:23, endBlock:'newest'} ); Transaction listener When there is a need to monitor for the completion of a transaction on your organization's peer, use a transaction listener. The client application callback will be notified when a new block is committed to the ledger on the peer. fabric-client will then check the block for registered transaction identifiers. If a transaction is found, then the callback will be notified with the transaction ID, the transaction status, and the block number. Filtered blocks contain the transaction status, so there is no need to connect to the Peer's channel-based event service to receive full blocks. Since most non-admin users will not be able to see full blocks, connecting to receive filtered blocks will avoid access issues when users only need to listen for their transactions to be committed. The following example will show registering a transaction ID within a javascript promise and building another promise for sending the transaction to the orderer. Both promises will be executed together so that the results will be received for both actions together. The default optional setting of unregister is by default true with a transaction listener. In the following example the listener that is registered will be automatically unregistered after the listener sees the transaction. let tx_object = client.newTransactionID(); // get the transaction ID string for later use let tx_id = tx_object.getTransactionID(); let request = { targets : targets, chaincodeId: 'my_chaincode', fcn: 'invoke', args: ['doSomething', 'with this data'], txId: tx_object }; return channel.sendTransactionProposal(request); }).then((results) =&gt; { // a real application would check the proposal results console.log('Successfully endorsed proposal to invoke chaincode'); let event_monitor = new Promise((resolve, reject) =&gt; { let handle = setTimeout(() =&gt; { // do the housekeeping when there is a problem channel_event_hub.unregisterTxEvent(tx_id); console.log('Timeout - Failed to receive the transaction event'); reject(new Error('Timed out waiting for block event')); }, 20000); channel_event_hub.registerTxEvent((event_tx_id, status, block_num) =&gt; { clearTimeout(handle); //channel_event_hub.unregisterTxEvent(event_tx_id); let the default do this console.log('Successfully received the transaction event'); resolve(status); }, (error)=&gt; { clearTimeout(handle); console.log('Failed to receive the transaction event ::'+error); reject(error); }, // notice that `unregister` is not specified, so it will default to true // `disconnect` is also not specified and will default to false ); }); let send_trans = channel.sendTransaction({proposalResponses: results[0], proposal: results[1]}); return Promise.all([event_monitor, send_trans]); }).then((results) =&gt; { Chaincode event listener When there is a need to monitor for events that will be posted from within your chaincode, use a chaincode event listener. The client Node.js will be notified when a new block is committed to the ledger. The client will then check for registered chaincode patterns within the chaincode event's name field. The registration of the listener includes a regular expression to be used in the check against a chaincode event name. If a chaincode event name is found to match the listener's regular expression then the listener's callback will be notified with the chaincode event, the block number, transaction id, and transaction status. Filtered blocks will not have the chaincode event payload information; it has only the chaincode event name. If the payload information is required, the user must have access to the full block and the channel event hub must be connect({full_block:true}) to receive the full block events from the Peer's channel-based event service. The following example demonstrates registering a chaincode event listener within a javascript promise and building another promise for sending the transaction to the orderer. Both promises will be executed together so that the results will be received for both actions together. If a chaincode event listener is needed for long term monitoring, follow the block listener example above. let tx_object = client.newTransactionID(); let request = { targets : targets, chaincodeId: 'my_chaincode', fcn: 'invoke', args: ['doSomething', 'with this data'], txId: tx_object }; return channel.sendTransactionProposal(request); }).then((results) =&gt; { // a real application would check the proposal results console.log('Successfully endorsed proposal to invoke chaincode'); // Build the promise to register a event listener with the NodeSDK. // The NodeSDK will then send a request to the Peer's channel-based event service // to start sending blocks. The blocks will be inspected to see if // there is a match with a chaincode event listener. let event_monitor = new Promise((resolve, reject) =&gt; { let regid = null; let handle = setTimeout(() =&gt; { if (regid) { // might need to do the clean up this listener channel_event_hub.unregisterChaincodeEvent(regid); console.log('Timeout - Failed to receive the chaincode event'); } reject(new Error('Timed out waiting for chaincode event')); }, 20000); regid = channel_event_hub.registerChaincodeEvent(chaincode_id.toString(), '^evtsender*', (event, block_num, txnid, status) =&gt; { // This callback will be called when there is a chaincode event name // within a block that will match on the second parameter in the registration // from the chaincode with the ID of the first parameter. console.log('Successfully got a chaincode event with transid:'+ txnid + ' with status:'+status); // might be good to store the block number to be able to resume if offline storeBlockNumForLater(block_num); // to see the event payload, the channel_event_hub must be connected(true) let event_payload = event.payload.toString('utf8'); if(event_payload.indexOf('CHAINCODE') &gt; -1) { clearTimeout(handle); // Chaincode event listeners are meant to run continuously // Therefore the default to automatically unregister is false // So in this case we want to shutdown the event listener once // we see the event with the correct payload channel_event_hub.unregisterChaincodeEvent(regid); console.log('Successfully received the chaincode event on block number '+ block_num); resolve('RECEIVED'); } else { console.log('Successfully got chaincode event ... just not the one we are looking for on block number '+ block_num); } }, (error)=&gt; { clearTimeout(handle); console.log('Failed to receive the chaincode event ::'+error); reject(error); } // no options specified // unregister will default to false // disconnect will default to false ); }); // build the promise to send the proposals to the orderer let send_trans = channel.sendTransaction({proposalResponses: results[0], proposal: results[1]}); // now that we have two promises all set to go... execute them return Promise.all([event_monitor, send_trans]); }).then((results) =&gt; { The default is to receive the chaincode events one at a time, however it would be difficult to know that a chaincode event was missed and to maintain the order within the block. Using the new option as_array the callback will receive all chaincode events found in a block as an array. The following example will register a chaincode listener with a callback that will handle the chaincodes as an array, notice the fifth parameter is an options object with the 'as_array' true setting. channel_event_hub.registerChaincodeEvent( 'mychaincode', 'myeventname', (...events) =&gt; { for (const {chaincode_event, block_num, tx_id, tx_status} of events) { /* process each event */ } }, (err) =&gt;{ /* process err */ }, { as_array: true} ); When using mutual tls All peers and orderers objects need to use the same client side credentials for a mutual TLS connection. The credentials must be assigned to the 'client' object instance before it is used to create the peer used in the ChannelEventHub creation. const client = new Client(); client.setTlsClientCertAndKey(tlsInfo.certificate, tlsInfo.key); const channel = client.newChannel('mychannel'); const peer = client.newPeer('grpcs://localhost:7051', { pem: '&lt;pem string here&gt;', 'ssl-target-name-override': 'peer0.org1.example.com' }); channel.addPeer(peer); const channelEventHub = channel.newChannelEventHub(peer); When connecting to replay Your application may be recording the block numbers as they come in or it may use the last block of another channel event hub. Your application has been off line and now wishes to catch up on the missed blocks and then continue to process new blocks. The following will connect a channel event hub to the Peer's channel-based event service at the point of your choice and since there is no endBlock specified, it will continue to receive the blocks as they are added to the ledger. Note: Use the ChannelEventHubs.lastBlockNumber() to get the number of the last block received from a previously running ChannelEventHub instance. const channel_event_hub = channel.newChannelEventHub(mypeer); // be sure to register your listeners before calling `connect` or you may // miss an event channel_event_hub.registerBlockEvent(eventCallBack, errorCallBack, options) const my_starting_point = this._calculate_starting_point(old_event_hub); channel_event_hub.connect({startBlock: my_starting_point}, my_connect_call_back); When reconnecting Your application has a long running block listener or chaincode event listener and you wish to restart the event listening. The following will reconnect the channel event hub to the Peer's channel-based event service and not disturb the existing event listeners. The connection will be setup to start sending blocks from the last block the channel event hub had seen. The listeners may be notified by a block or event that has already been seen and this may be used to verify that notifications are again running. channel_event_hub.reconnect({startBlock: 'last_seen'}, my_connect_call_back); This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-discovery.html":{"id":"tutorial-discovery.html","title":"Tutorial: fabric-client: How to use the discovery service","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to use the discovery service This tutorial illustrates the use of the service discovery by the Hyperledger Fabric Node.js Client as of 1.2. For more information on: getting started with Hyperledger Fabric see Building your first network. the configuration of a channel in Hyperledger Fabric and the internal process of creating and updating see Hyperledger Fabric channel configuration Service Discovery The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development, including the use of the Javascript promise and async await. Overview The service discovery provided by the Hyperledger Fabric helps an application to understand the current view of the network. The service discovery also has insight into the endorsement policy of chaincodes and is able to provide various list of peers that are currently active on the network that could be used to endorse a proposal. To use the service the application will have to connect with just one peer. Modified API's that will use the service discovery channel.initialize() - This method has been enhanced by adding an option to query a peer using the new service discovery to initialize the channel object. This method may be call at anytime to reinitialize the channel. When using discovery, this may be used to assign a new target peer providing the discovery service. The initialize() method is also required to instantiate the handlers, by default the handlers shipped with the fabric-client are designed to use the discovery results. channel.sendTransactionProposal() - This method has been enhanced to use the discovered peers to send the endorsement proposal. channel.sendTransaction() - This method has been enhanced to use the discovered orderers to send the signed endorsements. New API's that will use service discovery channel.refresh() - The channel will be refreshed with new service discovery results, add new peers, orderers, and MSPs. The call will use the service discovery settings as provided on the channel.initialize() call. If a new peer is required for the refresh of discovery results then call the channel.initialize() with a new target peer rather then calling refresh(). channel.getDiscoveryResults() - The channel will cache the results of the last query made to the service discovery and make the results available. The call will use the discovery-cache-life setting to determine if the results should be refreshed. if the results need to be refreshed, the channel.refresh() will be called internally to fetch new service discovery results. The call is used by the DiscoveryEndorsementHandler as it starts to determine the target peers. client.queryPeers() - A client object will be able to query a target peer using the discovery service to provide a list of peer endpoints and associated organizations active on the network at the time of the query. see Client#queryPeers New configuration settings initialize-with-discovery - boolean - When the applications calls for the channel to be initialized, service discovery will be used. (default false) discovery-cache-life - integer (time in milliseconds) - The amount of time the service discovery results are considered valid. (default 300000 - 5 minutes) override-discovery-protocol - string - Override the protocol to use when building URL's for the discovered endpoints. The Discovery Service only provides host:port. By default, if you connect to the Discovery Service without TLS (grpc://), then all discovered endpoints will be connected to without TLS. If you connect to the Discovery Service with TLS (grpcs://), then all discovered endpoints will be connected to with TLS. You can use this configuration setting to force either grpc or grpcs for all discovered endpoints, regardless of how you connected to the Discovery Service. Please note that it is highly recommended not to connect to the Discovery Service or any discovered endpoints without TLS (grpc://), as all information will be sent over plaintext, un-encrypted. endorsement-handler - string - The path to the endorsement handler. Allows for a custom handler to be used. This handler is used in the sendTransactionProposal method to determine the target peers and how to send the proposal. (default 'fabric-client/lib/impl/DiscoveryEndorsementHandler.js') commit-handler - string - The path to the commit handler. Allows for a custom handler to be used. This handler is used in the sendTransaction method to determine the orderers and how to send the transaction to be committed. (default 'fabric-client/lib/impl/BasicCommitHandler.js') How the DiscoveryEndorsementHandler works The sendTransactionProposal will use the peers included in the \"targets\" to endorse the proposal. If there is no \"targets\" parameter, the endorsement request will be handled by the endorsement handler. The default handler that comes with the fabric-client is designed to use the results from the fabric discovery service. The peer that is assigned as the target during channel initialization will be the peer that is sent the discovery service request. The discovery service results will be based on the chaincode of the endorsement or based on an endorsement hint (endorsementHint) included in the endorsement request. The hint may include one or more chaincodes and each chaincode may include one or more associated collection names. Results will be refreshed using the discovery-cache-life system setting. By default the cache life is 5 minutes. This may be changed easily by using the following. Client.setConfigSetting('discover-cache-life', &lt;milliseconds&gt;); If there are no service discovery results, the handler will send the endorsement request to the peers that have been assigned to the channel with the endorsingPeer role (a peer that has nor been assigned a role will default to having that role, this means that a role must be explicitly turned off). When the handler processes the discovery service results it assumes that all peers referenced have a peer instance object created and assigned to the channel instance object. The channel instance will build the required peer instances to support endorsements when it processes the discovery service results before passing the results to the handler. The channel will not build new peer instances if the peer is already assigned to the channel either by the application or by a previous discovery service request. The default 'DiscoveryEndorsementHandler' takes optional parameters that allow the application to specify peers or organizations that will be preferred, ignored or required. The discovery service results will include groups of peers and layouts that specify how many peers from each group it will take to satisfy the endorsement policy of the proposal's chaincode or the endorsement policies of the endorsement hint. Each group will be modified using the parameters of the endorsement call. The handler will first remove peers that are not required or should be ignored. Then the group list will be sorted by ledger height or randomized. Finally preferred peers will be moved to the top of the group list. The handler will randomly select a layout to make the endorsement. The handler looks at each group in the layout and selects the number peers specified by that group in the layout. The number of peers is the number of endorsements needed to satisfy the endorsement policy. Peers will be selected starting at the top of the modified group list to be sent an endorsement request. If any of the requests fail, the handler will select the next available peer from the modified group list. If the number of successful endorsements reaches the number of peers called out for each group in the layout, the handler will successfully return the endorsements. If there are not enough successful endorsements, the handler will select another random layout and try again or return an error indicating that it was unable to complete successfully. The error will include the responses from all peers. Note: The default handler does not remember the results of the previous call. Peers that may have failed will be tried again. With randomizing and refreshing of the discovery service results, the order of how peers are selected will likely change on every request. Note: If the above behavior does not meet the needs of your organization a custom handler may be used. How the BasicCommitHandler works The default handler that comes with the fabric-client will send to one orderer at a time until it receives a successful submission of the transaction. Sending a transaction (a set of endorsements) to an orderer does not mean that the transaction will be committed, it means that the request was built properly and that the sender has the authority to send the request. The response from the orderer will indicate that the orderer has accepted the request. The sendTransaction has an optional parameter orderer that indicates the orderer to send the transaction. The handler will use the orderer as specified with the orderer parameter and not send to any other orderers. If no orderer is specified the handler will get the list of orderers assigned to the channel. These orderers may have been assigned manually to the channel with a channel.addOrderer() call or assigned automatically when using the service discovery. To Initialize By default the fabric-client will not use the service discovery. To enable the use of the service, set the config setting to true or use the discover parameter on the initialize() call. note: Channel#initialize must be run to both enable discovery and to startup the handlers. Client.setConfigSetting('initialize-with-discovery', true); --or-- Client.addConfigFile('/path/to/config.json'); // the json file contains the following line //\"initialize-with-discovery\": true //--or-- await channel.initialize({discover:true}); To use the service discovery on the initialize(), a channel must have at least one peer assigned with the discovery role or a target must be provided on the call. Peers may be assigned automatically by loading a connection profile or they may have been added manually with the channel.addPeer(). await channel.initialize({ discover: true, target: peer }); //--or-- await channel.initialize({ discover: true, target: 'peer2.org2.example.com' //peer defined in the connection profile }); //--or-- // no target specified, using the first peer with the discover role // peer was added to the channel either by the 'addPeer' or when using // a connection profile await channel.initialize({ discover: true }); The return results of initialization with service discovery will be the MSP configurations, the peers, the orderers, and the endorsing plans for all chaincodes on the channel in JSON format. The results are stored and cached internally and the caller does not have to do anything with the results, they are provided only for reference. The initialize call also allows for changing the endorsement handler by specifying a path to a custom endorsement handler. The handler may be changed independently of using the service discovery. The default endorsement handler however does use discovery service results to determine the endorsing peers. await channel.initialize({ endorsementHandler: '/path/to/my/handler.js' }); When the fabric network is running in a docker-compose and the node.js application is running outside of the docker containers, it will be necessary to modify the addresses returned from the service discovery. The service discovery sees the addresses of the peers and orderers as host names and ports, however the node.js application running outside of docker will only know the endpoints as localhost and port. In the docker-compose file, notice how Docker is mapping the port addresses, these must be same when using service discovery. Using - 7061:7051 will not work as the fabric-client does not have visibility into the docker-compose file. Notice in the following definition of a peer from a docker-compose file. The port number is the same and has been defined along with the host name peer0.org1.example.com:7051 for the peer and gossip settings. The node.js fabric-client application running outside of of the docker containers will use localhost:7051. peer0.org1.example.com: container_name: peer0.org1.example.com image: hyperledger/fabric-peer environment: - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_PEER_ID=peer0.org1.example.com - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LISTENADDRESS=peer0.org1.example.com:7051 - CORE_PEER_GOSSIP_ENDPOINT=peer0.org1.example.com:7051 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051 - CORE_LOGGING_LEVEL=debug ## the following setting redirects chaincode container logs to the peer container logs - CORE_VM_DOCKER_ATTACHSTDOUT=true - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/peer ## - CORE_PEER_TLS_ENABLED=true - CORE_PEER_TLS_CLIENTAUTHREQUIRED=true - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/msp/peer/tls/key.pem - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/msp/peer/tls/cert.pem - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/msp/peer/cacerts/org1.example.com-cert.pem - CORE_PEER_TLS_CLIENTROOTCAS_FILES=/etc/hyperledger/msp/peer/cacerts/org1.example.com-cert.pem # # the following setting starts chaincode containers on the same # # bridge network as the peers # # https://docs.docker.com/compose/networking/ - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fixtures_default working_dir: /opt/gopath/src/github.com/hyperledger/fabric command: peer node start ports: - 7051:7051 volumes: - /var/run/:/host/var/run/ - ./channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/:/etc/hyperledger/msp/peer depends_on: - orderer.example.com The channel.initialize() call as new parameter to indicate that the hostname mapping to localhost should be done. Use the asLocalhost with true or false, the default is false. await channel.initialize({discover:true, asLocalhost:true}) Using peers added manually to the channel: Only one peer will now be required to be added to the channel when the applications programmatically adds the peers and orderers to build a channel instance. The peer must have the role discover. As with all roles, if the role is not defined and set to false, the peer will have that role on the channel by default. const channel = client.newChannel('mychannel'); const peer = client.newPeer(....); channel.addPeer(peer); await channel.initialize({discover:true}); When the channel is initialized using service discovery and peers and orderers are added to the channel, a peer with the address that was used for service discovery will likely be on the list of discovered peers. A peer with the address used for service discovery will not be added again to the channel as a peer with that address has already been assigned to the channel. The name a peer will be known by may be set by using the name setting when creating the peer. const peer = client.newPeer(url, {name: 'peer0', ...}); The default name of a peer will be the host name and port if the name parameter is not provided or for peers added by service discovery. peer0.org1.example.com:7051 Using a peer not added to the channel: To use the service discovery a peer is required. The application may define a peer and pass it on the initialize call. The peer does not have to be added to the channel instance. const channel = client.newChannel('mychannel'); const peer = client.newPeer(....); await channel.initialize({discover:true, target:peer}); When the channel is initialized using service discovery and peers and orderers are added to the channel, a peer with the address that was used for service discovery will likely be on the list of discovered peers. A peer instance with the address used for service discovery will be added to the channel with the same address as the peer instance used for service discovery because the peer instance used on the initialize call is not added to the channel, it is only used on the initialize call. If the application chooses to use no longer use the peer on the initialize call or the peer that was automatically assigned call the channel.initialize() again and provide a peer instance or name. This new peer will be used going forward for service discovery calls. Using connection profile: When using a connection profile, all the peers and orderers on the network will no longer need to be provided. Just one peer will be required and assigned to the channel. The peer must have the role discover. As with all roles, if the role is not defined and set to false, the peer will have that role on the channel by default. The following example shows a peer that is going to be used primarily for service discovery. channels: mychannel: peers: peer1.org2.example.com: endorsingPeer: false chaincodeQuery: false ledgerQuery: true eventSource: false discover: true peer2.org2.example.com: endorsingPeer: true chaincodeQuery: true ledgerQuery: true eventSource: false discover: false peers: peer1.org2.example.com: url: grpcs://localhost:8051 grpcOptions: ssl-target-name-override: peer1.org2.example.com tlsCACerts: path: test/fixtures/channel/c... peer2.org2.example.com: url: grpcs://localhost:8052 grpcOptions: ssl-target-name-override: peer2.org2.example.com tlsCACerts: path: test/fixtures/channel/c... When a channel is created using the client.getChannel() after the client instance has loaded a connection profile, the fabric-client will create peers and assign them to the channel. The peers and orderers will inherent the connection options as assigned to the client instance. see Client#addConnectionOptions Peers with the the discover role will be used when the channel.initialize() is called and no peer is passed as a target. const client = Client.loadFromConfig(...); const channel = client.getChannel('mychannel'); await channel.initialize({discover:true, asLocalhost:true}; If the initialize fails because the peer with the discover role is not online, the application may select another peer. await channel.initialize({discover:true, target:'peer2.org2.example.com'}); When the application passes a peer name or a peer instance to the initialize call, that peer will be used and the discover role will not be checked. The name a peer will be known by is the name used in the yaml file. peer1.org2.example.com:port The name of a peer will be the host name and port for peers added by the service discovery. peer0.org1.example.com:7051 To Endorse As discussed above, the channel.sendTransactionProposal() will now use a pluggable handler. The fabric-client will come with a handler that will use service discovery. By default the endorsement-handler configuration setting will point to the DiscoveryEndorsementHandler. If the channel has been initialized using the service discovery and there are no targets define on the sendTransactionProposal call, the handler will use the service discovery results based on the chaincode of the proposal request to determine the target peers to perform the endorsements. const tx_id = client.newTransactionID(); const request = { chaincodeId : 'example', fcn: 'move', args: ['a', 'b','100'], txId: tx_id }; await channel.sendTransactionProposal(request); If the endorsement will require one or more chaincode to chaincode calls and/or be over a collection or two, then the endorsement proposal request must include the parameter \"endorsement_hint\". This will assist the discovery service in putting together an endorsement plan based on all the endorsement policies of chaincodes and collections involved and the active peers on the network. The following example shows a chaincode to chaincode call over collections. Notice how the chaincode that starts the endorsement must also still be included as the \"chaincodeId\" of the endorsement request. const hint = { chaincodes: [ { name: \"my_chaincode1\", collection_names: [\"my_collection1\", \"my_collection2\"] }, { name: \"my_chaincode2\", collection_names: [\"my_collection1\", \"my_collection2\"] } ]}; const tx_id = client.newTransactionID(); const request = { chaincodeId : 'my_chaincode1', fcn: 'move', args: ['a', 'b','100'], txId: tx_id, endorsement_hint: hint }; await channel.sendTransactionProposal(request); The application is able to have specific peers or peers in a specified organization chosen before other peers or not be chosen at all for endorsements. required: An array of strings that represent the names of peers. Peers named on this list and in the endorsement plan will be the only peers to be sent the endorsement request. Other peers found in the endorsement plan will not be used. preferred: An array of strings that represent the names of peers that should be given priority by the endorsement handler if their ledger height is up to date. ignored: An array of strings that represent the names of peers that should be ignored by the endorsement handler. requiredOrgs: An array of strings that represent the names of organizations. Peers found in the endorsement plan that are in these organizations will be the only peers to be sent the endorsement request. Other peers found in the endorsement plan will not be used. preferredOrgs: An array of strings that represent the MSP ids of organizations that should be given priority by the endorsement handler if their ledger height is up to date. ignoredOrgs: An array of strings that represent the MSP ids of organizations that should be ignored by the endorsement handler. preferredHeightGap: An integer representing the maximum difference in the ledger height of a peer and the highest ledger height found in a group of peers. A peer will be given priority if it's ledger height is within this range. There is no default, if this value is not provided the ledger height of the peer will not be considered when being added a peer to the preferred list. sort: A string value that indicates how the peers within groups should be chosen. There are two sorts available: \"ledgerHeight\", sort the peers descending by the number of blocks on the channel ledger. \"random\", sort the peers randomly from the list, the preferred peers will be added randomly first then the others will be added randomly. The default is to sort by ledger height. For example when the handler gets the following request and has an endorsement plan with 'peer3' ledger height of 2000 and 'peer1' ledger height of 1990. Notice that the gap is 10, this gap is too large and 'peer1' will not be given priority. const request = { chaincodeId : 'example', fcn: 'move', args: ['a', 'b','100'], txId: tx_id, preferred: ['peer0', 'peer1.org1.example.com:8051'], preferredHeightGap: 5, ignored: ['peer1', 'peer2.org2.example.com:8054'] } For example when the handler gets the following request and has an endorsement plan with 'peer3' in 'Org3MSP' ledger height of 2000 and 'peer1' in 'Org1MSP' ledger height of 1990. Notice that the difference is 10, this gap is too large and 'peer1' will not be given priority. const request = { chaincodeId : 'example', fcn: 'move', args: ['a', 'b','100'], txId: tx_id, preferredOrgs: ['Org1MSP', 'Org3MSP'], preferredHeightGap: 5, ignored: ['Org4MSP'] } When the application only knows about organizations and will not know about specific peers it may use the 'requiredOrgs', 'preferredOrgs', and/or 'ignoredOrgs' request parameters. For example if the application knows that the transaction is between two organizations, it may require that only these two endorse the proposal. const request = { chaincodeId : 'example', fcn: 'move', args: ['a', 'b','100'], txId: tx_id, requiredOrgs: ['Org2MSP', 'Org3MSP'] } To Commit As discussed above, the channel.sendTransaction() will now use a pluggable handler. The fabric-client will come with a handler that will use all orderers added to the channel. By default the commit-handler configuration setting will point to the BasicCommitHandler. This handler will send the transaction to each orderer, one at a time, that has been assigned to the channel until it gets a SUCCESS response or until the list is exhausted. The orderers may been added manually, due to a service discovery initialization or combination of the two. If an orderer is specified on the call, only that orderer will be used. This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-event-checkpointer.html":{"id":"tutorial-event-checkpointer.html","title":"Tutorial: fabric-network: How to replay missed events","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-network: How to replay missed events Event Checkpointing This tutorial describes the approaches that can be selected by users of the fabric-network module for replaying missed events emitted by peers. Overview Events are emitted by peers when blocks are committed. Two types of events support checkpointing: Contract events (also known as chaincode events) - Defined in transactions to be emitted. E.g. an event emitted when a commercial paper is sold Block Events - Emitted when a block is committed In the case of an application crashing and events being missed, applications may still want to execute the event callback for the event it missed. Peers in a Fabric network support event replay, and to support this, the fabric-network module supports checkpointing strategies that track the last block and transactions in that block, that have been seen by the client. Disclaimer Checkpointing in its current form has not been tested to deal with all recovery scenarios, so it should be used alongside existing recovery infrastructure. module:fabric-network~FileSystemCheckpointer is designed for Proof of Technology projects, so we strongly suggest implementing your own checkpointer using the module:fabric-network~BaseCheckpointer interface. Notes Block Number = Block Height - 1 When using checkpointing: The listener will only catch up on events if the startBlock is less than the current Block Number If the latest block in the checkpointer is block n the startBlock will be n + 1 (e.g. for checkpoint blockNumber=1,startBlock=2) Checkpointers The BaseCheckpoint class is an interface that is to be used by all Checkpoint classes. fabric-network has one default class, module:fabric-network~FileSystemCheckpointer that is exported as a factory in the module:fabric-network~CheckpointFactories. The FILE_SYSTEM_CHECKPOINTER is the default checkpointer. A checkpoint factory is a function that returns an instance with BaseCheckpointer as a parent class. These classes implement the async save(channelName, listenerName) and async load() functions. BaseCheckpointer.save() is called after the async callback function given to the event listener has finished processing. Custom Checkpointer Configuring a custom checkpointer requires two components to be created: The Checkpointer class The Factory const fs = require('fs-extra'); const path = require('path'); const { Gateway } = require('fabric-network'); class FileSystemCheckpointer extends BaseCheckpointer { constructor(channelName, listenerName, fsOptions) { super(channelName, listenerName); this.basePath = path.resolve(fsOptions.basePath); this.channelName = channelName; this.listenerName = listenerName; } /** * Initializes the checkpointer directory structure */ async _initialize() { const cpPath = this._getCheckpointFileName() } /** * Constructs the checkpoint files name */ _getCheckpointFileName() { let filePath = path.join(this._basePath, this._channelName); if (this._chaincodeId) { filePath = path.join(filePath, this._chaincodeId); } return path.join(filePath, this._listenerName); } async save(transactionId, blockNumber) { const cpPath = this._getCheckpointFileName() if (!(await fs.exists(cpPath))) { await this._initialize(); } const latestCheckpoint = await this.load(); if (Number(latestCheckpoint.blockNumber) === Number(blockNumber)) { const transactionIds = latestCheckpoint.transactionIds; latestCheckpoint.transactionIds = transactionIds; } else { latestCheckpoint.blockNumber = blockNumber; latestCheckpoint.transactionIds = [transactionIds]; } await fs.writeFile(cppPath, JSON.stringify(latestCheckpoint)); } async load() { const cpPath = this._getCheckpointFileName(this._chaincodeId); if (!(await fs.exists(cpPath))) { await this._initialize(); } const chkptBuffer = await fs.readFile(cpFile); let checkpoint = checkpointBuffer.toString('utf8'); if (!checkpoint) { checkpoint = {}; } else { checkpoint = JSON.parse(checkpoint); } return checkpoint; } } function File_SYSTEM_CHECKPOINTER_FACTORY(channelName, listenerName, options) { return new FileSystemCheckpointer(channelName, listenerName, options); } const gateway = new Gateway(); await gateway.connect({ checkpointer: { factory: FILE_SYSTEM_CHECKPOINTER_FACTORY, options: {basePath: '/home/blockchain/checkpoints'} // These options will vary depending on the checkpointer implementation }); In addition to save() and load() the BaseCheckpointer interface also has the loadLatestCheckpoint() function which, in the case that load() returns a list of checkpoints, will return the latest incomplete checkpoint (or whichever is most relevant for the specific implementation). Note: When using the filesystem checkpointer, use absolute paths rather than relative paths. When specifying a specific type of checkpointer for a listener, the checkpointer option in module:fabric-network.Network~EventListenerOptions`.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-event-hub-management.html":{"id":"tutorial-event-hub-management.html","title":"Tutorial: fabric-network: How to automatically select and reconnect to event hubs","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-network: How to automatically select and reconnect to event hubs This tutorial describes how to define the behavior of the event hub selection strategy used when event hubs disconnect or new event hubs are required. The ChannelEventHub is a fabric-client class that receives contract, commit and block events from the event hub within a peer. The fabric-network abstracts the event hub away, and instead uses an event hub selection strategy to create new event hub instances or reuse existing instances. Below is an example event hub selection strategy: class ExampleEventHubSelectionStrategy extends AbstractEventHubSelectionStrategy { constructor(peers) { this.peers = peers; this.disconnectedPeers = []; this.cleanupInterval = null; } _disconnectedPeerCleanup() { this.cleanupInterval = setInterval(() =&gt; { // Reset the list of disconnected peers every 10 seconds for (const peerRecord of disconnectedPeers) { // If 10 seconds has passed since the disconnect if (Date.now() - peerRecord.time &gt; 10000) { this.disconnectedPeers = this.disconnectedPeers.filter((p) =&gt; p !== peerRecord.peer); } } if (this.disconnectedPeers.length === 0) { clearInterval(this.cleanupInterval); this.cleanupInterval = null; } }, 10000); } /** * Returns the next peer in the list per the strategy implementation * @returns {ChannelPeer} */ getNextPeer() { // Only select those peers that have not been disconnected recently let availablePeers = this.peers.filter((peer) =&gt; this.disconnectedPeers.indexOf(peer) === -1) if (availablePeers.length === 0) { availablePeers = this.peers; } const randomPeerIdx = Math.floor(Math.random() * availablePeers.length); return availablePeers[randomPeerIdx]; } /** * Updates the status of a peers event hub * @param {ChannelPeer} deadPeer The peer that needs its status updating */ updateEventHubAvailability(deadPeer) { if (!this.cleanupInterval) { this._disconnectedPeerCleanup() } this.disconnectedPeers.push({peer: deadPeer, time: Date.now()}) } } The event hub strategy exists at a gateway level, and is included in the GatewayOptions in the form of a factory function. The factory gives the event hub selection strategy instance a list of peers that it can select event hubs from. function EXAMPLE_EVENT_HUB_SELECTION_FACTORY(network) { const orgPeers = getOrganizationPeers(network); const eventEmittingPeers = filterEventEmittingPeers(orgPeers); return new ExampleEventHubSelectionStrategy(eventEmittingPeers); } const gateway = new Gateway(); await gateway.connect(connectionProfile, { ... eventHubSelectionOptions: { strategy: EXAMPLE_EVENT_HUB_SELECTION_FACTORY } }) Static event hub Calling module:fabric-network.AbstractEventListener#setEventHub allows you to set one event hub that will not change. On unanticipated disconnect the SDK will attempt to reconnect to that event hub, rather than select the next peer using the event hub selection strategy.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-grpc-settings.html":{"id":"tutorial-grpc-settings.html","title":"Tutorial: fabric-client: How to set gRPC settings","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to set gRPC settings This tutorial illustrates the different ways of setting the gRPC settings used on connections to the Hyperledger Fabric network with a Hyperledger Fabric Node.js Client as of 1.4. For more information on: getting started with Hyperledger Fabric see Building your first network. The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development. Overview The Hyperledger Fabric Node.js javascript SDK, fabric-client, communicates with a Hyperledger Fabric network using gRPC. The gRPC technology, framework, handles moving data reliably between the fabric network and the fabric client application. fabric-client allows the application to provide settings required to control the environment. fabric-client has default connection options that include default gRPC settings. There are various ways for the application to override the default connection options. Default connection options fabric-client has the following gRPC connection options as defaults. These are in the default.json system configuration file that is included with the fabric-client NPM package. \"connection-options\": { \"grpc.max_receive_message_length\": -1, \"grpc.max_send_message_length\": -1, \"grpc.keepalive_time_ms\": 120000, \"grpc.http2.min_time_between_pings_ms\": 120000, \"grpc.keepalive_timeout_ms\": 20000, \"grpc.http2.max_pings_without_data\": 0, \"grpc.keepalive_permit_without_calls\": 1 } grpc.max_receive_message_length - Maximum message length that the channel can receive. Int valued, bytes. -1 means unlimited. grpc.max_send_message_length - Maximum message length that the channel can send. Int valued, bytes. -1 means unlimited. grpc.keepalive_time_ms - After a duration of this time the client/server pings its peer to see if the transport is still alive. Int valued, milliseconds. grpc.keepalive_timeout_ms - After waiting for a duration of this time, if the keepalive ping sender does not receive the ping ack, it will close the transport. Int valued, milliseconds. grpc.keepalive_permit_without_calls - Is it permissible to send keepalive pings without any outstanding streams. Int valued, 0(false)/1(true). grpc.http2.min_time_between_pings_ms - Minimum time between sending successive ping frames without receiving any data frame. Int valued, milliseconds. grpc.http2.max_pings_without_data - Minimum allowed time between a server receiving successive ping frames without sending any data frame. Int valued, milliseconds. Change default connection options The application may have a need to change or add new gRPC settings. By using the system configuration, the application may change the default connection options used for all new connections established. The default connection options are retrieved as a set of options when the Client instance builds new Peers or new Orderers. To modify the default connection options before runtime, update the default.json file or add your own configuration file to the system configuration. The last file loaded will override all previous files including the default.json file shipped with the fabric-client. see BaseClient.addConfigFile. const Client = require('fabric-client'); Client.addConfigFile(&lt;path to the config file&gt;); To modify the default connection options during runtime, get them from the system configuration, make modifications, then set them back on the system configuration. const default_options = client.getConfigSetting('connection-options'); const new_option = { 'grpc.keepalive_timeout_ms': 10000 }; // use the assign call to keep all other options and only update // the one setting or add a setting. const new_defaults = Object.assign(default_options, new_option); client.setConfigSetting('connection-options', new_defaults); // peer will have default options const peer = client.newPeer(url, options); Note: Making a change to the system configuration will have all new connections use new default connection options. This includes the connections that are created by new peers and new orderers that are created automatically when using the discovery service. Be careful when assigning new values to not remove other values. All the default connection options are contained in the one system configuration setting connection-options. Add connection options to the client The application may have a need to change or add new gRPC settings. The application may add connection options to the client instance that may be new options or to override existing default connection options stored in the system configuration. See the above discussion on how to change the options within the system configuration. const new_options = { 'grpc.keepalive_timeout_ms': 10000 }; client.addConnectionOptions(new_options); // peer will have options from default and from client const peer = client.newPeer(url, options); // discovered peers will have options from default and from client channel.initialize({discover: true, target: peer}); Note: All new connections created by this client, including those created automatically when using the discovery service will use the client's connection options to override the default connection options. Add connection options on create The application may need unique connection options for individual peers or orderers. Unique settings may be passed on the Client#newPeer or Client#newOrderer calls in the option parameter. Options passed in on the call will override both the client based options and the system configuration based options. const options = { pem: '&lt;pem string&gt;', 'ssl-target-name-override': 'myhost.org1.com', 'grpc.keepalive_timeout_ms': 10000 }; // peer will have options from default, client, and parameter const peer = client.newPeer(url, options); Note: Connection options passed on the newPeer() and the newOrderer() calls will only be used for that peer or orderer. Add connection options to a common connection profile Connection options may be set at the client level or individually on peers and orderers when using a common connection profile. In the following profile both the client section and one peer have a gRPC setting. client: # Which organization does this application instance belong to? The value is the name of an org # defined under \"organizations\" organization: Org1 # set connection timeouts for the peer and orderer for the client connection: timeout: peer: # the timeout in seconds to be used on requests to a peer, # for example 'sendTransactionProposal' endorser: 120 # the timeout in seconds to be used by applications when waiting for an # event to occur. This time should be used in a javascript timer object # that will cancel the event registration with the channel event hub instance. eventHub: 60 # the timeout in seconds to be used when setting up the connection # with the peer event hub. If the peer does not acknowledge the # connection within the time, the application will be notified over the # error callback if provided. eventReg: 3 # the timeout in seconds to be used on request to the orderer, # for example orderer: 30 # connection options, typically these will be common GRPC settings, # overriding what has been set in the system config file \"default.json\" options: grpc.keepalive_timeout_ms: 10000 peers: peer1.org2.example.com: url: grpcs://localhost:8051 grpcOptions: ssl-target-name-override: peer1.org2.example.com grpc.keepalive_timeout_ms: 20000 tlsCACerts: path: test/fixtures/channel/c... peer2.org2.example.com: url: grpcs://localhost:8052 grpcOptions: ssl-target-name-override: peer2.org2.example.com tlsCACerts: path: test/fixtures/channel/c... Note: All new connections created by this client, including those created automatically when using the discovery service will use the client's connection options to override the default connection options. peer1 will be override the one setting with it's own unique value. peer2 will not override any of the client's or the system defaults. The application may call the client.addConnectionOptions() to add additional settings or override settings. Peers created by a call to Client#getPeer or orderers created by a call to Client#getOrderer or by a call to Client#getChannel after the add call will use the new set of values. This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-handlers.html":{"id":"tutorial-handlers.html","title":"Tutorial: fabric-client: How to use the endorsement and commit handlers","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to use the endorsement and commit handlers This tutorial illustrates the use of the handlers by the Hyperledger Fabric Node.js Client as of 1.3. For more information on: getting started with Hyperledger Fabric see Building your first network. the configuration of a channel in Hyperledger Fabric and the internal process of creating and updating see Hyperledger Fabric channel configuration Service Discovery The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development, including the use of the Javascript promise and async await. Overview The fabric-client provides the ability for custom code that will handle the endorsement process and the submitting of endorsements to the orderer. There are two plug points defined, one on the Channel#sendTransactionProposal and one on the Channel#sendTransaction. The fabric-client will pass control to the handler to complete the processing. The custom code may decide to retry, try another end point, or use discovery to complete the task. see fabric-client: How to use the discovery service on how the default handlers are used with discovery. Modified API's that will use handlers channel.initialize() - This method has been enhanced to instantiate instances of the handlers for use by the channel. The method will get the paths from the system configuration settings to create and initialize them. channel.sendTransactionProposal() - This method has been enhanced to use an endorsement-handler if one has been instantiated and initialized. channel.sendTransaction() - This method has been enhanced to use a commit-handler if one has been instantiated and initialized. New configuration settings endorsement-handler - string - The path to the endorsement handler. Allows for a custom handler to be used. This handler is used in the sendTransactionProposal() method to determine the target peers and how to send the proposal. (default 'fabric-client/lib/impl/DiscoveryEndorsementHandler.js') commit-handler - string - The path to the commit handler. Allows for a custom handler to be used. This handler is used in the sendTransaction() method to determine the orderers and how to send the transaction to be committed. (default 'fabric-client/lib/impl/BasicCommitHandler.js') new Endorsement Handler The sending of a proposal to be endorsed may be done using custom code. The fabric-client will use by default the file called DiscoveryEndorsementHandler. A different endorsement handler may be used by changing the configuration setting \"endorsement-handler\" with the setConfigSetting() or placing a new line in configuration JSON file that application has applied to the fabric-client configuration. This will instantiate a handler located at the path provide in the attribute for all channels initialized after the call. The default handler was designed to be used with discovery to provided automatic selection of peers and fail over. When used without discovery the handler will only send to the peers as defined in the targets parameter without fail over. The handler may also be changed using the endorsementHandler attribute on the channel.initialize() request call parameter. This will instantiate a handler located at the path provide in the attribute just for this channel. // set value in memory Client.setConfigSetting('endorsement-handler', '/path/to/the/handler.js'); --or-- // the path to an additional config file Client.addConfigFile('/path/to/config.json'); // the json file contains the following line // \"endorsement-handler\": \"/path/to/the/handler.js\" --or-- const request = { ... endorsementHandler: \"/path/to/the/handler.js\", ... } // initialize must be run to use handlers. channel.initialize(request); A endorsement handler should extend the EndorsementHandler. When the channel is initialized, the channel will read the path setting and create an instance of the handler for use by the new channel instance. new CommitHandler The sending of the endorsements to be committed may be done using custom code. The fabric-client will use by default the file called BasicCommitHandler. The commit handler may be changed by changing the configuration setting \"commit-handler\" by doing a setConfigSetting() or placing a new line in configuration JSON file that application has applied to the fabric-client configuration. The default handler was designed to be used with discovery to provided automatic selection of orderers and fail over. When used without discovery the handler will still provide fail over to all orderers assigned to the channel, sending to each one in orderer until an orderer response successfully to the transaction submission. The handler may also be changed using the commitHandler attribute on the channel.initialize() request call parameter. This will instantiate a handler located at the path provide in the attribute just for this channel. // set the config value in memory Client.setConfigSetting('commit-handler', '/path/to/the/handler.js'); --or-- // path of an additional config file Client.addConfigFile('/path/to/config.json'); // the json file contains the following line // \"commit-handler\": \"/path/to/the/handler.js\" --or-- const request = { ... commitHandler: \"/path/to/the/handler.js\", ... } // initialize must be run to use handlers. channel.initialize(request); A commit handler should extend the CommitHandler. When the channel is initialized, the channel will read the path setting and create an instance of the handler for use by the new channel instance. This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-listening-to-events.html":{"id":"tutorial-listening-to-events.html","title":"Tutorial: fabric-network: How to listen to events","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-network: How to listen to events Listening to events with Fabric Network This tutorial describes the different ways to listen to events emitted by a Hyperledger Fabric network channel using the fabric-network event service. Listening for events allows an application to react without directly calling a transaction. This is ideal in use cases such as monitoring network analytics. Events The amount of information contained within the event provided to an application event listener is determined at the time of the fabric-network event service setup with the Hyperledger Fabric network channel. The fabric-network event service must connect with the Hyperledgert Fabric network channel Peer's event service to receive new blocks as they are committed to the ledger. The conection setup will determine if 'filtered' or 'full' blocks are received and if private data will be include in the 'full' blocks. The fabric-network event service will check each block for a match with each application event listener. Filter blocks as the source of event data will have the best proformance and require the minimum access authority to the Hyperledger Fabric network channel ledger. Full blocks as the source of the event data may also include private data if the application user is allowed to see the private data. There are three types of application event listeners. Block events - These are emitted automatically when a block is committed to the ledger. Filtered blocks do not contain any transaction data or private data, only status, therefore it may not be useful to the application monitoring the the ledger. It is recommended that the fabric-network event service receive full blocks, especially if private data information is required. Contract events - A chaincode event name and value are explicitly added to the transaction information by the chaicode when the chaincode is invoked. When a transaction contains a chaincode event, it is emitted automatically when the transaction is committed to the ledger. When the fabric-network event service is receiving filtered blocks as the source of a contract event, only the event name as emitted by the chaincode will be provided, the chaincode event value will not be available. The application must setup the fabric-network event service to receive full blocks by using the 'filtered=false'. Commit events - These are emitted automatically when a transaction is committed to the ledger. Both filtered and full blocks will contain the transaction id and it's status, therefore there no advantage to receiving full blocks and the default of filtered blocks may be used. Usage Callback To subscribe to listen for any of the event types, the application must provide a callback. This is the function that is called when an event is emmitted. Naming Each appliction event listener must have a unique name. This allows the application to reuse event listeners. Block events const gateway = new Gateway(); await gateway.connect(connectionProfile, gatewayOptions); const network = await gateway.getNetwork('mychannel'); const listener = await network.addBlockListener('my-block-listener', (error, block) =&gt; { if (err) { console.error(err); return; } console.log(`Block: ${block}`); }); When listening for block events, it is important to specify if you want a filtered or none filtered event, as this determines which event hub is compatible with the request. Contract events const gateway = new Gateway(); await gateway.connect(connectionProfile, gatewayOptions); const network = await gateway.getNetwork('mychannel'); const contract = network.getContract('my-contract'); const listener = await contract.addContractListener('my-contract-listener', 'sale', (err, blockNumber, chaincodeEvents) =&gt; { if (err) { console.error(err); return; } console.log(`Processing chaincode events in block number: ${blockNumber}`); for (const chaincodeEvent of chaincodeEvents) { const {chaincodeId, transactionId, status, eventName, payload} = chaincodeEvent; console.log(`Block Number:${blockNumber} EventName:${eventName} Transaction ID:${transactionId} Status:${status}`); } }) Notice that there is no need to specify an event service instance, the EventSelectionStrategy will select it automatically. Commit events By default the commit listener will monitor for all transactions. Use the option `trasactionId: '1234567890' to listen for a specific transaction. Monitor all transactions const gateway = new Gateway(); await gateway.connect(connectionProfile, gatewayOptions); const network = await gateway.getNetwork('mychannel'); const contract = network.getContract('my-contract'); const transaction = contract.newTransaction('sell'); const listener = await network.addCommitListener( 'All sell transactions', (err, blockNumber, transactionId, status) =&gt; { if (err) { console.error(err); return; } console.log(`Transaction ID: ${transactionId} Status: ${status} Block number: ${blockNumber}`); } ); Monitor for a known transaction const gateway = new Gateway(); await gateway.connect(connectionProfile, gatewayOptions); const network = await gateway.getNetwork('mychannel'); const listener = await network.addCommitListener( 'All sell transactions', (err, blockNumber, transactionId, status) =&gt; { if (err) { console.error(err); return; } console.log(`Transaction ID: ${transactionId} Status: ${status} Block number: ${blockNumber}`); }, { transactionId: '1234567890' } ); Checkpointing fabric-network: How to replay missed events Start Block and End Block In the module:fabric-network~EventListenerOptions it is possible to specify a startBlock and an endBlock. This behaves in the same way as the same options on ChannelEventHub shown in the tutorial here fabric-client: How to use the channel-based event service. Using startBlock and endBlock disables event replay using a checkpointer for the events received by that listener. Unregistering listeners addContractListener, addBlockListener and addCommitListener return a ContractEventListener, BlockEventListener and CommitEventListener respectively. Each has an unregister() function that removes the listener from the event services, meaning no further events will be received from that listener until register() is called again.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-logging.html":{"id":"tutorial-logging.html","title":"Tutorial: fabric-client: How to use logging","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to use logging This tutorial illustrates how to use the Hyperledger Fabric Node.js client logging feature. Overview Hyperledger Fabric Node.js client logging uses the Node.js 'winston' package. The logging is initialized when the Node.js application first loads the Hyperledger Fabric package. All Hyperledger Fabric client objects will use the same settings (Peer, Orderer, ChannelEventHub). const Client = require('fabric-client'); // the logging is now set There are four levels of logging info warn error debug By default info, warn, and error log entries will be sent to the 'console'. debug will not be recorded. How to change logging The Hyperledger Fabric client's logging is controlled by the configuration setting hfc-logging and by the environment setting HFC_LOGGING. setting the logging settings in the default.json config file with an entry: \"hfc-logging\": \"{'debug':'console', 'info':'console'}\" using an environment setting will override the configuration setting: export HFC_LOGGING='{\"debug\":\"console\",\"info\":\"console\"}' The logging may use a file to write entries by specifying a file location as the level value. export HFC_LOGGING='{\"debug\":\"/temp/debug.log\",\"info\":\"console\"}' Using the logging from application When there is a need to log entries from the application code along with the Hyperledger Fabric client entries, use the following to get access to the same logger. as of 1.2 const logger = Client.getLogger('APPLICATION'); prior to 1.2 const sdkUtils = require('fabric-client/lib/utils.js'); const logger = sdkUtils.getLogger('APPLICATION'); To log const log_info = 'Sometext'; logger.info('%s infotext', log_info); // will log // info: [APPLICATION]: Sometext infotext logger.warn('%s warntext', log_info); // will log // warn: [APPLICATION]: Sometext warntext logger.error('%s errortext', log_info); // will log // error: [APPLICATION]: Sometext errortext logger.debug('%s debugtext', log_info); // will log // debug: [APPLICATION]: Sometext debugtext  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-metadata-chaincode.html":{"id":"tutorial-metadata-chaincode.html","title":"Tutorial: fabric-client: How to add CouchDB indexes during chaincode installation","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to add CouchDB indexes during chaincode installation This tutorial illustrates the use of adding metadata to your chaincode installation. As of v1.1 the only metadata are the indexes that may be added to a CouchDB state database of your channel ledger. For more information: getting started with Hyperledger Fabric setting up a CouchDB as the state database The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development, including the use of the Javascript Promise. Overview Fabric 1.1 has introduced the capability of defining indexes in a CouchDB state database to help improve performance of your queries made in your chaincode. The index definitions need to be in JSON format and in files with a .json extension. These definitions will be included in the chaincode installation package that is sent to the Fabric peer. Modified API's that allow for metadata client.installChaincode() - There is a new attribute ('metadataPath') that may be included in the installation request. The value of the metadataPath is a string representing the absolute path to the directory structure containing the JSON index files. Installing chaincode The following example will install the chaincode 'my_chaincode' and include index files. let targets = buildTargets(); //build the list of peers that will require this chaincode let chaincode_path = path.resolve(__dirname, '../chaincode/src/node_cc/my_chaincode'); let metadata_path = path.resolve(__dirname, '../chaincode/my_indexes'); // send proposal to install var request = { targets: targets, chaincodePath: chaincode_path, metadataPath: metadata_path, // notice this is the new attribute of the request chaincodeId: 'my_chaincode', chaincodeType: 'node', chaincodeVersion: 'v1' }; client.installChaincode(request).then((results) =&gt; { var proposalResponses = results[0]; // check the results }, (err) =&gt; { console.log('Failed to send install proposal due to error: ' + err.stack ? err.stack : err); throw new Error('Failed to send install proposal due to error: ' + err.stack ? err.stack : err); }); The following shows the path used as the metadataPath above. This is the required directory structure required under the path. The indexes directory will hold the files with the index definitions. The required directory structure and files with a 'json' extension will be included in the chaincode installation package under the 'META_INF' package directory. 'META-INF' should not be included in your local directory structure. .. &lt;&gt; chaincode   &lt;&gt; my_indexes // here is where the 'metadataPath' will point to   &lt;&gt; statedb //starting here are the required directories   &lt;&gt; couchdb   &lt;&gt; indexes // this directory will contain the index files index-owner.json // these will be the index files and must index-address.json // have the file extension of 'json' Each index must be defined in its own text file with an extension of *.json and contain the index definition formatted in JSON following the CouchDB index JSON syntax. {\"index\":{\"fields\":[\"docType\",\"owner\"]},\"ddoc\":\"indexOwnerDoc\", \"name\":\"indexOwner\",\"type\":\"json\"} This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-mutual-tls.html":{"id":"tutorial-mutual-tls.html","title":"Tutorial: fabric-client: How to configure mutual TLS","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to configure mutual TLS This tutorial illustrates how to use the node SDK APIs to connect to an orderer or peer which has TLS client authentication enabled (aka \"mutual TLS\"). An orderer has TLS client authentication enabled if the ORDERER_GENERAL_TLS_CLIENTAUTHREQUIRED environment variable is set to true. A peer has TLS client authentication enabled if the CORE_PEER_TLS_CLIENTAUTHREQUIRED environment variable is set to true. Connecting to an orderer or peer with TLS client authentication enabled After retrieving the client certificate and client key, assign those to the Client instance. The Client instance will then assign the material to each orderer and peer it creates. For example, the following demonstrates how to assign to the client first. Then build an orderer and peer which will then have the TLS client authentication enabled. This assumes that the client's PEM-encoded TLS key and certificate are at somepath/tls/client.key and somepath/tls/client.crt, respectively. let serverCert = fs.readFileSync(path.join(__dirname, 'somepath/msp/tlscacerts/example.com-cert.pem')); let clientKey = fs.readFileSync(path.join(__dirname, 'somepath/tls/client.key')); let clientCert = fs.readFileSync(path.join(__dirname, 'somepath/tls/client.crt')); client.setTlsClientCertAndKey(Buffer.from(clientCert).toString(), Buffer.from(clientKey).toString()); let orderer = client.newOrderer( 'grpcs://localhost:7050', { 'pem': Buffer.from(serverCert).toString() }); let peer = client.newPeer( 'grpcs://localhost:7051', { 'pem': Buffer.from(serverCert).toString() } );  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-network-config.html":{"id":"tutorial-network-config.html","title":"Tutorial: fabric-client: How to use a common connection profile","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-client: How to use a common connection profile This tutorial illustrates the use of common connection profiles. Connection profiles are a new feature of the Hyperledger Fabric Node.js Client as of 1.1. A connection profile will describe the Hyperledger Fabric network to the Hyperledger Fabric Node.js Client (fabric client). For more information on: getting started with Hyperledger Fabric see Building your first network. the configuration of a channel in Hyperledger Fabric and the internal process of creating and updating see Hyperledger Fabric channel configuration cryptographic generation see cryptogen configuration transaction generator see configtxgen configuration translation tool see configtxlator The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development, including the use of the Javascript Promise. Overview A connection profile contain entries that describe the Hyperledger Fabric network including entries that describe the fabric client that will access the the network. The application will load a configuration file and then it will be used by fabric client to simplify the steps needed to setup and use the network. The connection profile has specific addresses and settings of network items. Resources like javascript classes to instantiate are stored in the fabric client's configuration system. It will be easier to work with a fabric client loaded with a connection profile configuration because it reduces the setup before calling an action. Parameters for items like targets may be specified by name and object will not have to be created and maintained before the action is called. On many calls if no target peer is specified, the fabric client will look to see if there is a Peer in the role needed for the action. API's to load a connection profile Client.loadFromConfig() - A static utility method to get a fabric client instance loaded with the connection profile configuration. client.loadFromConfig() - A fabric client instance method to load a connection profile configuration, overriding any existing connection profile configuration settings that may have been set when this client object was created by the call above. new API's that use a loaded connection profile client.initCredentialStores() - A fabric client instance method to create a state store and assign it to the fabric client instance based on the current settings in the loaded connection profile configuration. It will also create the crypto suite and assign it to the fabric client instance. A crypto store will be created and assigned to crypto suite if needed. (HSM based crypto suites do not require a crypto store). client.setTlsClientCertAndKey(clientCert, clientKey) -A fabric client instance method that will set a certificate and the corresponding private key on the client instance. Mutual TLS client settings are not stored within the connection profile. When a peer or orderer instance is created for the user from the endpoints defined in the connection profile, these settings will be used as the client mutual TLS settings. When using mutual TLS and a connection profile, this method must be called before endpoints are required. Calling this method is only required when using mutual TLS and a connection profile. channel.newChannelEventHub() - A fabric channel instance method to create an channel-based event hub based on the current settings in the loaded connection profile configuration of the named peer. channel.getChannelEventHubsForOrg() - A fabric channel instance method to return a list of channel-based event hubs that are associated with an organizations. Peers in an organizations that have the eventSource set to true will be returned. client.getPeersForOrg() - A fabric client instance method to return a list of peer objects that are associated with an organizations. Modified API's that will use the connection profile configuration if one has been loaded client.getChannel() - A fabric client instance method that will create a channel instance object based on the settings for a channel defined in the currently loaded connection profile configuration. client.newTransactionID(&lt;boolean&gt;) - This method was modified to allow for a boolean to indicate that the transaction id generated should be based on the administrative identity if one has been assigned rather than the user context assigned to the fabric client. client.setUserContext() - Now allows username and password as a parameter or a User object. When username and password are used the fabric client will perform an enroll with the certificate authority using the username and password. client.installChaincode() - If the targets parameter is excluded from the request parameter list then the peers defined in the current organization of the client will be used. client.queryXXXX() - The query API's will now take a peer name (as defined in the connection profile config) or peer object instance as the target. channel.instantiateChaincode() - If the targets parameter is excluded from the request parameter list then the peers defined in the current organization of the client that are also on this channel will be used. channel.sendTransactionProposal() The request object parameter may use names for targets or let the fabric client find peers to use for targets as defined in the connection profile configuration. channel.sendTransaction() The request object parameter may use orderer name or let the fabric client find an orderer to use as defined in the connection profile configuration. channel.queryXXXX() - All the query API's will now take a peer name as the target rather than an peer instance object. Loading connection profile configurations The application code can either point to a yaml or json file that contains the configuration information or it may pass a Javascript object directory to the API's to load a configuration. For convenience there is a static utility method on the fabric-client to create a new fabric client object and load a connection profile configuration at the same time. There is also a method on the fabric client instance that may be used to load a connection profile configuration on top of an existing connection profile configuration. The following example will create a new instance of the fabric-client and load a connection profile configuration. However in this case the connection profile configuration does not contain any information about the client side of the fabric network, just the fabric network elements. var client = Client.loadFromConfig('test/fixtures/network.yaml'); Here is the connection profile definition loaded name: \"Network\" version: \"1.0\" channels: mychannel: orderers: - orderer.example.com peers: peer0.org1.example.com: endorsingPeer: true chaincodeQuery: true ledgerQuery: true eventSource: true peer0.org2.example.com: endorsingPeer: true chaincodeQuery: false ledgerQuery: true eventSource: false organizations: Org1: mspid: Org1MSP peers: - peer0.org1.example.com certificateAuthorities: - ca-org1 adminPrivateKey: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/keystore/9022d671ceedbb24af3ea69b5a8136cc64203df6b9920e26f48123fcfcb1d2e9_sk signedCert: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/signcerts/Admin@org1.example.com-cert.pem Org2: mspid: Org2MSP peers: - peer0.org2.example.com certificateAuthorities: - ca-org2 adminPrivateKey: path: test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/keystore/5a983ddcbefe52a7f9b8ee5b85a590c3e3a43c4ccd70c7795bec504e7f74848d_sk signedCert: path: test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/signcerts/Admin@org2.example.com-cert.pem orderers: orderer.example.com: url: grpcs://localhost:7050 grpcOptions: ssl-target-name-override: orderer.example.com grpc-max-send-message-length: 4194304 tlsCACerts: path: test/fixtures/channel/crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tlscacerts/example.com-cert.pem peers: peer0.org1.example.com: url: grpcs://localhost:7051 grpcOptions: ssl-target-name-override: peer0.org1.example.com grpc.keepalive_time_ms: 600000 tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem peer0.org2.example.com: url: grpcs://localhost:8051 grpcOptions: ssl-target-name-override: peer0.org2.example.com tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem certificateAuthorities: ca-org1: url: https://localhost:7054 httpOptions: verify: false tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem registrar: - enrollId: admin enrollSecret: adminpw caName: caorg1 ca-org2: url: https://localhost:8054 httpOptions: verify: false tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/ca/org2.example.com-cert.pem registrar: - enrollId: admin enrollSecret: adminpw caName: caorg2 The following example will have an existing fabric client load a connection profile configuration. The definition will only contain client side definitions and no fabric network definitions. The client may load a new profile at anytime, it will overlay the top level sections it contains of those previously loaded. In this case the file being loaded only has a client section, therefore the loaded definition will now have the previously loaded channels, organizations, peers, orderers, and certificateAuthorities section definitions and the newly loaded client section definition. This allows for an existing fabric client to be able to work within different organization. Notice this client definition contains a connection section with an options attribute in the client section. Settings defined here will be applied to new peer and orderer instances the client creates. This will include peers and orderers that will be created automatically when using the discovery service. Peers and Orderers may override these connection settings in their grpcOptions settings. Note: The fabric-client grpc-max-send-message-length and grpc-max-receive-message-length defaults are -1 (unlimited). client.loadFromConfig('test/fixtures/org1.yaml'); Here is the client definition loaded above name: \"Org1 Client\" version: \"1.0\" client: organization: Org1 credentialStore: path: \"/tmp/hfc-kvs/org1\" cryptoStore: path: \"/tmp/hfc-cvs/org1\" connection: options grpc.keepalive_time_ms: 120000 Setup the stores The next step is to set up the client object with the state and crypto stores. If the client section of the connection profile configuration has these defined then it is a simple matter of running the following. This API is promise based, notice that we will need a .then on the returned promise to have it actually execute. This API does not return anything, however it has created a state store and assigned it to the client, it has created a CryptoSuite and also assigned it to the client, and created a crypto store and assigned that to the crypto suite. Notice the credentialStore and cryptoStore definitions above in the client section of the connection profile configuration. In this case we are using two different locations, it may be easier to have these in the same locations when first starting out. The following will create two stores and a CryptoSuite and assign them to the fabric client all based on the loaded configurations. client.initCredentialStores() .then((nothing) =&gt; { Work with user context When there is certificate Authority information on the organization, the fabric client may be used to simplify the enrollment and user context creation. The application will still have to register new users with the certificate authority, however when a connection profile configuration has been loaded there is a simpler way to get a certificate authority client. So first let's enroll an admin user so that we have the credentials (crypto material) needed to interact with the certificate authority and the fabric network. The following convenience method will first look in the state store (as defined above) to see if the user exist. If the user is not found and there is a connection profile configuration loaded, the fabric client will build a certificate authority client object as defined in the fabric client configuration with the address as defined in the currently loaded connection profile configuration. The fabric client uses the certificate authority client to enroll the admin user with the certificate authority, this requires that a new set of keys be generated on the client side. The fabric client will then use the signed certificate returned by the certificate authority from the enroll to create a user context. The context will then be assign it to fabric client and stored in the state store along with storing the keys in the crypto store. At this point the fabric client is ready to interact with the fabric network and the application may use the returned user object to interact with the certificate authority. In the following example we are able to enroll the user because it is known by the certificate authority. New users will have to be registered first. client.setUserContext({username:'admin', password:'adminpw'}) .then((admin) =&gt; { The following example will have the fabric client build a certificate authority client based on the currently loaded connection profile configuration by first finding which organization defined in the client section and then finding the certificate authority associated with that organization. var fabric_ca_client = client.getCertificateAuthority(); Then once we have a fabric-ca-client, we will be able to register new users. We could also use the fabric-ca-client to enroll users and make a few calls to the fabric client to create a user object and then assign that user object to the fabric client, but it will be much easier to just use the convenience method of the fabric client instance. Notice how we have to use the 'admin' user object returned from the client.setUserContext() to do the register. The admin user object has the credentials needed to the register. Then notice we called the same setUserContext method as we did with the admin above, this will have the fabric client object assigned with the 'user1' user context thus providing the credentials to interact with the fabric network. Note that the setUserContext also stores the user context which contains the signed certificate from the certificate authority and newly created public and private keys of the now enrolled user. fabric_ca_client.register({enrollmentID: 'user1', affiliation: 'org1'}, admin) .then((secret) =&gt; { return client.setUserContext({username:'user1', password:secret}); }).then((user)=&gt; { Work with mutual TLS When your network is using mutual TLS, the client certificate and private key must be available to the client instance before the endpoints are automatically built. The client instance will be able to pass the required material to the endpoint instance that is needed to establish the connection. The example shown will also retrieve the material. These steps must be performed before any actions on the fabric network. // get the CA associated with this client's organization let fabric_ca_client = client.getCertificateAuthority(); let request = { enrollmentID: 'user1', enrollmentSecret: secret, profile: 'tls' }; // make the request to build the keys and get the certificate fabric_ca_client.enroll(request) .then((enrollment) =&gt; { // Successfully called the Certificate Authority to get the TLS material let key = enrollment.key.toBytes(); let cert = enrollment.certificate; // set the material on the client to be used when building endpoints for the user client.setTlsClientCertAndKey(cert, key); ... When an admin is needed Notice in the organizations section of the connection profile configuration that an organization may have a signed cert setting and admin private key setting that are associated with the organization. This is a convenience for your organization such that operations that require a fabric network administrator will be able to get one easily. These credentials will be assigned to the fabric client when the configuration is loaded. If one has not been assigned than the current user context assigned to the fabric client is assumed to be an administrator. There is also a convenience method on the client object that will assign credentials to the client to be used for operations that require an admin. client.setAdminSigningIdentity('admin privateKey','admin cert'); Assume that a common connection profile has been loaded, setting up both an organization with an admin and indicating that the client is in that organization. Then when the call is made to get a transaction id object, the fabric client will check to see if an admin has been assigned to the fabric client and use that to generate the transaction id. The transaction id returned will be tagged that it was generated with the assigned administrative identity. Notice how the request object being built is using just a name for the orderer rather than an Orderer object. The fabric client will look up this name in the loaded connection profile configuration. When the createChannel call is made, the fabric client will know that this action should be signed by the administrative identity because the transaction id was marked as an admin based transaction. Note that the administrative signing identity is not required if the logged in user is an administrative user and has been assigned to the fabric client. let tx_id = client.newTransactionID(true); let request = { config: config, signatures : signatures, name : channel_name, orderer : 'orderer.example.com', txId : tx_id }; return client.createChannel(request); }).then((result) =&gt; { When a peer is needed Notice how a peer is added to an organization, it is more than just a reference to the actual peer definition, the peer is also defined to have roles within that organization. peer0.org2.example.com: endorsingPeer: true chaincodeQuery: false ledgerQuery: true eventSource: false This peer may be used to endorse transaction, but not used to run chaincode queries. This peer may be used to audit the channel by making ledger based queries (like queryBlock), but may not be used to be an event source. Of course this combination of roles does not make much sense in real life. So let's have a look at a chaincode invoke endorsement let tx_id = client.newTransactionID(); var request = { chaincodeId : 'example', fcn: 'move', args: ['a', 'b','100'], txId: tx_id }; channel.sendTransactionProposal(request) .then((results) =&gt; { Notice that we have left off the targets parameter of the request object. This will have the fabric client do a lookup of peers on this channel in the connection profile configuration. The fabric client will be looking for peers defined in the role of endorsingPeer. The fabric client will then send the proposal to the located peers and return all the endorsements in the results object. There may be a need to have only the peers in a specific organization. Use the mspid of the organization. var peers = getPeersForOrg('Org1MSP'); Or maybe for the organization that is defined in the client section of the connection profile. var peers = getPeersForOrg(); When an orderer is needed After receiving endorsements from the peers for a transaction proposal, they will need to be sent to an orderer along with the proposal for a transaction to be committed to the ledger. var request = { proposalResponses: proposalResponses, proposal: proposal }; channel.sendTransaction(request) .then((results) =&gt; { Notice that an orderer to send this transaction to is not included in the request object. The orderer defined in the connection profile configuration will be used. When doing queries When there is a connection profile configuration loaded and the query call is not passed a target peer to use, the fabric client will look in the connection profile configuration for a peer to use. These are fabric client based queries and require the user have an admin role or indicate that the admin identity should be used. These queries do not use the connection profile config lookup to find a peer to use and must be passed the target peer. queryChannels queryInstalledChaincodes These queries are channel based queries that require a peer with the ledgerQuery role. queryInstantiatedChaincodes (user must be an admin or indicate that the assigned admin identity should be used) queryInfo queryBlockByHash queryBlock queryTransaction this is a channel based query and requires a peer with the chaincodeQuery role. queryByChaincode When monitoring for events Working with an channel-based event hub will not changed when a connection profile configuration has been loaded. A new method has been added to the fabric client to simplify setting up of an ChannelEventHub object. Use the following to get an ChannelEventHub object that will be setup to work with the named peer's channel-based event hub. var channel_event_hub = channel.newChannelEventHub('peer0.org1.example.com'); Notice how the parameter to the call is the name of the peer. All settings to create an channel-based event hub are defined by the connection profile configuration under the peer by that name. peer0.org1.example.com: url: grpcs://localhost:7051 grpcOptions: ssl-target-name-override: peer0.org1.example.com grpc.keepalive_time_ms: 600000 tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem The following will be a list of event hubs that are within the 'Org1' organization. All peers referenced by an organization that the 'eventSource' set to true. Use the mspid of the organization. var channel_event_hubs = channel.getChannelEventHubsForOrg('Org1MSP'); The following will be a list of channel-based event hubs that are within the organization defined in the client section of the connection profile. var channel_event_hubs = channel.getChannelEventHubsForOrg(); What does the Fabric Client look for in a common connection profile The Fabric Client will be looking for the following key names and parameters for those keys: # # Schema version of the content. Used by the SDK to apply the parsing rules. # version: \"1.0\" # only supported version as of fabric-client v1.3.0 # # The client section is SDK-specific. These are the settings that the # NodeSDK will use to automatically set up a Client instance. # client: # Which organization does this application instance belong to? The value must be the name of an org # defined under \"organizations\" ... see below organization: Org1 # Some SDKs support pluggable KV stores, the properties under \"credentialStore\" # are implementation specific credentialStore: # Specific to FileKeyValueStore.js or similar implementations in other SDKs. Can be others # if using an alternative impl. For instance, CouchDBKeyValueStore.js would require an object # here for properties like url, db name, etc. path: \"/tmp/hfc-kvs\" or &lt;implementation specific properties&gt; # Specific to the CryptoSuite implementation. Software-based implementations like # CryptoSuite_ECDSA_AES.js in node SDK requires a key store. PKCS#11 based implementations does # not. cryptoStore: # Specific to the underlying KeyValueStore that backs the crypto key store. path: \"/tmp/hfc-cvs\" or &lt;implementation specific properties&gt; # Sets the connection timeouts for new peer and orderer objects when the client creates # peer and orderer objects during the client.getPeer() and client.getOrderer() calls # or when the peer and orderer objects are created automatically when a channel # is created by the client.getChannel() call. connection: timeout: peer: # the timeout in seconds to be used on requests to a peer, # for example 'sendTransactionProposal' endorser: 120 # the timeout in seconds to be used by applications when waiting for an # event to occur. This time should be used in a javascript timer object # that will cancel the event registration with the channel event hub instance. eventHub: 60 # the timeout in seconds to be used when setting up the connection # with a peer event hub. If the peer does not acknowledge the # connection within the time, the application will be notified over the # error callback if provided. eventReg: 3 # the timeout in seconds to be used on request to the orderer, # for example orderer: 30 # # How a channel is defined and the peers and orderers on that channel. When the # client.getChannel() call is used the client will pre-populate the channel with # orderers and peers as defined in this section. # channels: # name of the channel mychannel2: # List of orderers designated by the application to use for transactions on this channel. # The values must be orderer names defined under \"orderers\" section orderers: - orderer.example.com # List of peers from participating organizations peers: # The values must be peer names defined under \"peers\" section peer0.org1.example.com: # Will this peer be sent transaction proposals for endorsement? The peer must # have the chaincode installed. The app can also use this property to decide which peers # to send the chaincode install request. Default: true endorsingPeer: true # Will this peer be sent query proposals? The peer must have the chaincode # installed. The app can also use this property to decide which peers to send the # chaincode install request. Default: true chaincodeQuery: true # Will this peer be sent query proposals that do not require chaincodes, like # queryBlock(), queryTransaction(), etc. Default: true ledgerQuery: true # Will this peer be the target of a SDK listener registration? All peers can # produce events but the app typically only needs to connect to one to listen to events. # Default: true eventSource: true # Will this peer be the target of Discovery requests. # Default: true discover: true # # list of participating organizations in this network # organizations: Org1: mspid: Org1MSP # The peers that are known to be in this organization peers: - peer0.org1.example.com # Certificate Authorities issue certificates for identification purposes in a Fabric based # network. Typically certificates provisioning is done in a separate process outside of the # runtime network. Fabric-CA is a special certificate authority that provides a REST APIs for # dynamic certificate management (enroll, revoke, re-enroll). The following section is only for # Fabric-CA servers. certificateAuthorities: - ca-org1 # If the application is going to make requests that are reserved to organization # administrators, including creating/updating channels, installing/instantiating chaincodes, it # must have access to the admin identity represented by the private key and signing certificate. # Both properties can be the PEM string or local path to the PEM file. # path: &lt;the path to a file containing the byte string&gt; # or # pem: &lt;the byte string&gt; # Note that this is mainly for convenience in development mode, production systems # should not expose sensitive information this way. # The SDK should allow applications to set the org admin identity via APIs, and only use # this route as an alternative when it exists. adminPrivateKey: path: &lt;path to file&gt; or pem: &lt;byte string&gt; signedCert: path: &lt;path to file&gt; or pem: &lt;byte string&gt; # the profile will contain public information about organizations other than the one it belongs to. # These are necessary information to make transaction lifecycles work, including MSP IDs and # peers with a public URL to send transaction proposals. The file will not contain private # information reserved for members of the organization, such as admin key and certificate, # fabric-ca registrar enroll ID and secret, etc. Org2: mspid: Org2MSP peers: - peer0.org2.example.com certificateAuthorities: - ca-org2 adminPrivateKey: path: &lt;path to file&gt; or pem: &lt;byte string&gt; signedCert: path: &lt;path to file&gt; or pem: &lt;byte string&gt; # # List of orderers to send transaction and channel create/update requests. # orderers: orderer.example.com: url: grpcs://localhost:7050 # these are standard properties defined by the gRPC library # they will be passed in as-is to gRPC client constructor grpcOptions: ssl-target-name-override: orderer.example.com tlsCACerts: path: &lt;path to file&gt; or pem: &lt;byte string&gt; # # List of peers to send various requests to, including endorsement, query # and event listener registration. # peers: peer0.org1.example.com: # this URL is used to send endorsement and query requests url: grpcs://localhost:7051 grpcOptions: ssl-target-name-override: peer0.org1.example.com request-timeout: 120001 tlsCACerts: path: &lt;path to file&gt; or pem: &lt;byte string&gt; peer0.org2.example.com: url: grpcs://localhost:8051 grpcOptions: ssl-target-name-override: peer0.org2.example.com tlsCACerts: path: &lt;path to file&gt; or pem: &lt;byte string&gt; # # Fabric-CA is a special kind of Certificate Authority provided by Hyperledger Fabric which allows # certificate management to be done via REST APIs. Application may choose to use a standard # Certificate Authority instead of Fabric-CA, in which case this section would not be specified. # certificateAuthorities: ca-org1: url: https://localhost:7054 # the properties specified under this object are passed to the 'http' client verbatim when # making the request to the Fabric-CA server httpOptions: verify: false tlsCACerts: path: &lt;path to file&gt; or pem: &lt;byte string&gt; # Fabric-CA supports dynamic user enrollment via REST APIs. A \"root\" user, a.k.a registrar, is # needed to enroll and invoke new users. registrar: - enrollId: admin enrollSecret: adminpw # The optional name of the CA. caName: ca-org1 This work is licensed under a Creative Commons Attribution 4.0 International License.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-private-data.html":{"id":"tutorial-private-data.html","title":"Tutorial: How to use private data","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER How to use private data This tutorial illustrates how to use the Node.js SDK APIs to store and retrieve private data in the Hyperledger Fabric network. Starting in v1.2, Fabric offers the ability to create private data collections, which allows a subset of organizations on a channel to endorse, commit, or query private data without having to create a separate channel. For more information, refer to: Private Data Concept Private Data Architecture Using Private Data in Fabric Overview The following are the steps to use private data with the Node.js SDK (fabric-client). Check out the sections below for details on these steps. Create a collection definition json file Implement chaincode to store and query private data Install and instantiate chaincode with a collection definition Invoke chaincode to store and query private data Purge private data Query for a collection definition Create a collection definition json file A collection definition describes who can persist data, how many peers the data is distributed to, how many peers are required to disseminate the private data, and how long the private data is persisted in the private database. Chaincode APIs will map the collection to the private data by the collection name. A collection definition is composed of the following five properties. name: Name of the collection. policy: Defines the organization peers allowed to persist the collection data. requiredPeerCount: Number of peers required to disseminate the private data as a condition of the endorsement of the chaincode maxPeerCount: For data redundancy purposes, the number of other peers that the current endorsing peer will attempt to distribute the data to. If an endorsing peer goes down, these other peers are available at commit time if there are requests to pull the private data. blockToLive: For very sensitive information such as pricing or personal information, this value represents how long the data should live on the private database in terms of blocks. The data will be purged after this specified number of blocks on the private database. To keep private data indefinitely, that is, to never purge private data, set the blockToLive property to 0. Here is a sample collection definition JSON file, containing an array of two collection definitions: [ { \"name\": \"collectionMarbles\", \"policy\": { \"identities\": [ { \"role\": { \"name\": \"member\", \"mspId\": \"Org1MSP\" } }, { \"role\": { \"name\": \"member\", \"mspId\": \"Org2MSP\" } } ], \"policy\": { \"1-of\": [ { \"signed-by\": 0 }, { \"signed-by\": 1 } ] } }, \"requiredPeerCount\": 1, \"maxPeerCount\": 2, \"blockToLive\": 100 }, { \"name\": \"collectionMarblePrivateDetails\", \"policy\": { \"identities\": [ { \"role\": { \"name\": \"member\", \"mspId\": \"Org1MSP\" } } ], \"policy\": { \"1-of\": [ { \"signed-by\": 0 } ] } }, \"requiredPeerCount\": 1, \"maxPeerCount\": 1, \"blockToLive\": 100 } ] This example contains two private data collections: collectionMarbles and collectionMarblePrivateDetails. The policy property in the collectionMarbles definition allows all members of the channel (Org1 and Org2) to have the private data in a private database. The collectionMarblesPrivateDetails collection allows only members of Org1 to have the private data in their private database. For Node.js SDK, you must define policies in the same format as shown above. Implement chaincode to store and query private data Fabric provides chaincode APIs to store and query private data. As an example, check out marbles private data example to understand how to use the chaincode APIs to read and write private data. This example implements the following functions to manage private data. readMarble: query the values of the name, color, size and owner attributes using collection collectionMarbles. readMarblePrivateDetails: query the values of the price attribute using collection collectionMarblePrivateDetails. initMarble: store private data for the collections. delete: delete a marble from private database. Install and instantiate chaincode with a collection definition Client applications interact with the blockchain ledger through chaincode. As such we need to install and instantiate the chaincode on every peer that will execute and endorse transactions. When instantiated a chaincode on a channel the collection will be associated with that chaincode. Install chaincode. No specific parameter needed to support private data. Instantiate chaincode. To support private data, the request must include the collections-config attribute. const collectionsConfigPath = path.resolve(__dirname, collection_definition_json_filepath); const request = { targets: peers, chaincodeId: chaincodeId, chaincodeType: chaincodeType, chaincodeVersion: chaincodeVersion, fcn: functionName, args: args, txId: tx_id, 'collections-config': collectionsConfigPath }; const endorsementResults = await channel.sendInstantiateProposal(request, time_out); // additional code needed to validate endorsementResults and send transaction to commit ...... Invoke chaincode to store and query private data You must be authorized to transact with the private data based on the policy defined in collection definition. Recall that the above collection definition allows all members of Org1 and Org2 to access collectionMarbles (name, color, size, and owner) in their private database, but only peers in Org1 can have access to collectionMarblePrivateDetails (price) in their private database. Acting as a member of Org1, you can do the following with marbles private data example, Invoke initMarble to create a marble with private data. Invoke readMarble to read name, color, size and owner from the private database for collectionMarbles. Invoke readMarblePrivateDetails to read price from the private database for collectionMarblePrivateDetails. Purge private data The Hyperledger Fabric allows client applications to optionally purge the private data in a collection by setting the blockToLive property. This option may be needed when private data include personal or confidential information and transacting parties want to have a limited lifespan for the data. When blockToLive is set to a non-zero value in the collection definition file, Fabric will automatically purge the related private data after the specified number of blocks are committed. Client applications do not need to call any API. Query for a collection definition The Hyperledger Fabric allows client applications to query a peer for collection definitions. The Node.js SDK (fabric-client) has an API that will query a Hyperledger Fabric Peer for a collection definition associated with a chaincode running on the specified channel. See Channel#queryCollectionsConfig for detailed information. const request = { chaincodeId: chaincodeId, target: peer }; try { const response = await channel.queryCollectionsConfig(request); // response contains an array of collection definitions return response; } catch (error) { throw error; } Include private data in a transaction invocation The client application must put all private data into the transient data of the proposal request if the application wishes to keep the data private. Transient data is not returned in the endorsement results, only the hash of the transient data is returned in the endorsement created by the peer. The chaincode executed during the endorsement will be responsible for pulling the private data from the transient area of the proposal request and then work with the private data store of the peer. Example using fabric-network API // Private data sent as transient data: { [key: string]: Buffer } const transientData = { marblename: Buffer.from('marble1'), color: Buffer.from('red'), owner: Buffer.from('John'), size: Buffer.from('85'), price: Buffer.from('99') }; const result = await contract.createTransaction('initMarble') .setTransient(transientData) .submit(); Example using fabric-client API // private data const transient_data = { 'marblename': Buffer.from('marble1'), // string &lt;-&gt; byte[] 'color': Buffer.from('red'), // string &lt;-&gt; byte[] 'owner': Buffer.from('John'), // string &lt;-&gt; byte[] 'size': Buffer.from('85'), // string &lt;-&gt; byte[] 'price': Buffer.from('99') // string &lt;-&gt; byte[] }; const tx_id = client.newTransactionID(); const request = { chaincodeId : chaincodeId, txId: tx_id, fcn: 'initMarble', args: [], // all data is transient data transientMap: transient_data // private data }; // results will not contain the private data const endorsementResults = await channel.sendTransactionProposal(request);  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-query-peers.html":{"id":"tutorial-query-peers.html","title":"Tutorial: fabric-network: How to select peers for evaluating transactions (queries)","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-network: How to select peers for evaluating transactions (queries) This tutorial describes how peers are selected to evaluate transactions that will not then be written to the ledger, which may also be considered as queries. Query handling strategies The SDK provides several selectable strategies for how it should evaluate transactions on peers in the network. The available strategies are defined in QueryHandlerStrategies. The desired strategy is (optionally) specified as an argument to connect() on the Gateway, and is used for all transaction evaluations on Contracts obtained from that Gateway instance. If no query handling strategy is specified, MSPID_SCOPE_SINGLE is used by default. This will evaluate all transactions on the first peer from which is can obtain a response, and only switch to another peer if this peer fails. const { Gateway, QueryHandlerStrategies } = require('fabric-network'); const connectOptions = { query: { timeout: 3, strategy: QueryHandlerStrategies.MSPID_SCOPE_SINGLE } } const gateway = new Gateway(); await gateway.connect(connectionProfile, connectOptions); Plug-in query handlers If behavior is required that is not provided by the default query handling strategies, it is possible to implement your own query handling. This is achieved by specifying your own factory function as the query handling strategy. The factory function should return a query handler object and take one parameter: Blockchain network: Network The Network provides access to peers on which transactions should be evaluated. function createQueryHandler(network) { /* Your implementation here */ return new MyQueryHandler(peers); } const connectOptions = { query: { timeout: 3, strategy: createQueryHandler } } const gateway = new Gateway(); await gateway.connect(connectionProfile, connectOptions); The query handler object returned must implement the following functions. class MyQueryHandler { /** * Evaluate the supplied query on appropriate peers. * @param {Query} query A query object that provides an evaluate() * function to invoke itself on specified peers. * @returns {Buffer} Query result. */ async evaluate(query) { /* Your implementation here */ } } For a complete sample plug-in query handler implementation, see sample-query-handler.ts.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-sign-transaction-offline.html":{"id":"tutorial-sign-transaction-offline.html","title":"Tutorial: Working with an offline private key","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER Working with an offline private key This tutorial illustrates how to work with an offline private key with the Hyperledger Fabric Node.js SDK (fabric-client and fabric-ca-client) APIs. For more information on: getting started with Hyperledger Fabric see Building your first network. The transactional mechanics that take place during a standard asset exchange. transacton flow in fabric. The Certificate Signing Request (CSR) in a PKI system. CSR The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development, including the use of the Javascript promise and async await. Overview In most use cases the fabric-client will persist the user's credentials including the private key and sign transactions for the user. However some business scenarios may require higher level of privacy. What if the user wants to keep their private key secret and does not trust another system or backend server to securely store it and use it? The fabric-client comes with the ability to sign a transaction with an offline private key. By contrast to call setUserContext() with the user's identity (which contains the user's private key), an alternative way is to split the sign a tx process out of the fabric-client and let the application layer choose the place to store the private key, sign the transaction and send the signed transaction back. By this approach, the fabric-client does not require the user's private key any more. The Fabric-ca comes with the ability to enroll with a PKCS#10 standard CSR, which means the user can use an existing key pairs to generate the CSR and send this CSR to Fabric-ca to get the signed certificate. The fabric-ca-client also accepts a CSR at the API enroll(). The transaction flow for signing a transaction offline The following will show the steps to signing a transaction offline: With the user's identity (cert and private key) set at the fabric client: Endorse -&gt; Channel.sendTransactionProposal() Commit -&gt; Channel.sendTransaction() ChannelEventHub -&gt; ChannelEventHub.connect() (if the channel-eventhub has not connected to the peers) Without the user's private key at the fabric client: Endorse: generate an unsigned transaction proposal with the identity's certificate -&gt; Channel.generateUnsignedProposal() sign the unsigned transaction proposal with the identity's private key offline producing a signed transaction proposal send the signed transaction proposal to the peer(s) and get endorsement(s) -&gt; Channel.sendSignedProposal() Commit: generate an unsigned transaction with the endorsements -&gt; Channel.generateUnsignedTransaction() sign the unsigned transaction with the identity's private key offline producing a signed transaction send the signed transaction to the orderer -&gt; Channel.sendSignedTransaction() Register Channel Event Listerner: If the channel event hub has not connected to the peer, the channel eventhub registration needs the private key's signature too. generate an unsigned eventhub registration for the ChannelEventHub -&gt; ChannelEventHub.generateUnsignedRegistration() sign the unsigned eventhub registration with the identity's private key offline producing a signed eventhub registration using the signed eventhub registration for the ChannelEventHub's registration -&gt; ChannelEventHub.connect({signedEvent}) How to sign a transaction by an identity's private key There might be several digital signature algorithms. If we set the user's identity at the fabric client, the fabric client would use ECDSA with algorithm 'EC' by default. Here is how this works with an offline private key. first, generate an unsigned transaction proposal with the identity's certificate const certPem = '&lt;PEM encoded certificate content&gt;'; const mspId = 'Org1MSP'; // the msp Id for this org const transactionProposal = { fcn: 'move', args: ['a', 'b', '100'], chaincodeId: 'mychaincodeId', channelId: 'mychannel', }; const { proposal, txId } = channel.generateUnsignedProposal(transactionProposal, mspId, certPem); // now we have the 'unsigned proposal' for this transaction calculate the hash of the transaction proposal bytes. A hash algorithm should be picked and calculate the hash of the transaction proposal bytes. There exists multiple hash functions (such as SHA2/3). by default, the fabric client will use 'SHA2' with key size 256. The user may use an alternative implementation const proposalBytes = proposal.toBuffer(); // the proposal comes from step 1 const hashFunction = xxxx; // A hash function by the user's desire const digest = hashFunction(proposalBytes); // calculate the hash of the proposal bytes calculate the signature for this transaction proposal We may have a series of choices for the signature algorithm. Including asymmetric keys (such as ECDSA or RSA), symmetric keys (such as AES). By default the the fabric client will use ECDSA with algorithm 'EC'. // This is a sample code for signing the digest from step 2 with EC. // Different signature algorithm may have different interfaces const elliptic = require('elliptic'); const { KEYUTIL } = require('jsrsasign'); const privateKeyPEM = '&lt;The PEM encoded private key&gt;'; const { prvKeyHex } = KEYUTIL.getKey(privateKeyPEM); // convert the pem encoded key to hex encoded private key const EC = elliptic.ec; const ecdsaCurve = elliptic.curves['p256']; const ecdsa = new EC(ecdsaCurve); const signKey = ecdsa.keyFromPrivate(prvKeyHex, 'hex'); const sig = ecdsa.sign(Buffer.from(digest, 'hex'), signKey); // now we have the signature, next we should send the signed transaction proposal to the peer const signature = Buffer.from(sig.toDER()); const signedProposal = { signature, proposal_bytes: proposalBytes, }; send the signed transaction proposal to peer(s) const sendSignedProposalReq = { signedProposal, targets }; const proposalResponses = await channel.sendSignedProposal(sendSignedProposalReq); // check the proposal responses, if all good, commit the transaction similar to step 1, generate an unsigned transaction const commitReq = { proposalResponses, proposal, }; const commitProposal = await channel.generateUnsignedTransaction(commitReq); similar to step 3, sign the unsigned transaction with the user's private key const signedCommitProposal = signProposal(commitProposal); commit the signed transaction const response = await channel.sendSignedTransaction({ signedProposal: signedCommitProposal, request: commitReq, }); // response.status should be 'SUCCESS' if the commit succeed similar to step 1, generate an unsigned eventhub registration for the ChannelEventHub. const unsignedEvent = eh.generateUnsignedRegistration({ certificate: certPem, mspId, }); similar to step 3, sign the unsigned eventhub registration with the user's private key const signedProposal = signProposal(unsignedEvent); const signedEvent = { signature: signedProposal.signature, payload: signedProposal.proposal_bytes, }; register this ChannelEventHub at peer channelEventHub.connect({signedEvent}); A full test can be found at fabric-sdk-node/test/integration/signTransactionOffline.js How to enroll with a CSR The fabric-ca-client provides the API enroll() that accepts an optional param 'CSR'. If the params does not contains CSR, fabric-ca-client will first generate a key pair, then use the user's enrollmentID as the common name to create a CSR which is signed with the new generated private key. The response will contain the private key object if no 'CSR' in enroll params. To enroll with a CSR, first we should call fabric-ca-client API register to register a new identity at Fabric-ca. After a successfully register, we have the enrollmentID and enrollmentSecret. Then we should create the CSR. A common way is using the openssl command. Notice the CSR must contain the information \"common name\" and the \"common name\" must be same as the \"enrollmentID\" at the register step. Here is an example of how to create a CSR with the key algorithm rsa and key size 2048 bits openssl req -nodes -newkey rsa:2048 -keyout test.key -out test.csr The test.csr from the above command is represented as a Base64 encoded PKCS#10. Here is how we call enroll with a CSR const fs = require('fs'); const csr = fs.readFileSync('the path to test.csr', 'utf8'); const req = { enrollmentID: enrollmentID, enrollmentSecret: enrollmentSecret, csr: csr, }; const enrollment = await caService.enroll(req); // the enrollment.certificate contains the signed certificate from Fabric-ca  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-transaction-commit-events.html":{"id":"tutorial-transaction-commit-events.html","title":"Tutorial: fabric-network: How to wait for transactions to be committed to the ledger","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-network: How to wait for transactions to be committed to the ledger This tutorial describes the approaches that can be selected by users of the fabric-network module for ensuring that submitted transactions are committed on peers. Overview The submit of a transaction involves several steps: Send proposals to endorsing peers. Send the endorsed transaction to the orderer. The transaction is eventually committed on all peers in the network. In some cases a client application might be happy to proceed immediately after the transaction is successfully sent to the orderer. In other cases a client application might need to ensure that the transaction has been committed on certain peers with which it wants to interact before proceeding. It is important to note that the blockchain state visible from a specific peer will remain unchanged until a transaction is committed on that peer. If a client application queries a peer for state after an endorsed transaction has been successfully sent to the orderer but before the transaction has been committed on that peer, the state returned will still be that prior to the transaction. For example, a query of a bank balance after a transaction to deduct funds from that bank account is submitted to the orderer will return the old balance until the transaction is eventually committed on the peer being queried. Event handling strategies The SDK provides several selectable strategies for how it should wait for commit events following a transaction invocation. The available strategies are defined in EventHandlerStrategies. The desired strategy is (optionally) specified as an argument to connect() on the Gateway, and is used for all transaction invocations on Contracts obtained from that Gateway instance. If no event handling strategy is specified, MSPID_SCOPE_ALLFORTX is used by default. const { Gateway, EventHandlerStrategies } = require('fabric-network'); const connectOptions = { transaction: { strategy: EventHandlerStrategies.MSPID_SCOPE_ALLFORTX } } const gateway = new Gateway(); await gateway.connect(connectionProfile, connectOptions); Specifying null as the event handling strategy will cause transaction invocations to return immediately after successfully sending the endorsed transaction to the orderer. It will not wait for any commit events to be received from peers. For more details on Event Handling Options, see TransactionOptions. Plug-in event handlers If behavior is required that is not provided by the default event handling strategies, it is possible to implement your own event handling. This is achieved by specifying your own factory function as the event handling strategy. The factory function should return a transaction event handler object and take two parameters: transaction: Transaction options: any From the Transaction instance get the Network instance to provides access to peers and event services from which events will be recieved. function createTransactionEventHandler(transaction, options) { /* Your implementation here */ return new MyTransactionEventHandler(transaction, options); } const connectOptions = { transaction: { strategy: createTransactionEventhandler } } const gateway = new Gateway(); await gateway.connect(connectionProfile, connectOptions); For more details on Event Handling Options, see TransactionOptions. The transaction event handler object returned must implement the following functions. class MyTransactionEventHandler { /** * Called to initiate listening for transaction events. * @async * @throws {Error} if not in a state where the handling strategy can be satified and the transaction should * be aborted. For example, if insufficient event hubs are available. */ async startListening() { /* Your implementation here */ } /** * Wait until enough events have been received from the event hubs to satisfy the event handling strategy. * @async * @throws {Error} if the transaction commit is not successfully confirmed. */ async waitForEvents() { /* Your implementation here */ } /** * Cancel listening for events. */ cancelListening() { /* Your imeplementation here */ } } For a complete sample plug-in event handler implementation, see sample-transaction-event-handler.js.  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "},"tutorial-wallet.html":{"id":"tutorial-wallet.html","title":"Tutorial: fabric-network: Using wallets to manage identities","body":" Hyperledger Fabric SDK for node.js Modules fabric-network Classes AffiliationServiceBasePackagerBasicCommitHandlerBlockDecoderCertificateAuthorityChaincodeChaincodeRegistrationChannelChannelEventHubChannelPeerClientCommitHandlerDiscoveryEndorsementHandlerEndorsementHandlerEndorsementPolicyEndpointevent_hub_numberFabricCAClientFabricCAServicesIdentityServicefabric-network.BaseCheckpointerfabric-network.BaseEventListenerfabric-network.CommitEventListenerfabric-network.Contractfabric-network.ContractEventListenerfabric-network.EventHubDisconnectErrorfabric-network.EventServiceManagerfabric-network.FabricErrorfabric-network.FileSystemCheckpointerfabric-network.Gatewayfabric-network.HsmX509Providerfabric-network.IdentityProviderRegistryfabric-network.Networkfabric-network.TimeoutErrorfabric-network.Transactionfabric-network.Walletfabric-network.WalletsMSPMSPManagerNetworkConfigNetworkConfig_1_0OrdererOrganizationPeerRemoteTransactionID Interfaces fabric-network.WalletStore Tutorials Setting up the Application Developer's Environmentfabric-client: How to install and start your chaincodefabric-client: How to create a Hyperledger Fabric channelfabric-client: How to use the channel-based event servicefabric-client: How to use the discovery servicefabric-network: How to replay missed eventsfabric-network: How to automatically select and reconnect to event hubsfabric-client: How to set gRPC settingsfabric-client: How to use the endorsement and commit handlersfabric-network: How to listen to eventsfabric-client: How to use loggingfabric-client: How to add CouchDB indexes during chaincode installationfabric-client: How to configure mutual TLSfabric-client: How to use a common connection profileHow to use private datafabric-network: How to select peers for evaluating transactions (queries)Working with an offline private keyfabric-network: How to wait for transactions to be committed to the ledgerfabric-network: Using wallets to manage identities Global CLIENTfinalPackageHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERloadConfigGrouploadConfigValueORDERERpackagePEERtoEnvelopeUSER fabric-network: Using wallets to manage identities This tutorial describes how to use wallets to manage identities used to connect to a Hyperledger Fabric network. Overview A wallet provides an interface for storing and accessing identity information, backed by a persistent (or non-persistent) store of your choice. Identity information stored in a wallet can be used to connect to a Hyperledger Fabric network. Creating a wallet A wallet is backed by a wallet store, which is responsible only for storing and retrieving data. Several different store implementations are provided for convenience: In-memory: Non-persistent store. Useful for testing. File system: Stores identity information in a directory on the local file system. CouchDB: Stores identity information in a CouchDB database. Wallets using default store implementations are created using static factory functions on the Wallets class, for example: const wallet = await Wallets.newFileSystemWallet('/path/to/wallet/directory'); You can write your own custom wallet store to suit your deployment environment by implementing the WalletStore interface. A wallet backed by a custom wallet store implementation is created as follows: const walletStore = new MyCustomWalletStore(); const wallet = new Wallet(walletStore); Storing identity information in a wallet An identity is a set of information and credentials required to connect to a Hyperledger Fabric network. This information is described as a simple JavaScript object using a well-defined format, including the Member Services Provider associated with the user and a type identifier that indicates the type of credentials contained in the identity. Two identity types are supported by default: X.509: X.509 certificate and private key in PEM format. HSM-X.509: X.509 certificate in PEM format, with the private key stored in a Hardware Security Module. Once an identity object has been created from credentials supplied to you by your administrator or certificate authority, it can be stored and retreived from a wallet using an arbitrary label to locate the identity within the wallet, for example: const identity: X509Identity = { credentials: { certificate: 'PEM format certificate string', privateKey: 'PEM format private key string', }, mspId: 'wonderland', type: 'X.509', }; await wallet.put('alice', identity); Note that a wallet may contain identities of varying types so, in TypeScript, indentity information retrieved from the wallet is typed as Identity (or undefined if the identity does not exist in the wallet) and will need to be cast to its specific subtype to access type-specific information, for example: const identity = await wallet.get('alice'); if (identity &amp;&amp; identity.type === 'X.509') { const privateKey = (identity as X509Identity).credentials.privateKey; } Using a Hardware Security Module The SDK uses the PKCS #11 interface to make use of Hardware Security Module (HSM) devices for key management. Identities using an HSM-managed private key are similar to an X.509 identity but with the private key omitted. However, in order to use HSM-managed identities the containing wallet must be configured with details of the HSM that holds the private key. This is achieved by registering an IdentityProvider with the wallet, for example: const hsmProvider = new HsmX509Provider({ lib: '/path/to/hsm-specific/pkcs11/library', pin: '1234567890', slot: 0, }); wallet.getProviderRegistry().addProvider(hsmProvider); Once the wallet has been configured with details of the HSM, HSM-managed identities can be stored and retreived from the wallet as normal, for example: const identity: HsmX509Identity = { credentials: { certificate: 'PEM format certificate string', }, mspId: 'org1', type: 'HSM-X.509', }; await wallet.put('bob', identity);  Search results Close Documentation generated by JSDoc 3.6.3 on 2020-01-23T15:00:30+00:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
