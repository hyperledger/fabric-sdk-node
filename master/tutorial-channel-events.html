<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Hyperledger Fabric SDK for node.js Tutorial: fabric-client: How to use the channel-based event service</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Hyperledger Fabric SDK for node.js</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-fabric-network.html">fabric-network</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="AffiliationService.html">AffiliationService</a></li><li><a href="BasePackager.html">BasePackager</a></li><li><a href="BasicCommitHandler.html">BasicCommitHandler</a></li><li><a href="BlockDecoder.html">BlockDecoder</a></li><li><a href="CertificateAuthority.html">CertificateAuthority</a></li><li><a href="Chaincode.html">Chaincode</a></li><li><a href="ChaincodeRegistration.html">ChaincodeRegistration</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ChannelEventHub.html">ChannelEventHub</a></li><li><a href="ChannelPeer.html">ChannelPeer</a></li><li><a href="Client.html">Client</a></li><li><a href="CommitHandler.html">CommitHandler</a></li><li><a href="DiscoveryEndorsementHandler.html">DiscoveryEndorsementHandler</a></li><li><a href="EndorsementHandler.html">EndorsementHandler</a></li><li><a href="EndorsementPolicy.html">EndorsementPolicy</a></li><li><a href="Endpoint.html">Endpoint</a></li><li><a href="event_hub_number.html">event_hub_number</a></li><li><a href="FabricCAClient.html">FabricCAClient</a></li><li><a href="FabricCAServices.html">FabricCAServices</a></li><li><a href="IdentityService.html">IdentityService</a></li><li><a href="module-fabric-network.BaseCheckpointer.html">fabric-network.BaseCheckpointer</a></li><li><a href="module-fabric-network.BaseEventListener.html">fabric-network.BaseEventListener</a></li><li><a href="module-fabric-network.CommitEventListener.html">fabric-network.CommitEventListener</a></li><li><a href="module-fabric-network.Contract.html">fabric-network.Contract</a></li><li><a href="module-fabric-network.ContractEventListener.html">fabric-network.ContractEventListener</a></li><li><a href="module-fabric-network.EventHubDisconnectError.html">fabric-network.EventHubDisconnectError</a></li><li><a href="module-fabric-network.EventServiceManager.html">fabric-network.EventServiceManager</a></li><li><a href="module-fabric-network.FabricError.html">fabric-network.FabricError</a></li><li><a href="module-fabric-network.FileSystemCheckpointer.html">fabric-network.FileSystemCheckpointer</a></li><li><a href="module-fabric-network.Gateway.html">fabric-network.Gateway</a></li><li><a href="module-fabric-network.HsmX509Provider.html">fabric-network.HsmX509Provider</a></li><li><a href="module-fabric-network.IdentityProviderRegistry.html">fabric-network.IdentityProviderRegistry</a></li><li><a href="module-fabric-network.Network.html">fabric-network.Network</a></li><li><a href="module-fabric-network.TimeoutError.html">fabric-network.TimeoutError</a></li><li><a href="module-fabric-network.Transaction.html">fabric-network.Transaction</a></li><li><a href="module-fabric-network.Wallet.html">fabric-network.Wallet</a></li><li><a href="module-fabric-network.Wallets.html">fabric-network.Wallets</a></li><li><a href="MSP.html">MSP</a></li><li><a href="MSPManager.html">MSPManager</a></li><li><a href="NetworkConfig.html">NetworkConfig</a></li><li><a href="NetworkConfig_1_0.html">NetworkConfig_1_0</a></li><li><a href="Orderer.html">Orderer</a></li><li><a href="Organization.html">Organization</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Remote.html">Remote</a></li><li><a href="TransactionID.html">TransactionID</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="interfaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Interfaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-fabric-network.WalletStore.html">fabric-network.WalletStore</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-app-dev-env-setup.html">Setting up the Application Developer's Environment</a></li><li><a href="tutorial-chaincode-lifecycle.html">fabric-client: How to install and start your chaincode</a></li><li><a href="tutorial-channel-create.html">fabric-client: How to create a Hyperledger Fabric channel</a></li><li><a href="tutorial-channel-events.html">fabric-client: How to use the channel-based event service</a></li><li><a href="tutorial-discovery.html">fabric-client: How to use the discovery service</a></li><li><a href="tutorial-event-checkpointer.html">fabric-network: How to replay missed events</a></li><li><a href="tutorial-event-hub-management.html">fabric-network: How to automatically select and reconnect to event hubs</a></li><li><a href="tutorial-grpc-settings.html">fabric-client: How to set gRPC settings</a></li><li><a href="tutorial-handlers.html">fabric-client: How to use the endorsement and commit handlers</a></li><li><a href="tutorial-listening-to-events.html">fabric-network: How to listen to events</a></li><li><a href="tutorial-logging.html">fabric-client: How to use logging</a></li><li><a href="tutorial-metadata-chaincode.html">fabric-client: How to add CouchDB indexes during chaincode installation</a></li><li><a href="tutorial-mutual-tls.html">fabric-client: How to configure mutual TLS</a></li><li><a href="tutorial-network-config.html">fabric-client: How to use a common connection profile</a></li><li><a href="tutorial-private-data.html">How to use private data</a></li><li><a href="tutorial-query-peers.html">fabric-network: How to select peers for evaluating transactions (queries)</a></li><li><a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a></li><li><a href="tutorial-transaction-commit-events.html">fabric-network: How to wait for transactions to be committed to the ledger</a></li><li><a href="tutorial-wallet.html">fabric-network: Using wallets to manage identities</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#CLIENT">CLIENT</a></li><li><a href="global.html#finalPackage">finalPackage</a></li><li><a href="global.html#HFAFFILIATIONMGR">HFAFFILIATIONMGR</a></li><li><a href="global.html#HFGENCRL">HFGENCRL</a></li><li><a href="global.html#HFINTERMEDIATECA">HFINTERMEDIATECA</a></li><li><a href="global.html#HFREGISTRARATTRIBUTES">HFREGISTRARATTRIBUTES</a></li><li><a href="global.html#HFREGISTRARDELEGATEROLES">HFREGISTRARDELEGATEROLES</a></li><li><a href="global.html#HFREGISTRARROLES">HFREGISTRARROLES</a></li><li><a href="global.html#HFREVOKER">HFREVOKER</a></li><li><a href="global.html#loadConfigGroup">loadConfigGroup</a></li><li><a href="global.html#loadConfigValue">loadConfigValue</a></li><li><a href="global.html#ORDERER">ORDERER</a></li><li><a href="global.html#package">package</a></li><li><a href="global.html#PEER">PEER</a></li><li><a href="global.html#toEnvelope">toEnvelope</a></li><li><a href="global.html#USER">USER</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			<section class="tutorial-section">

<header>
    

    <h2>fabric-client: How to use the channel-based event service</h2>
</header>

<article>
    <p>This tutorial discusses the channel event service and how to
use the Hyperledger Fabric Node.js client (fabric-client) <a href="ChannelEventHub.html">ChannelEventHub</a> class.</p>
<ul>
<li>For more information on getting started with Fabric see
<a href="http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html">Building your first network</a>.</li>
<li>For more information on Hyperledger Fabric
<a href="http://hyperledger-fabric.readthedocs.io/en/latest/peer_event_services.html">Peer channel-based event services</a>.</li>
<li>See the NPM module <a href="https://www.npmjs.com/package/fabric-client">fabric-client</a>.</li>
</ul>
<p>The following assumes an understanding of Fabric networks (orderers and peers),
and of Node application development, including the use of the
Javascript <code>await</code>, <code>async</code> and <code>Promise</code>.</p>
<h2>Overview</h2>
<p>The channel event service is made up both the fabric network's
Peer channel-based event services and the Node.js fabric-client
class <a href="ChannelEventHub.html">ChannelEventHub</a>.
A Hyperledger Fabric Peer's channel-based event service will deliver
the requested blocks to a
client application's ChannelEventHub running instance.
The ChannelEventHub processes the
blocks as they are delivered from the Hyperledger Fabric Peer.
Client applications register <code>event listeners</code> with the ChannelEventHub
to be notified when a block is received that is of interest.
Together, the Peer's channel-based event service and the fabric-client's
ChannelEventHub class provide the
<code>channel event service</code> for the client application.</p>
<p>The ChannelEventHub will de-serialize the blocks
as they are received from the peer. The ChannelEventHub will then look
at the block contents to see if there is match to an <code>event listener</code>.
If there is a match, the event listener will be notified.</p>
<p>The client application may choose to start the delivery of blocks at a selected
block number or start from the latest block.
The client application may choose to end the
delivery of blocks at a selected block number, end at the latest block,
or continue to send blocks as they are added to the ledger.</p>
<p>Client applications typically are not interested that a new block was added to
the ledger, but would be interested in knowing that the transaction
that has just been submitted has been committed and if it was valid.
For example when a transaction with the id of '12345' has been submitted.
The client application would have to register a &quot;transaction event listener&quot;
to be notified when the transaction is committed.
The notification is a javascript call to a javascript function
provided on the registration.
This function known as a <code>callback</code>, will be called by the ChannelEventHub
with information defined for a &quot;transaction&quot; event from a block that
the ChannelEventHub has received from the Peer's channel-based event service.
In this example the ChannelEventHub will notify the &quot;event listener&quot;
(the client application program) with
the transaction id <code>12345</code>, the transaction status <code>VALID</code>,
and the block number <code>73</code> that contains the committed transaction.</p>
<p>fabric-client ChannelEventHub provides for three types of events:</p>
<ul>
<li><code>block</code> - An application program will be notified when
the fabric-client receives a block. There is no checking the
contents of the block for a match with this event type as the application
program will be notified for each block received.
These blocks may be old or new depending on how the connection was setup.</li>
<li><code>transaction</code> - An application program will be notified when the
fabric-client receives a block containing a specific transaction id.
The transaction may have been just added to the ledger or may be
from existing blocks depending on how the connection was setup.</li>
<li><code>chaincode</code> - An application program will be notified when the
fabric-client receives a block containing a specific chaincode event.
The value of a chaincode event is generated by the chaincode during
the endorsement of a proposal and placed into the endorsement results,
however a block must be committed
with the transaction that contains the chaincode event before the
event will be seen by the channel event service.
The fabric-client will see the chaincode event when it looks at each block
received. If the fabric-client finds a chaincode
event it will check for a matching &quot;event listener&quot; to notify.</li>
</ul>
<p>The Peer's channel-based event service allows fabric-clients to
receive &quot;filtered&quot; blocks
(which allow for receiving transaction validation status without providing
other sensitive information). Access to &quot;filtered&quot; blocks or &quot;full&quot; blocks
is configured when the connection is setup to a
Peer's channel-based event service.
The default behavior is to connect to receive filtered blocks.
For more information on filtered blocks see
<a href="http://hyperledger-fabric.readthedocs.io/en/latest/peer_event_services.html">Peer channel-based event services</a>.</p>
<h2><code>Channel</code></h2>
<h3>methods</h3>
<ul>
<li><a href="Channel.html#newChannelEventHub">newChannelEventHub(peer)</a> --
A Channel instance method to get a new instance of a
<a href="ChannelEventHub.html">ChannelEventHub</a>.</li>
<li><a href="Channel.html#getChannelEventHub">getChannelEventHub(name)</a> --
A Channel instance method to get an existing instance of a
<a href="ChannelEventHub.html">ChannelEventHub</a> by the name of the peer.</li>
<li><a href="Channel.html#getChannelEventHubsForOrg">getChannelEventHubsForOrg(org)</a> --
Gets a list of <a href="ChannelEventHub.html">ChannelEventHub</a>s based on an organization.
If the organization name is omitted then the current organization
of the current user is used.
Note: Use the <code>mspid</code> of the organization as the organization name.</li>
</ul>
<h2><code>ChannelEventHub</code></h2>
<h3>methods</h3>
<p>The following are the methods of the <a href="ChannelEventHub.html">ChannelEventHub</a> that will be used
for registering and removing registrations for event listeners.</p>
<ul>
<li><a href="ChannelEventHub.html#registerBlockEvent">registerBlockEvent(eventCallBack, errorCallBack, options)</a>
-- To register for block events.</li>
<li><a href="ChannelEventHub.html#unregisterBlockEvent">unregisterBlockEvent(reg_num)</a>
-- To remove a block registration.</li>
<li><a href="ChannelEventHub.html#registerTxEvent">registerTxEvent(tx_id, eventCallBack, errorCallBack, options)</a>
-- To register for a specific transaction event.</li>
<li><a href="ChannelEventHub.html#unregisterTxEvent">unregisterTxEvent(tx_id)</a>
-- To remove a specific transaction registration.</li>
<li><a href="ChannelEventHub.html#registerChaincodeEvent">registerChaincodeEvent(ccid, eventCallBack, errorCallBack, options)</a>
-- To register for chaincode events.</li>
<li><a href="ChannelEventHub.html#unregisterChaincodeEvent">unregisterChaincodeEvent(cc_handle)</a>
-- To remove a chaincode event registration.
lastBlockNumber</li>
<li>lastBlockNumber()
-- To get the last block number this channel event hub has seen.</li>
</ul>
<p>The following are the methods of <a href="ChannelEventHub.html">ChannelEventHub</a> that will be used to
control a connection to a Peer's channel-based event service on
the fabric network.</p>
<ul>
<li><a href="ChannelEventHub.html#disconnect">disconnect()</a>
-- To have the client channel event hub shutdown the connection
to the fabric network channel-based event service and notify all current channel
event registrations of the shutdown by using the registered <code>errorCallBack</code>s.</li>
<li><a href="ChannelEventHub.html#connect">connect()</a>
-- <strong>Deprecated</strong> -
To have the client channel event hub connect with the
fabric channel-based event service. This call must be made before events will be
received by your instance of a <code>ChannelEventHub</code>. When the channel-based event hub
connects with the service, it will request to receive blocks or filtered blocks.
If the parameter is omitted, it will default to false
and filtered blocks will be requested.</li>
<li><a href="ChannelEventHub.html#connect">connect(options, connectCallBack)</a>
-- To have the client channel event hub
connect with the fabric channel-based event service using the options provided
and report back the results of the connect using the provided call back.
see <a href="#connect-options">connect options</a> for details and
see <a href="#connect-callback">connect callback</a> for details.</li>
<li><a href="ChannelEventHub.html#reconnect">reconnect(options, connectCallBack)</a>
-- To have the client channel event hub
reconnect with the fabric channel-based event service using the options provided
and report back the results of the connect using the provided call back.</li>
</ul>
<h3>parameters</h3>
<p>The following are descriptions for the parameters shown above on
the method descriptions.</p>
<h4>'peer' parameter for newChannelEventHub</h4>
<p>This optional parameter on the <a href="Channel.html">Channel</a> <a href="Channel.html#newChannelEventHub">newChannelEventHub</a>
may be included when creating a new instance of the <a href="ChannelEventHub.html">ChannelEventHub</a>.
The value is a <a href="Peer.html">Peer</a> instance or the name of a peer when
using a <code>connection profile</code>
see <a href="tutorial-network-config.html">How to use a common common connection profile file</a>.
This is the target peer that will provide the fabric event service.
If the application wishes to pass the target peer on the connect call then this
parameter may be left empty.</p>
<h4>'eventCallback' parameter for registration</h4>
<p>This parameter must be included in all
event listener registrations.
This is the callback function to be notified (called)
when the fabric-client receives a block and finds an &quot;event listener&quot; that is a
match for the block.</p>
<h4>'errorCallback' parameter for registration</h4>
<p>This is an optional parameter. This is the callback function to be notified
(called) when this channel event hub is shutdown.
The shutdown may be caused by a fabric network error,
network connection problem or by a call to the
<a href="ChannelEventHub.html">ChannelEventHub</a> <a href="ChannelEventHub.html#disconnect">disconnect()</a> method.
This callback will also be called when the channel event hub is shutdown
due to the last block being received when replaying events
with the <code>endBlock</code> set.</p>
<h4><a name="connect-options"></a><code>options</code> parameter for connect and reconnect</h4>
<p>This is an optional parameter for the <a href="ChannelEventHub.html">ChannelEventHub</a>
<a href="ChannelEventHub.html#connect">connect()</a> and
<a href="ChannelEventHub.html#reconnect">reconnect()</a> methods.</p>
<p>This parameter may contain the following optional properties:</p>
<ul>
<li>
<p>{integer | 'newest' | 'oldest' | 'last_seen'} <code>startBlock</code>
(Optional) The starting block number for event checking.
When included, the  Peer's channel-based event service will be asked to start
sending blocks from this block number.
This is how to resume listening or replay missed blocks that were added
to the ledger.
Replaying events may confuse event listeners and will not be allowed if
listeners have registered with <code>startBlock</code> or <code>endBlock</code>.
When this parameter is excluded (as it will be normally) the event service
will be asked to start sending blocks from the newest block on the ledger.</p>
<ul>
<li>
<p><code>Number</code> - A number value may be specified as the block number.</p>
</li>
<li>
<p><code>'newest'</code> - The string of 'newest'. This will have the block
number determined by the Peer's channel-based event service at connect
time of the the newest block on the ledger.</p>
</li>
<li>
<p><code>'oldest'</code> - The string of 'oldest'. This will have the block
number determined by the Peer's channel-based event service at connect
time of the the oldest block on the ledger, unless your ledger
has been pruned, this will be block 0.</p>
</li>
<li>
<p><code>'last_seen'</code> - The string of 'last_seen'. This will have the channel event hub
instance determine the block number at the time of the registration.
The number will be based on the last block that this channel event hub has
received from the Peer's channel-based event service.
Using this option on an event listener does require that this
channel event hub has been previously running.</p>
</li>
</ul>
</li>
<li>
<p>{integer | 'newest' | 'oldest' | 'last_seen' } <code>endBlock</code>
(Optional) The ending block number for event checking.
When included, the Peer's channel-based event service will be asked to stop
sending blocks once this block is delivered.
This is how to replay missed blocks that were added to the ledger. When a
<code>startBlock</code> is not included, the <code>endBlock</code> must be equal to or larger than
the current channel block height.
The value 'newest' will indicate that 'endBlock' will be calculated by the
peer as the newest block on the ledger.
This allows the application to replay up to the latest block on
the ledger and then the listener will stop and be notified by the
'onError' callback.</p>
<ul>
<li>
<p><code>Number</code> - A number value may be specified as the block number.</p>
</li>
<li>
<p><code>'newest'</code> - The string of 'newest'. This will have the block
number determined by the Peer's channel-based event service at connect
time of the the newest block on the ledger.</p>
</li>
<li>
<p><code>'oldest'</code> - The string of 'oldest'. This will have the block
number determined by the Peer's channel-based event service at connect
time of the the oldest block on the ledger, unless your ledger
has been pruned, this will be block 0.</p>
</li>
<li>
<p><code>'last_seen'</code> - The string of 'last_seen'. This will have the channel event hub
instance determine the block number at the time of the registration.
The number will be based on the last block that this channel event hub has
received from the Peer's channel-based event service.
Using this option on an event listener does require that this
channel event hub has been previously running.</p>
</li>
</ul>
</li>
<li>
<p>{<a href="global.html#SignedEvent">SignedEvent</a>} <code>signedEvent</code> (Optional) The signed event to be sent
to the peer. This option is useful when the fabric-client application
does not have the user's privateKey and can not sign requests to the
fabric network.
see <a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a>.</p>
</li>
<li>
<p>{<a href="Peer.html">Peer</a> | string} <code>target</code> (Optional) The peer that provides the
fabric event service. When using a string, the <a href="Channel.html">Channel</a> associated
with this <a href="ChannelEventHub.html">ChannelEventHub</a> must have the peer assigned with that
as the name of the peer.
When used on the <a href="ChannelEventHub.html">ChannelEventHub</a>
<a href="ChannelEventHub.html#connect">connect()</a> method or the
<a href="ChannelEventHub.html#reconnect">reconnect()</a> method the target peer
will replace the existing target endpoint assigned to this
<a href="ChannelEventHub.html">ChannelEventHub</a> instance.</p>
</li>
</ul>
<h4><code>options</code> parameter for event listener registration</h4>
<p>This is an optional parameter. This parameter may contain the following optional
properties:</p>
<ul>
<li>
<p>{integer | 'newest' | 'oldest' | 'last_seen'} <code>startBlock</code>
(Optional) The starting block number for event checking.
When included, the Peer's channel-based event service will be asked to start
sending blocks from this block number.
This is how to resume listening or replay missed blocks that were added
to the ledger. This option changes how the connection is made to the fabric
Peer's channel-based event service,
therefore the registration must be made before the
channel event hub has setup the connection.
Replaying events may confuse other event listeners; therefore, only one listener
will be allowed on a <code>ChannelEventHub</code> when <code>startBlock</code>
and/or <code>endBlock</code> are used on a listener registration.</p>
<ul>
<li>
<p><code>Number</code> - A number value may be specified as the block number.</p>
</li>
<li>
<p><code>'newest'</code> - The string of 'newest'. This will have the block
number determined by the Peer's channel-based event service at connect
time of the the newest block on the ledger.</p>
</li>
<li>
<p><code>'oldest'</code> - The string of 'oldest'. This will have the block
number determined by the Peer's channel-based event service at connect
time of the the oldest block on the ledger, unless your ledger
has been pruned, this will be block 0.</p>
</li>
<li>
<p><code>'last_seen'</code> - The string of 'last_seen'. This will have the channel event hub
instance determine the block number at the time of the registration.
The number will be based on the last block that this channel event hub has
received from the Peer's channel-based event service.
Using this option on an event listener does require that this
channel event hub has been previously running.</p>
</li>
</ul>
</li>
<li>
<p>{integer | 'newest' | 'oldest' | 'last_seen' } <code>endBlock</code>
(Optional) The ending block number for event checking.
When included, the  Peer's channel-based event service will be asked to stop
sending blocks once this block is delivered.
This is how to replay missed blocks that were added to the ledger. When a
<code>startBlock</code> is not included, the <code>endBlock</code> must be equal to or larger than
the current channel block height.
This option changes how the connection is made to the fabric
Peer's channel-based event service, therefore the
registration must be made before the
channel event hub has setup the connection.
Replaying events may confuse other event
listeners; therefore, only one listener will be allowed on a <code>ChannelEventHub</code>
when <code>startBlock</code> and/or <code>endBlock</code> are used.
The value 'newest' will indicate that 'endBlock' will be calculated by the
peer as the newest block on the ledger.
This allows the application to replay up to the latest block on
the ledger and then the listener will stop and be notified by the
'onError' callback.</p>
<ul>
<li>
<p><code>Number</code> - A number value may be specified as the block number.</p>
</li>
<li>
<p><code>'newest'</code> - The string of 'newest'. This will have the block
number determined by the Peer's channel-based event service at connect
time of the the newest block on the ledger.</p>
</li>
<li>
<p><code>'oldest'</code> - The string of 'oldest'. This will have the block
number determined by the Peer's channel-based event service at connect
time of the the oldest block on the ledger, unless your ledger
has been pruned, this will be block 0.</p>
</li>
<li>
<p><code>'last_seen'</code> - The string of 'last_seen'. This will have the channel event hub
instance determine the block number at the time of the registration.
The number will be based on the last block that this channel event hub has
received from the Peer's channel-based event service.
Using this option on an event listener does require that this
channel event hub has been previously running.</p>
</li>
</ul>
</li>
<li>
<p>{boolean} <code>unregister</code> -- (Optional) This setting indicates that the
registration should be removed (unregister) after the event is seen. When the
application is using a timeout to only wait a specified amount of time for the
transaction to be seen, the timeout processing should include the manual
'unregister' of the transaction event listener to avoid the event callbacks
being called unexpectedly. The default for this setting is different for the
different types of event listeners. For block listeners the default is true when
an end_block was set as a option, the listener will be active and receiving
blocks until the end block is received and then the listener will be automatically
unregistered. For transaction listeners the default is true and once the transaction
event has occurred the listener will be automatically unregistered. If the
transaction listener has used an endBlock, the default will be
to automatically unregister the listener even if the transaction has not been
seen.
For chaincode event listeners the default will be false as the match filter
might be intended for many transactions, however if the chaincode event
listener has set an endBlock it will be automatically unregistered after
the endBlock is seen.</p>
</li>
<li>
<p>{boolean} <code>disconnect</code> -- (Optional) This setting indicates to the
<code>ChannelEventHub</code> instance to automatically disconnect itself from the peer's
channel-based event service once the event has been seen. The default is false.
When not set and the endBlock has been set the ChannelEventHub instance
will automatically disconnect itself.</p>
</li>
<li>
<p>{boolean} <code>as_array</code> -- (Optional) This setting indicates to the
<code>ChannelEventHub</code> instance to send all chaincode events to the
callback as array rather than one at a time. This setting is only
available for chaincode events.</p>
</li>
</ul>
<h3>How to use a Channel Event Hub</h3>
<p>The ChannelEventHub class is very flexible. It allows for many usage models.</p>
<ul>
<li>waiting for my transaction to complete</li>
<li>looking at chaincode events</li>
<li>auditing a channel for all new blocks</li>
<li>replay events</li>
</ul>
<h4>Transaction events</h4>
<p>A majority of users will need to know when a transaction is committed to the
ledger.
All transactions have an unique identifier that may be monitored. Users may
register an event listener to indicate that a specific transaction has
been written to the ledger. This will be known as a transaction event.</p>
<p>Steps to be notified for a transaction event:</p>
<ul>
<li>Get a channel event hub instance, this may be done for every transaction
or may be done once and reused.</li>
<li>Connect the channel event hub instance with the peer's event service. You
may wish to connect before registering when reusing the ChannelEventHub
instance for many transactions.</li>
<li>Create transaction and have it endorsed.</li>
<li>Register your callback using the transaction ID string of the transaction
with the channel event hub instance.</li>
<li>Connect the channel event hub if not already connected.</li>
<li>Submit the endorsed transaction to be ordered.</li>
<li>Wait to be notified of the transaction being committed to the ledger
or timeout if there is an issue.</li>
<li>Unregister the event listener when transaction is seen, which will be done
automatically by default.</li>
<li>Disconnect the channel event hub when finished listening,
which could be done automatically if configured.</li>
</ul>
<h4>Chaincode events</h4>
<p>Chaincode programs running on the fabric network are able to add into a
transaction a name and a value, this is known as a chaincode event.
The &quot;name&quot; will most likely not be unique and more than one transaction
may contain the chaincode event name,
therefore the listener callback may be called many times. The listener may be
setup to use a regular expression when looking for a name match such that a
single listener may be notified with many different names.</p>
<p>NOTE: Chaincode events must be committed and written to the ledger before
a listener will be notified. The ChannelEventHub instance will not see
chaincode events in transactions until the transactions commits and is
written to the peer's ledger on the peer that ChannelEventHub has connected
to the event service.</p>
<p>Steps to be notified when a chaincode event occurs:</p>
<ul>
<li>Get a channel event hub instance, this should be done once and reused.</li>
<li>Connect the channel event hub instance with the peer's event service. You
should connect before registering when reusing the ChannelEventHub
instance for many transactions and if waiting for a chaincode event in
a transaction that will be committed.
<ul>
<li><strong>Note:</strong> When the ChannelEventHub <code>connect</code> completes to the Peer's event
service blocks will start to be delivered to the ChannelEventHub instance.
If the startBlock parameter is not used, the first block received will be
the latest block. The latest block may contain a chaincode event and it
may match the chaincode event that you will register. This latest block
is not the block that will contain the transaction that you will commit
shortly and is just the last block on the channel ledger. We know that
it is not our block because we have not committed our transaction,
however the Peer was asked to start and keep sending the latest blocks.
So you should connect first then register and then commit when using
chaincode events.</li>
</ul>
</li>
<li>Register your callback with the name of the chaincode event, you may use
a regular expression to match on more than one name.</li>
<li>Somewhere on the network a transaction is endorsed and committed containing
a chaincode event.</li>
<li>Process the chaincode events as they come in.</li>
<li>Unregister the event listener when finished.</li>
<li>Disconnect the channel event hub when finished listening.</li>
</ul>
<h4>Block events</h4>
<p>Once a ChannelEventHub connects to the Peer's event service it will
start receiving blocks as they are added to the ledger, unless a
&quot;startBlock&quot; is specified, then it will start receiving blocks from
the block specified. When a block is received by the ChannelEventHub
instance from the Peer's event service, this is known as a block
event,</p>
<p>Steps to be notified when a block event occurs:</p>
<ul>
<li>Get a channel event hub instance.</li>
<li>Register to receive blocks.</li>
<li>Connect the channel event hub instance with the peer's event service.</li>
<li>Somewhere on the network a transaction is endorsed and committed.</li>
<li>Process the blocks as they come in.</li>
<li>Disconnect the channel event hub when finished listening.</li>
</ul>
<h4>Replay events</h4>
<p>If you wish to look at events that already happened, use the &quot;startBlock&quot;
option to replay the events. Using the start block will connect to the
Peer's event service and have it start sending existing blocks starting
with the block number specified rather than the latest block. Blocks will
be continued to be sent until the &quot;endBlock&quot; is seen. If no end block
is specified, then blocks will continue to be sent as they are added
to the ledger. Replay may be used to look again for your transaction
or chaincode events when your application was off-line. When not specifying
an end block the channel event hub may continued to be used to monitor for
new events as they happen on the channel after catching up on existing events.</p>
<p>Steps to be notified when a replay event occurs:</p>
<ul>
<li>Get a channel event hub instance.</li>
<li>Register to receive your events.</li>
<li>Connect the channel event hub instance with the peer's event service using
a &quot;startBlock&quot;</li>
<li>Process the events as they come in.</li>
<li>Disconnect the channel event hub when finished listening.</li>
</ul>
<h3>Get a Channel Event Hub</h3>
<p>Use the fabric-client <a href="Channel.html">Channel</a>
<a href="Channel.html#newChannelEventHub">newChannelEventHub</a> object to
create new instances of <a href="ChannelEventHub.html">ChannelEventHub</a> objects.
Use the following to get a
<code>ChannelEventHub</code> instances that will be setup to work with the
Peer's channel-based event service.
A <code>ChannelEventHub</code> instance will use all the same
endpoint configuration settings that the peer instance is using, like the tls
certs and the host and port address.</p>
<pre class="prettyprint source"><code>// peer is a instance
const channel_event_hub = channel.newChannelEventHub(peer);

// using the peer name
const channel_event_hub = channel.newChannelEventHub('peer0.org1.example.com');
</code></pre>
<p>When using a connection profile
(see <a href="tutorial-network-config.html">How to use a common common connection profile file</a>)
then the peer's name may be used to get a channel event hub. This will return
the same ChannelEventHub instance each time the &quot;getChannelEventHub&quot; is called.</p>
<pre class="prettyprint source"><code>// must use peer name
const channel_event_hub = channel.getChannelEventHub('peer0.org1.example.com');
</code></pre>
<p>Here is an example of how to get a list of channel event hubs when using a
connection profile. The following will get a list based on the current
organization that is defined in the currently active <code>client</code> section of the
connection profile. Peers defined in the organization that have the <code>eventSource</code>
set to true will be added to the list.</p>
<pre class="prettyprint source"><code>const channel_event_hubs = channel.getChannelEventHubsForOrg();
</code></pre>
<p>When creating a peer instance, you can get a <code>ChannelEventHub</code> instance by using
the peer instance.</p>
<pre class="prettyprint source"><code>const data = fs.readFileSync(path.join(__dirname, 'somepath/tlscacerts/org1.example.com-cert.pem'));
const peer = client.newPeer(
	'grpcs://localhost:7051',
	{
		pem: Buffer.from(data).toString(),
		'ssl-target-name-override': 'peer0.org1.example.com'
	}
);
const channel_event_hub = channel.newChannelEventHub(peer);
</code></pre>
<h3>Connect a Channel Event Hub</h3>
<p>Once you have a ChannelEventHub instance you will need to connect to the peer's
event service. The &quot;connect&quot; call setups up a connection to the peer's event
service. The connection with the peer's event service must
indicate which blocks to receive. By default the ChannelEventHub will
specify the latest block as the starting point. This is usually the point
on the ledger where monitoring is required. Users may specify both a starting
point and an ending point. Specifying a &quot;startBlock&quot; is useful when the
application needs to look at existing transactions, chaincode events, or
blocks. The connect call may be made before or after registration, however
start blocks and end blocks may not be changed after the connect call is
made. The connection with the peer's event service must also indicate
full blocks or filtered blocks. By default the connection will be setup
to receive filtered blocks as this contains transaction status and does
not contain sensitive data.</p>
<p>The best practice is to connect before registering for transaction events
and provide a callback.</p>
<pre class="prettyprint source"><code>const channel_event_hub = ...

channel_event_hub.connect({full_block: false}, (err, status) => {
	if (err) {
		// process the error
	} else {
		// connect was good
	}
});

channel_event_hub.register...

</code></pre>
<p>The best practice is to connect before registering for chaincode events. When
connect is not part of the registration flow then it is easily modified
to include the &quot;startBlock&quot; (for replay).
Since filtered blocks contain very little information, chaincode events
and block events may not be useful unless full blocks are received. The
user performing the connect must have the access authority to see full
blocks.</p>
<pre class="prettyprint source"><code>const channel_event_hub = ...

channel_event_hub.register...

channel_event_hub.connect({full_block: true}, (err, status) => {
	if (err) {
		// process the error
	} else {
		// connect was good
	}
});
</code></pre>
<p>With replay, notice that the user gets the start block from a previous
ChannelEventHub.</p>
<pre class="prettyprint source"><code>const channel_event_hub = ...

const my_start = old_channel_event_hub.lastBlockNumber();

channel_event_hub.register...

channel_event_hub.connect({full_block: true, startBlock: my_start}, (err, status) => {
	if (err) {
		// process the error
	} else {
		// connect was good
	}
});
</code></pre>
<h3>Block Listener</h3>
<p>When there is a need to monitor for new blocks being added to the ledger,
use a block event listener. The Fabric client Node.js will be notified when a
new block is committed to the ledger on the peer. The client Node.js will then
call the registered callback of the application program. The callback will be
passed a JSON representation of the newly added block.
Note that when <code>connect()</code>
is not called with <code>{full_block: true}</code>
the callback will receive a filtered block.
The access rights of the user registering to receive full blocks will be checked
by the Peer's channel-based event service. When there is a need to see previously
added blocks, the registration of the callback may include a starting block
number. The callback will start receiving blocks from this number and continue
to receive new blocks as they are added to the ledger. This is a way for the
application to resume and replay events that may have been lost if the
application were to be offline. The application should remember the last block
it has processed to avoid replaying the entire ledger.</p>
<p>The following example will register a block listener to start receiving new
blocks as they are added to the ledger.</p>
<pre class="prettyprint source"><code>// keep the block_reg to unregister with later if needed
block_reg = channel_event_hub.registerBlockEvent((block) => {
	console.log('Successfully received the block event');
	&lt;do something with the block>
}, (error)=> {
	console.log('Failed to receive the block event ::'+error);
	&lt;do something with the error>
});
</code></pre>
<p>The following example will register with a start block number because this
application needs to resume at a specific block and replay the missed blocks.
The application callback will handle the replayed blocks in the same manor like
current events. The block listener will continue to receive blocks as they are
committed to the ledger on the peer.</p>
<pre class="prettyprint source"><code>// keep the block_reg to unregister with later if needed
block_reg = channel_event_hub.registerBlockEvent((block) => {
	console.log('Successfully received the block event');
	&lt;do something with the block>
}, (error)=> {
	console.log('Failed to receive the block event ::'+error);
	&lt;do something with the error>
},
	{startBlock:23}
);
</code></pre>
<p>The following example will register with a start block number and an end block.
The application needs to replay the missed blocks. The application callback will
handle the replayed blocks in the same manor as current events. The block
listener will be automatically unregistered and the <code>ChannelEventHub</code> shutdown
when the end block event is seen by the listener. The application will not have
to handle this housekeeping.</p>
<pre class="prettyprint source"><code>block_reg = channel_event_hub.registerBlockEvent((full_block) => {
	console.log('Successfully received a block event');
	&lt;do something with the block>
	const event_block = Long.fromValue(full_block.header.number);
	if(event_block.equals(current_block)) {
		console.log('Successfully got the last block number');
		&lt;application is now up to date>
	}
}, (error)=> {
	console.log('Failed to receive the block event ::'+error);
	&lt;do something with the error>
},
	// for block listeners, the defaults for unregister and disconnect are true,
	// so they are not required to be set in the following example
	{startBlock:23, endBlock:30, unregister: true, disconnect: true}
);
</code></pre>
<p>The following example will register with a start block number and an end block
set to 'newest'. The error callback will be called to notify the application
that the last block has been delivered and that the listener has been shutdown.</p>
<pre class="prettyprint source"><code>block_reg = channel_event_hub.registerBlockEvent((block) => {
	console.log('Successfully received the block event');
	&lt;do something with the block>
}, (error)=> {
	if(error.toString().indexOf('Newest block received')) {
		console.log('Received latest block');
		&lt;application is now up to date>
	} else {
		console.log('Failed to receive the block event ::'+error);
		&lt;do something with the error>
	}

},
	{startBlock:23, endBlock:'newest'}
);
</code></pre>
<h3>Transaction listener</h3>
<p>When there is a need to monitor for the completion of a transaction on your
organization's peer, use a transaction listener. The client application callback
will be notified when a new block is committed to the ledger on the peer.
fabric-client will then check the block for registered transaction identifiers.
If a transaction is
found, then the callback will be notified with the transaction ID, the transaction
status, and the block number. Filtered blocks contain the transaction status, so
there is no need to connect to the Peer's channel-based event service to receive
full blocks. Since most non-admin users will not be able to see full blocks,
connecting to receive filtered blocks will avoid access issues when users
only need to listen for their transactions to be committed.</p>
<p>The following example will show registering a transaction ID within a javascript
promise and building another promise for sending the transaction to the orderer.
Both promises will be executed together so that the results will be received for
both actions together. The default optional setting of <code>unregister</code> is
by default true with a transaction listener.
In the following example the listener that is
registered will be automatically unregistered after the listener sees the
transaction.</p>
<pre class="prettyprint source"><code>let tx_object = client.newTransactionID();

// get the transaction ID string for later use
let tx_id = tx_object.getTransactionID();

let request = {
	targets : targets,
	chaincodeId: 'my_chaincode',
	fcn: 'invoke',
	args: ['doSomething', 'with this data'],
	txId: tx_object
};

return channel.sendTransactionProposal(request);
}).then((results) => {
// a real application would check the proposal results
console.log('Successfully endorsed proposal to invoke chaincode');

let event_monitor = new Promise((resolve, reject) => {
	let handle = setTimeout(() => {
		// do the housekeeping when there is a problem
		channel_event_hub.unregisterTxEvent(tx_id);
		console.log('Timeout - Failed to receive the transaction event');
		reject(new Error('Timed out waiting for block event'));
	}, 20000);

	channel_event_hub.registerTxEvent((event_tx_id, status, block_num) => {
		clearTimeout(handle);
		//channel_event_hub.unregisterTxEvent(event_tx_id); let the default do this
		console.log('Successfully received the transaction event');
		resolve(status);
	}, (error)=> {
		clearTimeout(handle);
		console.log('Failed to receive the transaction event ::'+error);
		reject(error);
	},
		// notice that `unregister` is not specified, so it will default to true
		// `disconnect` is also not specified and will default to false
	);
});
let send_trans = channel.sendTransaction({proposalResponses: results[0], proposal: results[1]});

return Promise.all([event_monitor, send_trans]);
}).then((results) => {
</code></pre>
<h3>Chaincode event listener</h3>
<p>When there is a need to monitor for events that will be posted from within your
chaincode, use a chaincode event listener. The client Node.js will be
notified when a new block is committed to the ledger. The client will then check
for registered chaincode patterns within the chaincode event's name field. The
registration of the listener includes a regular expression to be used in the
check against a chaincode event name. If a chaincode event name is found to
match the listener's regular expression then the listener's callback will be
notified with the chaincode event, the block number, transaction id, and
transaction status. Filtered blocks will not have the chaincode event payload
information; it has only the chaincode event name. If the payload information is
required, the user must have access to the full block and the channel event hub
must be <code>connect({full_block:true})</code> to receive the full block events from the
Peer's channel-based event service.</p>
<p>The following example demonstrates registering a chaincode event listener within a
javascript promise and building another promise for sending the transaction to
the orderer. Both promises will be executed together so that the results will
be received for both actions together. If a chaincode event listener is needed
for long term monitoring, follow the block listener example above.</p>
<pre class="prettyprint source"><code>let tx_object = client.newTransactionID();
let request = {
	targets : targets,
	chaincodeId: 'my_chaincode',
	fcn: 'invoke',
	args: ['doSomething', 'with this data'],
	txId: tx_object
};

return channel.sendTransactionProposal(request);
}).then((results) => {
// a real application would check the proposal results
console.log('Successfully endorsed proposal to invoke chaincode');

// Build the promise to register a event listener with the NodeSDK.
// The NodeSDK will then send a request to the Peer's channel-based event service
// to start sending blocks. The blocks will be inspected to see if
// there is a match with a chaincode event listener.
let event_monitor = new Promise((resolve, reject) => {
	let regid = null;
	let handle = setTimeout(() => {
		if (regid) {
			// might need to do the clean up this listener
			channel_event_hub.unregisterChaincodeEvent(regid);
			console.log('Timeout - Failed to receive the chaincode event');
		}
		reject(new Error('Timed out waiting for chaincode event'));
	}, 20000);

	regid = channel_event_hub.registerChaincodeEvent(chaincode_id.toString(), '^evtsender*',
		(event, block_num, txnid, status) => {
		// This callback will be called when there is a chaincode event name
		// within a block that will match on the second parameter in the registration
		// from the chaincode with the ID of the first parameter.
		console.log('Successfully got a chaincode event with transid:'+ txnid + ' with status:'+status);

		// might be good to store the block number to be able to resume if offline
		storeBlockNumForLater(block_num);

		// to see the event payload, the channel_event_hub must be connected(true)
		let event_payload = event.payload.toString('utf8');
		if(event_payload.indexOf('CHAINCODE') > -1) {
			clearTimeout(handle);
			// Chaincode event listeners are meant to run continuously
			// Therefore the default to automatically unregister is false
			// So in this case we want to shutdown the event listener once
			// we see the event with the correct payload
			channel_event_hub.unregisterChaincodeEvent(regid);
			console.log('Successfully received the chaincode event on block number '+ block_num);
			resolve('RECEIVED');
		} else {
			console.log('Successfully got chaincode event ... just not the one we are looking for on block number '+ block_num);
		}
	}, (error)=> {
		clearTimeout(handle);
		console.log('Failed to receive the chaincode event ::'+error);
		reject(error);
	}
		// no options specified
		// unregister will default to false
		// disconnect will default to false
	);
});

// build the promise to send the proposals to the orderer
let send_trans = channel.sendTransaction({proposalResponses: results[0], proposal: results[1]});

// now that we have two promises all set to go... execute them
return Promise.all([event_monitor, send_trans]);
}).then((results) => {
</code></pre>
<p>The default is to receive the chaincode events one at a time, however
it would be difficult to know that a chaincode event was missed
and to maintain the order within the block.
Using the new option <code>as_array</code> the callback will
receive all chaincode events found in a block as an array.
The following example will register a chaincode listener with a callback that
will handle the chaincodes as an array, notice the fifth parameter is an
options object with the 'as_array' true setting.</p>
<pre class="prettyprint source"><code>channel_event_hub.registerChaincodeEvent(
   'mychaincode',
   'myeventname',
   (...events) => {
      for (const {chaincode_event, block_num, tx_id, tx_status} of events) {
         /* process each event */
      }
    },
    (err) =>{
      /* process err */
    },
    { as_array: true}
);
</code></pre>
<h3>When using mutual tls</h3>
<p>All peers and orderers objects need to use the same client side credentials
for a mutual TLS connection. The credentials must be assigned to the 'client'
object instance before it is used to create the peer used in the ChannelEventHub
creation.</p>
<pre class="prettyprint source"><code>const client = new Client();
client.setTlsClientCertAndKey(tlsInfo.certificate, tlsInfo.key);

const channel = client.newChannel('mychannel');
const peer = client.newPeer('grpcs://localhost:7051', {
	pem: '&lt;pem string here>',
	'ssl-target-name-override': 'peer0.org1.example.com'
});
channel.addPeer(peer);
const channelEventHub = channel.newChannelEventHub(peer);
</code></pre>
<h3>When connecting to replay</h3>
<p>Your application may be recording the block numbers as they come in or
it may use the last block of another channel event hub.
Your application has been off line and now wishes to catch
up on the missed blocks and then continue to process new blocks.
The following will connect a channel event hub to the
Peer's channel-based event service
at the point of your choice and since there is no endBlock specified, it will
continue to receive the blocks as they are added to the ledger.</p>
<p>Note: Use the ChannelEventHubs.lastBlockNumber()
to get the number of the last block received from a previously running
ChannelEventHub instance.</p>
<pre class="prettyprint source"><code>const channel_event_hub = channel.newChannelEventHub(mypeer);

// be sure to register your listeners before calling `connect` or you may
// miss an event
channel_event_hub.registerBlockEvent(eventCallBack, errorCallBack, options)

const my_starting_point =  this._calculate_starting_point(old_event_hub);

channel_event_hub.connect({startBlock: my_starting_point}, my_connect_call_back);

</code></pre>
<h3>When reconnecting</h3>
<p>Your application has a long running block listener or chaincode event listener
and you wish to restart the event listening.  The following will reconnect the
channel event hub to the
Peer's channel-based event service and not disturb the existing
event listeners. The connection will be setup to start sending blocks from the
last block the channel event hub had seen. The listeners may be notified
by a block or event that has already been seen and this may be used to verify
that notifications are again running.</p>
<pre class="prettyprint source"><code>channel_event_hub.reconnect({startBlock: 'last_seen'}, my_connect_call_back);

</code></pre>
<p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>
</article>

</section>

		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
	
		on 2020-01-23T16:52:11+00:00
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : false,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>